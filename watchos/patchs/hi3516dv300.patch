diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index ceaf87c4d..ea05aa4b4 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -322,7 +322,7 @@ config ARCH_MULTIPLATFORM
 	select ARCH_SELECT_MEMORY_MODEL
 	select ARM_HAS_SG_CHAIN
 	select ARM_PATCH_PHYS_VIRT
-	select AUTO_ZRELADDR
+	#select AUTO_ZRELADDR
 	select TIMER_OF
 	select COMMON_CLK
 	select GENERIC_CLOCKEVENTS
@@ -650,6 +650,8 @@ source "arch/arm/mach-highbank/Kconfig"
 
 source "arch/arm/mach-hisi/Kconfig"
 
+source "arch/arm/mach-hibvt/Kconfig"
+
 source "arch/arm/mach-imx/Kconfig"
 
 source "arch/arm/mach-integrator/Kconfig"
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index cb7c6b02f..95308da9c 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -182,6 +182,7 @@ machine-$(CONFIG_ARCH_FOOTBRIDGE)	+= footbridge
 machine-$(CONFIG_ARCH_GEMINI)		+= gemini
 machine-$(CONFIG_ARCH_HIGHBANK)		+= highbank
 machine-$(CONFIG_ARCH_HISI)		+= hisi
+machine-$(CONFIG_ARCH_HISI_BVT)		+= hibvt
 machine-$(CONFIG_ARCH_INTEGRATOR)	+= integrator
 machine-$(CONFIG_ARCH_IOP32X)		+= iop32x
 machine-$(CONFIG_ARCH_IXP4XX)		+= ixp4xx
@@ -270,6 +271,10 @@ KBUILD_CPPFLAGS += $(patsubst %,-I$(srctree)/%include,$(machdirs) $(platdirs))
 endif
 endif
 
+ifeq ($(CONFIG_ARCH_HISI_BVT),y)
+KBUILD_CPPFLAGS += $(patsubst %,-I$(srctree)/%include,$(machdirs) $(platdirs))
+endif
+
 export	TEXT_OFFSET GZFLAGS MMUEXT
 
 core-y				+= arch/arm/
diff --git a/arch/arm/boot/Makefile b/arch/arm/boot/Makefile
index 0b3cd7a33..763d37e86 100644
--- a/arch/arm/boot/Makefile
+++ b/arch/arm/boot/Makefile
@@ -16,6 +16,8 @@ OBJCOPYFLAGS	:=-O binary -R .comment -S
 ifneq ($(MACHINE),)
 include $(MACHINE)/Makefile.boot
 endif
+include $(srctree)/arch/arm/mach-hibvt/Makefile.boot
+include $(srctree)/arch/arm/boot/dts/Makefile
 
 # Note: the following conditions must always be true:
 #   ZRELADDR == virt_to_phys(PAGE_OFFSET + TEXT_OFFSET)
@@ -24,10 +26,12 @@ endif
 ZRELADDR    := $(zreladdr-y)
 PARAMS_PHYS := $(params_phys-y)
 INITRD_PHYS := $(initrd_phys-y)
+DTB_OBJS ?= $(dtb-y)
+DTB_OBJS_FULL := $(addprefix $(obj)/dts/,$(DTB_OBJS))
 
 export ZRELADDR INITRD_PHYS PARAMS_PHYS
 
-targets := Image zImage xipImage bootpImage uImage
+targets := Image zImage xipImage bootpImage uImage zImage-dtb
 
 ifeq ($(CONFIG_XIP_KERNEL),y)
 
@@ -66,6 +70,10 @@ $(obj)/compressed/vmlinux: $(obj)/Image FORCE
 $(obj)/zImage:	$(obj)/compressed/vmlinux FORCE
 	$(call if_changed,objcopy)
 
+$(obj)/zImage-dtb:	$(obj)/zImage $(DTB_OBJS_FULL) FORCE
+	@cat $(obj)/zImage $(DTB_OBJS_FULL) > $@
+	@$(kecho) '  Kernel: $@ is ready'
+
 endif
 
 ifneq ($(LOADADDR),)
@@ -86,7 +94,7 @@ if [ $(words $(UIMAGE_LOADADDR)) -ne 1 ]; then \
 	false; \
 fi
 
-$(obj)/uImage:	$(obj)/zImage FORCE
+$(obj)/uImage:	$(obj)/zImage-dtb FORCE
 	@$(check_for_multiple_loadaddr)
 	$(call if_changed,uimage)
 
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index ce66ffd5a..a84efd2d6 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -239,6 +239,10 @@ dtb-$(CONFIG_ARCH_HISI) += \
 	hi3519-demb.dtb
 dtb-$(CONFIG_ARCH_HIX5HD2) += \
 	hisi-x5hd2-dkb.dtb
+
+dtb-$(CONFIG_ARCH_HI3516DV300) += \
+	hi3516dv300-demb.dtb
+
 dtb-$(CONFIG_ARCH_INTEGRATOR) += \
 	integratorap.dtb \
 	integratorap-im-pd1.dtb \
@@ -1408,3 +1412,4 @@ dtb-$(CONFIG_ARCH_ASPEED) += \
 	aspeed-bmc-opp-zaius.dtb \
 	aspeed-bmc-portwell-neptune.dtb \
 	aspeed-bmc-quanta-q71l.dtb
+
diff --git a/arch/arm/boot/dts/hi3516dv300-demb.dts b/arch/arm/boot/dts/hi3516dv300-demb.dts
new file mode 100644
index 000000000..bbe67651e
--- /dev/null
+++ b/arch/arm/boot/dts/hi3516dv300-demb.dts
@@ -0,0 +1,270 @@
+/*
+ * Copyright (c) 2013-2014 Linaro Ltd.
+ * Copyright (c) 2015-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/dts-v1/;
+#include "hi3516dv300.dtsi"
+#include "autoconf.h"
+
+/ {
+	model = "Hisilicon HI3516DV300 DEMO Board";
+	compatible = "hisilicon,hi3516dv300";
+
+	memory {
+		device_type = "memory";
+		reg = <0x82000000 0x20000000>;
+	};
+	firmware {
+		android {
+			compatible = "android,firmware";
+			fstab {
+				compatible = "android,fstab";
+				 // delete for system as root
+				   /*system {
+				   compatible = "android,system";
+				   dev = "/dev/block/platform/soc/f9830000.himciv200.MMC/by-name/system";
+				   type = "ext4";
+				   mnt_flags = "ro,barrier=1,inode_readahead_blks=8";
+				   fsmgr_flags = "wait";
+				   };*/
+				vendor {
+					compatible = "android,vendor";
+					//dev = "mmcblk0p4";
+					//dev = "/dev/block/by-name/vendor";
+					//dev = "/dev/block/platform/soc/100f0000.eMMC/by-name/vendor";
+					//dev = "/dev/block/platform/soc/10100000.eMMC/by-name/vendor";
+					dev = "/dev/block/platform/soc/10100000.himci.eMMC/by-name/vendor";
+					//dev = "/dev/block/platform/soc/100f0000.eMMC/mmcblk0p4";
+				        //dev = "/dev/block/platform/soc/f9830000.himciv200.MMC/by-name/vendor";
+					type = "ext4";
+					mnt_flags = "ro,barrier=1,inode_readahead_blks=8";
+					fsmgr_flags = "wait";
+				};
+			};
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+#ifndef CONFIG_ARCH_HISI_BVT_AMP
+&uart1 {
+	status = "okay";
+};
+
+&i2c_bus0 {
+    status = "okay";
+    clock-frequency = <100000>;
+};
+
+&i2c_bus1 {
+    status = "okay";
+    clock-frequency = <100000>;
+};
+
+&i2c_bus2 {
+    status = "okay";
+    clock-frequency = <100000>;
+};
+
+&i2c_bus3 {
+    status = "okay";
+    clock-frequency = <100000>;
+};
+
+&i2c_bus4 {
+    status = "okay";
+    clock-frequency = <100000>;
+};
+
+&i2c_bus5 {
+    status = "okay";
+    clock-frequency = <100000>;
+};
+
+&i2c_bus6 {
+    status = "okay";
+    clock-frequency = <100000>;
+};
+
+&i2c_bus7 {
+    status = "okay";
+    clock-frequency = <100000>;
+};
+
+&spi_bus0{
+    status = "okay";
+    num-cs = <1>;
+
+    spidev@0 {
+        compatible = "rohm,dh2228fv";
+        reg = <0>;
+        pl022,interface = <0>;
+        pl022,com-mode = <0>;
+        spi-max-frequency = <25000000>;
+    };
+};
+&spi_bus1{
+    status = "okay";
+    num-cs = <2>;
+
+    spidev@0 {
+        compatible = "rohm,dh2228fv";
+        reg = <0>;
+        pl022,interface = <0>;
+        pl022,com-mode = <0>;
+        spi-max-frequency = <25000000>;
+    };
+    spidev@1 {
+        compatible = "rohm,dh2228fv";
+        reg = <1>;
+        pl022,interface = <0>;
+        pl022,com-mode = <0>;
+        spi-max-frequency = <25000000>;
+    };
+};
+&spi_bus2{
+    status = "okay";
+    num-cs = <1>;
+
+    spidev@0 {
+        compatible = "rohm,dh2228fv";
+        reg = <0>;
+        pl022,interface = <0>;
+        pl022,com-mode = <0>;
+        spi-max-frequency = <25000000>;
+    };
+};
+#endif
+
+&mdio0 {
+	hisilicon,phy-reset-delays-us = <10000 20000 150000>;
+	phy0: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&hisi_femac0 {
+	mac-address = [00 00 00 00 00 00];
+	phy-mode = "rmii";
+	phy-handle = <&phy0>;
+	status = "okay";
+};
+
+&hisfc {
+	hi_sfc {
+		   compatible = "jedec,spi-nor";
+		   reg = <0>;
+		   spi-max-frequency = <160000000>;
+	};
+};
+
+&hisnfc {
+	hinand {
+		   compatible = "jedec,spi-nand";
+		   reg = <0>;
+		   spi-max-frequency = <160000000>;
+	};
+};
+
+&mmc0 {
+#ifdef CONFIG_MTD
+	status = "disabled";
+#else
+	status = "okay";
+#endif
+};
+
+&mmc1 {
+	status = "okay";
+};
+
+&mmc2 {
+	status = "okay";
+};
+
+&watchdog {
+        status = "okay";
+};
+
+&pwm0 {
+        status = "okay";
+};
+
+&pwm1 {
+        status = "okay";
+};
+
+&hidmac {
+	status = "disabled";
+};
+
+#ifdef CONFIG_HIEDMACV310
+&hiedmacv310_0 {
+    status = "okay";
+};
+#endif
+
+&gpio_chip0 {
+	status = "okay";
+};
+
+&gpio_chip1 {
+	status = "okay";
+};
+
+&gpio_chip2 {
+	status = "okay";
+};
+
+&gpio_chip3 {
+	status = "okay";
+};
+
+&gpio_chip4 {
+	status = "okay";
+};
+
+&gpio_chip5 {
+	status = "okay";
+};
+
+&gpio_chip6 {
+	status = "okay";
+};
+
+&gpio_chip7 {
+	status = "okay";
+};
+
+&gpio_chip8 {
+	status = "okay";
+};
+
+&gpio_chip9 {
+	status = "okay";
+};
+
+&gpio_chip10 {
+	status = "okay";
+};
+
+&gpio_chip11 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/hi3516dv300.dtsi b/arch/arm/boot/dts/hi3516dv300.dtsi
new file mode 100644
index 000000000..c58f5b1ad
--- /dev/null
+++ b/arch/arm/boot/dts/hi3516dv300.dtsi
@@ -0,0 +1,906 @@
+/*
+ * Copyright (c) 2013-2014 Linaro Ltd.
+ * Copyright (c) 2015-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "autoconf.h"
+#include "skeleton.dtsi"
+#include "clock/hi3516dv300-clock.h"
+/ {
+	aliases {
+		serial0 = &uart0;
+#ifndef CONFIG_ARCH_HISI_BVT_AMP
+		i2c0 = &i2c_bus0;
+		i2c1 = &i2c_bus1;
+		i2c2 = &i2c_bus2;
+		i2c3 = &i2c_bus3;
+#endif
+		i2c4 = &i2c_bus4;
+		i2c5 = &i2c_bus5;
+		i2c6 = &i2c_bus6;
+		i2c7 = &i2c_bus7;
+#ifndef CONFIG_ARCH_HISI_BVT_AMP
+		spi0 = &spi_bus0;
+		spi1 = &spi_bus1;
+		spi2 = &spi_bus2;
+#endif
+		gpio0 = &gpio_chip0;
+		gpio1 = &gpio_chip1;
+		gpio2 = &gpio_chip2;
+		gpio3 = &gpio_chip3;
+		gpio4 = &gpio_chip4;
+		gpio5 = &gpio_chip5;
+		gpio6 = &gpio_chip6;
+		gpio7 = &gpio_chip7;
+		gpio8 = &gpio_chip8;
+		gpio9 = &gpio_chip9;
+		gpio10 = &gpio_chip10;
+		gpio11 = &gpio_chip11;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		enable-method = "hisilicon,hi3516dv300";
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			clock-frequency = <HI3516DV300_FIXED_1000M>;
+			reg = <0>;
+		};
+#ifndef CONFIG_ARCH_HISI_BVT_AMP
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			clock-frequency = <HI3516DV300_FIXED_1000M>;
+			reg = <1>;
+		};
+#endif
+	};
+
+	clock: clock@12010000 {
+		compatible = "hisilicon,hi3516dv300-clock";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		#clock-cells = <1>;
+		#reset-cells = <2>;
+		reg = <0x12010000 0x1000>;
+	};
+
+	gic: interrupt-controller@10300000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		/* gic dist base, gic cpu base , no virtual support */
+		reg = <0x10301000 0x1000>, <0x10302000 0x100>;
+	 };
+
+	syscounter {
+		compatible = "arm,armv7-timer";
+		interrupt-parent = <&gic>;
+		interrupts = <1 13 0xf08>,
+			<1 14 0xf08>;
+		clock-frequency = <50000000>;
+	};
+
+	soc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		interrupt-parent = <&gic>;
+		ranges;
+
+		clk_3m: clk_3m {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <3000000>;
+		};
+
+		clk_apb: clk_apb {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+		};
+
+		pmu {
+			compatible = "arm,cortex-a7-pmu";
+			interrupts = <0 54 4>;
+		};
+#ifdef CONFIG_HIEDMACV310
+        hiedmacv310_0: hiedma-controller@10060000 {
+			compatible = "hisilicon,hiedmacv310";
+			reg = <0x10060000 0x1000>;
+			interrupts = <0 28 4>;
+			clocks = <&clock HI3516DV300_DMAC_CLK>, <&clock HI3516DV300_DMAC_AXICLK>;
+			clock-names = "apb_pclk", "axi_aclk";
+			#clock-cells = <2>;
+			resets = <&clock 0x194 0>;
+			reset-names = "dma-reset";
+			dma-requests = <32>;
+			dma-channels = <8>;
+			devid = <0>;
+			#dma-cells = <2>;
+			status = "disabled";
+		};
+#endif
+#ifdef CONFIG_HIEDMAC
+        hiedmacv310_0: hiedma-controller@10060000 {
+			compatible = "hisilicon,hiedmacv310_n";
+			reg = <0x10060000 0x1000>;
+			interrupts = <0 28 4>;
+			clocks = <&clock HI3516DV300_DMAC_CLK>, <&clock HI3516DV300_DMAC_AXICLK>;
+			clock-names = "apb_pclk", "axi_aclk";
+			#clock-cells = <2>;
+			resets = <&clock 0x194 0>;
+			reset-names = "dma-reset";
+			dma-requests = <32>;
+			dma-channels = <8>;
+			devid = <0>;
+			#dma-cells = <2>;
+			status = "disabled";
+		};
+#endif
+
+		sysctrl: system-controller@12020000 {
+			compatible = "hisilicon,sysctrl";
+			reg = <0x12020000 0x1000>;
+			reboot-offset = <0x4>;
+			#clock-cells = <1>;
+		};
+
+		amba {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "arm,amba-bus";
+			ranges;
+
+			timer@hisp804 {
+				compatible = "hisilicon,hisp804";
+				/* timer0 & timer1 & timer2 */
+				reg = <0x12000000 0x20>, /* clocksource */
+					<0x12000020 0x20>, /* local timer for each cpu */
+					<0x12001000 0x20>;
+				interrupts = <0 1 4>, /* irq of local timer */
+					<0 2 4>;
+				clocks = <&clock HI3516DV300_FIXED_3M>,
+					<&clock HI3516DV300_FIXED_3M>,
+					<&clock HI3516DV300_FIXED_3M>;
+				clock-names = "timer0", "timer1", "timer2";
+			};
+
+			dual_timer2: dual_timer@12002000 {
+				compatible = "arm,sp804", "arm,primecell";
+				/* timer4 & timer5 */
+				interrupts = <0 3 4>;
+				reg = <0x12002000 0x1000>;
+				clocks = <&clk_3m>, <&clk_3m>, <&clk_apb>;
+				clock-names = "timer20", "timer21", "apb_pclk";
+				status = "disabled";
+			};
+
+			watchdog: watchdog@12051000 {
+                                compatible = "arm,sp805-wdt", "arm,primecell";
+                                arm,primecell-periphid = <0x00141805>;
+                                reg = <0x12051000 0x1000>;
+                                clocks = <&clk_3m>,<&clk_apb>;
+                                clock-names = "wdog_clk", "apb_pclk";
+                                status = "disabled";
+                        };
+
+			uart0: uart@120a0000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x120a0000 0x1000>;
+				interrupts = <0 6 4>;
+				clocks = <&clock HI3516DV300_UART0_CLK>;
+				clock-names = "apb_pclk";
+				status = "disabled";
+			};
+#ifndef CONFIG_ARCH_HISI_BVT_AMP
+			uart1: uart@120a1000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x120a1000 0x1000>;
+				interrupts = <0 7 4>;
+				clocks = <&clock HI3516DV300_UART1_CLK>;
+				clock-names = "apb_pclk";
+#ifdef CONFIG_HIEDMACV310
+				dmas = <&hiedmacv310_0 19 19>, <&hiedmacv310_0 18 18>;
+				dma-names = "tx","rx";
+#endif
+				status = "disabled";
+			};
+#endif
+			uart2: uart@120a2000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x120a2000 0x1000>;
+				interrupts = <0 8 4>;
+				clocks = <&clock HI3516DV300_UART2_CLK>;
+				clock-names = "apb_pclk";
+#ifdef CONFIG_HIEDMACV310
+				dmas = <&hiedmacv310_0 21 21>, <&hiedmacv310_0 20 20>;
+				dma-names = "tx","rx";
+#endif
+				status = "disabled";
+			};
+
+            uart3: uart@120a3000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x120a3000 0x1000>;
+				interrupts = <0 9 4>;
+				clocks = <&clock HI3516DV300_UART3_CLK>;
+				clock-names = "apb_pclk";
+#ifdef CONFIG_HIEDMACV310
+				dmas = <&hiedmacv310_0 23 23>, <&hiedmacv310_0 22 22>;
+				dma-names = "tx","rx";
+#endif
+				status = "disabled";
+			};
+
+            uart4: uart@120a4000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x120a4000 0x1000>;
+				interrupts = <0 10 4>;
+				clocks = <&clock HI3516DV300_UART4_CLK>;
+				clock-names = "apb_pclk";
+#ifdef CONFIG_HIEDMACV310
+				dmas = <&hiedmacv310_0 25 25>, <&hiedmacv310_0 24 24>;
+				dma-names = "tx","rx";
+#endif
+				status = "disabled";
+			};
+
+		};
+
+#ifndef CONFIG_ARCH_HISI_BVT_AMP
+		i2c_bus0: i2c@120b0000 {
+			compatible = "hisilicon,hibvt-i2c";
+			reg = <0x120b0000 0x1000>;
+			clocks = <&clock HI3516DV300_I2C0_CLK>;
+#ifdef CONFIG_HIEDMAC
+				dmas = <&hiedmacv310_0 1 1>, <&hiedmacv310_0 0 0>;
+				dma-names = "tx","rx";
+#endif
+			status = "disabled";
+		};
+
+		i2c_bus1: i2c@120b1000 {
+			compatible = "hisilicon,hibvt-i2c";
+			reg = <0x120b1000 0x1000>;
+			clocks = <&clock HI3516DV300_I2C1_CLK>;
+#ifdef CONFIG_HIEDMAC
+				dmas = <&hiedmacv310_0 3 3>, <&hiedmacv310_0 2 2>;
+				dma-names = "tx","rx";
+#endif
+			status = "disabled";
+		};
+
+		i2c_bus2: i2c@120b2000 {
+			compatible = "hisilicon,hibvt-i2c";
+			reg = <0x120b2000 0x1000>;
+			clocks = <&clock HI3516DV300_I2C2_CLK>;
+#ifdef CONFIG_HIEDMAC
+				dmas = <&hiedmacv310_0 5 5>, <&hiedmacv310_0 4 4>;
+				dma-names = "tx","rx";
+#endif
+			status = "disabled";
+		};
+
+		i2c_bus3: i2c@120b3000 {
+			compatible = "hisilicon,hibvt-i2c";
+			reg = <0x120b3000 0x1000>;
+			clocks = <&clock HI3516DV300_I2C3_CLK>;
+#ifdef CONFIG_HIEDMAC
+				dmas = <&hiedmacv310_0 7 7>, <&hiedmacv310_0 6 6>;
+				dma-names = "tx","rx";
+#endif
+			status = "disabled";
+		};
+#endif
+		i2c_bus4: i2c@120b4000 {
+			compatible = "hisilicon,hibvt-i2c";
+			reg = <0x120b4000 0x1000>;
+			clocks = <&clock HI3516DV300_I2C4_CLK>;
+#ifdef CONFIG_HIEDMAC
+				dmas = <&hiedmacv310_0 9 9>, <&hiedmacv310_0 8 8>;
+				dma-names = "tx","rx";
+#endif
+			status = "disabled";
+		};
+		i2c_bus5: i2c@120b5000 {
+			compatible = "hisilicon,hibvt-i2c";
+			reg = <0x120b5000 0x1000>;
+			clocks = <&clock HI3516DV300_I2C5_CLK>;
+#ifdef CONFIG_HIEDMAC
+				dmas = <&hiedmacv310_0 11 11>, <&hiedmacv310_0 10 10>;
+				dma-names = "tx","rx";
+#endif
+			status = "disabled";
+		};
+
+		i2c_bus6: i2c@120b6000 {
+			compatible = "hisilicon,hibvt-i2c";
+			reg = <0x120b6000 0x1000>;
+			clocks = <&clock HI3516DV300_I2C6_CLK>;
+#ifdef CONFIG_HIEDMAC
+				dmas = <&hiedmacv310_0 13 13>, <&hiedmacv310_0 12 12>;
+				dma-names = "tx","rx";
+#endif
+			status = "disabled";
+		};
+
+		i2c_bus7: i2c@120b7000 {
+			compatible = "hisilicon,hibvt-i2c";
+			reg = <0x120b7000 0x1000>;
+			clocks = <&clock HI3516DV300_I2C7_CLK>;
+#ifdef CONFIG_HIEDMAC
+				dmas = <&hiedmacv310_0 15 15>, <&hiedmacv310_0 14 14>;
+				dma-names = "tx","rx";
+#endif
+			status = "disabled";
+		};
+
+#ifndef CONFIG_ARCH_HISI_BVT_AMP
+        spi_bus0: spi@120c0000 {
+            compatible = "arm,pl022", "arm,primecell";
+            arm,primecell-periphid = <0x00800022>;
+            reg = <0x120c0000 0x1000>;
+            interrupts = <0 68 4>;
+            clocks = <&clock HI3516DV300_SPI0_CLK>;
+            clock-names = "apb_pclk";
+            #address-cells = <1>;
+            #size-cells = <0>;
+#ifdef CONFIG_HIEDMACV310
+            dmas = <&hiedmacv310_0 27 27>, <&hiedmacv310_0 26 26>;
+            dma-names = "tx","rx";
+#endif
+            status = "disabled";
+        };
+
+        spi_bus1: spi@120c1000 {
+            compatible = "arm,pl022", "arm,primecell";
+            arm,primecell-periphid = <0x00800022>;
+            reg = <0x120c1000 0x1000>, <0x12030000 0x4>;
+            interrupts = <0 69 4>;
+            clocks = <&clock HI3516DV300_SPI1_CLK>;
+            clock-names = "apb_pclk";
+            #address-cells = <1>;
+            #size-cells = <0>;
+            num-cs = <2>;
+            hisi,spi_cs_sb = <2>;
+            hisi,spi_cs_mask_bit = <0x4>;//0100
+#ifdef CONFIG_HIEDMACV310
+            dmas = <&hiedmacv310_0 29 29>, <&hiedmacv310_0 28 28>;
+            dma-names = "tx","rx";
+#endif
+            status = "disabled";
+        };
+
+        spi_bus2: spi@120c2000 {
+            compatible = "arm,pl022", "arm,primecell";
+            arm,primecell-periphid = <0x00800022>;
+            reg = <0x120c2000 0x1000>;
+            interrupts = <0 70 4>;
+            clocks = <&clock HI3516DV300_SPI2_CLK>;
+            clock-names = "apb_pclk";
+            #address-cells = <1>;
+            #size-cells = <0>;
+#ifdef CONFIG_HIEDMACV310
+            dmas = <&hiedmacv310_0 31 31>, <&hiedmacv310_0 30 30>;
+            dma-names = "tx","rx";
+#endif
+            status = "disabled";
+        };
+#endif
+
+        ipcm: ipcm@045E0000 {
+            compatible = "hisilicon,ipcm-interrupt";
+            interrupt-parent = <&gic>;
+            interrupts = <0 10 4>;
+            reg = <0x10300000 0x4000>;
+            status = "okay";
+        };
+
+		mdio0: mdio@10011100 {
+			compatible = "hisilicon,hisi-femac-mdio";
+			reg = <0x10011100 0x10>;
+			clocks = <&clock HI3516DV300_ETH0_CLK>;
+			clock-names = "mdio";
+			assigned-clocks = <&clock HI3516DV300_ETH0_CLK>;
+			assigned-clock-rates = <54000000>;
+			resets = <&clock 0x16c 3>;
+			reset-names = "external-phy";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		hisi_femac0: ethernet@10010000 {
+			compatible = "hisilicon,hi3516dv300-femac",
+				"hisilicon,hisi-femac-v2";
+			reg = <0x10010000 0x1000>,<0x10011300 0x200>;
+			interrupts = <0 32 4>;
+			clocks = <&clock HI3516DV300_ETH0_CLK>;
+			resets = <&clock 0x16c 0>;
+			reset-names = "mac";
+		};
+
+		fmc: flash-memory-controller@10000000 {
+			compatible = "hisilicon,hisi-fmc";
+			reg = <0x10000000 0x1000>, <0x14000000 0x10000>;
+			reg-names = "control", "memory";
+			clocks = <&clock HI3516DV300_FMC_CLK>;
+			max-dma-size = <0x2000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			hisfc:spi-nor@0 {
+					compatible = "hisilicon,fmc-spi-nor";
+					assigned-clocks = <&clock HI3516DV300_FMC_CLK>;
+					assigned-clock-rates = <24000000>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+			};
+
+			hisnfc:spi-nand@0 {
+					compatible = "hisilicon,fmc-spi-nand";
+					assigned-clocks = <&clock HI3516DV300_FMC_CLK>;
+					assigned-clock-rates = <24000000>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+			};
+		};
+
+		mmc0: himci.eMMC@0x10100000 {
+			compatible = "hisilicon,hi3516dv300-himci";
+			reg = <0x10100000 0x1000>;
+			interrupts = <0 64 4>;
+			clocks = <&clock HI3516DV300_MMC0_CLK>;
+			clock-names = "mmc_clk";
+			resets = <&clock 0x148 0>;
+			reset-names = "mmc_reset";
+			max-frequency = <100000000>;
+			bus-width = <4>;
+			cap-mmc-highspeed;
+			cap-mmc-hw-reset;
+			devid = <0>;
+			status = "disabled";
+		};
+
+		mmc1: himci.SD@0x100f0000 {
+			compatible = "hisilicon,hi3516dv300-himci";
+			reg = <0x100f0000 0x1000>;
+			interrupts = <0 30 4>;
+			clocks = <&clock HI3516DV300_MMC1_CLK>;
+			clock-names = "mmc_clk";
+			resets = <&clock 0x160 0>;
+			reset-names = "mmc_reset";
+			max-frequency = <100000000>;
+			bus-width = <4>;
+			cap-sd-highspeed;
+			sd-uhs-sdr12;
+			sd-uhs-sdr25;
+			sd-uhs-sdr50;
+			sd-uhs-sdr104;
+			full-pwr-cycle;
+			devid = <1>;
+			status = "disabled";
+		};
+
+		mmc2: himci.SD@0x10020000 {
+			compatible = "hisilicon,hi3516dv300-himci";
+			reg = <0x10020000 0x1000>;
+			interrupts = <0 31 4>;
+			clocks = <&clock HI3516DV300_MMC2_CLK>;
+			clock-names = "mmc_clk";
+			resets = <&clock 0x154 0>;
+			reset-names = "mmc_reset";
+			max-frequency = <100000000>;
+			bus-width = <4>;
+			cap-sd-highspeed;
+			cap-sdio-irq;
+			full-pwr-cycle;
+			devid = <2>;
+			status = "disabled";
+		};
+
+		hidmac: hidma-controller@10060000 {
+			compatible = "hisilicon,hisi-dmac";
+			reg = <0x10060000 0x1000>;
+			interrupts = <0 28 4>;
+			clocks = <&clock HI3516DV300_DMAC_CLK>;
+			clock-names = "dmac_clk";
+			resets = <&clock 0xc8 4>;
+			reset-names = "dma-reset";
+			#dma-cells = <2>;
+			status = "disabled";
+		};
+
+		usb_phy: phy {
+			compatible = "hisilicon,hisi-usb-phy";
+			reg = <0x12010000 0x1000>;
+			#phy-cells = <0>;
+		};
+
+#ifdef CONFIG_USB_DRD0_IN_HOST
+		xhci_0@0x100e0000 {
+			compatible = "generic-xhci";
+			reg = <0x100e0000 0x10000>;
+			interrupts = <0 27 4>;
+			usb2-lpm-disable;
+		};
+#endif
+#ifdef CONFIG_USB_DRD0_IN_DEVICE
+		hidwc3_0@0x100e0000 {
+			compatible = "snps,dwc3";
+			reg = <0x100e0000 0x10000>;
+			interrupts = <0 27 4>;
+			interrupt-names = "peripheral";
+			maximum-speed = "high-speed";
+			dr_mode = "otg";
+		};
+#endif
+		gpio_chip0: gpio_chip@120d0000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d0000 0x1000>;
+			interrupts = <0 16 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip1: gpio_chip@120d1000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d1000 0x1000>;
+			interrupts = <0 17 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip2: gpio_chip@120d2000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d2000 0x1000>;
+			interrupts = <0 18 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip3: gpio_chip@120d3000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d3000 0x1000>;
+			interrupts = <0 19 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip4: gpio_chip@120d4000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d4000 0x1000>;
+			interrupts = <0 20 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip5: gpio_chip@120d5000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d5000 0x1000>;
+			interrupts = <0 21 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip6: gpio_chip@120d6000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d6000 0x1000>;
+			interrupts = <0 22 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip7: gpio_chip@120d7000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d7000 0x1000>;
+			interrupts = <0 23 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip8: gpio_chip@120d8000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d8000 0x1000>;
+			interrupts = <0 24 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip9: gpio_chip@120d9000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120d9000 0x1000>;
+			interrupts = <0 25 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip10: gpio_chip@120da000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120da000 0x1000>;
+			interrupts = <0 26 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio_chip11: gpio_chip@120db000 {
+			compatible = "arm,pl061", "arm,primecell";
+			reg = <0x120db000 0x1000>;
+			interrupts = <0 80 4>;
+			clocks = <&clock  HI3516DV300_SYSAPB_CLK>;
+			clock-names = "apb_pclk";
+			#gpio-cells = <2>;
+			status = "disabled";
+		};
+
+		cipher: cipher@0x100c0000 {
+			compatible = "hisilicon,hisi-cipher";
+			reg = <0x100c0000 0x10000>;
+			reg-names = "cipher";
+			interrupts = <0 71 4>, <0 72 4>, <0 71 4>, <0 72 4>;
+			interrupt-names = "cipher", "nonsec_cipher", "hash", "nonsec_hash";
+		};
+
+	};
+
+        hidrm {
+            compatible = "hisilicon,hi-drm";
+        };
+
+	media {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		interrupt-parent = <&gic>;
+		ranges;
+
+		osal: osal {
+			compatible = "hisilicon,osal";
+		};
+
+		sys_config: sys_config {
+                        compatible = "hisilicon,sys_config";
+                };
+
+		sys: sys@12010000 {
+			compatible = "hisilicon,hisi-sys";
+			reg = <0x12010000 0x10000>, <0x12020000 0x8000>,
+				<0x12060000 0x10000>, <0x12030000 0x8000>;
+			reg-names = "crg", "sys", "ddr", "misc";
+		};
+
+		mipi: mipi@113a0000 {
+			compatible = "hisilicon,hisi-mipi";
+			reg = <0x113a0000 0x10000>;
+			reg-names = "mipi_rx";
+			interrupts = <0 57 4>;
+			interrupt-names = "mipi_rx";
+		};
+
+		mipi_tx: mipi_tx@11270000 {
+			compatible = "hisilicon,hisi-mipi_tx";
+			reg = <0x11270000 0x10000>;
+			reg-names = "mipi_tx";
+			interrupts = <0 63 4>;
+			interrupt-names = "mipi_tx";
+		};
+
+		vi: vi@11300000 {
+			compatible = "hisilicon,hisi-vi";
+			reg = <0x11300000 0xa0000>, <0x11000000 0x40000>;
+			reg-names = "VI_CAP0", "VI_PROC0";
+			interrupts = <0 56 4>, <0 44 4>;
+			interrupt-names = "VI_CAP0", "VI_PROC0";
+		};
+
+		isp: isp@11020000 {
+		 compatible = "hisilicon,hisi-isp";
+		 reg = <0x11020000 0x20000>;
+		 reg-names = "ISP";
+		 interrupts = <0 56 4>;
+		 interrupt-names = "ISP";
+		};
+
+		vpss: vpss@11040000 {
+			compatible = "hisilicon,hisi-vpss";
+			reg = <0x11040000 0x10000>;
+			reg-names = "vpss0";
+			interrupts = <0 43 4>;
+			interrupt-names = "vpss0";
+		};
+
+		vgs: vgs@11240000 {
+			compatible = "hisilicon,hisi-vgs";
+			reg = <0x11240000 0x10000>;
+			reg-names = "vgs0";
+			interrupts = <0 38 4>;
+			interrupt-names = "vgs0";
+		};
+
+		vo: vo@11440000 {
+			compatible = "hisilicon,hisi-vo";
+			reg = <0x11440000 0x40000>;
+			reg-names = "vo";
+			interrupts = <0 58 4>;
+			interrupt-names = "vo";
+		};
+
+		hifb: hifb@11440000 {
+			compatible = "hisilicon,hisi-hifb";
+			reg = <0x11440000 0x40000>, <0x12020000 0x8000>;
+			reg-names = "hifb", "sys";
+			interrupts = <0 59 4>, <0 51 4>;
+			interrupt-names = "hifb", "hifb_soft";
+		};
+
+		tde: tde@11210000 {
+			compatible = "hisilicon,hisi-tde";
+			reg = <0x11210000 0x10000>;
+			reg-names = "tde";
+			interrupts = <0 35 4>;
+			interrupt-names = "tde_osr_isr";
+		};
+
+		gyro_dis: gyro {
+			compatible = "hisilicon,hisi-gyro-dis";
+		};
+
+		gdc: gdc@11110000 {
+			compatible = "hisilicon,hisi-gdc";
+			reg = <0x11110000 0x10000>, <0x11100000 0x10000>;
+			reg-names = "gdc", "nnie0";
+			interrupts = <0 42 4>, <0 41 4>;
+			interrupt-names = "gdc", "nnie0";
+		};
+
+		gzip: gzip@11200000 {
+			compatible = "hisilicon,hisi-gzip";
+			reg = <0x11200000 0x10000>;
+			reg-names = "gzip";
+			interrupts = <0 34 4>;
+			interrupt-names = "gzip";
+		};
+
+		jpegd: jpegd@11260000 {
+			compatible = "hisilicon,hisi-jpegd";
+			reg = <0x11260000 0x10000>;
+			reg-names = "jpegd";
+			interrupts = <0 45 4>;
+			interrupt-names = "jpegd";
+		};
+
+		vedu: vedu@11500000 {
+			compatible = "hisilicon,hisi-vedu";
+			reg = <0x11500000 0x10000>, <0x11220000 0x10000>;
+			reg-names = "vedu0", "jpge";
+			interrupts = <0 40 4>, <0 36 4>;
+			interrupt-names = "vedu0","jpge";
+		};
+
+		venc: venc {
+                        compatible = "hisilicon,hisi-venc";
+                };
+
+		scd: scd@10030000 {
+			compatible = "hisilicon,hisi-scd";
+			reg = <0x10030000 0x10000>;
+			reg-names = "scd";
+			interrupts = <0 67 4>;
+			interrupt-names = "scd";
+		};
+
+		hdmi: hdmi@11400000 {
+			compatible = "hisilicon,hisi-hdmi";
+			reg = <0x11400000 0x30000>;
+			reg-names = "hdmi0";
+		};
+
+		aiao: aiao@113b0000 {
+			compatible = "hisilicon,hisi-aiao";
+			reg = <0x113b0000 0x10000>,<0x113c0000 0x10000>,<0x12010000 0x10000>;
+			reg-names = "aiao","acodec","crg";
+			interrupts = <0 55 4>;
+			interrupt-names = "AIO";
+		};
+
+		nnie: nnie@11100000 {
+			compatible = "hisilicon,hisi-nnie";
+			reg = <0x11100000 0x10000>,<0x11110000 0x10000>;
+			reg-names = "nnie0","gdc";
+			interrupts = <0 41 4>,<0 42 4>;
+			interrupt-names = "nnie0","gdc";
+		};
+
+		ive: ive@11230000 {
+			compatible = "hisilicon,hisi-ive";
+			reg = <0x11230000 0x10000>;
+			reg-names = "ive";
+			interrupts = <0 37 4>;
+			interrupt-names = "ive";
+		};
+
+		adc: adc@120e0000 {
+	     		compatible = "hisilicon,hisi-lsadc";
+	     		reg = <0x120e0000 0x1000>;
+	     		interrupts = <0 65 4>;
+	     		resets = <&clock 0x1bc 2>;
+	     		reset-names = "lsadc-crg";
+	     		status = "disabled";
+     		};
+		ir: ir@120f0000 {
+	        	compatible = "hisilicon,hi_ir";
+	        	reg = <0x120f0000 0x1000>;
+	        	interrupts = <0 75 4>;
+	        };
+
+		rtc: rtc@12080000 {
+			compatible = "hisilicon,hi35xx-rtc";
+			reg = <0x12080000 0x1000>;
+			interrupts = <0 5 4>;
+		};
+
+		wdg: wdg@12050000 {
+			compatible = "hisilicon,hi_wdg";
+			reg = <0x12050000 0x1000>;
+		};
+		pwm0: pwm@12070000 {
+			compatible = "hisilicon,pwm";
+			reg = <0x12070000 0x20>;
+			clocks = <&clock HI3516DV300_PWM_CLK>;
+			resets = <&clock 0x1bc 6>;
+		};
+		pwm1: pwm@12070020 {
+			compatible = "hisilicon,pwm";
+			reg = <0x12070020 0x20>;
+			clocks = <&clock HI3516DV300_PWM_CLK>;
+			resets = <&clock 0x1bc 6>;
+		};
+
+		irq: irq@120f0000 {
+	        	compatible = "hisilicon,hi_irq";
+				reg = <0x11240000 0x10000>,<0x11040000 0x10000>,<0x10030000 0x10000>,<0x113b0000 0x10000>,<0x113c0000 0x10000>,<0x12010000 0x10000>,<0x11500000 0x10000>, <0x11220000 0x10000>,<0x11440000 0x40000>,<0x11300000 0xa0000>, <0x11000000 0x40000>;
+			    reg-names =    "vgs",              "vpss0",       "scd",               "aiao",              "acodec",            "crg",                "vedu0",             "jpge",              "vo",                "VI_CAP0",            "VI_PROC0";
+				interrupts = <0 67 4>,<0 26 4>,<0 56 4>, <0 44 4>,<0 43 4>,<0 38 4>,<0 58 4>,<0 40 4>,<0 36 4>,<0 37 4>,<0 41 4>,<0 42 4>,<0 56 4>,<0 45 4>,<0 55 4>;
+				interrupt-names = "scd","new", "VI_CAP0", "VI_PROC0","vpss0","vgs0", "vo",   "vedu0",  "jpge", "ive",   "nnie0",  "gdc",  "ISP",   "jpegd" ,"AIO";
+	        };
+	};
+};
diff --git a/arch/arm/boot/dts/skeleton.dtsi b/arch/arm/boot/dts/skeleton.dtsi
new file mode 100644
index 000000000..34eda68d9
--- /dev/null
+++ b/arch/arm/boot/dts/skeleton.dtsi
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This file is deprecated, and will be removed once existing users have been
+ * updated. New dts{,i} files should *not* include skeleton.dtsi, and should
+ * instead explicitly provide the below nodes only as required.
+ *
+ * Skeleton device tree; the bare minimum needed to boot; just include and
+ * add a compatible value.  The bootloader will typically populate the memory
+ * node.
+ */
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	chosen { };
+	aliases { };
+	memory { device_type = "memory"; reg = <0 0>; };
+};
diff --git a/arch/arm/configs/hi3516dv300_emmc_smp_defconfig b/arch/arm/configs/hi3516dv300_emmc_smp_defconfig
new file mode 100644
index 000000000..daeb1fa65
--- /dev/null
+++ b/arch/arm/configs/hi3516dv300_emmc_smp_defconfig
@@ -0,0 +1,3070 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.19.90 Kernel Configuration
+#
+
+#
+# Compiler: arm-himix410-linux-gcc (HC&C V1R3C00SPC200B041_20200707) 7.3.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=70300
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_BUILD_SALT=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_USELIB=y
+# CONFIG_AUDIT is not set
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_MEMCG is not set
+# CONFIG_BLK_CGROUP is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+# CONFIG_USER_NS is not set
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_PROFILING is not set
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_ARTPEC is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+CONFIG_ARCH_HISI_BVT=y
+
+#
+# Hisilicon BVT platform type
+#
+# CONFIG_ARCH_HI3521DV200 is not set
+# CONFIG_ARCH_HI3520DV500 is not set
+# CONFIG_ARCH_HI3516A is not set
+# CONFIG_ARCH_HI3516CV500 is not set
+CONFIG_ARCH_HI3516DV300=y
+# CONFIG_ARCH_HI3516EV200 is not set
+# CONFIG_ARCH_HI3516EV300 is not set
+# CONFIG_ARCH_HI3518EV300 is not set
+# CONFIG_ARCH_HI3516DV200 is not set
+# CONFIG_ARCH_HI3556V200 is not set
+# CONFIG_ARCH_HI3559V200 is not set
+# CONFIG_ARCH_HI3536DV100 is not set
+# CONFIG_ARCH_HI3521A is not set
+# CONFIG_ARCH_HI3531A is not set
+# CONFIG_ARCH_HI3556AV100 is not set
+# CONFIG_ARCH_HI3519AV100 is not set
+# CONFIG_ARCH_HI3568V100 is not set
+# CONFIG_ARCH_HISI_BVT_AMP is not set
+# CONFIG_HISI_MC is not set
+CONFIG_HI_ZRELADDR=0x80008000
+CONFIG_HI_PARAMS_PHYS=0x00000100
+CONFIG_HI_INITRD_PHYS=0x00800000
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_NPCM is not set
+
+#
+# TI OMAP/AM/DM/DRA Family
+#
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_STM32 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_TANGO is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_SPECTRE=y
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_KUSER_HELPERS=y
+CONFIG_VDSO=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI is not set
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+# CONFIG_MCPM is not set
+# CONFIG_BIG_LITTLE is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
+CONFIG_CMDLINE=""
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# General architecture-dependent options
+#
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_ARCH_HAS_PHYS_TO_DMA=y
+CONFIG_REFCOUNT_FULL=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+CONFIG_BLK_CMDLINE_PARSER=y
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_DEBUG_FS is not set
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_CMDLINE_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Memory Management options
+#
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+CONFIG_CMA_DEBUG=y
+# CONFIG_CMA_DEBUGFS is not set
+CONFIG_CMA_AREAS=7
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FRAME_VECTOR=y
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_INTERFACE is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_GRO_CELLS=y
+# CONFIG_NET_DEVLINK is not set
+CONFIG_MAY_USE_DEVLINK=y
+# CONFIG_FAILOVER is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_SIMPLE_PM_BUS is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_MISC_RTSX_USB is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_MQ_DEFAULT is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+CONFIG_NET_VENDOR_AQUANTIA=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_CAVIUM=y
+# CONFIG_NET_VENDOR_CIRRUS is not set
+CONFIG_NET_VENDOR_CORTINA=y
+# CONFIG_GEMINI_ETHERNET is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+CONFIG_HISI_FEMAC=y
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+# CONFIG_HIETH_GMAC is not set
+CONFIG_NET_VENDOR_HUAWEI=y
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLXFW is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+CONFIG_NET_VENDOR_MICROSEMI=y
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+CONFIG_NET_VENDOR_NI=y
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_NET_VENDOR_SOLARFLARE=y
+# CONFIG_NET_VENDOR_SMSC is not set
+CONFIG_NET_VENDOR_SOCIONEXT=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+CONFIG_MDIO_HISI_FEMAC=y
+# CONFIG_MDIO_HISI_GEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_RTL8152=y
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+# CONFIG_HOSTAP is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_WLAN_VENDOR_REALTEK=y
+CONFIG_WLAN_VENDOR_RSI=y
+CONFIG_WLAN_VENDOR_ST=y
+CONFIG_WLAN_VENDOR_TI=y
+CONFIG_WLAN_VENDOR_ZYDAS=y
+CONFIG_WLAN_VENDOR_QUANTENNA=y
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_BYD=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_FOCALTECH=y
+CONFIG_MOUSE_PS2_SMBUS=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+# CONFIG_JOYSTICK_PSXPAD_SPI is not set
+# CONFIG_JOYSTICK_PXRC is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_DEMUX_PINCTRL is not set
+# CONFIG_I2C_MUX_MLXCPLD is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_HIBVT=y
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+CONFIG_DMA_MSG_MIN_LEN=5
+CONFIG_DMA_MSG_MAX_LEN=4090
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+# CONFIG_SPI_MEM is not set
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+CONFIG_GPIO_PL061=y
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMKONA is not set
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+CONFIG_POWER_RESET_HISI=y
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_VERSATILE is not set
+CONFIG_POWER_RESET_SYSCON=y
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
+# CONFIG_SYSCON_REBOOT_MODE is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LTC3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+CONFIG_MFD_HISI_FMC=y
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_RC_CORE is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_DTCS033 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STK1135 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TOUPTEK is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_VIDEO_USBTV is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_V4L2=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, spi, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Audio/Video compression chips
+#
+
+#
+# SDR tuner chips
+#
+
+#
+# Miscellaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Media SPI Adapters
+#
+
+#
+# Tools to develop new frontends
+#
+
+#
+# Graphics support
+#
+# CONFIG_IMX_IPUV3_CORE is not set
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+
+#
+# AMD Library routines
+#
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_OSSEMUL is not set
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# HD-Audio
+#
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+# CONFIG_SND_SOC is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+CONFIG_HID_BELKIN=y
+# CONFIG_HID_BETOP_FF is not set
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CMEDIA is not set
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+CONFIG_HID_ITE=y
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_HID_LOGITECH_HIDPP is not set
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+CONFIG_HID_REDRAGON=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_RETRODE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DBGCAP is not set
+CONFIG_USB_XHCI_PLATFORM=y
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_HOST is not set
+CONFIG_USB_DWC3_GADGET=y
+
+#
+# Platform Glue Driver Support
+#
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+# CONFIG_U_SERIAL_CONSOLE is not set
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_F_ACM=y
+CONFIG_USB_U_SERIAL=y
+CONFIG_USB_U_ETHER=y
+CONFIG_USB_U_AUDIO=y
+CONFIG_USB_F_RNDIS=y
+CONFIG_USB_F_MASS_STORAGE=y
+CONFIG_USB_F_UAC1=y
+CONFIG_USB_F_UVC=y
+CONFIG_USB_CONFIGFS=y
+# CONFIG_USB_CONFIGFS_SERIAL is not set
+CONFIG_USB_CONFIGFS_ACM=y
+# CONFIG_USB_CONFIGFS_OBEX is not set
+# CONFIG_USB_CONFIGFS_NCM is not set
+# CONFIG_USB_CONFIGFS_ECM is not set
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+CONFIG_USB_CONFIGFS_RNDIS=y
+# CONFIG_USB_CONFIGFS_EEM is not set
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+# CONFIG_USB_CONFIGFS_F_FS is not set
+CONFIG_USB_CONFIGFS_F_UAC1=y
+# CONFIG_USB_CONFIGFS_F_UAC1_LEGACY is not set
+# CONFIG_USB_CONFIGFS_F_UAC2 is not set
+# CONFIG_USB_CONFIGFS_F_MIDI is not set
+# CONFIG_USB_CONFIGFS_F_HID is not set
+CONFIG_USB_CONFIGFS_F_UVC=y
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+# CONFIG_TYPEC is not set
+# CONFIG_USB_ROLE_SWITCH is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_CQHCI is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_CQ_HCI is not set
+CONFIG_HIMCI=y
+CONFIG_SEND_AUTO_STOP=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_HIBVT=y
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO_MENU=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+CONFIG_COMMON_CLK_HI3516DV300=y
+CONFIG_RESET_HISI=y
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+# CONFIG_ARM_ARCH_TIMER_VCT_ACCESS is not set
+CONFIG_ARM_TIMER_SP804=y
+# CONFIG_TIMER_HISP804 is not set
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+
+#
+# i.MX SoC drivers
+#
+
+#
+# Qualcomm SoC drivers
+#
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_TI_SYSCON is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+CONFIG_HI_USB_PHY=y
+CONFIG_PHY_HISI_USB2=y
+CONFIG_HIBVT_USB_PHY=y
+CONFIG_USB_MODE_OPTION=y
+CONFIG_USB_DRD0_IN_HOST=y
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+# CONFIG_RAS is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_HI_DMAC is not set
+# CONFIG_HIEDMAC is not set
+
+#
+# Hisilicon driver support
+#
+# CONFIG_CMA_MEM_SHARED is not set
+# CONFIG_CMA_ADVANCE_SHARE is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_FS_IOMAP=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+CONFIG_REISERFS_CHECK=y
+CONFIG_REISERFS_PROC_INFO=y
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+CONFIG_JFS_DEBUG=y
+CONFIG_JFS_STATISTICS=y
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
+# CONFIG_XFS_ONLINE_SCRUB is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+CONFIG_CRAMFS_BLOCKDEV=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=m
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_AEGIS128L is not set
+# CONFIG_CRYPTO_AEGIS256 is not set
+# CONFIG_CRYPTO_MORUS640 is not set
+# CONFIG_CRYPTO_MORUS1280 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+CONFIG_CRYPTO_ECHAINIV=m
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CFB is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+CONFIG_CRYPTO_SHA256=m
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=m
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+CONFIG_CRYPTO_DRBG=m
+CONFIG_CRYPTO_JITTERENTROPY=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_SG_POOL=y
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITFIELD is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_IO_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP_DEBUGFS is not set
+# CONFIG_DEBUG_WX is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
diff --git a/arch/arm/configs/hi3516dv300_emmc_smp_hos_l2_defconfig b/arch/arm/configs/hi3516dv300_emmc_smp_hos_l2_defconfig
new file mode 100644
index 000000000..364f69865
--- /dev/null
+++ b/arch/arm/configs/hi3516dv300_emmc_smp_hos_l2_defconfig
@@ -0,0 +1,3135 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.19.41 Kernel Configuration
+#
+
+#
+# Compiler: arm-himix400-linux-gcc (HC&C V1R3C00SPC200B041_20200707) 7.3.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=70300
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_BUILD_SALT=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#HDF
+CONFIG_DRIVERS_HDF=y
+CONFIG_DRIVERS_HDF_PLATFORM=y
+CONFIG_DRIVERS_HDF_PLATFORM_MIPI_DSI=y
+CONFIG_DRIVERS_HDF_PLATFORM_MIPI_CSI=y
+CONFIG_DRIVERS_HDF_PLATFORM_GPIO=y
+CONFIG_DRIVERS_HDF_PLATFORM_I2C=y
+CONFIG_DRIVERS_HDF_PLATFORM_WATCHDOG=y
+CONFIG_DRIVERS_HDF_PLATFORM_PWM=y
+CONFIG_DRIVERS_HDF_PLATFORM_UART=y
+CONFIG_DRIVERS_HDF_PLATFORM_SPI=y
+CONFIG_DRIVERS_HDF_PLATFORM_RTC=y
+CONFIG_DRIVERS_HDF_DISP=y
+# CONFIG_DRIVERS_HDF_LCD_ST7789 is not set
+CONFIG_DRIVERS_HDF_LCD_ICN9700=y
+CONFIG_DRIVERS_HDF_INPUT=y
+CONFIG_DRIVERS_HDF_TP_5P5_GT911=y
+CONFIG_DRIVERS_HDF_TP_2P35_FT6236=y
+CONFIG_DRIVERS_HDF_WIFI=y
+CONFIG_DRIVERS_HI3881=y
+CONFIG_DRIVERS_HDF_USB_PNP_NOTIFY=y
+CONFIG_DRIVERS_HDF_SENSOR=y
+# CONFIG_DRIVERS_HDF_SENSOR_ACCEL is not set
+# CONFIG_DRIVERS_HDF_SENSOR_GYRO is not set
+CONFIG_DRIVERS_HDF_TEST=y
+CONFIG_DRIVERS_HDF_USB_F_GENERIC=y
+CONFIG_DRIVERS_HDF_USB_PNP_NOTIFY=y
+#
+# Timers subsystem
+#
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_MEMCG is not set
+# CONFIG_BLK_CGROUP is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+# CONFIG_USER_NS is not set
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_PROFILING is not set
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_ARTPEC is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+CONFIG_ARCH_HISI_BVT=y
+
+#
+# Hisilicon BVT platform type
+#
+# CONFIG_ARCH_HI3521DV200 is not set
+# CONFIG_ARCH_HI3520DV500 is not set
+# CONFIG_ARCH_HI3516A is not set
+# CONFIG_ARCH_HI3516CV500 is not set
+CONFIG_ARCH_HI3516DV300=y
+# CONFIG_ARCH_HI3516EV200 is not set
+# CONFIG_ARCH_HI3516EV300 is not set
+# CONFIG_ARCH_HI3518EV300 is not set
+# CONFIG_ARCH_HI3516DV200 is not set
+# CONFIG_ARCH_HI3556V200 is not set
+# CONFIG_ARCH_HI3559V200 is not set
+# CONFIG_ARCH_HI3536DV100 is not set
+# CONFIG_ARCH_HI3521A is not set
+# CONFIG_ARCH_HI3531A is not set
+# CONFIG_ARCH_HI3556AV100 is not set
+# CONFIG_ARCH_HI3519AV100 is not set
+# CONFIG_ARCH_HI3568V100 is not set
+# CONFIG_ARCH_HISI_BVT_AMP is not set
+# CONFIG_HISI_MC is not set
+CONFIG_HI_ZRELADDR=0x80008000
+CONFIG_HI_PARAMS_PHYS=0x00000100
+CONFIG_HI_INITRD_PHYS=0x00800000
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_NPCM is not set
+
+#
+# TI OMAP/AM/DM/DRA Family
+#
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_STM32 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_TANGO is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_SPECTRE=y
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_KUSER_HELPERS=y
+CONFIG_VDSO=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI is not set
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+# CONFIG_MCPM is not set
+# CONFIG_BIG_LITTLE is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
+CONFIG_CMDLINE=""
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_GC=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# General architecture-dependent options
+#
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_ARCH_HAS_PHYS_TO_DMA=y
+CONFIG_REFCOUNT_FULL=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+CONFIG_BLK_CMDLINE_PARSER=y
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_DEBUG_FS is not set
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_CMDLINE_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Memory Management options
+#
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+CONFIG_CMA_DEBUG=y
+# CONFIG_CMA_DEBUGFS is not set
+CONFIG_CMA_AREAS=7
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FRAME_VECTOR=y
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_INTERFACE is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETLABEL is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_GRO_CELLS=y
+# CONFIG_NET_DEVLINK is not set
+CONFIG_MAY_USE_DEVLINK=y
+# CONFIG_FAILOVER is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=64
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_SIMPLE_PM_BUS is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_MISC_RTSX_USB is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_MQ_DEFAULT is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+CONFIG_NET_VENDOR_AQUANTIA=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_CAVIUM=y
+# CONFIG_NET_VENDOR_CIRRUS is not set
+CONFIG_NET_VENDOR_CORTINA=y
+# CONFIG_GEMINI_ETHERNET is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+CONFIG_HISI_FEMAC=y
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+# CONFIG_HIETH_GMAC is not set
+CONFIG_NET_VENDOR_HUAWEI=y
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLXFW is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+CONFIG_NET_VENDOR_MICROSEMI=y
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+CONFIG_NET_VENDOR_NI=y
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_NET_VENDOR_SOLARFLARE=y
+# CONFIG_NET_VENDOR_SMSC is not set
+CONFIG_NET_VENDOR_SOCIONEXT=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+CONFIG_MDIO_HISI_FEMAC=y
+# CONFIG_MDIO_HISI_GEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_ASIX_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_RTL8152=y
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+# CONFIG_HOSTAP is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_WLAN_VENDOR_REALTEK=y
+CONFIG_WLAN_VENDOR_RSI=y
+CONFIG_WLAN_VENDOR_ST=y
+CONFIG_WLAN_VENDOR_TI=y
+CONFIG_WLAN_VENDOR_ZYDAS=y
+CONFIG_WLAN_VENDOR_QUANTENNA=y
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_BYD=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_FOCALTECH=y
+CONFIG_MOUSE_PS2_SMBUS=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+# CONFIG_JOYSTICK_PSXPAD_SPI is not set
+# CONFIG_JOYSTICK_PXRC is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_RMI4_CORE is not set
+CONFIG_INPUT_UINPUT=y
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_DEMUX_PINCTRL is not set
+# CONFIG_I2C_MUX_MLXCPLD is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_HIBVT=y
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+CONFIG_DMA_MSG_MIN_LEN=5
+CONFIG_DMA_MSG_MAX_LEN=4090
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+# CONFIG_SPI_MEM is not set
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+CONFIG_GPIO_PL061=y
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMKONA is not set
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+CONFIG_POWER_RESET_HISI=y
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_VERSATILE is not set
+CONFIG_POWER_RESET_SYSCON=y
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
+# CONFIG_SYSCON_REBOOT_MODE is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LTC3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+CONFIG_MFD_HISI_FMC=y
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_RC_CORE is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_DTCS033 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STK1135 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TOUPTEK is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_VIDEO_USBTV is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_V4L2=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, spi, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Audio/Video compression chips
+#
+
+#
+# SDR tuner chips
+#
+
+#
+# Miscellaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Media SPI Adapters
+#
+
+#
+# Tools to develop new frontends
+#
+
+#
+# Graphics support
+#
+# CONFIG_IMX_IPUV3_CORE is not set
+CONFIG_DRM=y
+# CONFIG_DRM_DP_AUX_CHARDEV is not set
+# CONFIG_DRM_DEBUG_MM is not set
+# CONFIG_DRM_DEBUG_SELFTEST is not set
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_FBDEV_EMULATION is not set
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+# CONFIG_DRM_DP_CEC is not set
+CONFIG_DRM_GEM_CMA_HELPER=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_I2C_NXP_TDA9950 is not set
+# CONFIG_DRM_HDLCD is not set
+# CONFIG_DRM_MALI_DISPLAY is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+
+#
+# AMD Library routines
+#
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VKMS is not set
+# CONFIG_DRM_EXYNOS is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_ARMADA is not set
+# CONFIG_DRM_RCAR_DW_HDMI is not set
+# CONFIG_DRM_RCAR_LVDS is not set
+# CONFIG_DRM_OMAP is not set
+# CONFIG_DRM_TILCDC is not set
+# CONFIG_DRM_FSL_DCU is not set
+# CONFIG_DRM_STM is not set
+CONFIG_DRM_PANEL=y
+
+#
+# Display Panels
+#
+# CONFIG_DRM_PANEL_ARM_VERSATILE is not set
+# CONFIG_DRM_PANEL_ILITEK_IL9322 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
+# CONFIG_DRM_PANEL_LG_LG4573 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
+CONFIG_DRM_BRIDGE=y
+CONFIG_DRM_PANEL_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+# CONFIG_DRM_ANALOGIX_ANX78XX is not set
+# CONFIG_DRM_CDNS_DSI is not set
+# CONFIG_DRM_DUMB_VGA_DAC is not set
+# CONFIG_DRM_LVDS_ENCODER is not set
+# CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW is not set
+# CONFIG_DRM_NXP_PTN3460 is not set
+# CONFIG_DRM_PARADE_PS8622 is not set
+# CONFIG_DRM_SIL_SII8620 is not set
+# CONFIG_DRM_SII902X is not set
+# CONFIG_DRM_SII9234 is not set
+# CONFIG_DRM_THINE_THC63LVD1024 is not set
+# CONFIG_DRM_TOSHIBA_TC358767 is not set
+# CONFIG_DRM_TI_TFP410 is not set
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_STI is not set
+# CONFIG_DRM_ARCPGU is not set
+CONFIG_DRM_HISI_HISMART=y
+# CONFIG_DRM_MXSFB is not set
+# CONFIG_DRM_TINYDRM is not set
+# CONFIG_DRM_PL111 is not set
+# CONFIG_DRM_TVE200 is not set
+# CONFIG_DRM_LEGACY is not set
+CONFIG_DRM_PANEL_ORIENTATION_QUIRKS=y
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_OSSEMUL is not set
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# HD-Audio
+#
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+# CONFIG_SND_SOC is not set
+
+#
+# HID support
+#
+# CONFIG_HID is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DBGCAP is not set
+CONFIG_USB_XHCI_PLATFORM=y
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_HOST is not set
+CONFIG_USB_DWC3_GADGET=y
+
+#
+# Platform Glue Driver Support
+#
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+# CONFIG_U_SERIAL_CONSOLE is not set
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_F_ACM=y
+CONFIG_USB_U_SERIAL=y
+CONFIG_USB_U_ETHER=y
+CONFIG_USB_U_AUDIO=y
+CONFIG_USB_F_RNDIS=y
+CONFIG_USB_F_MASS_STORAGE=y
+CONFIG_USB_F_FS=y
+CONFIG_USB_F_UAC1=y
+CONFIG_USB_F_UVC=y
+CONFIG_USB_CONFIGFS=y
+# CONFIG_USB_CONFIGFS_SERIAL is not set
+CONFIG_USB_CONFIGFS_ACM=y
+# CONFIG_USB_CONFIGFS_OBEX is not set
+# CONFIG_USB_CONFIGFS_NCM is not set
+# CONFIG_USB_CONFIGFS_ECM is not set
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+CONFIG_USB_CONFIGFS_RNDIS=y
+# CONFIG_USB_CONFIGFS_EEM is not set
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+# CONFIG_USB_CONFIGFS_F_UAC1_LEGACY is not set
+# CONFIG_USB_CONFIGFS_F_UAC2 is not set
+# CONFIG_USB_CONFIGFS_F_MIDI is not set
+# CONFIG_USB_CONFIGFS_F_HID is not set
+CONFIG_USB_CONFIGFS_F_UVC=y
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+CONFIG_TYPEC=y
+# CONFIG_TYPEC_TCPM is not set
+# CONFIG_TYPEC_UCSI is not set
+# CONFIG_TYPEC_TPS6598X is not set
+
+#
+# USB Type-C Multiplexer/DeMultiplexer Switch support
+#
+# CONFIG_TYPEC_MUX_PI3USB30532 is not set
+
+#
+# USB Type-C Alternate Mode drivers
+#
+# CONFIG_TYPEC_DP_ALTMODE is not set
+# CONFIG_USB_ROLE_SWITCH is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_CQHCI is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_CQ_HCI is not set
+CONFIG_HIMCI=y
+CONFIG_SEND_AUTO_STOP=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_HIBVT=y
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+CONFIG_SYNC_FILE=y
+# CONFIG_SW_SYNC is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO_MENU=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+CONFIG_COMMON_CLK_HI3516DV300=y
+CONFIG_RESET_HISI=y
+CONFIG_STAGING=y
+# CONFIG_HWSPINLOCK is not set
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_BINDER_DEVICES=binder,hwbinder,vndbinder
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
+# CONFIG_ANDROID_VSOC is not set
+CONFIG_ION=y
+CONFIG_ION_TEST=y
+# CONFIG_ION_DUMMY is not set
+CONFIG_ION_HICAMERA=y
+CONFIG_ION_OF=y
+# CONFIG_FIQ_DEBUGGER is not set
+# CONFIG_FIQ_WATCHDOG is not set
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_LTE_GDM724X is not set
+# CONFIG_MTD_SPINAND_MT29F is not set
+# CONFIG_LNET is not set
+# CONFIG_DGNC is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_FB_TFT is not set
+# CONFIG_FSL_MC_BUS is not set
+# CONFIG_MOST is not set
+# CONFIG_KS7010 is not set
+# CONFIG_GREYBUS is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+# CONFIG_ARM_ARCH_TIMER_VCT_ACCESS is not set
+CONFIG_ARM_TIMER_SP804=y
+# CONFIG_TIMER_HISP804 is not set
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+
+#
+# i.MX SoC drivers
+#
+
+#
+# Qualcomm SoC drivers
+#
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+CONFIG_PWM=y
+CONFIG_PWM_HI35XX=y
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_TI_SYSCON is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+CONFIG_HI_USB_PHY=y
+CONFIG_PHY_HISI_USB2=y
+CONFIG_HIBVT_USB_PHY=y
+CONFIG_USB_MODE_OPTION=y
+CONFIG_USB_DRD0_IN_HOST=y
+CONFIG_USB_DRD0_IN_DEVICE=y
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+# CONFIG_RAS is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_HI_DMAC is not set
+# CONFIG_HIEDMAC is not set
+
+#
+# Hisilicon driver support
+#
+# CONFIG_CMA_MEM_SHARED is not set
+# CONFIG_CMA_ADVANCE_SHARE is not set
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_FS_IOMAP=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+CONFIG_REISERFS_CHECK=y
+CONFIG_REISERFS_PROC_INFO=y
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+CONFIG_JFS_DEBUG=y
+CONFIG_JFS_STATISTICS=y
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
+# CONFIG_XFS_ONLINE_SCRUB is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+CONFIG_CRAMFS_BLOCKDEV=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Security options
+#
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+#CONFIG_PAGE_TABLE_ISOLATION=y
+#CONFIG_SECURITY_INFINIBAND=y
+#CONFIG_SECURITY_NETWORK_XFRM=y
+#CONFIG_SECURITY_PATH=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+# CONFIG_SECURITY_SELINUX_DISABLE is not set
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+CONFIG_DEFAULT_SECURITY="selinux"
+#CONFIG_SECURITY_SMACK=y
+# CONFIG_SECURITY_SMACK_BRINGUP is not set
+#CONFIG_SECURITY_SMACK_NETFILTER=y
+#CONFIG_SECURITY_SMACK_APPEND_SIGNALS=y
+#CONFIG_SECURITY_TOMOYO=y
+#CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY=2048
+#CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG=1024
+#CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER is not set
+#CONFIG_SECURITY_TOMOYO_POLICY_LOADER="/sbin/tomoyo-init"
+#CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER="/sbin/init"
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE=1
+CONFIG_SECURITY_APPARMOR_HASH=y
+CONFIG_SECURITY_APPARMOR_HASH_DEFAULT=y
+# CONFIG_SECURITY_APPARMOR_DEBUG is not set
+# CONFIG_SECURITY_LOADPIN is not set
+# CONFIG_SECURITY_YAMA=y
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=m
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_AEGIS128L is not set
+# CONFIG_CRYPTO_AEGIS256 is not set
+# CONFIG_CRYPTO_MORUS640 is not set
+# CONFIG_CRYPTO_MORUS1280 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+CONFIG_CRYPTO_ECHAINIV=m
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CFB is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=m
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=m
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+CONFIG_CRYPTO_DRBG=m
+CONFIG_CRYPTO_JITTERENTROPY=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_GENERIC=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_SG_POOL=y
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITFIELD is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
diff --git a/arch/arm/configs/hi3516dv300_smp_defconfig b/arch/arm/configs/hi3516dv300_smp_defconfig
new file mode 100644
index 000000000..109c06652
--- /dev/null
+++ b/arch/arm/configs/hi3516dv300_smp_defconfig
@@ -0,0 +1,3189 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.19.90 Kernel Configuration
+#
+
+#
+# Compiler: arm-himix410-linux-gcc (HC&C V1R3C00SPC200B041_20200707) 7.3.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=70300
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_BUILD_SALT=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_USELIB=y
+# CONFIG_AUDIT is not set
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_MEMCG is not set
+# CONFIG_BLK_CGROUP is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+# CONFIG_USER_NS is not set
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_PROFILING is not set
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_ARTPEC is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+CONFIG_ARCH_HISI_BVT=y
+
+#
+# Hisilicon BVT platform type
+#
+# CONFIG_ARCH_HI3521DV200 is not set
+# CONFIG_ARCH_HI3520DV500 is not set
+# CONFIG_ARCH_HI3516A is not set
+# CONFIG_ARCH_HI3516CV500 is not set
+CONFIG_ARCH_HI3516DV300=y
+# CONFIG_ARCH_HI3516EV200 is not set
+# CONFIG_ARCH_HI3516EV300 is not set
+# CONFIG_ARCH_HI3518EV300 is not set
+# CONFIG_ARCH_HI3516DV200 is not set
+# CONFIG_ARCH_HI3556V200 is not set
+# CONFIG_ARCH_HI3559V200 is not set
+# CONFIG_ARCH_HI3536DV100 is not set
+# CONFIG_ARCH_HI3521A is not set
+# CONFIG_ARCH_HI3531A is not set
+# CONFIG_ARCH_HI3556AV100 is not set
+# CONFIG_ARCH_HI3519AV100 is not set
+# CONFIG_ARCH_HI3568V100 is not set
+# CONFIG_ARCH_HISI_BVT_AMP is not set
+# CONFIG_HISI_MC is not set
+CONFIG_HI_ZRELADDR=0x80008000
+CONFIG_HI_PARAMS_PHYS=0x00000100
+CONFIG_HI_INITRD_PHYS=0x00800000
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_NPCM is not set
+
+#
+# TI OMAP/AM/DM/DRA Family
+#
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_STM32 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_TANGO is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_SPECTRE=y
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_KUSER_HELPERS=y
+CONFIG_VDSO=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI is not set
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+# CONFIG_MCPM is not set
+# CONFIG_BIG_LITTLE is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
+CONFIG_CMDLINE=""
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# General architecture-dependent options
+#
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_ARCH_HAS_PHYS_TO_DMA=y
+CONFIG_REFCOUNT_FULL=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+CONFIG_BLK_CMDLINE_PARSER=y
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_DEBUG_FS is not set
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_CMDLINE_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Memory Management options
+#
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+CONFIG_CMA_DEBUG=y
+# CONFIG_CMA_DEBUGFS is not set
+CONFIG_CMA_AREAS=7
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FRAME_VECTOR=y
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_INTERFACE is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_GRO_CELLS=y
+# CONFIG_NET_DEVLINK is not set
+CONFIG_MAY_USE_DEVLINK=y
+# CONFIG_FAILOVER is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_SIMPLE_PM_BUS is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# Partition parsers
+#
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_MCHP23K256 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_ONENAND is not set
+CONFIG_MTD_SPI_NAND_HISI_BVT=y
+# CONFIG_HISI_NAND_ECC_STATUS_REPORT is not set
+# CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_NAND_DENALI_DT is not set
+# CONFIG_MTD_NAND_GPIO is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_BRCMNAND is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+CONFIG_MTD_SPI_NAND_HIFMC100=y
+# CONFIG_MTD_SPI_NAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_MT81xx_NOR is not set
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+CONFIG_SPI_HISI_SFC=y
+# CONFIG_MTD_SPI_IDS is not set
+# CONFIG_CLOSE_SPI_8PIN_4IO is not set
+CONFIG_HISI_SPI_BLOCK_PROTECT=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_BLOCK is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_MISC_RTSX_USB is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_MQ_DEFAULT is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+CONFIG_NET_VENDOR_AQUANTIA=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_CAVIUM=y
+# CONFIG_NET_VENDOR_CIRRUS is not set
+CONFIG_NET_VENDOR_CORTINA=y
+# CONFIG_GEMINI_ETHERNET is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+CONFIG_HISI_FEMAC=y
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+# CONFIG_HIETH_GMAC is not set
+CONFIG_NET_VENDOR_HUAWEI=y
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLXFW is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+CONFIG_NET_VENDOR_MICROSEMI=y
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+CONFIG_NET_VENDOR_NI=y
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_NET_VENDOR_SOLARFLARE=y
+# CONFIG_NET_VENDOR_SMSC is not set
+CONFIG_NET_VENDOR_SOCIONEXT=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+CONFIG_MDIO_HISI_FEMAC=y
+# CONFIG_MDIO_HISI_GEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_RTL8152=y
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+# CONFIG_HOSTAP is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_WLAN_VENDOR_REALTEK=y
+CONFIG_WLAN_VENDOR_RSI=y
+CONFIG_WLAN_VENDOR_ST=y
+CONFIG_WLAN_VENDOR_TI=y
+CONFIG_WLAN_VENDOR_ZYDAS=y
+CONFIG_WLAN_VENDOR_QUANTENNA=y
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_BYD=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_FOCALTECH=y
+CONFIG_MOUSE_PS2_SMBUS=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+# CONFIG_JOYSTICK_PSXPAD_SPI is not set
+# CONFIG_JOYSTICK_PXRC is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_DEMUX_PINCTRL is not set
+# CONFIG_I2C_MUX_MLXCPLD is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_HIBVT=y
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+CONFIG_DMA_MSG_MIN_LEN=5
+CONFIG_DMA_MSG_MAX_LEN=4090
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+# CONFIG_SPI_MEM is not set
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+CONFIG_GPIO_PL061=y
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMKONA is not set
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+CONFIG_POWER_RESET_HISI=y
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_VERSATILE is not set
+CONFIG_POWER_RESET_SYSCON=y
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
+# CONFIG_SYSCON_REBOOT_MODE is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LTC3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+CONFIG_MFD_HISI_FMC=y
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_RC_CORE is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_DTCS033 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STK1135 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TOUPTEK is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_VIDEO_USBTV is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_V4L2=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, spi, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Audio/Video compression chips
+#
+
+#
+# SDR tuner chips
+#
+
+#
+# Miscellaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Media SPI Adapters
+#
+
+#
+# Tools to develop new frontends
+#
+
+#
+# Graphics support
+#
+# CONFIG_IMX_IPUV3_CORE is not set
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+
+#
+# AMD Library routines
+#
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_OSSEMUL is not set
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# HD-Audio
+#
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+# CONFIG_SND_SOC is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+CONFIG_HID_BELKIN=y
+# CONFIG_HID_BETOP_FF is not set
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CMEDIA is not set
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+CONFIG_HID_ITE=y
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_HID_LOGITECH_HIDPP is not set
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+CONFIG_HID_REDRAGON=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_RETRODE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DBGCAP is not set
+CONFIG_USB_XHCI_PLATFORM=y
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_HOST is not set
+CONFIG_USB_DWC3_GADGET=y
+
+#
+# Platform Glue Driver Support
+#
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+# CONFIG_U_SERIAL_CONSOLE is not set
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_F_ACM=y
+CONFIG_USB_U_SERIAL=y
+CONFIG_USB_U_ETHER=y
+CONFIG_USB_U_AUDIO=y
+CONFIG_USB_F_RNDIS=y
+CONFIG_USB_F_MASS_STORAGE=y
+CONFIG_USB_F_UAC1=y
+CONFIG_USB_F_UVC=y
+CONFIG_USB_CONFIGFS=y
+# CONFIG_USB_CONFIGFS_SERIAL is not set
+CONFIG_USB_CONFIGFS_ACM=y
+# CONFIG_USB_CONFIGFS_OBEX is not set
+# CONFIG_USB_CONFIGFS_NCM is not set
+# CONFIG_USB_CONFIGFS_ECM is not set
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+CONFIG_USB_CONFIGFS_RNDIS=y
+# CONFIG_USB_CONFIGFS_EEM is not set
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+# CONFIG_USB_CONFIGFS_F_FS is not set
+CONFIG_USB_CONFIGFS_F_UAC1=y
+# CONFIG_USB_CONFIGFS_F_UAC1_LEGACY is not set
+# CONFIG_USB_CONFIGFS_F_UAC2 is not set
+# CONFIG_USB_CONFIGFS_F_MIDI is not set
+# CONFIG_USB_CONFIGFS_F_HID is not set
+CONFIG_USB_CONFIGFS_F_UVC=y
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+# CONFIG_TYPEC is not set
+# CONFIG_USB_ROLE_SWITCH is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_CQHCI is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_CQ_HCI is not set
+CONFIG_HIMCI=y
+CONFIG_SEND_AUTO_STOP=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_HIBVT=y
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO_MENU=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+CONFIG_COMMON_CLK_HI3516DV300=y
+CONFIG_RESET_HISI=y
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+# CONFIG_ARM_ARCH_TIMER_VCT_ACCESS is not set
+CONFIG_ARM_TIMER_SP804=y
+# CONFIG_TIMER_HISP804 is not set
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+
+#
+# i.MX SoC drivers
+#
+
+#
+# Qualcomm SoC drivers
+#
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_TI_SYSCON is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+CONFIG_HI_USB_PHY=y
+CONFIG_PHY_HISI_USB2=y
+CONFIG_HIBVT_USB_PHY=y
+CONFIG_USB_MODE_OPTION=y
+CONFIG_USB_DRD0_IN_HOST=y
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+# CONFIG_RAS is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_HI_DMAC is not set
+# CONFIG_HIEDMAC is not set
+
+#
+# Hisilicon driver support
+#
+# CONFIG_CMA_MEM_SHARED is not set
+# CONFIG_CMA_ADVANCE_SHARE is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_FS_IOMAP=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+CONFIG_REISERFS_CHECK=y
+CONFIG_REISERFS_PROC_INFO=y
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+CONFIG_JFS_DEBUG=y
+CONFIG_JFS_STATISTICS=y
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
+# CONFIG_XFS_ONLINE_SCRUB is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_ATIME_SUPPORT is not set
+CONFIG_UBIFS_FS_XATTR=y
+# CONFIG_UBIFS_FS_ENCRYPTION is not set
+CONFIG_UBIFS_FS_SECURITY=y
+CONFIG_CRAMFS=y
+CONFIG_CRAMFS_BLOCKDEV=y
+# CONFIG_CRAMFS_MTD is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=m
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_AEGIS128L is not set
+# CONFIG_CRYPTO_AEGIS256 is not set
+# CONFIG_CRYPTO_MORUS640 is not set
+# CONFIG_CRYPTO_MORUS1280 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+CONFIG_CRYPTO_ECHAINIV=m
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CFB is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+CONFIG_CRYPTO_SHA256=m
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=m
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+CONFIG_CRYPTO_DRBG=m
+CONFIG_CRYPTO_JITTERENTROPY=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_SG_POOL=y
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITFIELD is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_IO_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP_DEBUGFS is not set
+# CONFIG_DEBUG_WX is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
diff --git a/arch/arm/include/asm/mach/pci.h b/arch/arm/include/asm/mach/pci.h
index ea9bd0889..dbe96664b 100644
--- a/arch/arm/include/asm/mach/pci.h
+++ b/arch/arm/include/asm/mach/pci.h
@@ -9,6 +9,7 @@
 #define __ASM_MACH_PCI_H
 
 #include <linux/ioport.h>
+#include <linux/msi.h>
 
 struct pci_sys_data;
 struct pci_ops;
@@ -16,7 +17,25 @@ struct pci_bus;
 struct pci_host_bridge;
 struct device;
 
+#ifdef CONFIG_PCI_MSI
+#define HISI_PCI_MSI_NR (8 * 32)
+struct hisi_msi {
+	struct msi_controller chip;
+	DECLARE_BITMAP(used, HISI_PCI_MSI_NR);
+	struct irq_domain *domain;
+	unsigned long pages;
+	struct mutex lock;
+	int irq;
+};
+#endif
 struct hw_pci {
+#ifdef CONFIG_PCI_DOMAINS
+	int     domain;
+#endif
+#ifdef CONFIG_PCI_MSI
+	struct hisi_msi msi;
+#endif
+	struct device *dev;
 	struct pci_ops	*ops;
 	int		nr_controllers;
 	void		**private_data;
@@ -26,12 +45,17 @@ struct hw_pci {
 	void		(*postinit)(void);
 	u8		(*swizzle)(struct pci_dev *dev, u8 *pin);
 	int		(*map_irq)(const struct pci_dev *dev, u8 slot, u8 pin);
+	void		(*add_bus)(struct pci_bus *bus);
+	void		(*remove_bus)(struct pci_bus *bus);
 };
 
 /*
  * Per-controller structure
  */
 struct pci_sys_data {
+#ifdef CONFIG_PCI_DOMAINS
+	int     domain;
+#endif
 	struct list_head node;
 	int		busnr;		/* primary bus number			*/
 	u64		mem_offset;	/* bus->cpu memory mapping offset	*/
diff --git a/arch/arm/include/asm/vdso/gettimeofday.h b/arch/arm/include/asm/vdso/gettimeofday.h
index 2134cbd54..6f078fedb 100644
--- a/arch/arm/include/asm/vdso/gettimeofday.h
+++ b/arch/arm/include/asm/vdso/gettimeofday.h
@@ -109,14 +109,14 @@ static __always_inline int clock_getres32_fallback(
 
 static inline bool arm_vdso_hres_capable(void)
 {
-	return IS_ENABLED(CONFIG_ARM_ARCH_TIMER);
+    return 0;
 }
 #define __arch_vdso_hres_capable arm_vdso_hres_capable
 
 static __always_inline u64 __arch_get_hw_counter(int clock_mode,
 						 const struct vdso_data *vd)
 {
-#ifdef CONFIG_ARM_ARCH_TIMER
+#if defined (CONFIG_ARM_ARCH_TIMER) && defined(CONFIG_ARM_ARCH_TIMER_VCT_ACCESS)
 	u64 cycle_now;
 
 	/*
diff --git a/arch/arm/mach-hibvt/Kconfig b/arch/arm/mach-hibvt/Kconfig
new file mode 100644
index 000000000..89bedcb95
--- /dev/null
+++ b/arch/arm/mach-hibvt/Kconfig
@@ -0,0 +1,269 @@
+config ARCH_HISI_BVT
+	bool "Hisilicon BVT SoC Support"
+	select ARM_AMBA
+	select ARM_GIC if ARCH_MULTI_V7
+	select ARM_VIC if ARCH_MULTI_V5
+	select ARM_TIMER_SP804
+	select POWER_RESET
+	select POWER_SUPPLY
+
+if ARCH_HISI_BVT
+
+menu "Hisilicon BVT platform type"
+
+config ARCH_HI3521DV200
+	bool "Hisilicon Hi3521DV200 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+	select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3521DV200 Soc family.
+
+config ARCH_HI3520DV500
+	bool "Hisilicon Hi3520DV500 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+	select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3520DV500 Soc family.
+
+config ARCH_HI3516A
+	bool "Hisilicon Hi3516A Cortex-A7(Single) family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select ARM_GIC
+	select ARCH_HAS_RESET_CONTROLLER
+	select RESET_CONTROLLER
+	help
+		Support for Hisilicon Hi3516A Soc family.
+
+config ARCH_HI3516CV500
+	bool "Hisilicon Hi3516CV500 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+    select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3516CV500 Soc family.
+
+config ARCH_HI3516DV300
+	bool "Hisilicon Hi3516DV300 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+    select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3516DV300 Soc family.
+
+config ARCH_HI3516EV200
+	bool "Hisilicon Hi3516EV200 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+    select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3516EV200 Soc family.
+
+config ARCH_HI3516EV300
+	bool "Hisilicon Hi3516EV300 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+    select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3516EV300 Soc family.
+
+config ARCH_HI3518EV300
+	bool "Hisilicon Hi3518EV300 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+    select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3518EV300 Soc family.
+
+config ARCH_HI3516DV200
+	bool "Hisilicon Hi3516DV200 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+    select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3516DV200 Soc family.
+config ARCH_HI3556V200
+	bool "Hisilicon Hi3556V200 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+    select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3556V200 Soc family.
+
+config ARCH_HI3559V200
+	bool "Hisilicon Hi3559V200 Cortex-A7 family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+    select POWER_RESET_HISI
+	help
+		Support for Hisilicon Hi3559V200 Soc family.
+
+config ARCH_HI3518EV20X
+	bool "Hisilicon Hi3518ev20x ARM926T(Single) family"
+	depends on ARCH_MULTI_V5
+	select PINCTRL
+	select PINCTRL_SINGLE
+	help
+		Support for Hisilicon Hi3518ev20x Soc family.
+
+config ARCH_HI3536DV100
+	bool "Hisilicon Hi3536DV100 Cortex-A7(Single) family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select PINCTRL
+	help
+		Support for Hisilicon Hi3536DV100 Soc family.
+
+config ARCH_HI3521A
+	bool "Hisilicon Hi3521A A7(Single) family"
+	depends on ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select ARM_GIC
+	select PINCTRL
+	select PINCTRL_SINGLE
+	help
+		Support for Hisilicon Hi3521a Soc family.
+
+config ARCH_HI3531A
+   bool "Hisilicon Hi3531A A9 family" if ARCH_MULTI_V7
+   select HAVE_ARM_ARCH_TIMER
+   select ARM_GIC
+   select CACHE_L2X0
+   select PINCTRL
+   select PINCTRL_SINGLE
+   select HAVE_ARM_SCU if SMP
+   select NEED_MACH_IO_H if PCI
+   help
+       Support for Hisilicon Hi3531a Soc family.
+
+config ARCH_HI3556AV100
+	bool "Hisilicon Hi3556AV100 Cortex-a53 family" if ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select ARM_CCI
+	select ARCH_HAS_RESET_CONTROLLER
+	select RESET_CONTROLLER
+	select PMC if SMP
+	help
+	  Support for Hisilicon Hi3556AV100 Soc family
+if ARCH_HI3556AV100
+
+config PMC
+	bool
+	depends on ARCH_HI3556AV100
+	help
+	  support power control for Hi3556AV100 Cortex-a53
+
+endif
+
+config ARCH_HI3519AV100
+	bool "Hisilicon Hi3519AV100 Cortex-a53 family" if ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select ARM_CCI
+	select ARM_GIC
+	select ARCH_HAS_RESET_CONTROLLER
+	select RESET_CONTROLLER
+	select NEED_MACH_IO_H if PCI
+	select PMC if SMP
+	help
+	  Support for Hisilicon Hi3519AV100 Soc family
+if ARCH_HI3519AV100
+
+config PMC
+	bool
+	depends on ARCH_HI3519AV100
+	help
+	  support power control for Hi3519AV100 Cortex-a53
+
+endif
+
+config ARCH_HI3568V100
+	bool "Hisilicon Hi3568V100 Cortex-a53 family" if ARCH_MULTI_V7
+	select HAVE_ARM_ARCH_TIMER
+	select ARM_CCI
+	select ARM_GIC
+	select ARCH_HAS_RESET_CONTROLLER
+	select RESET_CONTROLLER
+	select NEED_MACH_IO_H if PCI
+	select PMC if SMP
+	help
+	  Support for Hisilicon Hi3568V100 Soc family
+if ARCH_HI3568V100
+
+config PMC
+	bool
+	depends on ARCH_HI3568V100
+	help
+	  support power control for Hi3568V100 Cortex-a53
+
+endif
+
+config ARCH_HISI_BVT_AMP
+	bool "Hisilicon AMP solution support"
+      depends on ARCH_HI3556AV100 || ARCH_HI3519AV100 || ARCH_HI3516CV500 || ARCH_HI3516DV300 || ARCH_HI3556V200 || ARCH_HI3559V200 || ARCH_HI3562V100 || ARCH_HI3566V100 || ARCH_HI3568V100
+	help
+	  support for Hisilicon AMP solution
+
+config HISI_MC
+	bool "Hisilicon mc platform solution"
+	default n
+	help
+	  support for Hisilicon mc platform solution
+
+config AMP_ZRELADDR
+	hex 'amp zreladdr'
+	depends on ARCH_HISI_BVT_AMP
+	default "0x32008000" if ARCH_HI3556AV100 || ARCH_HI3519AV100 || ARCH_HI3568V100
+	default "0x82008000" if ARCH_HI3516CV500 || ARCH_HI3516DV300 || ARCH_HI3556V200 || ARCH_HI3559V200 || ARCH_HI3562V100 || ARCH_HI3566V100
+	default "0x42008000" if ARCH_HI3516EV200 || ARCH_HI3516EV300 || ARCH_HI3518EV300 || ARCH_HI3516DV200
+config HI_ZRELADDR
+       hex 'zreladdr'
+       default "0x40008000" if ARCH_HI3521DV200
+       default "0x40008000" if ARCH_HI3520DV500
+       default "0x80008000" if ARCH_HI3516CV500
+       default "0x80008000" if ARCH_HI3516DV300
+       default "0x80008000" if ARCH_HI3556V200
+       default "0x80008000" if ARCH_HI3559V200
+       default "0x80008000" if ARCH_HI3562V100
+       default "0x80008000" if ARCH_HI3566V100
+       default "0x80008000" if ARCH_HI3516A
+       default "0x80008000" if ARCH_HI3518EV20X
+       default "0x80008000" if ARCH_HI3536DV100
+       default "0x80008000" if ARCH_HI3521A
+       default "0x40008000" if ARCH_HI3531A
+       default "0x40008000" if ARCH_HI3516EV200 || ARCH_HI3516EV300 || ARCH_HI3518EV300 || ARCH_HI3516DV200
+       default "0x22008000" if ARCH_HI3556AV100 || ARCH_HI3519AV100 || ARCH_HI3568V100
+
+config HI_PARAMS_PHYS
+       hex 'params_phys'
+       default "0x00000100"
+
+config HI_INITRD_PHYS
+       hex 'initrd_phys'
+       default "0x00800000"
+
+endmenu
+
+if ARCH_HI3516DV300
+
+config BLACKBOX_HI3516DV300
+	bool "Support BlackBox saving fault logs with pstore for hi3516dv300"
+	depends on PSTORE_BLACKBOX
+	depends on BLACKBOX_STORAGE_BY_PSTORE_BLK
+	help
+		Save fault logs with pstore for Hi3516DV300 when oops or panic occurs.
+
+endif
+
+endif
diff --git a/arch/arm/mach-hibvt/Makefile b/arch/arm/mach-hibvt/Makefile
new file mode 100644
index 000000000..8c4802fd1
--- /dev/null
+++ b/arch/arm/mach-hibvt/Makefile
@@ -0,0 +1,34 @@
+#
+# Makefile for Hisilicon processors family
+#
+
+obj-$(CONFIG_ARCH_HI3521DV200) += mach-hi3521dv200.o
+obj-$(CONFIG_ARCH_HI3520DV500) += mach-hi3521dv200.o
+obj-$(CONFIG_ARCH_HI3516A) += mach-hi3516a.o
+obj-$(CONFIG_ARCH_HI3516CV500) += mach-hi3516cv500.o
+obj-$(CONFIG_ARCH_HI3516EV200) += mach-hi3516ev200.o
+obj-$(CONFIG_ARCH_HI3516EV300) += mach-hi3516ev300.o
+obj-$(CONFIG_ARCH_HI3518EV300) += mach-hi3518ev300.o
+obj-$(CONFIG_ARCH_HI3516DV200) += mach-hi3516dv200.o
+obj-$(CONFIG_ARCH_HI3516DV300) += mach-hi3516dv300.o
+obj-$(CONFIG_ARCH_HI3556V200) += mach-hi3556v200.o
+obj-$(CONFIG_ARCH_HI3559V200) += mach-hi3559v200.o
+obj-$(CONFIG_ARCH_HI3562V100) += mach-hi3559v200.o
+obj-$(CONFIG_ARCH_HI3566V100) += mach-hi3559v200.o
+obj-$(CONFIG_ARCH_HI3518EV20X) += mach-hi3518ev20x.o
+obj-$(CONFIG_ARCH_HI3536DV100) += mach-hi3536dv100.o
+obj-$(CONFIG_ARCH_HI3521A) += mach-hi3521a.o
+obj-$(CONFIG_ARCH_HI3531A) += mach-hi3531a.o
+obj-$(CONFIG_ARCH_HI3556AV100) += mach-hi3556av100.o
+obj-$(CONFIG_ARCH_HI3519AV100) += mach-hi3519av100.o
+obj-$(CONFIG_ARCH_HI3568V100) += mach-hi3519av100.o
+
+
+obj-$(CONFIG_SMP)	+= platsmp.o
+
+ifdef CONFIG_BLACKBOX_HI3516DV300
+
+obj-$(CONFIG_BLACKBOX_STORAGE_BY_PSTORE_BLK) += system_adapter.o
+obj-$(CONFIG_BLACKBOX_STORAGE_BY_MEMORY) += system_adapter_by_memory.o
+
+endif
diff --git a/arch/arm/mach-hibvt/Makefile.boot b/arch/arm/mach-hibvt/Makefile.boot
new file mode 100644
index 000000000..8c8b30077
--- /dev/null
+++ b/arch/arm/mach-hibvt/Makefile.boot
@@ -0,0 +1,7 @@
+ifeq ($(CONFIG_ARCH_HISI_BVT_AMP), y)
+zreladdr-$(CONFIG_ARCH_HISI_BVT)      := $(CONFIG_AMP_ZRELADDR)
+else
+zreladdr-$(CONFIG_ARCH_HISI_BVT)      := $(CONFIG_HI_ZRELADDR)
+endif
+params_phys-$(CONFIG_ARCH_HISI_BVT)   := $(CONFIG_HI_PARAMS_PHYS)
+initrd_phys-$(CONFIG_ARCH_HISI_BVT)   := $(CONFIG_HI_INITRD_PHYS)
diff --git a/arch/arm/mach-hibvt/include/mach/hi3516dv300_io.h b/arch/arm/mach-hibvt/include/mach/hi3516dv300_io.h
new file mode 100644
index 000000000..72ab47e83
--- /dev/null
+++ b/arch/arm/mach-hibvt/include/mach/hi3516dv300_io.h
@@ -0,0 +1,26 @@
+#ifndef __HI3516DV300_IO_H
+#define __HI3516DV300_IO_H
+
+/*
+ * phy: 0x20000000 ~ 0x20700000
+ * vir: 0xFE100000 ~ 0xFE800000
+ */
+#define HI3516DV300_IOCH2_PHYS  0x20000000
+#define IO_OFFSET_HIGH      0xDE100000
+#define HI3516DV300_IOCH2_VIRT (HI3516DV300_IOCH2_PHYS + IO_OFFSET_HIGH)
+#define HI3516DV300_IOCH2_SIZE 0x700000
+
+/* phy: 0x10000000 ~ 0x100E0000
+ * vir: 0xFE000000 ~ 0xFE0E0000
+ */
+#define HI3516DV300_IOCH1_PHYS  0x10000000
+#define IO_OFFSET_LOW       0xEE000000
+#define HI3516DV300_IOCH1_VIRT (HI3516DV300_IOCH1_PHYS + IO_OFFSET_LOW)
+#define HI3516DV300_IOCH1_SIZE 0xE0000
+
+#define IO_ADDRESS(x) ((x) >= HI3516DV300_IOCH2_PHYS ? (x) + IO_OFFSET_HIGH \
+                                : (x) + IO_OFFSET_LOW)
+
+#define __io_address(n)     ((void __iomem __force *)IO_ADDRESS(n))
+
+#endif
diff --git a/arch/arm/mach-hibvt/include/mach/hi3516dv300_platform.h b/arch/arm/mach-hibvt/include/mach/hi3516dv300_platform.h
new file mode 100644
index 000000000..94c48064b
--- /dev/null
+++ b/arch/arm/mach-hibvt/include/mach/hi3516dv300_platform.h
@@ -0,0 +1,4 @@
+#ifndef __HI3516DV300_CHIP_REGS_H__
+#define __HI3516DV300_CHIP_REGS_H__
+
+#endif /* End of __HI3516DV300_CHIP_REGS_H__ */
diff --git a/arch/arm/mach-hibvt/include/mach/io.h b/arch/arm/mach-hibvt/include/mach/io.h
new file mode 100644
index 000000000..b5fd58c7b
--- /dev/null
+++ b/arch/arm/mach-hibvt/include/mach/io.h
@@ -0,0 +1,52 @@
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#ifdef CONFIG_ARCH_HI3516A
+#include <mach/hi3516a_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3518EV20X
+#include <mach/hi3518ev20x_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3536DV100
+#include <mach/hi3536dv100_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3521A
+#include <mach/hi3521a_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3531A
+#include <mach/hi3531a_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3516CV500
+#include <mach/hi3516cv500_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3516DV300
+#include <mach/hi3516dv300_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3556V200
+#include <mach/hi3556v200_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3559V200
+#include <mach/hi3559v200_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3562V100
+#include <mach/hi3559v200_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3566V100
+#include <mach/hi3559v200_io.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3519AV100
+#include <mach/hi3519av100_io.h>
+#endif
+
+#endif
diff --git a/arch/arm/mach-hibvt/include/mach/platform.h b/arch/arm/mach-hibvt/include/mach/platform.h
new file mode 100644
index 000000000..5e41d2696
--- /dev/null
+++ b/arch/arm/mach-hibvt/include/mach/platform.h
@@ -0,0 +1,52 @@
+#ifndef __HISI_PLATFORM_H__
+#define __HISI_PLATFORM_H__
+
+#ifdef CONFIG_ARCH_HI3536DV100
+#include <mach/hi3536dv100_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3521A
+#include <mach/hi3521a_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3531A
+#include <mach/hi3531a_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3516DV300
+#include <mach/hi3516dv300_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3516CV500
+#include <mach/hi3516cv500_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3556V200
+#include <mach/hi3556v200_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3559V200
+#include <mach/hi3559v200_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3562V100
+#include <mach/hi3559v200_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3566V100
+#include <mach/hi3559v200_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3556AV100
+#include <mach/hi3556av100_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3519AV100
+#include <mach/hi3519av100_platform.h>
+#endif
+
+#ifdef CONFIG_ARCH_HI3568V100
+#include <mach/hi3519av100_platform.h>
+#endif
+
+#endif /* End of __HISI_PLATFORM_H__ */
diff --git a/arch/arm/mach-hibvt/mach-common.h b/arch/arm/mach-hibvt/mach-common.h
new file mode 100644
index 000000000..f5edadb0f
--- /dev/null
+++ b/arch/arm/mach-hibvt/mach-common.h
@@ -0,0 +1,9 @@
+#ifndef __SMP_COMMON_H
+#define __SMP_COMMON_H
+
+#ifdef CONFIG_SMP
+void hi35xx_set_cpu(unsigned int cpu, bool enable);
+void __init hi35xx_smp_prepare_cpus(unsigned int max_cpus);
+int hi35xx_boot_secondary(unsigned int cpu, struct task_struct *idle);
+#endif /* CONFIG_SMP */
+#endif /* __SMP_COMMON_H */
diff --git a/arch/arm/mach-hibvt/mach-hi3516dv300.c b/arch/arm/mach-hibvt/mach-hi3516dv300.c
new file mode 100644
index 000000000..3061683bb
--- /dev/null
+++ b/arch/arm/mach-hibvt/mach-hi3516dv300.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ *
+*/
+
+#include <linux/of_address.h>
+#include <asm/smp_scu.h>
+
+#include "mach-common.h"
+
+#ifdef CONFIG_SMP
+
+#define REG_CPU_SRST_CRG    0x78
+#define CPU1_SRST_REQ       BIT(2)
+#define DBG1_SRST_REQ       BIT(4)
+
+void hi35xx_set_cpu(unsigned int cpu, bool enable)
+{
+	struct device_node *np = NULL;
+	unsigned int regval;
+	void __iomem *crg_base;
+
+	np = of_find_compatible_node(NULL, NULL, "hisilicon,hi3516dv300-clock");
+	if (!np) {
+		pr_err("failed to find hisilicon clock node\n");
+		return;
+	}
+
+	crg_base = of_iomap(np, 0);
+	if (!crg_base) {
+		pr_err("failed to map address\n");
+		return;
+	}
+
+	if (enable) {
+		/* clear the slave cpu reset */
+		regval = readl(crg_base + REG_CPU_SRST_CRG);
+		regval &= ~CPU1_SRST_REQ;
+		writel(regval, (crg_base + REG_CPU_SRST_CRG));
+	} else {
+		regval = readl(crg_base + REG_CPU_SRST_CRG);
+		regval |= (DBG1_SRST_REQ | CPU1_SRST_REQ);
+		writel(regval, (crg_base + REG_CPU_SRST_CRG));
+	}
+	iounmap(crg_base);
+}
+
+static const struct smp_operations hi35xx_smp_ops __initconst = {
+	.smp_prepare_cpus       = hi35xx_smp_prepare_cpus,
+	.smp_boot_secondary     = hi35xx_boot_secondary,
+};
+
+CPU_METHOD_OF_DECLARE(hi3516dv300_smp, "hisilicon,hi3516dv300",
+		      &hi35xx_smp_ops);
+#endif /* CONFIG_SMP */
diff --git a/arch/arm/mach-hibvt/platsmp.c b/arch/arm/mach-hibvt/platsmp.c
new file mode 100644
index 000000000..a73be20b1
--- /dev/null
+++ b/arch/arm/mach-hibvt/platsmp.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2013 Linaro Ltd.
+ * Copyright (c) 2013 Hisilicon Limited.
+ * Based on arch/arm/mach-vexpress/platsmp.c, Copyright (C) 2002 ARM Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/smp.h>
+#include <asm/smp_scu.h>
+
+#include "mach-common.h"
+
+#define HI35XX_BOOT_ADDRESS 0x00000000
+
+void __init hi35xx_smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned long base = 0;
+	void __iomem *scu_base = NULL;
+
+	if (scu_a9_has_base()) {
+		base = scu_a9_get_base();
+		scu_base = ioremap(base, PAGE_SIZE);
+		if (!scu_base) {
+			pr_err("ioremap(scu_base) failed\n");
+			return;
+		}
+
+		scu_enable(scu_base);
+		iounmap(scu_base);
+	}
+}
+
+void hi35xx_set_scu_boot_addr(phys_addr_t start_addr, phys_addr_t jump_addr)
+{
+	void __iomem *virt;
+
+	virt = ioremap(start_addr, PAGE_SIZE);
+	if (!virt) {
+		pr_err("ioremap(start_addr) failed\n");
+		return;
+	}
+
+	writel_relaxed(0xe51ff004, virt);   /* ldr pc, [rc, #-4] */
+	writel_relaxed(jump_addr, virt + 4);    /* pc jump phy address */
+	iounmap(virt);
+}
+
+int hi35xx_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	phys_addr_t jumpaddr;
+
+	jumpaddr = virt_to_phys(secondary_startup);
+	hi35xx_set_scu_boot_addr(HI35XX_BOOT_ADDRESS, jumpaddr);
+	hi35xx_set_cpu(cpu, true);
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+	return 0;
+}
+
diff --git a/arch/arm/mach-hibvt/system_adapter.c b/arch/arm/mach-hibvt/system_adapter.c
new file mode 100644
index 000000000..58fe574b3
--- /dev/null
+++ b/arch/arm/mach-hibvt/system_adapter.c
@@ -0,0 +1,340 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 Huawei Technologies Co., Ltd. All rights reserved.
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/blackbox.h>
+#include <linux/kmsg_dump.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/stacktrace.h>
+#include <linux/reboot.h>
+#include <linux/vmalloc.h>
+#include <linux/ctype.h>
+#include <linux/blackbox_common.h>
+#include <linux/blackbox_storage.h>
+
+/* ---- local macroes ---- */
+#define BOOTLOADER_LOG_NAME       "fastboot_log"
+#define KERNEL_LOG_NAME           "last_kmsg"
+#define SIZE_1K                   1024
+#define KERNEL_LOG_MAX_SIZE               \
+	round_up((0x80000 + sizeof(struct fault_log_info)), SIZE_1K)
+#define CALLSTACK_MAX_ENTRIES     20
+
+/* ---- local prototypes ---- */
+
+/* ---- local function prototypes ---- */
+static int save_kmsg_from_buffer(const char *log_dir,
+				const char *file_name, int clean_buf);
+static void dump(const char *log_dir, struct error_info *info);
+static void reset(struct error_info *info);
+static int get_last_log_info(struct error_info *info);
+static int save_last_log(const char *log_dir, struct error_info *info);
+static int bbox_reboot_notify(struct notifier_block *nb,
+					unsigned long code, void *unused);
+static int bbox_task_panic(struct notifier_block *this,
+					unsigned long event, void *ptr);
+
+/* ---- local variables ---- */
+static char *kernel_log;
+static DEFINE_SEMAPHORE(kmsg_sem);
+static struct notifier_block bbox_reboot_nb = {
+	.notifier_call = bbox_reboot_notify,
+};
+
+static struct notifier_block bbox_panic_block = {
+	.notifier_call = bbox_task_panic,
+};
+
+/* ---- function definitions ---- */
+static void dump_stacktrace(char *pbuf, size_t buf_size, bool is_panic)
+{
+	int i;
+	size_t stack_len = 0;
+	size_t com_len = 0;
+	unsigned long entries[CALLSTACK_MAX_ENTRIES];
+	unsigned int nr_entries;
+	char tmp_buf[ERROR_DESC_MAX_LEN];
+	bool find_panic = false;
+
+	if (unlikely(!pbuf || !buf_size))
+		return;
+
+	memset(pbuf, 0, buf_size);
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	nr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 0);
+	com_len = scnprintf(pbuf, buf_size, "Comm:%s,CPU:%d,Stack:",
+						current->comm, raw_smp_processor_id());
+	for (i = 0; i < nr_entries; i++) {
+		if (stack_len >= sizeof(tmp_buf)) {
+			tmp_buf[sizeof(tmp_buf) - 1] = '\0';
+			break;
+		}
+		stack_len += scnprintf(tmp_buf + stack_len, sizeof(tmp_buf) - stack_len,
+				"%pS-", (void *)entries[i]);
+		if (!find_panic && is_panic) {
+			if (strncmp(tmp_buf, "panic", strlen("panic")) == 0)
+				find_panic = true;
+			else
+				(void)memset(tmp_buf, 0, sizeof(tmp_buf));
+		}
+	}
+	if (com_len >= buf_size)
+		return;
+	stack_len = min(buf_size - com_len, strlen(tmp_buf));
+	memcpy(pbuf + com_len, tmp_buf, stack_len);
+	*(pbuf + buf_size - 1) = '\0';
+}
+
+static int save_kmsg_from_buffer(const char *log_dir,
+				const char *file_name, int clean_buf)
+{
+	int ret = -1;
+	char path[PATH_MAX_LEN];
+	struct fault_log_info *pinfo = NULL;
+
+	if (unlikely(!log_dir || !file_name)) {
+		bbox_print_err("log_dir: %p, file_name: %p!\n", log_dir, file_name);
+		return -EINVAL;
+	}
+
+	memset(path, 0, sizeof(path));
+	(void)scnprintf(path, sizeof(path) - 1, "%s/%s", log_dir, file_name);
+	down(&kmsg_sem);
+	if (kernel_log) {
+		pinfo = (struct fault_log_info *)kernel_log;
+		ret = full_write_file(path, kernel_log + sizeof(*pinfo),
+					min(KERNEL_LOG_MAX_SIZE - sizeof(*pinfo),
+						(size_t)pinfo->len), 0);
+		if (clean_buf)
+			memset(kernel_log, 0, KERNEL_LOG_MAX_SIZE);
+	} else {
+		bbox_print_err("kernel_log: %p!\n", kernel_log);
+	}
+	up(&kmsg_sem);
+	if (ret == 0)
+		change_own(path, AID_ROOT, AID_SYSTEM);
+
+	return ret;
+}
+
+static void dump(const char *log_dir, struct error_info *info)
+{
+	if (unlikely(!log_dir || !info)) {
+		bbox_print_err("log_dir: %p, info: %p!\n", log_dir, info);
+		return;
+	}
+
+	if (!strcmp(info->event, EVENT_PANIC) ||
+		!strcmp(info->event, EVENT_SYSREBOOT) ||
+		!strcmp(info->event, EVENT_POWEROFF)) {
+		struct fault_log_info *pinfo = (struct fault_log_info *)kernel_log;
+
+		if (down_trylock(&kmsg_sem) != 0) {
+			bbox_print_err("down_trylock failed!\n");
+			return;
+		}
+
+		if (kernel_log) {
+			memcpy(pinfo->flag, LOG_FLAG, strlen(LOG_FLAG));
+			memcpy(&pinfo->info, info, sizeof(*info));
+
+#if  __BITS_PER_LONG == 64
+			__flush_dcache_area(kernel_log, KERNEL_LOG_MAX_SIZE);
+#else
+			__cpuc_flush_dcache_area(kernel_log, KERNEL_LOG_MAX_SIZE);
+#endif
+		}
+
+		up(&kmsg_sem);
+	} else {
+		bbox_print_info("module [%s] starts saving log for event [%s]!\n",
+				info->module, info->event);
+		save_kmsg_from_buffer(log_dir, KERNEL_LOG_NAME, 0);
+		bbox_print_info("module [%s] ends saving log for event [%s]!\n",
+				info->module, info->event);
+	}
+}
+
+static void reset(struct error_info *info)
+{
+	if (unlikely(!info)) {
+		bbox_print_err("info: %p!\n", info);
+		return;
+	}
+
+	if (!strcmp(info->event, EVENT_PANIC))
+		emergency_restart();
+}
+
+static int get_last_log_info(struct error_info *info)
+{
+	struct fault_log_info *pinfo = (struct fault_log_info *)kernel_log;
+	int log_size = KERNEL_LOG_MAX_SIZE;
+	unsigned int i = 0;
+
+	if (unlikely(!info || !kernel_log))
+		return -EINVAL;
+
+	if (storage_lastword->get_log((void *)kernel_log, log_size) < 0) {
+		bbox_print_err("Get last log from strorage failed!\n");
+		return -ENOENT;
+	}
+
+	down(&kmsg_sem);
+	if (!memcmp(pinfo->flag, LOG_FLAG, strlen(LOG_FLAG))) {
+		memcpy(info, &pinfo->info, sizeof(*info));
+		for (i = 0; i < strlen((*info).event); i++)
+			(*info).event[i] = toupper((*info).event[i]);
+
+		if (strncmp((*info).module, "PSTORE", strlen("PSTORE")) == 0)
+			memcpy((*info).module, MODULE_SYSTEM, sizeof((*info).module));
+
+		up(&kmsg_sem);
+		return 0;
+	}
+	up(&kmsg_sem);
+	bbox_print_info("There's no valid fault log!\n");
+
+	return -ENOMSG;
+}
+
+static int save_last_log(const char *log_dir, struct error_info *info)
+{
+	int ret = -1;
+
+	if (unlikely(!log_dir || !info)) {
+		bbox_print_err("log_dir: %p, info: %p!\n", log_dir, info);
+		return -EINVAL;
+	}
+
+	ret = save_kmsg_from_buffer(log_dir, KERNEL_LOG_NAME, 1);
+	bbox_print_info("save last fault log %s!\n",
+			ret ? "failed" : "successfully");
+
+	return ret;
+}
+
+static int bbox_reboot_notify(struct notifier_block *nb,
+					unsigned long code, void *unused)
+{
+	char error_desc[ERROR_DESC_MAX_LEN];
+
+	/* notify blackbox to do dump */
+	memset(error_desc, 0, sizeof(error_desc));
+	dump_stacktrace(error_desc, sizeof(error_desc), false);
+	kmsg_dump(KMSG_DUMP_UNDEF);
+
+	switch (code) {
+	case SYS_RESTART:
+		bbox_notify_error(EVENT_SYSREBOOT, MODULE_SYSTEM, error_desc, 1);
+		break;
+	case SYS_POWER_OFF:
+		bbox_notify_error(EVENT_POWEROFF, MODULE_SYSTEM, error_desc, 0);
+		break;
+	default:
+		bbox_print_err("Invalid event code: %lu!\n", code);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int bbox_task_panic(struct notifier_block *this,
+				unsigned long event, void *ptr)
+{
+	char error_desc[ERROR_DESC_MAX_LEN];
+
+	/* notify blackbox to do dump */
+	kmsg_dump(KMSG_DUMP_OOPS);
+	memset(error_desc, 0, sizeof(error_desc));
+	bbox_notify_error(EVENT_PANIC, MODULE_SYSTEM, error_desc, 1);
+
+	return NOTIFY_DONE;
+}
+
+#ifdef CONFIG_BLACKBOX_TEST
+static void test_bbox(void)
+{
+	struct module_ops ops = {
+		.module = "TEST",
+		.dump = NULL,
+		.reset = NULL,
+		.get_last_log_info = NULL,
+		.save_last_log = NULL,
+	};
+
+	if (bbox_register_module_ops(&ops) != 0) {
+		bbox_print_err("bbox_register_module_ops failed!\n");
+		return -EINVAL;
+	}
+	kmsg_dump(KMSG_DUMP_OOPS);
+	bbox_notify_error("EVENT_TEST", "TEST", "Test bbox_notify_error", 0);
+
+}
+#endif
+
+static int __init blackbox_init(void)
+{
+	int ret = -1;
+	struct kmsg_dumper *dumper = NULL;
+	struct module_ops ops = {
+		.module = MODULE_SYSTEM,
+		.dump = dump,
+		.reset = reset,
+		.get_last_log_info = get_last_log_info,
+		.save_last_log = save_last_log,
+	};
+
+	if (bbox_register_module_ops(&ops) != 0) {
+		bbox_print_err("bbox_register_module_ops failed!\n");
+		return -EINVAL;
+	}
+
+	/* allocate buffer for kmsg */
+	kernel_log = kmalloc(KERNEL_LOG_MAX_SIZE, GFP_KERNEL);
+	if (!kernel_log)
+		goto __err;
+
+	bbox_print_info("kernel_log: %p for blackbox!\n", kernel_log);
+
+	/* register kdumper */
+	dumper = vmalloc(sizeof(*dumper));
+	if (!dumper)
+		goto __err;
+
+	memset(dumper, 0, sizeof(*dumper));
+	dumper->max_reason = KMSG_DUMP_MAX;
+	dumper->dump = storage_lastword->blackbox_dump;
+	ret = kmsg_dump_register(dumper);
+	if (ret != 0) {
+		bbox_print_err("kmsg_dump_register failed!\n");
+		goto __err;
+	}
+	atomic_notifier_chain_register(&panic_notifier_list, &bbox_panic_block);
+
+	register_reboot_notifier(&bbox_reboot_nb);
+#ifdef CONFIG_BLACKBOX_TEST
+	test_bbox();
+#endif
+	return 0;
+
+__err:
+	kfree(kernel_log);
+	kernel_log = NULL;
+
+	if (dumper) {
+		vfree(dumper);
+		dumper = NULL;
+	}
+
+	return ret;
+}
+
+postcore_initcall(blackbox_init);
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Blackbox for system");
+MODULE_AUTHOR("OHOS hi3516dv300");
diff --git a/arch/arm/mach-hibvt/system_adapter_by_memory.c b/arch/arm/mach-hibvt/system_adapter_by_memory.c
new file mode 100644
index 000000000..92a680a9e
--- /dev/null
+++ b/arch/arm/mach-hibvt/system_adapter_by_memory.c
@@ -0,0 +1,339 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 Huawei Technologies Co., Ltd. All rights reserved.
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/blackbox.h>
+#include <linux/kmsg_dump.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/stacktrace.h>
+#include <linux/reboot.h>
+#include <linux/vmalloc.h>
+#include <linux/ctype.h>
+#include <linux/blackbox_common.h>
+#include <linux/blackbox_storage.h>
+
+/* ---- local macroes ---- */
+#define BOOTLOADER_LOG_NAME       "fastboot_log"
+#define KERNEL_LOG_NAME           "last_kmsg"
+#define SIZE_1K                   1024
+#define KERNEL_LOG_MAX_SIZE               \
+	round_up((0x80000 + sizeof(struct fault_log_info)), SIZE_1K)
+#define CALLSTACK_MAX_ENTRIES     20
+
+/* ---- local prototypes ---- */
+
+/* ---- local function prototypes ---- */
+static int save_kmsg_from_buffer(const char *log_dir,
+				const char *file_name, int clean_buf);
+static void dump(const char *log_dir, struct error_info *info);
+static void reset(struct error_info *info);
+static int get_last_log_info(struct error_info *info);
+static int save_last_log(const char *log_dir, struct error_info *info);
+static int bbox_reboot_notify(struct notifier_block *nb,
+					unsigned long code, void *unused);
+static int bbox_task_panic(struct notifier_block *this,
+					unsigned long event, void *ptr);
+
+/* ---- local variables ---- */
+static char *kernel_log;
+static DEFINE_SEMAPHORE(kmsg_sem);
+static struct notifier_block bbox_reboot_nb = {
+	.notifier_call = bbox_reboot_notify,
+};
+
+static struct notifier_block bbox_panic_block = {
+	.notifier_call = bbox_task_panic,
+};
+
+/* ---- function definitions ---- */
+static void dump_stacktrace(char *pbuf, size_t buf_size, bool is_panic)
+{
+	int i;
+	size_t stack_len = 0;
+	size_t com_len = 0;
+	unsigned long entries[CALLSTACK_MAX_ENTRIES];
+	unsigned int nr_entries;
+	char tmp_buf[ERROR_DESC_MAX_LEN];
+	bool find_panic = false;
+
+	if (unlikely(!pbuf || !buf_size))
+		return;
+
+	memset(pbuf, 0, buf_size);
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	nr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 0);
+	com_len = scnprintf(pbuf, buf_size, "Comm:%s,CPU:%d,Stack:",
+						current->comm, raw_smp_processor_id());
+	for (i = 0; i < nr_entries; i++) {
+		if (stack_len >= sizeof(tmp_buf)) {
+			tmp_buf[sizeof(tmp_buf) - 1] = '\0';
+			break;
+		}
+		stack_len += scnprintf(tmp_buf + stack_len, sizeof(tmp_buf) - stack_len,
+				"%pS-", (void *)entries[i]);
+		if (!find_panic && is_panic) {
+			if (strncmp(tmp_buf, "panic", strlen("panic")) == 0)
+				find_panic = true;
+			else
+				(void)memset(tmp_buf, 0, sizeof(tmp_buf));
+		}
+	}
+	if (com_len >= buf_size)
+		return;
+	stack_len = min(buf_size - com_len, strlen(tmp_buf));
+	memcpy(pbuf + com_len, tmp_buf, stack_len);
+	*(pbuf + buf_size - 1) = '\0';
+}
+
+static int save_kmsg_from_buffer(const char *log_dir,
+				const char *file_name, int clean_buf)
+{
+	int ret = -1;
+	char path[PATH_MAX_LEN];
+	struct fault_log_info *pinfo = NULL;
+
+	if (unlikely(!log_dir || !file_name)) {
+		bbox_print_err("log_dir: %p, file_name: %p!\n", log_dir, file_name);
+		return -EINVAL;
+	}
+
+	memset(path, 0, sizeof(path));
+	(void)scnprintf(path, sizeof(path) - 1, "%s/%s", log_dir, file_name);
+	down(&kmsg_sem);
+	if (kernel_log) {
+		pinfo = (struct fault_log_info *)kernel_log;
+		ret = full_write_file(path, kernel_log + sizeof(*pinfo),
+					min(KERNEL_LOG_MAX_SIZE - sizeof(*pinfo),
+						(size_t)pinfo->len), 0);
+		if (clean_buf)
+			memset(kernel_log, 0, KERNEL_LOG_MAX_SIZE);
+	} else {
+		bbox_print_err("kernel_log: %p!\n", kernel_log);
+	}
+	up(&kmsg_sem);
+	if (ret == 0)
+		change_own(path, AID_ROOT, AID_SYSTEM);
+
+	return ret;
+}
+
+static void dump(const char *log_dir, struct error_info *info)
+{
+	if (unlikely(!log_dir || !info)) {
+		bbox_print_err("log_dir: %p, info: %p!\n", log_dir, info);
+		return;
+	}
+
+	if (!strcmp(info->event, EVENT_PANIC) ||
+		!strcmp(info->event, EVENT_SYSREBOOT) ||
+		!strcmp(info->event, EVENT_POWEROFF)) {
+		struct fault_log_info *pinfo = (struct fault_log_info *)kernel_log;
+
+		if (down_trylock(&kmsg_sem) != 0) {
+			bbox_print_err("down_trylock failed!\n");
+			return;
+		}
+
+		if (kernel_log) {
+			memcpy(pinfo->flag, LOG_FLAG, strlen(LOG_FLAG));
+			memcpy(&pinfo->info, info, sizeof(*info));
+
+#if  __BITS_PER_LONG == 64
+			__flush_dcache_area(kernel_log, KERNEL_LOG_MAX_SIZE);
+#else
+			__cpuc_flush_dcache_area(kernel_log, KERNEL_LOG_MAX_SIZE);
+#endif
+		}
+
+		up(&kmsg_sem);
+	} else {
+		bbox_print_info("module [%s] starts saving log for event [%s]!\n",
+				info->module, info->event);
+		save_kmsg_from_buffer(log_dir, KERNEL_LOG_NAME, 0);
+		bbox_print_info("module [%s] ends saving log for event [%s]!\n",
+				info->module, info->event);
+	}
+}
+
+static void reset(struct error_info *info)
+{
+	if (unlikely(!info)) {
+		bbox_print_err("info: %p!\n", info);
+		return;
+	}
+
+	if (!strcmp(info->event, EVENT_PANIC))
+		emergency_restart();
+}
+
+static int get_last_log_info(struct error_info *info)
+{
+	struct fault_log_info *pinfo = (struct fault_log_info *)kernel_log;
+	int log_size = KERNEL_LOG_MAX_SIZE;
+
+	if (unlikely(!info || !kernel_log))
+		return -EINVAL;
+
+	if (storage_lastword->get_log((void *)kernel_log, log_size) < 0) {
+		bbox_print_err("Get last log from strorage failed!\n");
+		return -ENOENT;
+	}
+
+	down(&kmsg_sem);
+	if (!memcmp(pinfo->flag, LOG_FLAG, strlen(LOG_FLAG))) {
+		memcpy(info, &pinfo->info, sizeof(*info));
+
+		up(&kmsg_sem);
+		return 0;
+	}
+	up(&kmsg_sem);
+	bbox_print_info("There's no valid fault log!\n");
+
+	return -ENOMSG;
+}
+
+static int save_last_log(const char *log_dir, struct error_info *info)
+{
+	int ret = -1;
+
+	if (unlikely(!log_dir || !info)) {
+		bbox_print_err("log_dir: %p, info: %p!\n", log_dir, info);
+		return -EINVAL;
+	}
+
+	ret = save_kmsg_from_buffer(log_dir, KERNEL_LOG_NAME, 1);
+	bbox_print_info("save last fault log %s!\n",
+			ret ? "failed" : "successfully");
+
+	return ret;
+}
+
+static int bbox_reboot_notify(struct notifier_block *nb,
+					unsigned long code, void *unused)
+{
+	char error_desc[ERROR_DESC_MAX_LEN];
+
+	/* notify blackbox to do dump */
+	memset(error_desc, 0, sizeof(error_desc));
+	dump_stacktrace(error_desc, sizeof(error_desc), false);
+	kmsg_dump(KMSG_DUMP_UNDEF);
+
+	switch (code) {
+	case SYS_RESTART:
+		bbox_notify_error(EVENT_SYSREBOOT, MODULE_SYSTEM, error_desc, 1);
+		break;
+	case SYS_POWER_OFF:
+		bbox_notify_error(EVENT_POWEROFF, MODULE_SYSTEM, error_desc, 0);
+		break;
+	default:
+		bbox_print_err("Invalid event code: %lu!\n", code);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int bbox_task_panic(struct notifier_block *this,
+				unsigned long event, void *ptr)
+{
+	char error_desc[ERROR_DESC_MAX_LEN];
+
+	/* notify blackbox to do dump */
+	kmsg_dump(KMSG_DUMP_OOPS);
+	memset(error_desc, 0, sizeof(error_desc));
+	bbox_notify_error(EVENT_PANIC, MODULE_SYSTEM, error_desc, 1);
+
+	return NOTIFY_DONE;
+}
+
+#ifdef CONFIG_BLACKBOX_TEST
+static void test_bbox(void)
+{
+	struct module_ops ops = {
+		.module = "TEST",
+		.dump = NULL,
+		.reset = NULL,
+		.get_last_log_info = NULL,
+		.save_last_log = NULL,
+	};
+
+	if (bbox_register_module_ops(&ops) != 0) {
+		bbox_print_err("bbox_register_module_ops failed!\n");
+		return -EINVAL;
+	}
+	kmsg_dump(KMSG_DUMP_OOPS);
+	bbox_notify_error("EVENT_TEST", "TEST", "Test bbox_notify_error", 0);
+
+}
+#endif
+
+static int __init blackbox_init(void)
+{
+	int ret = -1;
+	struct kmsg_dumper *dumper = NULL;
+	struct module_ops ops = {
+		.module = MODULE_SYSTEM,
+		.dump = dump,
+		.reset = reset,
+		.get_last_log_info = get_last_log_info,
+		.save_last_log = save_last_log,
+	};
+
+	if (bbox_register_module_ops(&ops) != 0) {
+		bbox_print_err("bbox_register_module_ops failed!\n");
+		return -EINVAL;
+	}
+
+	/* allocate buffer for kmsg */
+	kernel_log = kmalloc(KERNEL_LOG_MAX_SIZE, GFP_KERNEL);
+	if (!kernel_log)
+		goto __err;
+
+	bbox_print_info("kernel_log: %p for blackbox!\n", kernel_log);
+
+	if (storage_lastword->storage_log(kernel_log, KERNEL_LOG_MAX_SIZE) < 0) {
+		bbox_print_err("storage_log failed!\n");
+		goto __err;
+	}
+
+	/* register kdumper */
+	dumper = vmalloc(sizeof(*dumper));
+	if (!dumper)
+		goto __err;
+
+	memset(dumper, 0, sizeof(*dumper));
+	dumper->max_reason = KMSG_DUMP_MAX;
+	dumper->dump = storage_lastword->blackbox_dump;
+	ret = kmsg_dump_register(dumper);
+	if (ret != 0) {
+		bbox_print_err("kmsg_dump_register failed!\n");
+		goto __err;
+	}
+	atomic_notifier_chain_register(&panic_notifier_list, &bbox_panic_block);
+
+	register_reboot_notifier(&bbox_reboot_nb);
+#ifdef CONFIG_BLACKBOX_TEST
+	test_bbox();
+#endif
+	return 0;
+
+__err:
+	kfree(kernel_log);
+	kernel_log = NULL;
+
+	if (dumper) {
+		vfree(dumper);
+		dumper = NULL;
+	}
+
+	return ret;
+}
+
+postcore_initcall(blackbox_init);
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Blackbox for system");
+MODULE_AUTHOR("OHOS");
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index c4b8df2ad..374737bd5 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -237,7 +237,7 @@ const struct dma_map_ops arm_coherent_dma_ops = {
 };
 EXPORT_SYMBOL(arm_coherent_dma_ops);
 
-static void __dma_clear_buffer(struct page *page, size_t size, int coherent_flag)
+void __dma_clear_buffer(struct page *page, size_t size, int coherent_flag)
 {
 	/*
 	 * Ensure that the allocated pages are zeroed, and that any data
@@ -266,6 +266,7 @@ static void __dma_clear_buffer(struct page *page, size_t size, int coherent_flag
 		}
 	}
 }
+EXPORT_SYMBOL(__dma_clear_buffer);
 
 /*
  * Allocate a DMA buffer for 'dev' of size 'size' using the
@@ -454,6 +455,12 @@ static void __dma_remap(struct page *page, size_t size, pgprot_t prot)
 	flush_tlb_kernel_range(start, end);
 }
 
+void hisi_flush_tlb_kernel_range(unsigned long start, unsigned long end)
+{
+	flush_tlb_kernel_range(start, end);
+}
+EXPORT_SYMBOL(hisi_flush_tlb_kernel_range);
+
 static void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,
 				 pgprot_t prot, struct page **ret_page,
 				 const void *caller, bool want_vaddr)
@@ -2296,6 +2303,13 @@ void arch_teardown_dma_ops(struct device *dev)
 	set_dma_ops(dev, NULL);
 }
 
+void hi_dmac_map_area(const void *kaddr, size_t size,
+			enum dma_data_direction dir)
+{
+	dmac_map_area(kaddr, size, dir);
+}
+EXPORT_SYMBOL(hi_dmac_map_area);
+
 #ifdef CONFIG_SWIOTLB
 void arch_sync_dma_for_device(phys_addr_t paddr, size_t size,
 		enum dma_data_direction dir)
diff --git a/arch/arm/vdso/vgettimeofday.c b/arch/arm/vdso/vgettimeofday.c
old mode 100644
new mode 100755
diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile
index 485b7dbd4..65b9f45c8 100644
--- a/arch/arm64/Makefile
+++ b/arch/arm64/Makefile
@@ -11,6 +11,7 @@
 # Copyright (C) 1995-2001 by Russell King
 
 LDFLAGS_vmlinux	:=--no-undefined -X
+OBJCOPYFLAGS	:=-O binary -R .note -R .note.gnu.build-id -R .comment -S
 
 ifeq ($(CONFIG_RELOCATABLE), y)
 # Pass --no-apply-dynamic-relocs to restore pre-binutils-2.27 behaviour
diff --git a/arch/arm64/boot/Makefile b/arch/arm64/boot/Makefile
index cd3414898..f3e98628b 100644
--- a/arch/arm64/boot/Makefile
+++ b/arch/arm64/boot/Makefile
@@ -18,12 +18,28 @@ OBJCOPYFLAGS_Image :=-O binary -R .note -R .note.gnu.build-id -R .comment -S
 
 targets := Image Image.bz2 Image.gz Image.lz4 Image.lzma Image.lzo
 
+dtstree := $(srctree)/$(src)/dts
+
+dtb-$(CONFIG_OF_ALL_DTBS) := $(patsubst $(dtstree)/%.dts,%.dtb, $(foreach d,$(dts-dirs), $(wildcard $(dtstree)/$(d)/*.dts)))
+
+DTB_NAMES := $(subst $\",,$(CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE_NAMES))
+ifneq ($(DTB_NAMES),)
+DTB_LIST := $(addsuffix .dtb,$(DTB_NAMES))
+else
+DTB_LIST := $(dtb-y)
+endif
+
+DTB_OBJS := $(addprefix $(obj)/dts/,$(DTB_LIST))
+
 $(obj)/Image: vmlinux FORCE
 	$(call if_changed,objcopy)
 
 $(obj)/Image.bz2: $(obj)/Image FORCE
 	$(call if_changed,bzip2)
 
+$(obj)/Image-dtb: $(obj)/Image $(DTB_OBJS) FORCE
+	$(call if_changed,cat)
+
 $(obj)/Image.gz: $(obj)/Image FORCE
 	$(call if_changed,gzip)
 
@@ -36,10 +52,35 @@ $(obj)/Image.lzma: $(obj)/Image FORCE
 $(obj)/Image.lzo: $(obj)/Image FORCE
 	$(call if_changed,lzo)
 
-install:
+$(obj)/Image.gz-dtb: $(obj)/Image.gz $(DTB_OBJS) FORCE
+	$(call if_changed,cat)
+
+UIMAGE_LOADADDR=$(TEXT_OFFSET)
+UIMAGE_ENTRYADDR=$(TEXT_OFFSET)
+#UIMAGE_COMPRESSION = gzip
+check_for_multiple_loadaddr = \
+if [ $(words $(UIMAGE_LOADADDR)) -ne 1 ]; then \
+	echo 'multiple (or no) load addresses: $(UIMAGE_LOADADDR)'; \
+	echo 'This is incompatible with uImages'; \
+	echo 'Specify LOADADDR on the commandline to build an uImage'; \
+	false; \
+fi
+
+rm_uimage:
+	@rm -f $(obj)/uImage
+
+$(obj)/uImage: $(obj)/Image rm_uimage FORCE
+	@$(check_for_multiple_loadaddr)
+	@dd if=$< of=$<.dd ibs=4096 conv=sync && mv $<.dd $<
+	$(call if_changed,uimage)
+	$(if $(CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE),@$(kecho) '  CAT   $(DTB_OBJS) to $@')
+	$(if $(CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE),@cat $(DTB_OBJS) >>$@,)
+	@$(kecho) '  Image $@ is ready'
+
+install:$(obj)/uImage
 	$(CONFIG_SHELL) $(srctree)/$(src)/install.sh $(KERNELRELEASE) \
 	$(obj)/Image System.map "$(INSTALL_PATH)"
 
-zinstall:
+zinstall:$(obj)/uImage
 	$(CONFIG_SHELL) $(srctree)/$(src)/install.sh $(KERNELRELEASE) \
 	$(obj)/Image.gz System.map "$(INSTALL_PATH)"
diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index 9b1170658..9520bb244 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -30,3 +30,5 @@ subdir-y += ti
 subdir-y += toshiba
 subdir-y += xilinx
 subdir-y += zte
+dtbs: $(addprefix $(obj)/, $(DTB_LIST))
+clean-files := dts/*.dtb *.dtb
diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 1006ed2d7..aa1d2f2b9 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -29,6 +29,18 @@ int pcibios_alloc_irq(struct pci_dev *dev)
 
 	return 0;
 }
+#else
+#ifdef CONFIG_ARCH_HISI_BVT
+/*
+ * Try to assign the IRQ number when probing a new device
+ */
+int pcibios_alloc_irq(struct pci_dev *dev)
+{
+	dev->irq = of_irq_parse_and_map_pci(dev, 0, 0);
+
+	return 0;
+}
+#endif
 #endif
 
 /*
diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c
index c0a7f0d90..a5ca33ad8 100644
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@ -180,6 +180,10 @@ static void __init reserve_elfcorehdr(void)
  */
 static phys_addr_t __init max_zone_phys(unsigned int zone_bits)
 {
+#ifdef CONFIG_ARCH_HISI_BVT
+	phys_addr_t max_dma_phys;
+	extern phys_addr_t hisi_get_zones_start(void);
+#endif
 	phys_addr_t zone_mask = DMA_BIT_MASK(zone_bits);
 	phys_addr_t phys_start = memblock_start_of_DRAM();
 
@@ -188,7 +192,12 @@ static phys_addr_t __init max_zone_phys(unsigned int zone_bits)
 	else if (phys_start > zone_mask)
 		zone_mask = U32_MAX;
 
+#ifdef CONFIG_ARCH_HISI_BVT
+	max_dma_phys = min(zone_mask, memblock_end_of_DRAM() - 1) + 1;
+	return min(max_dma_phys, hisi_get_zones_start());
+#else
 	return min(zone_mask, memblock_end_of_DRAM() - 1) + 1;
+#endif
 }
 
 static void __init zone_sizes_init(unsigned long min, unsigned long max)
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 826b2b19d..96840663d 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -239,4 +239,12 @@ source "drivers/counter/Kconfig"
 source "drivers/most/Kconfig"
 
 source "drivers/accesstokenid/Kconfig"
+
+source "drivers/hidmac/Kconfig"
+
+source "drivers/hiedmac/Kconfig"
+
+source "drivers/hisilicon/Kconfig"
+
+source "drivers/hi_vdmav100/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index ecc494918..46d604b46 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -193,3 +193,7 @@ obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
 obj-$(CONFIG_ACCESS_TOKENID)	+= accesstokenid/
+obj-$(CONFIG_HI_DMAC)          += hidmac/
+obj-$(CONFIG_HIEDMAC)          += hiedmac/
+obj-$(CONFIG_ARCH_HISI_BVT)    += hisilicon/
+obj-$(CONFIG_HI_VDMA_V100)     += hi_vdmav100/
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 3604f0df6..2108d6686 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2966,7 +2966,7 @@ static void binder_transaction(struct binder_proc *proc,
 				return_error = BR_FAILED_REPLY;
 				return_error_param = -EINVAL;
 				return_error_line = __LINE__;
-				goto err_invalid_target_handle;
+				//goto err_invalid_target_handle;
 			}
 		}
 		if (!target_node) {
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index 030cb32da..97d530d3e 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -2,6 +2,7 @@
 #
 # SATA/PATA driver configuration
 #
+source "drivers/ata/Kconfig.hiahci"
 
 config HAVE_PATA_PLATFORM
 	bool
diff --git a/drivers/ata/Kconfig.hiahci b/drivers/ata/Kconfig.hiahci
new file mode 100644
index 000000000..030de3fc9
--- /dev/null
+++ b/drivers/ata/Kconfig.hiahci
@@ -0,0 +1,44 @@
+menuconfig HISI_SATA
+	bool "Hisilicon sata device support"
+	depends on (ARCH_HI3531DV200 || ARCH_HI3535AV100 || ARCH_HI3521DV200 || ARCH_HI3520DV500)
+	default n
+	select ATA
+	select ATA_VERBOSE_ERROR
+	select SATA_PMP
+	select SATA_AHCI_PLATFORM
+
+if HISI_SATA
+config HISI_SATA_IOBASE
+	hex "Hisi sata IO address"
+	default "0x10390000" if (ARCH_HI3531DV200 || ARCH_HI3535AV100)
+	default "0x10390000" if (ARCH_HI3521DV200 || ARCH_HI3520DV500)
+	help
+	  hisilicon sata io base address.
+
+config HISI_SATA_FBS
+	int "Hisi sata FIS-Based switching"
+	default 1
+	range 0 1
+	help
+	  Hisatav200 supports FBS.
+	  FBS is FIS-Based switching.
+	  Choose y if you want to use it.
+
+config HISI_SATA_NCQ
+	int "Hisi sata Native Command Queuing"
+	default 1
+	range 0 1
+	help
+	  Hisatav200 supports NCQ.
+	  NCQ is Native Command Queuing.
+	  Choose y if you want to use it.
+
+config HISI_ESATA
+	bool "Support Hisi eSATA"
+	default n
+	help
+	  Hisatav200 supports eSATA.
+	  Choose y if you want to use it.
+
+endif
+
diff --git a/drivers/ata/Makefile b/drivers/ata/Makefile
index b8aebfb14..f81f2d66b 100644
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 
 obj-$(CONFIG_ATA)		+= libata.o
+obj-$(CONFIG_HISI_SATA)       += hisi_sata_dbg.o
 
 # non-SFF interface
 obj-$(CONFIG_SATA_AHCI)		+= ahci.o libahci.o
diff --git a/drivers/ata/ahci.h b/drivers/ata/ahci.h
index d1f284f0c..af7963b12 100644
--- a/drivers/ata/ahci.h
+++ b/drivers/ata/ahci.h
@@ -224,6 +224,9 @@ enum {
 						        error-handling stage) */
 	AHCI_HFLAG_NO_DEVSLP		= (1 << 17), /* no device sleep */
 	AHCI_HFLAG_NO_FBS		= (1 << 18), /* no FBS */
+#ifdef CONFIG_HISI_SATA
+	AHCI_HFLAG_NO_SXS		= (1 << 19), /* do not support External SATA */
+#endif
 
 #ifdef CONFIG_PCI_MSI
 	AHCI_HFLAG_MULTI_MSI		= (1 << 20), /* per-port MSI(-X) */
@@ -346,6 +349,12 @@ struct ahci_host_priv {
 	struct regulator	**target_pwrs;	/* Optional */
 	struct regulator	*ahci_regulator;/* Optional */
 	struct regulator	*phy_regulator;/* Optional */
+#ifdef CONFIG_HISI_SATA
+#define PCI_AHCI 0
+#define ORI_AHCI 1
+	u32			type;
+#endif
+
 	/*
 	 * If platform uses PHYs. There is a 1:1 relation between the port number and
 	 * the PHY position in this array.
diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 3aab2e3d5..385d3d7d5 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -22,6 +22,16 @@
 
 #define DRV_NAME "ahci"
 
+#ifdef CONFIG_HISI_SATA_NCQ
+static unsigned int ncq_en = CONFIG_HISI_SATA_NCQ;
+module_param(ncq_en, uint, 0600);
+MODULE_PARM_DESC(ncq_en, "ahci ncq flag (default:1)");
+#endif
+
+#ifdef CONFIG_HISI_SATA
+extern unsigned int sata_port_map;
+#endif
+
 static const struct ata_port_info ahci_port_info = {
 	.flags		= AHCI_FLAG_COMMON,
 	.pio_mask	= ATA_PIO4,
@@ -59,8 +69,21 @@ static int ahci_probe(struct platform_device *pdev)
 	of_property_read_u32(dev->of_node,
 			     "ports-implemented", &hpriv->force_port_map);
 
+#ifdef CONFIG_HISI_SATA
+	hpriv->type = ORI_AHCI;
+	hpriv->force_port_map = sata_port_map;
+#ifndef CONFIG_HISI_ESATA
+	hpriv->flags |= AHCI_HFLAG_NO_SXS;
+#endif
+
+#ifdef CONFIG_HISI_SATA_NCQ
+	if (!ncq_en)
+		 hpriv->flags |= AHCI_HFLAG_NO_NCQ;
+#endif
+#else
 	if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
 		hpriv->flags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
+#endif
 
 	port = acpi_device_get_match_data(dev);
 	if (!port)
diff --git a/drivers/ata/hisi_sata_dbg.c b/drivers/ata/hisi_sata_dbg.c
new file mode 100644
index 000000000..935c71689
--- /dev/null
+++ b/drivers/ata/hisi_sata_dbg.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2009-2014 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/libata.h>
+#include <linux/io.h>
+
+#include "ahci.h"
+#include "hisi_sata_dbg.h"
+
+void hisi_sata_mem_dump(unsigned int *addr, unsigned int size)
+{
+	unsigned int ix;
+
+	for (ix = 0; ix < size; ix += 0x04, addr++) {
+		if (!(ix & 0x0F))
+			pr_debug("\n0x%08X: ",
+				 (unsigned int)virt_to_phys(addr));
+		pr_debug("%08X ", *addr);
+	}
+}
+EXPORT_SYMBOL(hisi_sata_mem_dump);
+
+void hisi_sata_phys_mem_dump(unsigned int addr, unsigned int size)
+{
+	hisi_sata_mem_dump(phys_to_virt(addr), size);
+}
+EXPORT_SYMBOL(hisi_sata_phys_mem_dump);
+
+void hisi_ahci_reg_dump(void)
+{
+	unsigned int ix;
+	unsigned int regbase;
+
+	regbase = CONFIG_HISI_SATA_IOBASE;
+	pr_debug("AHCI GHC Register dump:");
+	for (ix = 0; ix <= 0x28; ix += 0x04) {
+		if (!(ix & 0x0F))
+			pr_debug("\n0x%08X: ", (regbase + ix));
+	}
+	pr_debug("\n");
+
+	regbase = CONFIG_HISI_SATA_IOBASE + 0x0100;
+	pr_debug("AHCI PORT 0 Register dump:");
+	for (ix = 0; ix <= 0x7F; ix += 0x04) {
+		if (!(ix & 0x0F))
+			pr_debug("\n0x%08X: ", (regbase + ix));
+	}
+	pr_debug("\n");
+}
+EXPORT_SYMBOL(hisi_ahci_reg_dump);
+
+void hisi_ahci_rx_fis_dump(struct ata_link *link, int pmp_port_num)
+{
+	struct ahci_port_priv *pp = NULL;
+
+	pp = link->ap->private_data;
+	if (NULL == pp) {
+		pr_debug("Error: pp=NULL\n");
+		return;
+	}
+	pr_debug("ACHI Received FIS:");
+	hisi_sata_phys_mem_dump((unsigned int)(pp->rx_fis_dma),
+				AHCI_RX_FIS_SZ * pmp_port_num);
+	pr_debug("\n");
+}
+EXPORT_SYMBOL_GPL(hisi_ahci_rx_fis_dump);
+
+void hisi_ata_taskfile_dump(struct ata_taskfile *tf)
+{
+	if (NULL == tf) {
+		pr_debug("Error: tf=NULL\n");
+		return;
+	}
+
+	pr_debug("Taskfile dump:\n");
+	pr_debug("flags:0x%08lX, protocol:0x%02X, command:0x%02X, device:0x%02X, ctl:0x%02X\n",
+		 tf->flags, tf->protocol, tf->command, tf->device, tf->ctl);
+	pr_debug("feature:0x%08X, nsect:0x%02X, lbal:0x%02X, lbam:0x%02X, lbah:0x%02X\n",
+		 tf->feature, tf->nsect, tf->lbal, tf->lbam, tf->lbah);
+	pr_debug("hob_feature:0x%08X, hob_nsect:0x%02X, hob_lbal:0x%02X, hob_lbam:0x%02X, hob_lbah:0x%02X\n",
+		 tf->hob_feature, tf->hob_nsect, tf->hob_lbal,
+		 tf->hob_lbam, tf->hob_lbah);
+}
+EXPORT_SYMBOL_GPL(hisi_ata_taskfile_dump);
+
+static void __hisi_ahci_st_md(void __iomem *addr)
+{
+	unsigned int *addr_v = NULL;
+	unsigned int *tmp = NULL;
+	unsigned int i;
+
+	addr_v = (unsigned int *)addr;
+
+	pr_debug("\n\n");
+	for (i = 0; i < 16; i++) {
+		tmp = addr_v + i * 4;
+		pr_debug("%8x: %8x %8x %8x %8x\n",
+			 (unsigned int)(uintptr_t)(addr + i * 16),
+			 *tmp, *(tmp + 1), *(tmp + 2), *(tmp + 3));
+	}
+
+	pr_debug("\n");
+}
+
+void hisi_ahci_st_dump(const void __iomem *port_base)
+{
+	unsigned int tmp;
+
+	pr_debug("\n**********Dmac status**********\n");
+	tmp = readl(port_base + 0x58);
+	pr_debug("txdmac_curr_st:0x%2x\n", (tmp >> 24) & 0xf);
+	tmp = readl(port_base + 0x64);
+	pr_debug("rxdmac_curr_st:0x%2x\n", (tmp >> 24) & 0xf);
+	tmp = readl(port_base + 0x70);
+	pr_debug("dmac tx fifo:count-0x%x-empty-%x-ful-%x\n",
+		 (tmp >> 0) & 0xff,
+		 (tmp >> 16) & 0x1, (tmp >> 17) & 0x1);
+	pr_debug("dmac rx fifo:count-0x%x-empty-%x-ful-%x\n",
+		 (tmp >> 8) & 0xff,
+		 (tmp >> 18) & 0x1, (tmp >> 19) & 0x1);
+
+	pr_debug("\n");
+	pr_debug("**********HBA status**********\n");
+	tmp = readl(port_base + 0x50);
+	pr_debug("pxxx_curr_st:0x%2x      ndrx_curr_st:0x%2x\n",
+		 (tmp >> 24) & 0xf,
+		 (tmp >> 16) & 0xff);
+	pr_debug("cfis_curr_st:0x%2x      piox_curr_st:0x%2x\n",
+		 (tmp >> 12) & 0xf,
+		 (tmp >> 8) & 0xf);
+	pr_debug("pmxx_curr_st:0x%2x      errx_curr_st:0x%2x\n",
+		 (tmp >> 4) & 0xf,
+		 (tmp >> 0) & 0xf);
+
+	pr_debug("\n");
+	pr_debug("**********Link status**********\n");
+	tmp = readl(port_base + 0x54);
+	pr_debug("link_curr_st:0x%2x\n", (tmp >> 24) & 0x1f);
+	pr_debug("link tx fifo:count-0x%x-empty-%x-ful-%x\n",
+		 (tmp >> 0) & 0x1f,
+		 (tmp >> 5) & 0x1, (tmp >> 6) & 0x1);
+	pr_debug("link rx fifo:count-0x%x-empty-%x-ful-%x\n",
+		 (tmp >> 8) & 0x1f,
+		 (tmp >> 13) & 0x1, (tmp >> 14) & 0x1);
+	pr_debug("link df fifo:count-0x%x-empty-%x-ful-%x\n\n",
+		 (tmp >> 16) & 0x1f,
+		 (tmp >> 21) & 0x1, (tmp >> 22) & 0x1);
+
+	pr_debug("**********CMD header**********\n");
+	tmp = readl(port_base + 0x0);
+	__hisi_ahci_st_md(phys_to_virt(tmp));
+	__hisi_ahci_st_md(phys_to_virt(tmp + 0x100));
+	__hisi_ahci_st_md(phys_to_virt(tmp + 0x200));
+	__hisi_ahci_st_md(phys_to_virt(tmp + 0x300));
+}
+EXPORT_SYMBOL_GPL(hisi_ahci_st_dump);
+
diff --git a/drivers/ata/hisi_sata_dbg.h b/drivers/ata/hisi_sata_dbg.h
new file mode 100644
index 000000000..5103658a4
--- /dev/null
+++ b/drivers/ata/hisi_sata_dbg.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2009-2014 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _HISI_SATA_DBG_H
+#define _HISI_SATA_DBG_H
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/libata.h>
+#include "ahci.h"
+
+void hisi_sata_mem_dump(unsigned int *addr, unsigned int size);
+void hisi_sata_phys_mem_dump(unsigned int addr, unsigned int size);
+void hisi_ahci_rx_fis_dump(struct ata_link *link, int pmp_port_num);
+void hisi_ata_taskfile_dump(struct ata_taskfile *tf);
+void hisi_ahci_st_dump(const void __iomem *port_base);
+void hisi_ahci_reg_dump(void);
+
+#define HISI_AHCI_REG_DUMP(X) \
+do { \
+	pr_debug("------------------[ Start ]--------------------\n"); \
+	pr_debug("Dump AHCI registers at %s %d\n", __func__, __LINE__); \
+	hisi_ahci_reg_dump(); \
+	pr_debug("------------------[  End  ]--------------------\n"); \
+} while (0)
+
+#define hisi_sata_readl(addr) do { \
+		unsigned int reg = readl((unsigned int)addr); \
+		pr_debug("HI_AHCI(REG) %s:%d: readl(0x%08X) = 0x%08X\n", \
+		__func__, __LINE__, (unsigned int)addr, reg); \
+		reg; \
+	} while (0)
+
+#define hisi_sata_writel(v, addr) do { writel(v, (unsigned int)addr); \
+	pr_debug("HI_AHCI(REG) %s:%d: writel(0x%08X) = 0x%08X\n", \
+		__func__, __LINE__, (unsigned int)addr, \
+		(unsigned int)(v)); \
+	} while (0)
+
+#undef HISI_DUMP_AHCI_REG_OPS
+#ifdef HISI_DUMP_AHCI_REG_OPS
+#define readl(addr) hisi_sata_readl(addr)
+#define write(v, addr) hisi_sata_writel(v, addr)
+#endif
+#endif /* _HISI_SATA_DBG_H */
diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c
index fec2e9754..bff99aebd 100644
--- a/drivers/ata/libahci.c
+++ b/drivers/ata/libahci.c
@@ -31,6 +31,7 @@
 #include <linux/pci.h>
 #include "ahci.h"
 #include "libata.h"
+#include "hisi_sata_dbg.h"
 
 static int ahci_skip_host_reset;
 int ahci_ignore_sss;
@@ -42,6 +43,33 @@ MODULE_PARM_DESC(skip_host_reset, "skip global host reset (0=don't skip, 1=skip)
 module_param_named(ignore_sss, ahci_ignore_sss, int, 0444);
 MODULE_PARM_DESC(ignore_sss, "Ignore staggered spinup flag (0=don't ignore, 1=ignore)");
 
+#ifdef CONFIG_HISI_SATA_FBS
+static int fbs_en = CONFIG_HISI_SATA_FBS;
+module_param(fbs_en, uint, 0600);
+MODULE_PARM_DESC(fbs_en, "ahci fbs flags (default:1)");
+
+#define AHCI_TIMEOUT_COUNT	10
+#define AHCI_POLL_TIMER		(20 * HZ)
+
+struct ata_fbs_ctrl {
+	unsigned int fbs_enable_ctrl; /* fbs enable or disable control switch */
+	unsigned int fbs_mode_ctrl;   /* 1.5G: fbs disable, 3G/6G: fbs enable */
+	unsigned int fbs_enable_flag;
+	unsigned int fbs_disable_flag;
+	unsigned int fbs_cmd_issue_flag;
+	struct timer_list poll_timer;
+#ifdef CONFIG_HISI_SATA
+	struct ata_port *ap;
+#endif
+};
+static struct ata_fbs_ctrl fbs_ctrl[4];
+extern void hisi_sata_set_fifoth(void *mmio);
+#endif
+#ifdef CONFIG_HISI_SATA
+extern void hisi_sata_reset_rxtx_assert(unsigned int port_no);
+extern void hisi_sata_reset_rxtx_deassert(unsigned int port_no);
+#endif
+
 static int ahci_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 			unsigned hints);
 static ssize_t ahci_led_show(struct ata_port *ap, char *buf);
@@ -460,6 +488,13 @@ void ahci_save_initial_config(struct device *dev, struct ahci_host_priv *hpriv)
 		cap |= HOST_CAP_NCQ;
 	}
 
+#ifdef CONFIG_HISI_SATA
+	if ((cap & HOST_CAP_SXS) && (hpriv->flags & AHCI_HFLAG_NO_SXS)) {
+		dev_info(dev, "controller can't support eSATA, turning off CAP_SXS\n");
+		cap &= ~HOST_CAP_SXS;
+	}
+#endif
+
 	if ((cap & HOST_CAP_PMP) && (hpriv->flags & AHCI_HFLAG_NO_PMP)) {
 		dev_info(dev, "controller can't do PMP, turning off CAP_PMP\n");
 		cap &= ~HOST_CAP_PMP;
@@ -1396,8 +1431,28 @@ int ahci_do_softreset(struct ata_link *link, unsigned int *class,
 	bool fbs_disabled = false;
 	int rc;
 
+#ifdef CONFIG_HISI_SATA_FBS
+	unsigned int port_num = ap->port_no;
+#endif
+
 	DPRINTK("ENTER\n");
 
+#ifdef CONFIG_HISI_SATA_FBS
+	if (fbs_ctrl[port_num].fbs_enable_ctrl &&
+			(link->pmp == SATA_PMP_CTRL_PORT) &&
+			(hpriv->type == ORI_AHCI)) {
+		struct ahci_port_priv *pp = ap->private_data;
+
+		if (pp->fbs_enabled == false)
+			ahci_enable_fbs(ap);
+
+		fbs_ctrl[port_num].fbs_enable_flag = 0;
+		fbs_ctrl[port_num].fbs_disable_flag = 0;
+		fbs_ctrl[port_num].fbs_cmd_issue_flag = 0;
+
+	}
+#endif
+
 	/* prepare for SRST (AHCI-1.1 10.4.1) */
 	rc = ahci_kick_engine(ap);
 	if (rc && rc != -EOPNOTSUPP)
@@ -1426,6 +1481,10 @@ int ahci_do_softreset(struct ata_link *link, unsigned int *class,
 				 AHCI_CMD_RESET | AHCI_CMD_CLR_BUSY, msecs)) {
 		rc = -EIO;
 		reason = "1st FIS failed";
+#ifdef CONFIG_HISI_SATA
+		hisi_sata_reset_rxtx_assert(ap->port_no);
+		hisi_sata_reset_rxtx_deassert(ap->port_no);
+#endif
 		goto fail;
 	}
 
@@ -1623,6 +1682,68 @@ static int ahci_pmp_qc_defer(struct ata_queued_cmd *qc)
 	struct ata_port *ap = qc->ap;
 	struct ahci_port_priv *pp = ap->private_data;
 
+#ifdef CONFIG_HISI_SATA_FBS
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	int is_atapi = ata_is_atapi(qc->tf.protocol);
+	void __iomem *port_mmio = ahci_port_base(ap);
+	unsigned int port_num = ap->port_no;
+	unsigned int cmd_timeout_count;
+
+	if (fbs_ctrl[port_num].fbs_enable_ctrl &&
+			(ap->link.pmp == SATA_PMP_CTRL_PORT) &&
+			(hpriv->type == ORI_AHCI)) {
+		if (is_atapi || fbs_ctrl[ap->port_no].fbs_cmd_issue_flag) {
+			mod_timer(&fbs_ctrl[port_num].poll_timer,
+					jiffies + AHCI_POLL_TIMER);
+
+			if (!fbs_ctrl[port_num].fbs_disable_flag) {
+				cmd_timeout_count = 0;
+				while (readl(port_mmio + PORT_SCR_ACT)
+						|| readl(port_mmio
+							+ PORT_CMD_ISSUE)
+						|| readl(port_mmio
+							+ PORT_IRQ_STAT)) {
+					cmd_timeout_count++;
+					if (cmd_timeout_count >=
+							AHCI_TIMEOUT_COUNT) {
+						fbs_ctrl[ap->port_no].
+							fbs_cmd_issue_flag = 1;
+						return ATA_DEFER_LINK;
+					}
+				}
+
+				if (pp->fbs_enabled == true)
+					ahci_disable_fbs(ap);
+
+				ap->excl_link = NULL;
+				ap->nr_active_links = 0;
+				fbs_ctrl[port_num].fbs_disable_flag = 1;
+				fbs_ctrl[port_num].fbs_enable_flag = 0;
+				fbs_ctrl[ap->port_no].fbs_cmd_issue_flag = 0;
+			}
+		} else {
+			if (fbs_ctrl[port_num].fbs_enable_flag) {
+				cmd_timeout_count = 0;
+				while (readl(port_mmio + PORT_SCR_ACT)
+						|| readl(port_mmio
+							+ PORT_CMD_ISSUE)
+						|| readl(port_mmio
+							+ PORT_IRQ_STAT)) {
+					cmd_timeout_count++;
+					if (cmd_timeout_count >=
+							AHCI_TIMEOUT_COUNT) {
+						return ATA_DEFER_LINK;
+					}
+				}
+
+				if (pp->fbs_enabled == false)
+					ahci_enable_fbs(ap);
+				fbs_ctrl[port_num].fbs_enable_flag = 0;
+				fbs_ctrl[port_num].fbs_disable_flag = 0;
+			}
+		}
+	}
+#endif
 	if (!sata_pmp_attached(ap) || pp->fbs_enabled)
 		return ata_std_qc_defer(qc);
 	else
@@ -1669,6 +1790,7 @@ static enum ata_completion_errors ahci_qc_prep(struct ata_queued_cmd *qc)
 	return AC_ERR_OK;
 }
 
+#ifndef CONFIG_HISI_SATA_FBS
 static void ahci_fbs_dec_intr(struct ata_port *ap)
 {
 	struct ahci_port_priv *pp = ap->private_data;
@@ -1692,6 +1814,7 @@ static void ahci_fbs_dec_intr(struct ata_port *ap)
 	if (fbs & PORT_FBS_DEC)
 		dev_err(ap->host->dev, "failed to clear device error\n");
 }
+#endif
 
 static void ahci_error_intr(struct ata_port *ap, u32 irq_stat)
 {
@@ -1799,7 +1922,9 @@ static void ahci_error_intr(struct ata_port *ap, u32 irq_stat)
 		ata_port_freeze(ap);
 	else if (fbs_need_dec) {
 		ata_link_abort(link);
+#ifndef CONFIG_HISI_SATA_FBS
 		ahci_fbs_dec_intr(ap);
+#endif
 	} else
 		ata_port_abort(ap);
 }
@@ -2200,7 +2325,9 @@ static void ahci_enable_fbs(struct ata_port *ap)
 	writel(fbs | PORT_FBS_EN, port_mmio + PORT_FBS);
 	fbs = readl(port_mmio + PORT_FBS);
 	if (fbs & PORT_FBS_EN) {
+#ifndef CONFIG_HISI_SATA_FBS
 		dev_info(ap->host->dev, "FBS is enabled\n");
+#endif
 		pp->fbs_enabled = true;
 		pp->fbs_last_dev = -1; /* initialization */
 	} else
@@ -2240,6 +2367,9 @@ static void ahci_disable_fbs(struct ata_port *ap)
 	}
 
 	hpriv->start_engine(ap);
+#ifdef CONFIG_HISI_SATA_FBS
+	hisi_sata_set_fifoth(port_mmio);
+#endif
 }
 
 static void ahci_pmp_attach(struct ata_port *ap)
@@ -2248,12 +2378,24 @@ static void ahci_pmp_attach(struct ata_port *ap)
 	struct ahci_port_priv *pp = ap->private_data;
 	u32 cmd;
 
+#ifdef CONFIG_HISI_SATA_FBS
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	unsigned int port_num = ap->port_no;
+#endif
+
 	cmd = readl(port_mmio + PORT_CMD);
 	cmd |= PORT_CMD_PMP;
 	writel(cmd, port_mmio + PORT_CMD);
 
 	ahci_enable_fbs(ap);
 
+#ifdef CONFIG_HISI_SATA_FBS
+	if (hpriv->type == ORI_AHCI) {
+		if (!fbs_ctrl[port_num].fbs_enable_ctrl)
+			ahci_disable_fbs(ap);
+	}
+#endif
+
 	pp->intr_mask |= PORT_IRQ_BAD_PMP;
 
 	/*
@@ -2322,6 +2464,32 @@ static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)
 }
 #endif
 
+#ifdef CONFIG_HISI_SATA_FBS
+static void ahci_poll_func(unsigned long arg)
+{
+	struct ata_port *ap = (struct ata_port *)arg;
+	unsigned int port_num = ap->port_no;
+
+	if (ap->link.pmp == SATA_PMP_CTRL_PORT) {
+		fbs_ctrl[port_num].fbs_enable_flag = 1;
+		fbs_ctrl[port_num].fbs_disable_flag = 0;
+	}
+}
+
+static void ahci_poll_timerout(struct timer_list *t)
+{
+	struct ata_fbs_ctrl *ata_fbs_ctrl_ptr = from_timer(ata_fbs_ctrl_ptr, t, poll_timer);
+	struct ata_port *ap = ata_fbs_ctrl_ptr->ap;
+
+	if (ap == NULL) {
+		pr_err("%s:poll_timer parameter is error!\n", __func__);
+		return;
+	}
+
+	ahci_poll_func((uintptr_t)ap);
+}
+#endif
+
 static int ahci_port_start(struct ata_port *ap)
 {
 	struct ahci_host_priv *hpriv = ap->host->private_data;
@@ -2414,6 +2582,19 @@ static int ahci_port_start(struct ata_port *ap)
 
 	ap->private_data = pp;
 
+#ifdef CONFIG_HISI_SATA_FBS
+	if (hpriv->type == ORI_AHCI) {
+		fbs_ctrl[ap->port_no].fbs_enable_ctrl = fbs_en;
+		fbs_ctrl[ap->port_no].fbs_enable_flag = 0;
+		fbs_ctrl[ap->port_no].fbs_disable_flag = 0;
+		fbs_ctrl[ap->port_no].fbs_cmd_issue_flag = 0;
+		fbs_ctrl[ap->port_no].ap = ap;
+
+		timer_setup(&fbs_ctrl[ap->port_no].poll_timer, ahci_poll_timerout, 0);
+		fbs_ctrl[ap->port_no].poll_timer.expires = jiffies + AHCI_POLL_TIMER;
+	}
+#endif
+
 	/* engage engines, captain */
 	return ahci_port_resume(ap);
 }
diff --git a/drivers/block/paride/pcd.c b/drivers/block/paride/pcd.c
index 70da8b86c..5725b026b 100644
--- a/drivers/block/paride/pcd.c
+++ b/drivers/block/paride/pcd.c
@@ -1031,6 +1031,9 @@ static int __init pcd_init(void)
 	}
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
+
 		if (cd->present) {
 			register_cdrom(cd->disk, &cd->info);
 			cd->disk->private_data = cd;
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index da8fcf147..04bbcd945 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -82,6 +82,7 @@ obj-$(CONFIG_ARCH_BERLIN)		+= berlin/
 obj-$(CONFIG_ARCH_DAVINCI)		+= davinci/
 obj-$(CONFIG_H8300)			+= h8300/
 obj-$(CONFIG_ARCH_HISI)			+= hisilicon/
+obj-$(CONFIG_ARCH_HISI_BVT)		+= hisilicon/
 obj-y					+= imgtec/
 obj-y					+= imx/
 obj-y					+= ingenic/
diff --git a/drivers/clk/hisilicon/Kconfig b/drivers/clk/hisilicon/Kconfig
index 6a9e93a0b..4d212e5a1 100644
--- a/drivers/clk/hisilicon/Kconfig
+++ b/drivers/clk/hisilicon/Kconfig
@@ -22,6 +22,38 @@ config COMMON_CLK_HI3660
 	help
 	  Build the clock driver for hi3660.
 
+config COMMON_CLK_HI3531DV200
+	tristate "Hi3531DV200 Clock Driver"
+	depends on ARCH_HI3531DV200 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for Hi3531DV200.
+
+config COMMON_CLK_HI3535AV100
+	tristate "Hi3535AV100 Clock Driver"
+	depends on ARCH_HI3535AV100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for Hi3535AV100.
+
+config COMMON_CLK_HI3521DV200
+	tristate "Hi3521DV200 Clock Driver"
+	depends on ARCH_HI3521DV200 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3521DV200.
+
+config COMMON_CLK_HI3520DV500
+	tristate "Hi3520DV500 Clock Driver"
+	depends on ARCH_HI3520DV500 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3520DV500.
+
 config COMMON_CLK_HI3670
 	bool "Hi3670 Clock Driver"
 	depends on ARCH_HISI || COMPILE_TEST
@@ -37,6 +69,166 @@ config COMMON_CLK_HI3798CV200
 	help
 	  Build the clock driver for hi3798cv200.
 
+config COMMON_CLK_HI3516A
+	tristate "Hi3516A Clock Driver"
+	depends on ARCH_HI3516A || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3516A.
+
+config COMMON_CLK_HI3516CV500
+	tristate "Hi3516CV500 Clock Driver"
+	depends on ARCH_HI3516CV500 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3516CV500.
+
+config COMMON_CLK_HI3516EV200
+	tristate "Hi3516EV200 Clock Driver"
+	depends on ARCH_HI3516EV200 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3516EV200.
+
+config COMMON_CLK_HI3516EV300
+	tristate "Hi3516EV300 Clock Driver"
+	depends on ARCH_HI3516EV300 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3516EV300.
+
+config COMMON_CLK_HI3518EV300
+	tristate "Hi3518EV300 Clock Driver"
+	depends on ARCH_HI3518EV300 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3518EV300.
+
+config COMMON_CLK_HI3516DV200
+	tristate "Hi3516DV200 Clock Driver"
+	depends on ARCH_HI3516DV200 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3516DV200.
+
+config COMMON_CLK_HI3516DV300
+	tristate "Hi3516DV300 Clock Driver"
+	depends on ARCH_HI3516DV300 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3516DV300.
+
+config COMMON_CLK_HI3556V200
+	tristate "Hi3556V200 Clock Driver"
+	depends on ARCH_HI3556V200 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3556V200.
+
+config COMMON_CLK_HI3559V200
+	tristate "Hi3559V200 Clock Driver"
+	depends on ARCH_HI3559V200 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3559V200.
+
+config COMMON_CLK_HI3562V100
+	tristate "Hi3562V100 Clock Driver"
+	depends on ARCH_HI3562V100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3562V100.
+
+config COMMON_CLK_HI3566V100
+	tristate "Hi3566V100 Clock Driver"
+	depends on ARCH_HI3566V100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3566V100.
+
+config COMMON_CLK_HI3518EV20X
+	tristate "Hi3518EV20X Clock Driver"
+	depends on ARCH_HI3518EV20X || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3516A.
+
+config COMMON_CLK_HI3536DV100
+	tristate "Hi3536DV100 Clock Driver"
+	depends on ARCH_HI3536DV100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3536DV100.
+
+config COMMON_CLK_HI3559AV100
+	tristate "Hi3559AV100 Clock Driver"
+	depends on ARCH_HI3559AV100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3559av100.
+
+config COMMON_CLK_HI3569V100
+	tristate "Hi3569V100 Clock Driver"
+	depends on ARCH_HI3569V100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3569v100.
+
+config COMMON_CLK_HI3521A
+	tristate "Hi3521A Clock Driver"
+	depends on ARCH_HI3521A || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3521A.
+
+config COMMON_CLK_HI3531A
+	tristate "Hi3531A Clock Driver"
+	depends on ARCH_HI3531A || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI_BVT
+	help
+	  Build the clock driver for hi3531A.
+
+config COMMON_CLK_HI3556AV100
+	tristate "Hi3556AV100 Clock Driver"
+	depends on ARCH_HI3556AV100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3556av100.
+
+config COMMON_CLK_HI3519AV100
+	tristate "Hi3519AV100 Clock Driver"
+	depends on ARCH_HI3519AV100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3519av100.
+
+config COMMON_CLK_HI3568V100
+	tristate "Hi3568V100 Clock Driver"
+	depends on ARCH_HI3568V100 || COMPILE_TEST
+	select RESET_HISI
+	default ARCH_HISI
+	help
+	  Build the clock driver for hi3568v100.
+
 config COMMON_CLK_HI6220
 	bool "Hi6220 Clock Driver"
 	depends on ARCH_HISI || COMPILE_TEST
@@ -46,7 +238,7 @@ config COMMON_CLK_HI6220
 
 config RESET_HISI
 	bool "HiSilicon Reset Controller Driver"
-	depends on ARCH_HISI || COMPILE_TEST
+	depends on ARCH_HISI || COMPILE_TEST || ARCH_HISI_BVT
 	select RESET_CONTROLLER
 	help
 	  Build reset controller driver for HiSilicon device chipsets.
diff --git a/drivers/clk/hisilicon/Makefile b/drivers/clk/hisilicon/Makefile
index b2441b99f..91dc23fdb 100644
--- a/drivers/clk/hisilicon/Makefile
+++ b/drivers/clk/hisilicon/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_COMMON_CLK_HI3660) += clk-hi3660.o
 obj-$(CONFIG_COMMON_CLK_HI3670) += clk-hi3670.o
 obj-$(CONFIG_COMMON_CLK_HI3798CV200)	+= crg-hi3798cv200.o
 obj-$(CONFIG_COMMON_CLK_HI6220)	+= clk-hi6220.o
+obj-$(CONFIG_COMMON_CLK_HI3516DV300)  += clk-hi3516dv300.o
 obj-$(CONFIG_RESET_HISI)	+= reset.o
 obj-$(CONFIG_STUB_CLK_HI6220)	+= clk-hi6220-stub.o
 obj-$(CONFIG_STUB_CLK_HI3660)	+= clk-hi3660-stub.o
diff --git a/drivers/clk/hisilicon/clk-hi3516dv300.c b/drivers/clk/hisilicon/clk-hi3516dv300.c
new file mode 100644
index 000000000..1a2ab9975
--- /dev/null
+++ b/drivers/clk/hisilicon/clk-hi3516dv300.c
@@ -0,0 +1,271 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <dt-bindings/clock/hi3516dv300-clock.h>
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include "clk.h"
+#include "crg.h"
+#include "reset.h"
+
+static struct hisi_fixed_rate_clock hi3516dv300_fixed_rate_clks[] __initdata = {
+	{ HI3516DV300_FIXED_3M, "3m", NULL, 0, 3000000, },
+	{ HI3516DV300_FIXED_6M, "6m", NULL, 0, 6000000, },
+	{ HI3516DV300_FIXED_12M, "12m", NULL, 0, 12000000, },
+	{ HI3516DV300_FIXED_24M, "24m", NULL, 0, 24000000, },
+	{ HI3516DV300_FIXED_25M, "25m", NULL, 0, 25000000, },
+	{ HI3516DV300_FIXED_50M, "50m", NULL, 0, 50000000, },
+	{ HI3516DV300_FIXED_54M, "54m", NULL, 0, 54000000, },
+	{ HI3516DV300_FIXED_83P3M, "83.3m", NULL, 0, 83300000, },
+	{ HI3516DV300_FIXED_100M, "100m", NULL, 0, 100000000, },
+	{ HI3516DV300_FIXED_125M, "125m", NULL, 0, 125000000, },
+	{ HI3516DV300_FIXED_150M, "150m", NULL, 0, 150000000, },
+	{ HI3516DV300_FIXED_163M, "163m", NULL, 0, 163000000, },
+	{ HI3516DV300_FIXED_200M, "200m", NULL, 0, 200000000, },
+	{ HI3516DV300_FIXED_250M, "250m", NULL, 0, 250000000, },
+	{ HI3516DV300_FIXED_257M, "257m", NULL, 0, 257000000, },
+	{ HI3516DV300_FIXED_300M, "300m", NULL, 0, 300000000, },
+	{ HI3516DV300_FIXED_324M, "324m", NULL, 0, 324000000, },
+	{ HI3516DV300_FIXED_342M, "342m", NULL, 0, 342000000, },
+	{ HI3516DV300_FIXED_342M, "375m", NULL, 0, 375000000, },
+	{ HI3516DV300_FIXED_396M, "396m", NULL, 0, 396000000, },
+	{ HI3516DV300_FIXED_400M, "400m", NULL, 0, 400000000, },
+	{ HI3516DV300_FIXED_448M, "448m", NULL, 0, 448000000, },
+	{ HI3516DV300_FIXED_500M, "500m", NULL, 0, 500000000, },
+	{ HI3516DV300_FIXED_540M, "540m", NULL, 0, 540000000, },
+	{ HI3516DV300_FIXED_600M, "600m", NULL, 0, 600000000, },
+	{ HI3516DV300_FIXED_750M, "750m", NULL, 0, 750000000, },
+	{ HI3516DV300_FIXED_1000M, "1000m", NULL, 0, 1000000000, },
+	{ HI3516DV300_FIXED_1500M, "1500m", NULL, 0, 1500000000UL, },
+};
+
+static const char *sysaxi_mux_p[] __initconst = {
+	"24m", "200m", "300m"
+};
+static const char *sysapb_mux_p[] __initconst = {"24m", "50m"};
+static const char *uart_mux_p[] __initconst = {"24m", "6m"};
+static const char *fmc_mux_p[] __initconst = {"24m", "100m", "150m", "163m", "200m", "257m", "300m", "396m"};
+static const char *eth_mux_p[] __initconst = {"100m", "54m"};
+static const char *mmc_mux_p[] __initconst = {"100m", "50m", "25m"};
+static const char *pwm_mux_p[] __initconst = {"3m", "50m", "24m", "24m"};
+
+static u32 sysaxi_mux_table[] = {0, 1, 2};
+static u32 sysapb_mux_table[] = {0, 1};
+static u32 uart_mux_table[] = {0, 1};
+static u32 fmc_mux_table[] = {0, 1, 2, 3, 4, 5, 6, 7};
+static u32 eth_mux_table[] = {0, 1};
+static u32 mmc_mux_table[] = {1, 2, 3};
+static u32 pwm_mux_table[] = {0, 1, 2, 3};
+
+static struct hisi_mux_clock hi3516dv300_mux_clks[] __initdata = {
+	{
+		HI3516DV300_SYSAXI_CLK, "sysaxi_mux", sysaxi_mux_p,
+		ARRAY_SIZE(sysaxi_mux_p),
+		CLK_SET_RATE_PARENT, 0x80, 6, 2, 0, sysaxi_mux_table,
+	},
+	{
+		HI3516DV300_SYSAPB_CLK, "sysapb_mux", sysapb_mux_p,
+		ARRAY_SIZE(sysapb_mux_p),
+		CLK_SET_RATE_PARENT, 0x80, 10, 1, 0, sysapb_mux_table,
+	},
+	{
+		HI3516DV300_FMC_MUX, "fmc_mux", fmc_mux_p, ARRAY_SIZE(fmc_mux_p),
+		CLK_SET_RATE_PARENT, 0x144, 2, 3, 0, fmc_mux_table,
+	},
+	{
+		HI3516DV300_MMC0_MUX, "mmc0_mux", mmc_mux_p, ARRAY_SIZE(mmc_mux_p),
+		CLK_SET_RATE_PARENT, 0x148, 2, 2, 0, mmc_mux_table,
+	},
+	{
+		HI3516DV300_MMC1_MUX, "mmc1_mux", mmc_mux_p, ARRAY_SIZE(mmc_mux_p),
+		CLK_SET_RATE_PARENT, 0x160, 2, 2, 0, mmc_mux_table,
+	},
+	{
+		HI3516DV300_MMC2_MUX, "mmc2_mux", mmc_mux_p, ARRAY_SIZE(mmc_mux_p),
+		CLK_SET_RATE_PARENT, 0x154, 2, 2, 0, mmc_mux_table,
+	},
+	{
+		HI3516DV300_UART_MUX, "uart_mux0", uart_mux_p,
+		ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1bc, 18, 1, 0, uart_mux_table,
+	},
+	{
+		HI3516DV300_UART1_MUX, "uart_mux1", uart_mux_p,
+		ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1bc, 19, 1, 0, uart_mux_table,
+	},
+	{
+		HI3516DV300_UART2_MUX, "uart_mux2", uart_mux_p,
+		ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1bc, 20, 1, 0, uart_mux_table,
+	},
+	{
+		HI3516DV300_UART3_MUX, "uart_mux3", uart_mux_p,
+		ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1bc, 21, 1, 0, uart_mux_table,
+	},
+	{
+		HI3516DV300_UART4_MUX, "uart_mux4", uart_mux_p,
+		ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1bc, 22, 1, 0, uart_mux_table,
+	},
+	{
+		HI3516DV300_PWM_MUX, "pwm_mux", pwm_mux_p,
+		ARRAY_SIZE(pwm_mux_p),
+		CLK_SET_RATE_PARENT, 0x1bc, 8, 2, 0, pwm_mux_table,
+	},
+	/* ethernet clock select */
+	{
+		HI3516DV300_ETH_MUX, "eth_mux", eth_mux_p, ARRAY_SIZE(eth_mux_p),
+		CLK_SET_RATE_PARENT, 0x16c, 7, 1, 0, eth_mux_table,
+	},
+};
+
+static struct hisi_fixed_factor_clock hi3516dv300_fixed_factor_clks[] __initdata
+	= {
+	{
+		HI3516DV300_SYSAXI_CLK, "clk_sysaxi", "sysaxi_mux", 1, 4,
+		CLK_SET_RATE_PARENT
+	},
+};
+
+static struct hisi_gate_clock hi3516dv300_gate_clks[] __initdata = {
+	{
+		HI3516DV300_FMC_CLK, "clk_fmc", "fmc_mux",
+		CLK_SET_RATE_PARENT, 0x144, 1, 0,
+	},
+	{
+		HI3516DV300_MMC0_CLK, "clk_mmc0", "mmc0_mux",
+		CLK_SET_RATE_PARENT, 0x148, 1, 0,
+	},
+	{
+		HI3516DV300_MMC1_CLK, "clk_mmc1", "mmc1_mux",
+		CLK_SET_RATE_PARENT, 0x160, 1, 0,
+	},
+	{
+		HI3516DV300_MMC2_CLK, "clk_mmc2", "mmc2_mux",
+		CLK_SET_RATE_PARENT, 0x154, 1, 0,
+	},
+	{
+		HI3516DV300_UART0_CLK, "clk_uart0", "uart_mux0",
+		CLK_SET_RATE_PARENT, 0x1b8, 0, 0,
+	},
+	{
+		HI3516DV300_UART1_CLK, "clk_uart1", "uart_mux1",
+		CLK_SET_RATE_PARENT, 0x1b8, 1, 0,
+	},
+	{
+		HI3516DV300_UART2_CLK, "clk_uart2", "uart_mux2",
+		CLK_SET_RATE_PARENT, 0x1b8, 2, 0,
+	},
+	{
+		HI3516DV300_UART3_CLK, "clk_uart3", "uart_mux3",
+		CLK_SET_RATE_PARENT, 0x1b8, 3, 0,
+	},
+	{
+		HI3516DV300_UART4_CLK, "clk_uart4", "uart_mux4",
+		CLK_SET_RATE_PARENT, 0x1b8, 4, 0,
+	},
+	{
+		HI3516DV300_I2C0_CLK, "clk_i2c0", "50m",
+		CLK_SET_RATE_PARENT, 0x1b8, 11, 0,
+	},
+	{
+		HI3516DV300_I2C1_CLK, "clk_i2c1", "50m",
+		CLK_SET_RATE_PARENT, 0x1b8, 12, 0,
+	},
+	{
+		HI3516DV300_I2C2_CLK, "clk_i2c2", "50m",
+		CLK_SET_RATE_PARENT, 0x1b8, 13, 0,
+	},
+	{
+		HI3516DV300_I2C3_CLK, "clk_i2c3", "50m",
+		CLK_SET_RATE_PARENT, 0x1b8, 14, 0,
+	},
+	{
+		HI3516DV300_I2C4_CLK, "clk_i2c4", "50m",
+		CLK_SET_RATE_PARENT, 0x1b8, 15, 0,
+	},
+	{
+		HI3516DV300_I2C5_CLK, "clk_i2c5", "50m",
+		CLK_SET_RATE_PARENT, 0x1b8, 16, 0,
+	},
+	{
+		HI3516DV300_I2C6_CLK, "clk_i2c6", "50m",
+		CLK_SET_RATE_PARENT, 0x1b8, 17, 0,
+	},
+	{
+		HI3516DV300_I2C7_CLK, "clk_i2c7", "50m",
+		CLK_SET_RATE_PARENT, 0x1b8, 18, 0,
+	},
+	{
+		HI3516DV300_SPI0_CLK, "clk_spi0", "100m",
+		CLK_SET_RATE_PARENT, 0x1bc, 12, 0,
+	},
+	{
+		HI3516DV300_SPI1_CLK, "clk_spi1", "100m",
+		CLK_SET_RATE_PARENT, 0x1bc, 13, 0,
+	},
+	{
+		HI3516DV300_SPI2_CLK, "clk_spi2", "100m",
+		CLK_SET_RATE_PARENT, 0x1bc, 14, 0,
+	},
+	{
+		HI3516DV300_ETH0_CLK, "clk_eth0", "eth_mux",
+		CLK_SET_RATE_PARENT, 0x16c, 1, 0,
+	},
+	{
+		HI3516DV300_DMAC_CLK, "clk_dmac", NULL,
+		CLK_SET_RATE_PARENT, 0x194, 1, 0,
+	},
+	{
+		HI3516DV300_DMAC_AXICLK, "axiclk_dmac", NULL,
+		CLK_SET_RATE_PARENT, 0x194, 2, 0,
+	},
+	{
+		HI3516DV300_PWM_CLK, "clk_pwm", "pwm_mux",
+		CLK_SET_RATE_PARENT, 0x1bc, 7, 0,
+	},
+};
+
+static void __init hi3516dv300_clk_init(struct device_node *np)
+{
+	struct hisi_clock_data *clk_data;
+
+	clk_data = hisi_clk_init(np, HI3516DV300_NR_CLKS);
+	if (!clk_data)
+		return;
+	if (IS_ENABLED(CONFIG_RESET_CONTROLLER))
+		hibvt_reset_init(np, HI3516DV300_NR_RSTS);
+
+	hisi_clk_register_fixed_rate(hi3516dv300_fixed_rate_clks,
+				     ARRAY_SIZE(hi3516dv300_fixed_rate_clks),
+				     clk_data);
+	hisi_clk_register_mux(hi3516dv300_mux_clks, ARRAY_SIZE(hi3516dv300_mux_clks),
+			      clk_data);
+	hisi_clk_register_fixed_factor(hi3516dv300_fixed_factor_clks,
+				       ARRAY_SIZE(hi3516dv300_fixed_factor_clks), clk_data);
+	hisi_clk_register_gate(hi3516dv300_gate_clks,
+			       ARRAY_SIZE(hi3516dv300_gate_clks), clk_data);
+}
+
+CLK_OF_DECLARE(hi3516dv300_clk, "hisilicon,hi3516dv300-clock",
+	       hi3516dv300_clk_init);
+
diff --git a/drivers/clk/hisilicon/clk-hi3519av100.c b/drivers/clk/hisilicon/clk-hi3519av100.c
new file mode 100644
index 000000000..657767941
--- /dev/null
+++ b/drivers/clk/hisilicon/clk-hi3519av100.c
@@ -0,0 +1,559 @@
+/*
+ * Hi3519A Clock Driver
+ *
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/of_address.h>
+#include <dt-bindings/clock/hi3519av100-clock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "clk.h"
+#include "reset.h"
+
+struct hi3519av100_pll_clock {
+	u32             id;
+	const char      *name;
+	const char      *parent_name;
+	u32             ctrl_reg1;
+	u8              frac_shift;
+	u8              frac_width;
+	u8              postdiv1_shift;
+	u8              postdiv1_width;
+	u8              postdiv2_shift;
+	u8              postdiv2_width;
+	u32             ctrl_reg2;
+	u8              fbdiv_shift;
+	u8              fbdiv_width;
+	u8              refdiv_shift;
+	u8              refdiv_width;
+};
+
+struct hi3519av100_clk_pll {
+	struct clk_hw   hw;
+	u32             id;
+	void __iomem    *ctrl_reg1;
+	u8              frac_shift;
+	u8              frac_width;
+	u8              postdiv1_shift;
+	u8              postdiv1_width;
+	u8              postdiv2_shift;
+	u8              postdiv2_width;
+	void __iomem    *ctrl_reg2;
+	u8              fbdiv_shift;
+	u8              fbdiv_width;
+	u8              refdiv_shift;
+	u8              refdiv_width;
+};
+
+static struct hi3519av100_pll_clock hi3519av100_pll_clks[] __initdata = {
+	{
+		HI3519AV100_APLL_CLK, "apll", NULL, 0x0, 0, 24, 24, 3, 28, 3,
+		0x4, 0, 12, 12, 6
+	},
+};
+
+#define to_pll_clk(_hw) container_of(_hw, struct hi3519av100_clk_pll, hw)
+
+/* soc clk config */
+static struct hisi_fixed_rate_clock hi3519av100_fixed_rate_clks[] __initdata = {
+	{ HI3519AV100_FIXED_2376M, "2376m", NULL, 0, 2376000000UL, },
+	{ HI3519AV100_FIXED_1188M, "1188m", NULL, 0, 1188000000, },
+	{ HI3519AV100_FIXED_594M, "594m", NULL, 0, 594000000, },
+	{ HI3519AV100_FIXED_297M, "297m", NULL, 0, 297000000, },
+	{ HI3519AV100_FIXED_148P5M, "148p5m", NULL, 0, 148500000, },
+	{ HI3519AV100_FIXED_74P25M, "74p25m", NULL, 0, 74250000, },
+	{ HI3519AV100_FIXED_792M, "792m", NULL, 0, 792000000, },
+	{ HI3519AV100_FIXED_475M, "475m", NULL, 0, 475000000, },
+	{ HI3519AV100_FIXED_340M, "340m", NULL, 0, 340000000, },
+	{ HI3519AV100_FIXED_72M, "72m", NULL, 0, 72000000, },
+	{ HI3519AV100_FIXED_400M, "400m", NULL, 0, 400000000, },
+	{ HI3519AV100_FIXED_200M, "200m", NULL, 0, 200000000, },
+	{ HI3519AV100_FIXED_54M, "54m", NULL, 0, 54000000, },
+	{ HI3519AV100_FIXED_27M, "27m", NULL, 0, 1188000000, },
+	{ HI3519AV100_FIXED_37P125M, "37p125m", NULL, 0, 37125000, },
+	{ HI3519AV100_FIXED_3000M, "3000m", NULL, 0, 3000000000UL, },
+	{ HI3519AV100_FIXED_1500M, "1500m", NULL, 0, 1500000000, },
+	{ HI3519AV100_FIXED_500M, "500m", NULL, 0, 500000000, },
+	{ HI3519AV100_FIXED_250M, "250m", NULL, 0, 250000000, },
+	{ HI3519AV100_FIXED_125M, "125m", NULL, 0, 125000000, },
+	{ HI3519AV100_FIXED_1000M, "1000m", NULL, 0, 1000000000, },
+	{ HI3519AV100_FIXED_600M, "600m", NULL, 0, 600000000, },
+	{ HI3519AV100_FIXED_750M, "750m", NULL, 0, 750000000, },
+	{ HI3519AV100_FIXED_150M, "150m", NULL, 0, 150000000, },
+	{ HI3519AV100_FIXED_75M, "75m", NULL, 0, 75000000, },
+	{ HI3519AV100_FIXED_300M, "300m", NULL, 0, 300000000, },
+	{ HI3519AV100_FIXED_60M, "60m", NULL, 0, 60000000, },
+	{ HI3519AV100_FIXED_214M, "214m", NULL, 0, 214000000, },
+	{ HI3519AV100_FIXED_107M, "107m", NULL, 0, 107000000, },
+	{ HI3519AV100_FIXED_100M, "100m", NULL, 0, 100000000, },
+	{ HI3519AV100_FIXED_50M, "50m", NULL, 0, 50000000, },
+	{ HI3519AV100_FIXED_25M, "25m", NULL, 0, 25000000, },
+	{ HI3519AV100_FIXED_24M, "24m", NULL, 0, 24000000, },
+	{ HI3519AV100_FIXED_3M, "3m", NULL, 0, 3000000, },
+	{ HI3519AV100_FIXED_100K, "100k", NULL, 0, 100000, },
+	{ HI3519AV100_FIXED_400K, "400k", NULL, 0, 400000, },
+	{ HI3519AV100_FIXED_49P5M, "49p5m", NULL, 0, 49500000, },
+	{ HI3519AV100_FIXED_99M, "99m", NULL, 0, 99000000, },
+	{ HI3519AV100_FIXED_187P5M, "187p5m", NULL, 0, 187500000, },
+	{ HI3519AV100_FIXED_198M, "198m", NULL, 0, 198000000, },
+};
+
+
+static const char *fmc_mux_p[] __initdata = {
+	"24m", "100m", "150m", "198m", "250m", "300m", "396m"
+};
+static u32 fmc_mux_table[] = {0, 1, 2, 3, 4, 5, 6};
+
+static const char *mmc_mux_p[] __initdata = {
+	"100k", "25m", "49p5m", "99m", "187p5m", "150m", "198m", "400k"
+};
+static u32 mmc_mux_table[] = {0, 1, 2, 3, 4, 5, 6, 7};
+
+static const char *sysapb_mux_p[] __initdata = {
+	"24m", "50m",
+};
+static u32 sysapb_mux_table[] = {0, 1};
+
+static const char *sysbus_mux_p[] __initdata = {
+	"24m", "300m"
+};
+static u32 sysbus_mux_table[] = {0, 1};
+
+static const char *uart_mux_p[] __initdata = {"50m", "24m", "3m"};
+static u32 uart_mux_table[] = {0, 1, 2};
+
+static const char *a53_1_clksel_mux_p[] __initdata = {
+	"24m", "apll", "vpll", "792m"
+};
+static u32 a53_1_clksel_mux_table[] = {0, 1, 2, 3};
+
+static struct hisi_mux_clock hi3519av100_mux_clks[] __initdata = {
+	{
+		HI3519AV100_FMC_MUX, "fmc_mux", fmc_mux_p, ARRAY_SIZE(fmc_mux_p),
+		CLK_SET_RATE_PARENT, 0x170, 2, 3, 0, fmc_mux_table,
+	},
+
+	{
+		HI3519AV100_MMC0_MUX, "mmc0_mux", mmc_mux_p, ARRAY_SIZE(mmc_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a8, 24, 3, 0, mmc_mux_table,
+	},
+
+	{
+		HI3519AV100_MMC1_MUX, "mmc1_mux", mmc_mux_p, ARRAY_SIZE(mmc_mux_p),
+		CLK_SET_RATE_PARENT, 0x1ec, 24, 3, 0, mmc_mux_table,
+	},
+
+	{
+		HI3519AV100_MMC2_MUX, "mmc2_mux", mmc_mux_p, ARRAY_SIZE(mmc_mux_p),
+		CLK_SET_RATE_PARENT, 0x214, 24, 3, 0, mmc_mux_table,
+	},
+
+	{
+		HI3519AV100_SYSAPB_MUX, "sysapb_mux", sysapb_mux_p, ARRAY_SIZE(sysapb_mux_p),
+		CLK_SET_RATE_PARENT, 0xe8, 3, 1, 0, sysapb_mux_table
+	},
+
+	{
+		HI3519AV100_SYSBUS_MUX, "sysbus_mux", sysbus_mux_p, ARRAY_SIZE(sysbus_mux_p),
+		CLK_SET_RATE_PARENT, 0xe8, 0, 1, 1, sysbus_mux_table
+	},
+
+	{
+		HI3519AV100_UART0_MUX, "uart0_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 0, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_UART1_MUX, "uart1_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 2, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_UART2_MUX, "uart2_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 4, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_UART3_MUX, "uart3_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 6, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_UART4_MUX, "uart4_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 8, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_UART5_MUX, "uart5_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 10, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_UART6_MUX, "uart6_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 12, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_UART7_MUX, "uart7_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 14, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_UART8_MUX, "uart8_mux", uart_mux_p, ARRAY_SIZE(uart_mux_p),
+		CLK_SET_RATE_PARENT, 0x1a4, 28, 2, 1, uart_mux_table
+	},
+
+	{
+		HI3519AV100_A53_1_MUX, "a53_1_mux", a53_1_clksel_mux_p, ARRAY_SIZE(a53_1_clksel_mux_p),
+		CLK_SET_RATE_PARENT, 0xe4, 10, 2, 3, a53_1_clksel_mux_table
+	},
+
+};
+
+static struct hisi_fixed_factor_clock hi3519av100_fixed_factor_clks[] __initdata
+	= {
+
+};
+
+static struct hisi_gate_clock hi3519av100_gate_clks[] __initdata = {
+	{
+		HI3519AV100_FMC_CLK, "clk_fmc", "fmc_mux",
+		CLK_SET_RATE_PARENT, 0x170, 1, 0,
+	},
+	{
+		HI3519AV100_MMC0_CLK, "clk_mmc0", "mmc0_mux",
+		CLK_SET_RATE_PARENT, 0x1a8, 28, 0,
+	},
+	{
+		HI3519AV100_MMC1_CLK, "clk_mmc1", "mmc1_mux",
+		CLK_SET_RATE_PARENT, 0x1ec, 28, 0,
+	},
+	{
+		HI3519AV100_MMC2_CLK, "clk_mmc2", "mmc2_mux",
+		CLK_SET_RATE_PARENT, 0x214, 28, 0,
+	},
+	{
+		HI3519AV100_UART0_CLK, "clk_uart0", "uart0_mux",
+		CLK_SET_RATE_PARENT, 0x198, 16, 0,
+	},
+	{
+		HI3519AV100_UART1_CLK, "clk_uart1", "uart1_mux",
+		CLK_SET_RATE_PARENT, 0x198, 17, 0,
+	},
+	{
+		HI3519AV100_UART2_CLK, "clk_uart2", "uart2_mux",
+		CLK_SET_RATE_PARENT, 0x198, 18, 0,
+	},
+	{
+		HI3519AV100_UART3_CLK, "clk_uart3", "uart3_mux",
+		CLK_SET_RATE_PARENT, 0x198, 19, 0,
+	},
+	{
+		HI3519AV100_UART4_CLK, "clk_uart4", "uart4_mux",
+		CLK_SET_RATE_PARENT, 0x198, 20, 0,
+	},
+	{
+		HI3519AV100_UART5_CLK, "clk_uart5", "uart5_mux",
+		CLK_SET_RATE_PARENT, 0x198, 21, 0,
+	},
+	{
+		HI3519AV100_UART6_CLK, "clk_uart6", "uart6_mux",
+		CLK_SET_RATE_PARENT, 0x198, 22, 0,
+	},
+	{
+		HI3519AV100_UART7_CLK, "clk_uart7", "uart7_mux",
+		CLK_SET_RATE_PARENT, 0x198, 23, 0,
+	},
+	{
+		HI3519AV100_UART8_CLK, "clk_uart8", "uart8_mux",
+		CLK_SET_RATE_PARENT, 0x198, 29, 0,
+	},
+	{
+		HI3519AV100_ETH_CLK, "clk_eth", NULL,
+		CLK_SET_RATE_PARENT, 0x0174, 1, 0,
+	},
+	{
+		HI3519AV100_ETH_MACIF_CLK, "clk_eth_macif", NULL,
+		CLK_SET_RATE_PARENT, 0x0174, 5, 0,
+	},
+	/* i2c */
+	{
+		HI3519AV100_I2C0_CLK, "clk_i2c0", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 16, 0,
+	},
+	{
+		HI3519AV100_I2C1_CLK, "clk_i2c1", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 17, 0,
+	},
+	{
+		HI3519AV100_I2C2_CLK, "clk_i2c2", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 18, 0,
+	},
+	{
+		HI3519AV100_I2C3_CLK, "clk_i2c3", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 19, 0,
+	},
+	{
+		HI3519AV100_I2C4_CLK, "clk_i2c4", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 20, 0,
+	},
+	{
+		HI3519AV100_I2C5_CLK, "clk_i2c5", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 21, 0,
+	},
+	{
+		HI3519AV100_I2C6_CLK, "clk_i2c6", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 22, 0,
+	},
+	{
+		HI3519AV100_I2C7_CLK, "clk_i2c7", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 23, 0,
+	},
+	{
+		HI3519AV100_I2C8_CLK, "clk_i2c8", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 24, 0,
+	},
+	{
+		HI3519AV100_I2C9_CLK, "clk_i2c9", "50m",
+		CLK_SET_RATE_PARENT, 0x01a0, 25, 0,
+	},
+	{
+		HI3519AV100_SPI0_CLK, "clk_spi0", "100m",
+		CLK_SET_RATE_PARENT, 0x0198, 24, 0,
+	},
+	{
+		HI3519AV100_SPI1_CLK, "clk_spi1", "100m",
+		CLK_SET_RATE_PARENT, 0x0198, 25, 0,
+	},
+	{
+		HI3519AV100_SPI2_CLK, "clk_spi2", "100m",
+		CLK_SET_RATE_PARENT, 0x0198, 26, 0,
+	},
+	{
+		HI3519AV100_SPI3_CLK, "clk_spi3", "100m",
+		CLK_SET_RATE_PARENT, 0x0198, 27, 0,
+	},
+	{
+		HI3519AV100_SPI4_CLK, "clk_spi4", "100m",
+		CLK_SET_RATE_PARENT, 0x0198, 28, 0,
+	},
+	{
+		HI3519AV100_EDMAC_AXICLK, "axi_clk_edmac", NULL,
+		CLK_SET_RATE_PARENT, 0x16c, 6, 0,
+	},
+	{
+		HI3519AV100_EDMAC_CLK, "clk_edmac", NULL,
+		CLK_SET_RATE_PARENT, 0x16c, 5, 0,
+	},
+	{
+		HI3519AV100_EDMAC1_AXICLK, "axi_clk_edmac1", NULL,
+		CLK_SET_RATE_PARENT, 0x16c, 9, 0,
+	},
+	{
+		HI3519AV100_EDMAC1_CLK, "clk_edmac1", NULL,
+		CLK_SET_RATE_PARENT, 0x16c, 8, 0,
+	},
+	{
+		HI3519AV100_VDMAC_CLK, "clk_vdmac", NULL,
+		CLK_SET_RATE_PARENT, 0x14c, 5, 0,
+	},
+};
+
+static void hi3519av100_calc_pll(u32 *frac_val,
+				 u32 *postdiv1_val,
+				 u32 *postdiv2_val,
+				 u32 *fbdiv_val,
+				 u32 *refdiv_val,
+				 u64 rate)
+{
+	u64 rem;
+	*frac_val = 0;
+	rem = do_div(rate, 1000000);
+	*fbdiv_val = rate;
+	*refdiv_val = 24;
+	if ((rem * (1 << 24)) > ULLONG_MAX) {
+		pr_err("Data over limits!\n");
+		return;
+        }
+	rem = rem * (1 << 24);
+	do_div(rem, 1000000);
+	*frac_val = rem;
+}
+
+static int clk_pll_set_rate(struct clk_hw *hw,
+			    unsigned long rate,
+			    unsigned long parent_rate)
+{
+	struct hi3519av100_clk_pll *clk = to_pll_clk(hw);
+	u32 frac_val, postdiv1_val, postdiv2_val, fbdiv_val, refdiv_val;
+	u32 val;
+
+	postdiv1_val = postdiv2_val = 0;
+
+	hi3519av100_calc_pll(&frac_val, &postdiv1_val, &postdiv2_val,
+			     &fbdiv_val, &refdiv_val, rate);
+
+	val = readl_relaxed(clk->ctrl_reg1);
+	val &= ~(((1 << clk->frac_width) - 1) << clk->frac_shift);
+	val &= ~(((1 << clk->postdiv1_width) - 1) << clk->postdiv1_shift);
+	val &= ~(((1 << clk->postdiv2_width) - 1) << clk->postdiv2_shift);
+
+	val |= frac_val << clk->frac_shift;
+	val |= postdiv1_val << clk->postdiv1_shift;
+	val |= postdiv2_val << clk->postdiv2_shift;
+	writel_relaxed(val, clk->ctrl_reg1);
+
+	val = readl_relaxed(clk->ctrl_reg2);
+	val &= ~(((1 << clk->fbdiv_width) - 1) << clk->fbdiv_shift);
+	val &= ~(((1 << clk->refdiv_width) - 1) << clk->refdiv_shift);
+
+	val |= fbdiv_val << clk->fbdiv_shift;
+	val |= refdiv_val << clk->refdiv_shift;
+	writel_relaxed(val, clk->ctrl_reg2);
+
+	return 0;
+}
+
+static unsigned long clk_pll_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct hi3519av100_clk_pll *clk = to_pll_clk(hw);
+	u64 frac_val, fbdiv_val;
+	u32 val;
+	u64 tmp, rate;
+	u32 refdiv_val;
+
+	val = readl_relaxed(clk->ctrl_reg1);
+	val = val >> clk->frac_shift;
+	val &= ((1 << clk->frac_width) - 1);
+	frac_val = val;
+
+	val = readl_relaxed(clk->ctrl_reg2);
+	val = val >> clk->fbdiv_shift;
+	val &= ((1 << clk->fbdiv_width) - 1);
+	fbdiv_val = val;
+
+	val = readl_relaxed(clk->ctrl_reg2);
+	val = val >> clk->refdiv_shift;
+	val &= ((1 << clk->refdiv_width) - 1);
+	refdiv_val = val;
+
+	/* rate = 24000000 * (fbdiv + frac / (1<<24) ) / refdiv  */
+	rate = 0;
+	if ((24000000 * fbdiv_val) > ULLONG_MAX) {
+		pr_err("Data over limits!\n");
+		return 0;
+        }
+	tmp = 24000000 * fbdiv_val;
+	rate += tmp;
+	do_div(rate, refdiv_val);
+
+	return rate;
+}
+
+static int clk_pll_determine_rate(struct clk_hw *hw,
+				  struct clk_rate_request *req)
+{
+	return req->rate;
+}
+
+static struct clk_ops clk_pll_ops = {
+	.set_rate = clk_pll_set_rate,
+	.determine_rate = clk_pll_determine_rate,
+	.recalc_rate = clk_pll_recalc_rate,
+};
+
+void __init hi3519av100_clk_register_pll(struct hi3519av100_pll_clock *clks,
+		int nums, struct hisi_clock_data *data)
+{
+	int i;
+	void __iomem *base = NULL;
+
+	if (clks == NULL || data == NULL)
+		return;
+
+	base = data->base;
+	for (i = 0; i < nums; i++) {
+		struct hi3519av100_clk_pll *p_clk = NULL;
+		struct clk *clk = NULL;
+		struct clk_init_data init;
+
+		p_clk = kzalloc(sizeof(*p_clk), GFP_KERNEL);
+		if (!p_clk)
+			return;
+
+		init.name = clks[i].name;
+		init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+		init.parent_names =
+			(clks[i].parent_name ? &clks[i].parent_name : NULL);
+		init.num_parents = (clks[i].parent_name ? 1 : 0);
+		init.ops = &clk_pll_ops;
+
+		p_clk->ctrl_reg1 = base + clks[i].ctrl_reg1;
+		p_clk->frac_shift = clks[i].frac_shift;
+		p_clk->frac_width = clks[i].frac_width;
+		p_clk->postdiv1_shift = clks[i].postdiv1_shift;
+		p_clk->postdiv1_width = clks[i].postdiv1_width;
+		p_clk->postdiv2_shift = clks[i].postdiv2_shift;
+		p_clk->postdiv2_width = clks[i].postdiv2_width;
+
+		p_clk->ctrl_reg2 = base + clks[i].ctrl_reg2;
+		p_clk->fbdiv_shift = clks[i].fbdiv_shift;
+		p_clk->fbdiv_width = clks[i].fbdiv_width;
+		p_clk->refdiv_shift = clks[i].refdiv_shift;
+		p_clk->refdiv_width = clks[i].refdiv_width;
+		p_clk->hw.init = &init;
+
+		clk = clk_register(NULL, &p_clk->hw);
+		if (IS_ERR(clk)) {
+			kfree(p_clk);
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, clks[i].name);
+			continue;
+		}
+
+		data->clk_data.clks[clks[i].id] = clk;
+	}
+}
+
+static void __init hi3519av100_clk_init(struct device_node *np)
+{
+	struct hisi_clock_data *clk_data;
+
+	clk_data = hisi_clk_init(np, HI3519AV100_NR_CLKS);
+	if (!clk_data)
+		return;
+	if (IS_ENABLED(CONFIG_RESET_CONTROLLER))
+		hibvt_reset_init(np, HI3519AV100_NR_RSTS);
+
+	hisi_clk_register_fixed_rate(hi3519av100_fixed_rate_clks,
+				     ARRAY_SIZE(hi3519av100_fixed_rate_clks),
+				     clk_data);
+	hisi_clk_register_mux(hi3519av100_mux_clks, ARRAY_SIZE(hi3519av100_mux_clks),
+			      clk_data);
+	hisi_clk_register_fixed_factor(hi3519av100_fixed_factor_clks,
+				       ARRAY_SIZE(hi3519av100_fixed_factor_clks), clk_data);
+	hisi_clk_register_gate(hi3519av100_gate_clks,
+			       ARRAY_SIZE(hi3519av100_gate_clks), clk_data);
+
+	hi3519av100_clk_register_pll(hi3519av100_pll_clks,
+				     ARRAY_SIZE(hi3519av100_pll_clks), clk_data);
+}
+
+CLK_OF_DECLARE(hi3519av100_clk, "hisilicon,hi3519av100-clock",
+	       hi3519av100_clk_init);
diff --git a/drivers/clk/hisilicon/clk-hisi-phase.c b/drivers/clk/hisilicon/clk-hisi-phase.c
index ba6afad66..b13b91609 100644
--- a/drivers/clk/hisilicon/clk-hisi-phase.c
+++ b/drivers/clk/hisilicon/clk-hisi-phase.c
@@ -77,7 +77,7 @@ static int hisi_clk_set_phase(struct clk_hw *hw, int degrees)
 
 	val = readl(phase->reg);
 	val &= ~phase->mask;
-	val |= regval << phase->shift;
+	val |= (unsigned int)regval << phase->shift;
 	writel(val, phase->reg);
 
 	spin_unlock_irqrestore(phase->lock, flags);
diff --git a/drivers/clk/hisilicon/clk.c b/drivers/clk/hisilicon/clk.c
index 54d9fdc93..9ca4fc05f 100644
--- a/drivers/clk/hisilicon/clk.c
+++ b/drivers/clk/hisilicon/clk.c
@@ -82,6 +82,10 @@ struct hisi_clock_data *hisi_clk_init(struct device_node *np,
 	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data->clk_data);
 	return clk_data;
 err_data:
+	if (base) {
+		iounmap(base);
+		base = NULL;
+	}
 	kfree(clk_data);
 err:
 	return NULL;
diff --git a/drivers/clk/hisilicon/crg.h b/drivers/clk/hisilicon/crg.h
index 803f6ba6d..a84758660 100644
--- a/drivers/clk/hisilicon/crg.h
+++ b/drivers/clk/hisilicon/crg.h
@@ -13,7 +13,7 @@ struct hisi_reset_controller;
 
 struct hisi_crg_funcs {
 	struct hisi_clock_data*	(*register_clks)(struct platform_device *pdev);
-	void (*unregister_clks)(struct platform_device *pdev);
+	void (*unregister_clks)(const struct platform_device *pdev);
 };
 
 struct hisi_crg_dev {
diff --git a/drivers/clk/hisilicon/reset.c b/drivers/clk/hisilicon/reset.c
index 93cee17db..e9a03d924 100644
--- a/drivers/clk/hisilicon/reset.c
+++ b/drivers/clk/hisilicon/reset.c
@@ -87,6 +87,36 @@ static const struct reset_control_ops hisi_reset_ops = {
 	.deassert	= hisi_reset_deassert,
 };
 
+#ifdef CONFIG_ARCH_HISI_BVT
+int __init hibvt_reset_init(struct device_node *np,
+		int nr_rsts)
+{
+	struct hisi_reset_controller *rstc;
+
+	rstc = kzalloc(sizeof(*rstc), GFP_KERNEL);
+	if (!rstc)
+		return -ENOMEM;
+
+	rstc->membase = of_iomap(np, 0);
+	if (!rstc->membase){
+		kfree(rstc);
+		return -EINVAL;
+	}
+
+	spin_lock_init(&rstc->lock);
+
+	rstc->rcdev.owner = THIS_MODULE;
+	rstc->rcdev.nr_resets = nr_rsts;
+	rstc->rcdev.ops = &hisi_reset_ops;
+	rstc->rcdev.of_node = np;
+	rstc->rcdev.of_reset_n_cells = 2;
+	rstc->rcdev.of_xlate = hisi_reset_of_xlate;
+
+	return reset_controller_register(&rstc->rcdev);
+}
+EXPORT_SYMBOL_GPL(hibvt_reset_init);
+#endif
+
 struct hisi_reset_controller *hisi_reset_init(struct platform_device *pdev)
 {
 	struct hisi_reset_controller *rstc;
diff --git a/drivers/clk/hisilicon/reset.h b/drivers/clk/hisilicon/reset.h
index 81ff9e9e3..5954bdf91 100644
--- a/drivers/clk/hisilicon/reset.h
+++ b/drivers/clk/hisilicon/reset.h
@@ -11,6 +11,9 @@ struct hisi_reset_controller;
 
 #ifdef CONFIG_RESET_CONTROLLER
 struct hisi_reset_controller *hisi_reset_init(struct platform_device *pdev);
+#ifdef CONFIG_ARCH_HISI_BVT
+int __init hibvt_reset_init(struct device_node *np, int nr_rsts);
+#endif
 void hisi_reset_exit(struct hisi_reset_controller *rstc);
 #else
 static inline
diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index 39f4d8866..ddf6f7373 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -347,6 +347,14 @@ config ARM_ARCH_TIMER_EVTSTREAM
 config ARM_ARCH_TIMER_OOL_WORKAROUND
 	bool
 
+config ARM_ARCH_TIMER_VCT_ACCESS
+	bool "Support for ARM architected timer virtual counter access in userspace"
+	default n
+	depends on ARM_ARCH_TIMER
+	help
+	  This option enables support for reading the ARM architected timer's
+	  virtual counter in userspace.
+
 config FSL_ERRATUM_A008585
 	bool "Workaround for Freescale/NXP Erratum A-008585"
 	default y
@@ -402,6 +410,12 @@ config ARM_TIMER_SP804
 	select CLKSRC_MMIO
 	select TIMER_OF if OF
 
+config TIMER_HISP804
+	bool "Support for hisilicon SP804 module"
+	depends on GENERIC_SCHED_CLOCK && CLKDEV_LOOKUP
+	select CLKSRC_MMIO
+	select TIMER_OF if OF
+
 config CLKSRC_ARM_GLOBAL_TIMER_SCHED_CLOCK
 	bool
 	depends on ARM_GLOBAL_TIMER
diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
index 1c444cc3b..1a184f6ba 100644
--- a/drivers/clocksource/Makefile
+++ b/drivers/clocksource/Makefile
@@ -69,6 +69,7 @@ obj-$(CONFIG_ARM_ARCH_TIMER)		+= arm_arch_timer.o
 obj-$(CONFIG_ARM_GLOBAL_TIMER)		+= arm_global_timer.o
 obj-$(CONFIG_ARMV7M_SYSTICK)		+= armv7m_systick.o
 obj-$(CONFIG_ARM_TIMER_SP804)		+= timer-sp804.o
+obj-$(CONFIG_TIMER_HISP804)		+= timer-hisp804.o
 obj-$(CONFIG_ARCH_HAS_TICK_BROADCAST)	+= dummy_timer.o
 obj-$(CONFIG_KEYSTONE_TIMER)		+= timer-keystone.o
 obj-$(CONFIG_INTEGRATOR_AP_TIMER)	+= timer-integrator-ap.o
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index f4881764b..d435d1266 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -631,7 +631,8 @@ static bool arch_timer_counter_has_wa(void)
 }
 #else
 #define arch_timer_check_ool_workaround(t,a)		do { } while(0)
-#define arch_timer_this_cpu_has_cntvct_wa()		({false;})
+#define arch_timer_this_cpu_has_cntvct_wa()		\
+	({IS_ENABLED(CONFIG_ARM_ARCH_TIMER_VCT_ACCESS) ? false : true;})
 #define arch_timer_counter_has_wa()			({false;})
 #endif /* CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND */
 
diff --git a/drivers/clocksource/timer-hisp804.c b/drivers/clocksource/timer-hisp804.c
new file mode 100644
index 000000000..b2c857a41
--- /dev/null
+++ b/drivers/clocksource/timer-hisp804.c
@@ -0,0 +1,356 @@
+/******************************************************************************
+ *  Copyright (C) 2017 Hisilicon Technologies CO.,LTD.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Create By Cai Zhiying 2017.2.4
+ *
+******************************************************************************/
+
+#define pr_fmt(fmt) "hisp804: " fmt
+
+#include <linux/clk.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/cpu.h>
+#include <linux/io.h>
+#include <linux/smp.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/sched_clock.h>
+
+#define TIMER_LOAD      0x00             /* ACVR rw */
+#define TIMER_VALUE     0x04             /* ACVR ro */
+#define TIMER_CTRL      0x08             /* ACVR rw */
+#define TIMER_CTRL_ONESHOT      (1 << 0) /*  CVR */
+#define TIMER_CTRL_32BIT        (1 << 1) /*  CVR */
+#define TIMER_CTRL_DIV1         (0 << 2) /* ACVR */
+#define TIMER_CTRL_DIV16        (1 << 2) /* ACVR */
+#define TIMER_CTRL_DIV256       (2 << 2) /* ACVR */
+#define TIMER_CTRL_IE           (1 << 5) /*   VR */
+#define TIMER_CTRL_PERIODIC     (1 << 6) /* ACVR */
+#define TIMER_CTRL_ENABLE       (1 << 7) /* ACVR */
+
+#define TIMER_INTCLR    0x0c             /* ACVR wo */
+#define TIMER_RIS       0x10             /*  CVR ro */
+#define TIMER_MIS       0x14             /*  CVR ro */
+#define TIMER_BGLOAD    0x18             /*  CVR rw */
+
+#define CPU_TASKS_FROZEN        0x0010
+
+struct hisp804_clocksource {
+	void __iomem *base;
+	struct clocksource clksrc;
+};
+
+#define to_hiclksrc(e) \
+	container_of(e, struct hisp804_clocksource, clksrc)
+
+static struct hisp804_clocksource hisp804_clksrc;
+
+static void __iomem *hisp804_sched_clock_base;
+
+struct hisp804_clockevent_device {
+	struct clock_event_device clkevt;
+	struct irqaction action;
+	void __iomem *base;
+	unsigned long rate;
+	unsigned long reload;
+	char name[16];
+};
+
+#define to_hiclkevt(e) \
+	container_of(e, struct hisp804_clockevent_device, clkevt)
+
+static struct hisp804_clockevent_device __percpu *hisp804_clkevt;
+
+static void hisp804_clocksource_enable(void __iomem *base)
+{
+	writel(0, base + TIMER_CTRL);
+	writel(0xffffffff, base + TIMER_LOAD);
+	writel(0xffffffff, base + TIMER_VALUE);
+	writel(TIMER_CTRL_32BIT | TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC,
+	       base + TIMER_CTRL);
+}
+
+static void hisp804_clocksource_resume(struct clocksource *cs)
+{
+	hisp804_clocksource_enable(to_hiclksrc(cs)->base);
+}
+
+static u64 notrace hisp804_sched_clock_read(void)
+{
+	return ~readl_relaxed(hisp804_sched_clock_base + TIMER_VALUE);
+}
+
+static cycle_t hisp804_clocksource_read(struct clocksource *cs)
+{
+	return ~(cycle_t)readl_relaxed(to_hiclksrc(cs)->base + TIMER_VALUE);
+}
+
+static void __init hisp804_clocksource_init(void __iomem *base,
+					    unsigned long rate)
+{
+	hisp804_clksrc.base = base;
+	hisp804_clksrc.clksrc.name = "hisp804";
+	hisp804_clksrc.clksrc.rating = 499;
+	hisp804_clksrc.clksrc.read = hisp804_clocksource_read;
+	hisp804_clksrc.clksrc.resume = hisp804_clocksource_resume;
+	hisp804_clksrc.clksrc.mask = CLOCKSOURCE_MASK(32);
+	hisp804_clksrc.clksrc.flags = CLOCK_SOURCE_IS_CONTINUOUS;
+
+	hisp804_clocksource_enable(base);
+
+	clocksource_register_hz(&hisp804_clksrc.clksrc, rate);
+
+	hisp804_sched_clock_base = base;
+	sched_clock_register(hisp804_sched_clock_read, 32, rate);
+}
+
+static int hisp804_clockevent_shutdown(struct clock_event_device *clkevt)
+{
+	struct hisp804_clockevent_device *hiclkevt = to_hiclkevt(clkevt);
+
+	writel(0, hiclkevt->base + TIMER_CTRL);
+
+	return 0;
+}
+
+static int hisp804_clockevent_set_next_event(unsigned long next,
+					     struct clock_event_device *clkevt)
+{
+	unsigned long ctrl;
+	struct hisp804_clockevent_device *hiclkevt = to_hiclkevt(clkevt);
+
+	writel(TIMER_CTRL_32BIT, hiclkevt->base + TIMER_CTRL);
+
+	writel(next, hiclkevt->base + TIMER_LOAD);
+	writel(next, hiclkevt->base + TIMER_LOAD);
+
+	ctrl = TIMER_CTRL_32BIT |
+	       TIMER_CTRL_IE |
+	       TIMER_CTRL_ONESHOT |
+	       TIMER_CTRL_ENABLE;
+	writel(ctrl, hiclkevt->base + TIMER_CTRL);
+
+	return 0;
+}
+
+static int sp804_clockevent_set_periodic(struct clock_event_device *clkevt)
+{
+	unsigned long ctrl;
+	struct hisp804_clockevent_device *hiclkevt = to_hiclkevt(clkevt);
+
+	writel(TIMER_CTRL_32BIT, hiclkevt->base + TIMER_CTRL);
+
+	writel(hiclkevt->reload, hiclkevt->base + TIMER_LOAD);
+	writel(hiclkevt->reload, hiclkevt->base + TIMER_LOAD);
+
+	ctrl = TIMER_CTRL_32BIT |
+	       TIMER_CTRL_IE |
+	       TIMER_CTRL_PERIODIC |
+	       TIMER_CTRL_ENABLE;
+	writel(ctrl, hiclkevt->base + TIMER_CTRL);
+
+	return 0;
+}
+
+static irqreturn_t hisp804_clockevent_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *clkevt = dev_id;
+	struct hisp804_clockevent_device *hiclkevt = to_hiclkevt(clkevt);
+
+	/* clear the interrupt */
+	writel(1, hiclkevt->base + TIMER_INTCLR);
+
+	clkevt->event_handler(clkevt);
+
+	return IRQ_HANDLED;
+}
+
+static int hisp804_clockevent_setup(struct hisp804_clockevent_device *hiclkevt)
+{
+	struct clock_event_device *clkevt = &hiclkevt->clkevt;
+
+	writel(0, hiclkevt->base + TIMER_CTRL);
+
+	BUG_ON(setup_irq(clkevt->irq, &hiclkevt->action));
+
+	irq_force_affinity(clkevt->irq, clkevt->cpumask);
+
+	clockevents_config_and_register(clkevt, hiclkevt->rate, 0xf,
+					0x7fffffff);
+
+	return 0;
+}
+
+static void hisp804_clockevent_stop(struct hisp804_clockevent_device *hiclkevt)
+{
+	struct clock_event_device *clkevt = &hiclkevt->clkevt;
+
+	pr_info("disable IRQ%d cpu #%d\n", clkevt->irq, smp_processor_id());
+
+	disable_irq(clkevt->irq);
+
+	remove_irq(clkevt->irq, &hiclkevt->action);
+
+	clkevt->set_state_shutdown(clkevt);
+}
+
+static int hisp804_clockevent_cpu_notify(struct notifier_block *self,
+					 unsigned long action, void *hcpu)
+{
+	/*
+	 * Grab cpu pointer in each case to avoid spurious
+	 * preemptible warnings
+	 */
+	switch (action & ~CPU_TASKS_FROZEN) {
+	case CPU_ONLINE:
+		hisp804_clockevent_setup(this_cpu_ptr(hisp804_clkevt));
+		break;
+	case CPU_DEAD:
+		hisp804_clockevent_stop(this_cpu_ptr(hisp804_clkevt));
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block hisp804_clockevent_cpu_nb = {
+	.notifier_call = hisp804_clockevent_cpu_notify,
+};
+
+static void __init clockevent_init(struct hisp804_clockevent_device *hiclkevt,
+				   void __iomem *base, int irq, int cpu,
+				   unsigned long rate, unsigned long reload)
+{
+	struct irqaction *action = NULL;
+	struct clock_event_device *clkevt = NULL;
+
+	hiclkevt->base = base;
+	hiclkevt->rate = rate;
+	hiclkevt->reload = reload;
+	snprintf(hiclkevt->name, sizeof(hiclkevt->name), "clockevent %d", cpu);
+
+	clkevt = &hiclkevt->clkevt;
+
+	clkevt->name = hiclkevt->name;
+	clkevt->cpumask = cpumask_of(cpu);
+	clkevt->irq = irq;
+	clkevt->set_next_event = hisp804_clockevent_set_next_event;
+	clkevt->set_state_shutdown = hisp804_clockevent_shutdown;
+	clkevt->set_state_periodic = sp804_clockevent_set_periodic;
+	clkevt->features = CLOCK_EVT_FEAT_PERIODIC |
+			   CLOCK_EVT_FEAT_ONESHOT |
+			   CLOCK_EVT_FEAT_DYNIRQ;
+	clkevt->rating = 400;
+
+	action = &hiclkevt->action;
+
+	action->name = hiclkevt->name;
+	action->dev_id = hiclkevt;
+	action->irq = irq;
+	action->flags = IRQF_TIMER | IRQF_NOBALANCING;
+	action->handler = hisp804_clockevent_timer_interrupt;
+}
+
+static int __init hisp804_timer_init(struct device_node *node)
+{
+	int ret, irq, ix, nr_cpus;
+	struct clk *clk1 = NULL, *clk2 = NULL;
+	void __iomem *base = NULL;
+	unsigned long rate1, rate2, reload1, reload2;
+
+	hisp804_clkevt = alloc_percpu(struct hisp804_clockevent_device);
+	if (!hisp804_clkevt) {
+		pr_err("can't alloc memory.\n");
+		goto out;
+	}
+
+	clk1 = of_clk_get(node, 0);
+	if (IS_ERR(clk1))
+		goto out_free;
+
+	clk_prepare_enable(clk1);
+
+	rate1 = clk_get_rate(clk1);
+	reload1 = DIV_ROUND_CLOSEST(rate1, HZ);
+
+	/* Get the 2nd clock if the timer has 3 timer clocks */
+	if (of_count_phandle_with_args(node, "clocks", "#clock-cells") == 3) {
+		clk2 = of_clk_get(node, 1);
+		if (IS_ERR(clk2)) {
+			pr_err("hisp804: %s clock not found: %d\n", node->name,
+			       (int)PTR_ERR(clk2));
+			goto out_free;
+		}
+		clk_prepare_enable(clk2);
+		rate2 = clk_get_rate(clk2);
+		reload2 = DIV_ROUND_CLOSEST(rate2, HZ);
+	} else {
+		rate2 = rate1;
+		reload2 = rate2;
+	}
+
+	nr_cpus = of_irq_count(node);
+	if (nr_cpus > num_possible_cpus())
+		nr_cpus = num_possible_cpus();
+
+	/* local timer for each CPU */
+	for (ix = 0; ix < nr_cpus; ix++) {
+		irq = irq_of_parse_and_map(node, ix);
+		base = of_iomap(node, ix + 1);
+		if (!base) {
+			pr_err("can't iomap timer %d\n", ix);
+			while (--ix >= 0)
+				iounmap(per_cpu_ptr(hisp804_clkevt, ix)->base);
+			goto out_free;
+		}
+
+		clockevent_init(per_cpu_ptr(hisp804_clkevt, ix), base, irq,
+				ix, rate2, reload2);
+	}
+
+	base = of_iomap(node, 0);
+	if (!base) {
+		pr_err("can't iomap timer %d\n", 0);
+		goto out_unmap;
+	}
+
+	hisp804_clocksource_init(base, rate1);
+
+	ret = hi_register_cpu_notifier(&hisp804_clockevent_cpu_nb);
+	if (ret)
+		goto out_notifier;
+
+	hisp804_clockevent_setup(this_cpu_ptr(hisp804_clkevt));
+
+	return 0;
+
+out_notifier:
+	iounmap(base);
+out_unmap:
+	for (ix = 0; ix < nr_irqs; ix++)
+		iounmap(per_cpu_ptr(hisp804_clkevt, ix)->base);
+out_free:
+	free_percpu(hisp804_clkevt);
+out:
+	return -ENODEV;
+}
+CLOCKSOURCE_OF_DECLARE(hisp804, "hisilicon,hisp804", hisp804_timer_init);
\ No newline at end of file
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 08013345d..96107fbef 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -328,6 +328,20 @@ config K3_DMA
 	  Support the DMA engine for Hisilicon K3 platform
 	  devices.
 
+config HIEDMACV310
+	tristate "Hisilicon EDMAC Controller support"
+	depends on ARCH_HISI_BVT
+	select DMA_ENGINE
+	select DMA_VIRTUAL_CHANNELS
+	help
+		The Direction Memory Access(EDMA) is a high-speed data transfer
+		operation. It supports data read/write between peripherals and
+		memories without using the CPU.
+		Hisilicon EDMA Controller(EDMAC) directly transfers data between
+		a memory and a peripheral, between peripherals, or between memories.
+		This avoids the CPU intervention and reduces the interrupt handling
+		overhead of the CPU.
+
 config LPC18XX_DMAMUX
 	bool "NXP LPC18xx/43xx DMA MUX for PL080"
 	depends on ARCH_LPC18XX || COMPILE_TEST
@@ -710,7 +724,6 @@ config ZX_DMA
 	help
 	  Support the DMA engine for ZTE ZX family platform devices.
 
-
 # driver files
 source "drivers/dma/bestcomm/Kconfig"
 
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 948a8da05..c5f89432d 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -82,7 +82,7 @@ obj-$(CONFIG_XGENE_DMA) += xgene-dma.o
 obj-$(CONFIG_ZX_DMA) += zx_dma.o
 obj-$(CONFIG_ST_FDMA) += st_fdma.o
 obj-$(CONFIG_FSL_DPAA2_QDMA) += fsl-dpaa2-qdma/
-
+obj-$(CONFIG_HIEDMACV310) += hiedmacv310.o
 obj-y += mediatek/
 obj-y += qcom/
 obj-y += ti/
diff --git a/drivers/dma/hiedmacv310.c b/drivers/dma/hiedmacv310.c
new file mode 100644
index 000000000..a198c9224
--- /dev/null
+++ b/drivers/dma/hiedmacv310.c
@@ -0,0 +1,1443 @@
+/*
+ * driver/dma/hiedmacv310.c
+ *
+ * The Hiedma Controller v310 Device Driver for HiSilicon
+ *
+ * Copyright (c) 2020 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/dmaengine.h>
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_dma.h>
+#include <linux/pm_runtime.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+
+#include "hiedmacv310.h"
+#include "dmaengine.h"
+#include "virt-dma.h"
+
+#define DRIVER_NAME "hiedmacv310"
+
+#define MAX_TSFR_LLIS           512
+#define EDMACV300_LLI_WORDS     64
+#define EDMACV300_POOL_ALIGN    64
+#define BITS_PER_HALF_WORD 32
+#define ERR_STATUS_REG_NUM 3
+
+typedef struct hiedmac_lli {
+	u64 next_lli;
+	u32 reserved[5];
+	u32 count;
+	u64 src_addr;
+	u64 dest_addr;
+	u32 config;
+	u32 pad[3];
+} hiedmac_lli;
+
+struct hiedmac_sg {
+	dma_addr_t src_addr;
+	dma_addr_t dst_addr;
+	size_t len;
+	struct list_head node;
+};
+
+struct transfer_desc {
+	struct virt_dma_desc virt_desc;
+	dma_addr_t llis_busaddr;
+	u64 *llis_vaddr;
+	u32 ccfg;
+	size_t size;
+	bool done;
+	bool cyclic;
+};
+
+enum edmac_dma_chan_state {
+	HIEDMAC_CHAN_IDLE,
+	HIEDMAC_CHAN_RUNNING,
+	HIEDMAC_CHAN_PAUSED,
+	HIEDMAC_CHAN_WAITING,
+};
+
+struct hiedmacv310_dma_chan {
+	bool slave;
+	int signal;
+	int id;
+	struct virt_dma_chan virt_chan;
+	struct hiedmacv310_phy_chan *phychan;
+	struct dma_slave_config cfg;
+	struct transfer_desc *at;
+	struct hiedmacv310_driver_data *host;
+	enum edmac_dma_chan_state state;
+};
+
+struct hiedmacv310_phy_chan {
+	unsigned int id;
+	void __iomem *base;
+	spinlock_t lock;
+	struct hiedmacv310_dma_chan *serving;
+};
+
+struct hiedmacv310_driver_data {
+	struct platform_device *dev;
+	struct dma_device slave;
+	struct dma_device memcpy;
+	void __iomem *base;
+	struct regmap *misc_regmap;
+	void __iomem *crg_ctrl;
+	struct hiedmacv310_phy_chan *phy_chans;
+	struct dma_pool *pool;
+	unsigned int misc_ctrl_base;
+	int irq;
+	unsigned int id;
+	struct clk *clk;
+	struct clk *axi_clk;
+	struct reset_control *rstc;
+	unsigned int channels;
+	unsigned int slave_requests;
+	unsigned int max_transfer_size;
+};
+
+#ifdef DEBUG_HIEDMAC
+void dump_lli(const u64 *llis_vaddr, unsigned int num)
+{
+	hiedmac_lli *plli = (hiedmac_lli *)llis_vaddr;
+	unsigned int i;
+
+	hiedmacv310_trace(HIEDMACV310_CONFIG_TRACE_LEVEL, "lli num = 0%d\n", num);
+	for (i = 0; i < num; i++) {
+		printk("lli%d:lli_L:      0x%llx\n", i, plli[i].next_lli & 0xffffffff);
+		printk("lli%d:lli_H:      0x%llx\n", i, (plli[i].next_lli >> BITS_PER_HALF_WORD) & 0xffffffff);
+		printk("lli%d:count:      0x%x\n", i, plli[i].count);
+		printk("lli%d:src_addr_L: 0x%llx\n", i, plli[i].src_addr & 0xffffffff);
+		printk("lli%d:src_addr_H: 0x%llx\n", i, (plli[i].src_addr >> BITS_PER_HALF_WORD) & 0xffffffff);
+		printk("lli%d:dst_addr_L: 0x%llx\n", i, plli[i].dest_addr & 0xffffffff);
+		printk("lli%d:dst_addr_H: 0x%llx\n", i, (plli[i].dest_addr >> BITS_PER_HALF_WORD) & 0xffffffff);
+		printk("lli%d:CONFIG:	  0x%x\n", i, plli[i].config);
+	}
+}
+
+#else
+void dump_lli(u64 *llis_vaddr, unsigned int num)
+{
+}
+#endif
+
+static inline struct hiedmacv310_dma_chan *to_edamc_chan(const struct dma_chan *chan)
+{
+	return container_of(chan, struct hiedmacv310_dma_chan, virt_chan.chan);
+}
+
+static inline struct transfer_desc *to_edmac_transfer_desc(
+	const struct dma_async_tx_descriptor *tx)
+{
+	return container_of(tx, struct transfer_desc, virt_desc.tx);
+}
+
+static struct dma_chan *hiedmac_find_chan_id(
+	const struct hiedmacv310_driver_data *hiedmac,
+	int request_num)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = NULL;
+
+	list_for_each_entry(edmac_dma_chan, &hiedmac->slave.channels,
+			    virt_chan.chan.device_node) {
+		if (edmac_dma_chan->id == request_num)
+			return &edmac_dma_chan->virt_chan.chan;
+	}
+	return NULL;
+}
+
+static struct dma_chan *hiedma_of_xlate(struct of_phandle_args *dma_spec,
+					struct of_dma *ofdma)
+{
+	struct hiedmacv310_driver_data *hiedmac = ofdma->of_dma_data;
+	struct hiedmacv310_dma_chan *edmac_dma_chan = NULL;
+	struct dma_chan *dma_chan = NULL;
+	struct regmap *misc = NULL;
+	unsigned int signal, request_num;
+	unsigned int reg = 0;
+	unsigned int offset = 0;
+
+	if (!hiedmac)
+		return NULL;
+
+	misc = hiedmac->misc_regmap;
+
+	if (dma_spec->args_count != 2) { /* check num of dts node args */
+		hiedmacv310_error("args count not true!\n");
+		return NULL;
+	}
+
+	request_num = dma_spec->args[0];
+	signal = dma_spec->args[1];
+
+	hiedmacv310_trace(HIEDMACV310_CONFIG_TRACE_LEVEL, "host->id = %d,signal = %d, request_num = %d\n",
+			  hiedmac->id, signal, request_num);
+
+	if (misc != NULL) {
+#ifdef CONFIG_ACCESS_M7_DEV
+		offset = hiedmac->misc_ctrl_base;
+		reg = 0xc0;
+		regmap_write(misc, offset, reg);
+#else
+		offset = hiedmac->misc_ctrl_base + (request_num & (~0x3));
+		regmap_read(misc, offset, &reg);
+		/* set misc for signal line */
+		reg &= ~(0x3f << ((request_num & 0x3) << 3));
+		reg |= signal << ((request_num & 0x3) << 3);
+		regmap_write(misc, offset, reg);
+#endif
+	}
+
+	hiedmacv310_trace(HIEDMACV310_CONFIG_TRACE_LEVEL, "offset = 0x%x, reg = 0x%x\n", offset, reg);
+
+	dma_chan = hiedmac_find_chan_id(hiedmac, request_num);
+	if (!dma_chan) {
+		hiedmacv310_error("DMA slave channel is not found!\n");
+		return NULL;
+	}
+
+	edmac_dma_chan = to_edamc_chan(dma_chan);
+	edmac_dma_chan->signal = request_num;
+	return dma_get_slave_channel(dma_chan);
+}
+
+static int hiedmacv310_devm_get(struct hiedmacv310_driver_data *hiedmac)
+{
+	struct platform_device *platdev = hiedmac->dev;
+	struct resource *res = NULL;
+
+	hiedmac->clk = devm_clk_get(&(platdev->dev), "apb_pclk");
+	if (IS_ERR(hiedmac->clk)) {
+		return PTR_ERR(hiedmac->clk);
+	}
+
+	hiedmac->axi_clk = devm_clk_get(&(platdev->dev), "axi_aclk");
+	if (IS_ERR(hiedmac->axi_clk)) {
+		return PTR_ERR(hiedmac->axi_clk);
+	}
+
+	hiedmac->irq = platform_get_irq(platdev, 0);
+	if (unlikely(hiedmac->irq < 0))
+		return -ENODEV;
+
+	hiedmac->rstc = devm_reset_control_get(&(platdev->dev), "dma-reset");
+	if (IS_ERR(hiedmac->rstc))
+		return PTR_ERR(hiedmac->rstc);
+
+	res = platform_get_resource(platdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		hiedmacv310_error("no reg resource\n");
+		return -ENODEV;
+	}
+
+	hiedmac->base = devm_ioremap_resource(&(platdev->dev), res);
+	if (IS_ERR(hiedmac->base))
+		return PTR_ERR(hiedmac->base);
+	return 0;
+}
+
+static int hiedmacv310_of_property_read(struct hiedmacv310_driver_data *hiedmac)
+{
+	struct platform_device *platdev = hiedmac->dev;
+	struct device_node *np = platdev->dev.of_node;
+	int ret;
+
+	if (!of_find_property(np, "misc_regmap", NULL) ||
+		!of_find_property(np, "misc_ctrl_base", NULL))
+		hiedmac->misc_regmap = 0;
+	else {
+		hiedmac->misc_regmap = syscon_regmap_lookup_by_phandle(np, "misc_regmap");
+		if (IS_ERR(hiedmac->misc_regmap))
+			return PTR_ERR(hiedmac->misc_regmap);
+
+		ret = of_property_read_u32(np, "misc_ctrl_base", &(hiedmac->misc_ctrl_base));
+		if (ret) {
+			hiedmacv310_error("get dma-misc_ctrl_base fail\n");
+			return -ENODEV;
+		}
+	}
+	ret = of_property_read_u32(np, "devid", &(hiedmac->id));
+	if (ret) {
+		hiedmacv310_error("get hiedmac id fail\n");
+		return -ENODEV;
+	}
+	ret = of_property_read_u32(np, "dma-channels", &(hiedmac->channels));
+	if (ret) {
+		hiedmacv310_error("get dma-channels fail\n");
+		return -ENODEV;
+	}
+	ret = of_property_read_u32(np, "dma-requests", &(hiedmac->slave_requests));
+	if (ret) {
+		hiedmacv310_error("get dma-requests fail\n");
+		return -ENODEV;
+	}
+	hiedmacv310_trace(HIEDMACV310_REG_TRACE_LEVEL, "dma-channels = %d, dma-requests = %d\n",
+			  hiedmac->channels, hiedmac->slave_requests);
+	return 0;
+}
+
+static int get_of_probe(struct hiedmacv310_driver_data *hiedmac)
+{
+	struct platform_device *platdev = hiedmac->dev;
+	int ret;
+
+	ret = hiedmacv310_devm_get(hiedmac);
+	if (ret) {
+		return ret;
+	}
+
+	ret = hiedmacv310_of_property_read(hiedmac);
+	if (ret) {
+		return ret;
+	}
+
+	return of_dma_controller_register(platdev->dev.of_node,
+					  hiedma_of_xlate, hiedmac);
+}
+
+static void hiedmac_free_chan_resources(struct dma_chan *chan)
+{
+	vchan_free_chan_resources(to_virt_chan(chan));
+}
+
+static size_t read_residue_from_phychan(
+	struct hiedmacv310_dma_chan *edmac_dma_chan,
+	struct transfer_desc *tsf_desc)
+{
+	size_t bytes;
+	u64 next_lli;
+	struct hiedmacv310_phy_chan *phychan = edmac_dma_chan->phychan;
+	unsigned int i, index;
+	struct hiedmacv310_driver_data *hiedmac = edmac_dma_chan->host;
+	hiedmac_lli *plli = NULL;
+
+	next_lli = (hiedmacv310_readl(hiedmac->base + hiedmac_cx_lli_l(phychan->id)) &
+			(~(HIEDMAC_LLI_ALIGN - 1)));
+	next_lli |= ((u64)(hiedmacv310_readl(hiedmac->base + hiedmac_cx_lli_h(
+			phychan->id)) & 0xffffffff) << BITS_PER_HALF_WORD);
+	bytes = hiedmacv310_readl(hiedmac->base + hiedmac_cx_curr_cnt0(
+			phychan->id));
+	if (next_lli != 0) {
+		/* It means lli mode */
+		bytes += tsf_desc->size;
+		index = (next_lli - tsf_desc->llis_busaddr) / sizeof(*plli);
+		plli = (hiedmac_lli *)(tsf_desc->llis_vaddr);
+		for (i = 0; i < index; i++)
+			bytes -= plli[i].count;
+	}
+	return bytes;
+}
+
+static enum dma_status hiedmac_tx_status(struct dma_chan *chan,
+					 dma_cookie_t cookie,
+					 struct dma_tx_state *txstate)
+{
+	enum dma_status ret;
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	struct virt_dma_desc *vd = NULL;
+	struct transfer_desc *tsf_desc = NULL;
+	unsigned long flags;
+	size_t bytes;
+
+	ret = dma_cookie_status(chan, cookie, txstate);
+	if (ret == DMA_COMPLETE) {
+		return ret;
+	}
+
+	if (edmac_dma_chan->state == HIEDMAC_CHAN_PAUSED && ret == DMA_IN_PROGRESS) {
+		ret = DMA_PAUSED;
+		return ret;
+	}
+
+	spin_lock_irqsave(&edmac_dma_chan->virt_chan.lock, flags);
+	vd = vchan_find_desc(&edmac_dma_chan->virt_chan, cookie);
+	if (vd) {
+		/* no been trasfer */
+		tsf_desc = to_edmac_transfer_desc(&vd->tx);
+		bytes = tsf_desc->size;
+	} else {
+		/* trasfering */
+		tsf_desc = edmac_dma_chan->at;
+
+		if (!(edmac_dma_chan->phychan) || !tsf_desc) {
+			spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+			return ret;
+		}
+		bytes = read_residue_from_phychan(edmac_dma_chan, tsf_desc);
+	}
+	spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+	dma_set_residue(txstate, bytes);
+	return ret;
+}
+
+static struct hiedmacv310_phy_chan *hiedmac_get_phy_channel(
+	const struct hiedmacv310_driver_data *hiedmac,
+	struct hiedmacv310_dma_chan *edmac_dma_chan)
+{
+	struct hiedmacv310_phy_chan *ch = NULL;
+	unsigned long flags;
+	int i;
+
+	for (i = 0; i < hiedmac->channels; i++) {
+		ch = &hiedmac->phy_chans[i];
+
+		spin_lock_irqsave(&ch->lock, flags);
+
+		if (!ch->serving) {
+			ch->serving = edmac_dma_chan;
+			spin_unlock_irqrestore(&ch->lock, flags);
+			break;
+		}
+		spin_unlock_irqrestore(&ch->lock, flags);
+	}
+
+	if (i == hiedmac->channels) {
+		return NULL;
+	}
+
+	return ch;
+}
+
+static void hiedmac_write_lli(const struct hiedmacv310_driver_data *hiedmac,
+			      const struct hiedmacv310_phy_chan *phychan,
+			      const struct transfer_desc *tsf_desc)
+{
+	hiedmac_lli *plli = (hiedmac_lli *)tsf_desc->llis_vaddr;
+
+	if (plli->next_lli != 0x0)
+		hiedmacv310_writel((plli->next_lli & 0xffffffff) | HIEDMAC_LLI_ENABLE,
+				   hiedmac->base + hiedmac_cx_lli_l(phychan->id));
+	else
+		hiedmacv310_writel((plli->next_lli & 0xffffffff),
+				   hiedmac->base + hiedmac_cx_lli_l(phychan->id));
+
+	hiedmacv310_writel(((plli->next_lli >> 32) & 0xffffffff),
+			   hiedmac->base + hiedmac_cx_lli_h(phychan->id));
+	hiedmacv310_writel(plli->count, hiedmac->base + hiedmac_cx_cnt0(phychan->id));
+	hiedmacv310_writel(plli->src_addr & 0xffffffff,
+			   hiedmac->base + hiedmac_cx_src_addr_l(phychan->id));
+	hiedmacv310_writel((plli->src_addr >> 32) & 0xffffffff,
+			   hiedmac->base + hiedmac_cx_src_addr_h(phychan->id));
+	hiedmacv310_writel(plli->dest_addr & 0xffffffff,
+			   hiedmac->base + hiedmac_cx_dest_addr_l(phychan->id));
+	hiedmacv310_writel((plli->dest_addr >> 32) & 0xffffffff,
+			   hiedmac->base + hiedmac_cx_dest_addr_h(phychan->id));
+	hiedmacv310_writel(plli->config,
+			   hiedmac->base + hiedmac_cx_config(phychan->id));
+}
+
+static void hiedmac_start_next_txd(struct hiedmacv310_dma_chan *edmac_dma_chan)
+{
+	struct hiedmacv310_driver_data *hiedmac = edmac_dma_chan->host;
+	struct hiedmacv310_phy_chan *phychan = edmac_dma_chan->phychan;
+	struct virt_dma_desc *vd = vchan_next_desc(&edmac_dma_chan->virt_chan);
+	struct transfer_desc *tsf_desc = to_edmac_transfer_desc(&vd->tx);
+	unsigned int val;
+	list_del(&tsf_desc->virt_desc.node);
+	edmac_dma_chan->at = tsf_desc;
+	hiedmac_write_lli(hiedmac, phychan, tsf_desc);
+	val = hiedmacv310_readl(hiedmac->base + hiedmac_cx_config(phychan->id));
+	hiedmacv310_trace(HIEDMACV310_REG_TRACE_LEVEL, " HIEDMAC_Cx_CONFIG  = 0x%x\n", val);
+	hiedmacv310_writel(val | HIEDMAC_CXCONFIG_LLI_START,
+			   hiedmac->base + hiedmac_cx_config(phychan->id));
+}
+
+static void hiedmac_start(struct hiedmacv310_dma_chan *edmac_dma_chan)
+{
+	struct hiedmacv310_driver_data *hiedmac = edmac_dma_chan->host;
+	struct hiedmacv310_phy_chan *ch;
+	ch = hiedmac_get_phy_channel(hiedmac, edmac_dma_chan);
+	if (!ch) {
+		hiedmacv310_error("no phy channel available !\n");
+		edmac_dma_chan->state = HIEDMAC_CHAN_WAITING;
+		return;
+	}
+	edmac_dma_chan->phychan = ch;
+	edmac_dma_chan->state = HIEDMAC_CHAN_RUNNING;
+	hiedmac_start_next_txd(edmac_dma_chan);
+}
+
+static void hiedmac_issue_pending(struct dma_chan *chan)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	unsigned long flags;
+	spin_lock_irqsave(&edmac_dma_chan->virt_chan.lock, flags);
+	if (vchan_issue_pending(&edmac_dma_chan->virt_chan)) {
+		if (!edmac_dma_chan->phychan && edmac_dma_chan->state != HIEDMAC_CHAN_WAITING)
+			hiedmac_start(edmac_dma_chan);
+	}
+	spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+}
+
+static void hiedmac_free_txd_list(struct hiedmacv310_dma_chan *edmac_dma_chan)
+{
+	LIST_HEAD(head);
+	vchan_get_all_descriptors(&edmac_dma_chan->virt_chan, &head);
+	vchan_dma_desc_free_list(&edmac_dma_chan->virt_chan, &head);
+}
+
+static int hiedmac_config(struct dma_chan *chan,
+			  struct dma_slave_config *config)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	if (!edmac_dma_chan->slave) {
+		hiedmacv310_error("slave is null!");
+		return -EINVAL;
+	}
+	edmac_dma_chan->cfg = *config;
+	return 0;
+}
+
+static void hiedmac_pause_phy_chan(const struct hiedmacv310_dma_chan *edmac_dma_chan)
+{
+	struct hiedmacv310_driver_data *hiedmac = edmac_dma_chan->host;
+	struct hiedmacv310_phy_chan *phychan = edmac_dma_chan->phychan;
+	unsigned int val;
+	int timeout;
+
+	val = hiedmacv310_readl(hiedmac->base + hiedmac_cx_config(phychan->id));
+	val &= ~CCFG_EN;
+	hiedmacv310_writel(val, hiedmac->base + hiedmac_cx_config(phychan->id));
+	/* Wait for channel inactive */
+	for (timeout = 2000; timeout > 0; timeout--) {
+		if (!((0x1 << phychan->id) & hiedmacv310_readl(hiedmac->base + HIEDMAC_CH_STAT)))
+			break;
+		hiedmacv310_writel(val, hiedmac->base + hiedmac_cx_config(phychan->id));
+		udelay(1);
+	}
+	if (timeout == 0)
+		hiedmacv310_error(":channel%u timeout waiting for pause, timeout:%d\n",
+				  phychan->id, timeout);
+}
+
+static int hiedmac_pause(struct dma_chan *chan)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	unsigned long flags;
+
+	spin_lock_irqsave(&edmac_dma_chan->virt_chan.lock, flags);
+	if (!edmac_dma_chan->phychan) {
+		spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+		return 0;
+	}
+	hiedmac_pause_phy_chan(edmac_dma_chan);
+	edmac_dma_chan->state = HIEDMAC_CHAN_PAUSED;
+	spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+	return 0;
+}
+
+static void hiedmac_resume_phy_chan(const struct hiedmacv310_dma_chan *edmac_dma_chan)
+{
+	struct hiedmacv310_driver_data *hiedmac = edmac_dma_chan->host;
+	struct hiedmacv310_phy_chan *phychan = edmac_dma_chan->phychan;
+	unsigned int val;
+	val = hiedmacv310_readl(hiedmac->base + hiedmac_cx_config(phychan->id));
+	val |= CCFG_EN;
+	hiedmacv310_writel(val, hiedmac->base + hiedmac_cx_config(phychan->id));
+}
+
+static int hiedmac_resume(struct dma_chan *chan)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	unsigned long flags;
+
+	spin_lock_irqsave(&edmac_dma_chan->virt_chan.lock, flags);
+
+	if (!edmac_dma_chan->phychan) {
+		spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+		return 0;
+	}
+
+	hiedmac_resume_phy_chan(edmac_dma_chan);
+	edmac_dma_chan->state = HIEDMAC_CHAN_RUNNING;
+	spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+
+	return 0;
+}
+
+void hiedmac_phy_free(struct hiedmacv310_dma_chan *chan);
+static void hiedmac_desc_free(struct virt_dma_desc *vd);
+static int hiedmac_terminate_all(struct dma_chan *chan)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	unsigned long flags;
+
+	spin_lock_irqsave(&edmac_dma_chan->virt_chan.lock, flags);
+	if (!edmac_dma_chan->phychan && !edmac_dma_chan->at) {
+		spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+		return 0;
+	}
+
+	edmac_dma_chan->state = HIEDMAC_CHAN_IDLE;
+
+	if (edmac_dma_chan->phychan)
+		hiedmac_phy_free(edmac_dma_chan);
+	if (edmac_dma_chan->at) {
+		hiedmac_desc_free(&edmac_dma_chan->at->virt_desc);
+		edmac_dma_chan->at = NULL;
+	}
+	hiedmac_free_txd_list(edmac_dma_chan);
+	spin_unlock_irqrestore(&edmac_dma_chan->virt_chan.lock, flags);
+
+	return 0;
+}
+
+static u32 get_width(enum dma_slave_buswidth width)
+{
+	switch (width) {
+	case DMA_SLAVE_BUSWIDTH_1_BYTE:
+		return HIEDMAC_WIDTH_8BIT;
+	case DMA_SLAVE_BUSWIDTH_2_BYTES:
+		return HIEDMAC_WIDTH_16BIT;
+	case DMA_SLAVE_BUSWIDTH_4_BYTES:
+		return HIEDMAC_WIDTH_32BIT;
+	case DMA_SLAVE_BUSWIDTH_8_BYTES:
+		return HIEDMAC_WIDTH_64BIT;
+	default:
+		hiedmacv310_error("check here, width warning!\n");
+		return ~0;
+	}
+}
+
+static unsigned int hiedmac_set_config_value(enum dma_transfer_direction direction,
+					     unsigned int addr_width,
+					     unsigned int burst,
+					     unsigned int signal)
+{
+	unsigned int config, width;
+
+	if (direction == DMA_MEM_TO_DEV) {
+		config = HIEDMAC_CONFIG_SRC_INC;
+	} else {
+		config = HIEDMAC_CONFIG_DST_INC;
+	}
+	hiedmacv310_trace(HIEDMACV310_CONFIG_TRACE_LEVEL, "addr_width = 0x%x\n", addr_width);
+	width = get_width(addr_width);
+	hiedmacv310_trace(HIEDMACV310_CONFIG_TRACE_LEVEL, "width = 0x%x\n", width);
+	config |= width << HIEDMAC_CONFIG_SRC_WIDTH_SHIFT;
+	config |= width << HIEDMAC_CONFIG_DST_WIDTH_SHIFT;
+	hiedmacv310_trace(HIEDMACV310_REG_TRACE_LEVEL, "tsf_desc->ccfg = 0x%x\n", config);
+	hiedmacv310_trace(HIEDMACV310_CONFIG_TRACE_LEVEL, "burst = 0x%x\n", burst);
+	config |= burst << HIEDMAC_CONFIG_SRC_BURST_SHIFT;
+	config |= burst << HIEDMAC_CONFIG_DST_BURST_SHIFT;
+	if (signal >= 0) {
+		hiedmacv310_trace(HIEDMACV310_REG_TRACE_LEVEL, "edmac_dma_chan->signal = %d\n", signal);
+		config |= (unsigned int)signal << HIEDMAC_CXCONFIG_SIGNAL_SHIFT;
+	}
+	config |= HIEDMAC_CXCONFIG_DEV_MEM_TYPE << HIEDMAC_CXCONFIG_TSF_TYPE_SHIFT;
+	return config;
+}
+
+struct transfer_desc *hiedmac_init_tsf_desc(struct dma_chan *chan,
+	enum dma_transfer_direction direction,
+	dma_addr_t *slave_addr)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	struct transfer_desc *tsf_desc;
+	unsigned int burst = 0;
+	unsigned int addr_width = 0;
+	unsigned int maxburst = 0;
+	tsf_desc = kzalloc(sizeof(*tsf_desc), GFP_NOWAIT);
+	if (!tsf_desc)
+		return NULL;
+	if (direction == DMA_MEM_TO_DEV) {
+		*slave_addr = edmac_dma_chan->cfg.dst_addr;
+		addr_width = edmac_dma_chan->cfg.dst_addr_width;
+		maxburst = edmac_dma_chan->cfg.dst_maxburst;
+	} else if (direction == DMA_DEV_TO_MEM) {
+		*slave_addr = edmac_dma_chan->cfg.src_addr;
+		addr_width = edmac_dma_chan->cfg.src_addr_width;
+		maxburst = edmac_dma_chan->cfg.src_maxburst;
+	} else {
+		kfree(tsf_desc);
+		hiedmacv310_error("direction unsupported!\n");
+		return NULL;
+	}
+
+	if (maxburst > (HIEDMAC_MAX_BURST_WIDTH))
+		burst |= (HIEDMAC_MAX_BURST_WIDTH - 1);
+	else if (maxburst == 0)
+		burst |= HIEDMAC_MIN_BURST_WIDTH;
+	else
+		burst |= (maxburst - 1);
+
+	tsf_desc->ccfg = hiedmac_set_config_value(direction, addr_width,
+				 burst, edmac_dma_chan->signal);
+	hiedmacv310_trace(HIEDMACV310_REG_TRACE_LEVEL, "tsf_desc->ccfg = 0x%x\n", tsf_desc->ccfg);
+	return tsf_desc;
+}
+
+static int hiedmac_fill_desc(const struct hiedmac_sg *dsg,
+			     struct transfer_desc *tsf_desc,
+			     unsigned int length, unsigned int num)
+{
+	hiedmac_lli *plli = NULL;
+
+	if (num >= MAX_TSFR_LLIS) {
+		hiedmacv310_error("lli out of range. \n");
+		return -ENOMEM;
+	}
+
+	plli = (hiedmac_lli*)(tsf_desc->llis_vaddr);
+	memset(&plli[num], 0x0, sizeof(*plli));
+
+	plli[num].src_addr = dsg->src_addr;
+	plli[num].dest_addr = dsg->dst_addr;
+	plli[num].config = tsf_desc->ccfg;
+	plli[num].count = length;
+	tsf_desc->size += length;
+
+	if (num > 0) {
+		plli[num - 1].next_lli = (tsf_desc->llis_busaddr + (num) * sizeof(
+					  *plli)) & (~(HIEDMAC_LLI_ALIGN - 1));
+		plli[num - 1].next_lli |= HIEDMAC_LLI_ENABLE;
+	}
+	return 0;
+}
+
+static void free_dsg(struct list_head *dsg_head)
+{
+	struct hiedmac_sg *dsg = NULL;
+	struct hiedmac_sg *_dsg = NULL;
+
+	list_for_each_entry_safe(dsg, _dsg, dsg_head, node) {
+		list_del(&dsg->node);
+		kfree(dsg);
+	}
+}
+
+static int hiedmac_add_sg(struct list_head *sg_head,
+			  dma_addr_t dst, dma_addr_t src,
+			  size_t len)
+{
+	struct hiedmac_sg *dsg = NULL;
+
+	if (len == 0) {
+		hiedmacv310_error("Transfer length is 0. \n");
+		return -ENOMEM;
+	}
+
+	dsg = (struct hiedmac_sg *)kzalloc(sizeof(*dsg), GFP_NOWAIT);
+	if (!dsg) {
+		free_dsg(sg_head);
+		hiedmacv310_error("alloc memory for dsg fail.\n");
+		return -ENOMEM;
+	}
+
+	list_add_tail(&dsg->node, sg_head);
+	dsg->src_addr = src;
+	dsg->dst_addr = dst;
+	dsg->len = len;
+	return 0;
+}
+
+static int hiedmac_add_sg_slave(struct list_head *sg_head,
+			        dma_addr_t slave_addr, dma_addr_t addr,
+			        size_t length,
+				enum dma_transfer_direction direction)
+{
+	dma_addr_t src = 0;
+	dma_addr_t dst = 0;
+	if (direction == DMA_MEM_TO_DEV) {
+		src = addr;
+		dst = slave_addr;
+	} else if (direction == DMA_DEV_TO_MEM) {
+		src = slave_addr;
+		dst = addr;
+	} else {
+		hiedmacv310_error("invali dma_transfer_direction.\n");
+		return -ENOMEM;
+	}
+	return hiedmac_add_sg(sg_head, dst, src, length);
+}
+
+static int hiedmac_fill_sg_for_slave(struct list_head *sg_head,
+				     dma_addr_t slave_addr,
+				     struct scatterlist *sgl,
+				     unsigned int sg_len,
+				     enum dma_transfer_direction direction)
+{
+	struct scatterlist *sg = NULL;
+	int tmp, ret;
+	size_t length;
+	dma_addr_t addr;
+	if (sgl == NULL) {
+		hiedmacv310_error("sgl is null!\n");
+		return -ENOMEM;
+	}
+
+	for_each_sg(sgl, sg, sg_len, tmp) {
+		addr = sg_dma_address(sg);
+		length = sg_dma_len(sg);
+		ret = hiedmac_add_sg_slave(sg_head, slave_addr, addr, length, direction);
+		if (ret)
+			break;
+	}
+	return ret;
+}
+
+static inline int hiedmac_fill_sg_for_m2m_copy(struct list_head *sg_head,
+					     dma_addr_t dst, dma_addr_t src,
+					     size_t len)
+{
+	return hiedmac_add_sg(sg_head, dst, src, len);
+}
+
+static int hiedmac_fill_sg_for_cyclic(struct list_head *sg_head,
+				      dma_addr_t slave_addr,
+				      dma_addr_t buf_addr, size_t buf_len,
+				      size_t period_len,
+				      enum dma_transfer_direction direction)
+{
+	size_t count_in_sg = 0;
+	size_t trans_bytes;
+	int ret;
+	while (count_in_sg < buf_len) {
+		trans_bytes = min(period_len, buf_len - count_in_sg);
+		count_in_sg += trans_bytes;
+		ret = hiedmac_add_sg_slave(sg_head, slave_addr, buf_addr + count_in_sg, count_in_sg, direction);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static inline unsigned short get_max_width(dma_addr_t ccfg)
+{
+	unsigned short src_width = (ccfg & HIEDMAC_CONTROL_SRC_WIDTH_MASK) >> HIEDMAC_CONFIG_SRC_WIDTH_SHIFT;
+	unsigned short dst_width = (ccfg & HIEDMAC_CONTROL_DST_WIDTH_MASK) >> HIEDMAC_CONFIG_DST_WIDTH_SHIFT;
+	return 1 << max(src_width, dst_width); /* to byte */
+}
+
+static int hiedmac_fill_asg_lli_for_desc(struct hiedmac_sg *dsg,
+					 struct transfer_desc *tsf_desc,
+					 unsigned int *lli_count)
+{
+	int ret;
+	unsigned short width = get_max_width(tsf_desc->ccfg);
+
+	while (dsg->len != 0) {
+		size_t lli_len = MAX_TRANSFER_BYTES;
+		lli_len = (lli_len / width) * width; /* bus width align */
+		lli_len = min(lli_len, dsg->len);
+		ret = hiedmac_fill_desc(dsg, tsf_desc, lli_len, *lli_count);
+		if (ret)
+			return ret;
+
+		if (tsf_desc->ccfg & HIEDMAC_CONFIG_SRC_INC)
+			dsg->src_addr += lli_len;
+		if (tsf_desc->ccfg & HIEDMAC_CONFIG_DST_INC)
+			dsg->dst_addr += lli_len;
+		dsg->len -= lli_len;
+		(*lli_count)++;
+	}
+	return 0;
+}
+
+static int hiedmac_fill_lli_for_desc(struct list_head *sg_head,
+				     struct transfer_desc *tsf_desc)
+{
+	struct hiedmac_sg *dsg = NULL;
+	struct hiedmac_lli *last_plli = NULL;
+	unsigned int lli_count = 0;
+	int ret;
+
+	list_for_each_entry(dsg, sg_head, node) {
+		ret = hiedmac_fill_asg_lli_for_desc(dsg, tsf_desc, &lli_count);
+		if (ret)
+			return ret;
+	}
+
+	if (tsf_desc->cyclic) {
+		last_plli = (hiedmac_lli *)((uintptr_t)tsf_desc->llis_vaddr +
+					    (lli_count - 1) * sizeof(*last_plli));
+		last_plli->next_lli = tsf_desc->llis_busaddr | HIEDMAC_LLI_ENABLE;
+	} else {
+		last_plli = (hiedmac_lli *)((uintptr_t)tsf_desc->llis_vaddr +
+					    (lli_count - 1) * sizeof(*last_plli));
+		last_plli->next_lli = 0;
+	}
+	dump_lli(tsf_desc->llis_vaddr, lli_count);
+	return 0;
+}
+
+static struct dma_async_tx_descriptor *hiedmac_prep_slave_sg(
+	struct dma_chan *chan, struct scatterlist *sgl,
+	unsigned int sg_len, enum dma_transfer_direction direction,
+	unsigned long flags, void *context)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	struct hiedmacv310_driver_data *hiedmac = edmac_dma_chan->host;
+	struct transfer_desc *tsf_desc = NULL;
+	dma_addr_t slave_addr = 0;
+	int ret;
+	LIST_HEAD(sg_head);
+	if (sgl == NULL) {
+		hiedmacv310_error("sgl is null!\n");
+		return NULL;
+	}
+
+	tsf_desc = hiedmac_init_tsf_desc(chan, direction, &slave_addr);
+	if (!tsf_desc)
+		return NULL;
+
+	tsf_desc->llis_vaddr = dma_pool_alloc(hiedmac->pool, GFP_NOWAIT,
+					      &tsf_desc->llis_busaddr);
+	if (!tsf_desc->llis_vaddr) {
+		hiedmacv310_error("malloc memory from pool fail !\n");
+		goto err_alloc_lli;
+	}
+
+	ret = hiedmac_fill_sg_for_slave(&sg_head, slave_addr, sgl, sg_len, direction);
+	if (ret)
+		goto err_fill_sg;
+	ret = hiedmac_fill_lli_for_desc(&sg_head, tsf_desc);
+	free_dsg(&sg_head);
+	if (ret)
+		goto err_fill_sg;
+	return vchan_tx_prep(&edmac_dma_chan->virt_chan, &tsf_desc->virt_desc, flags);
+
+err_fill_sg:
+	dma_pool_free(hiedmac->pool, tsf_desc->llis_vaddr, tsf_desc->llis_busaddr);
+err_alloc_lli:
+	kfree(tsf_desc);
+	return NULL;
+}
+
+static struct dma_async_tx_descriptor *hiedmac_prep_dma_m2m_copy(
+	struct dma_chan *chan, dma_addr_t dst, dma_addr_t src,
+	size_t len, unsigned long flags)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	struct hiedmacv310_driver_data *hiedmac = edmac_dma_chan->host;
+	struct transfer_desc *tsf_desc = NULL;
+	LIST_HEAD(sg_head);
+	u32 config = 0;
+	int ret;
+
+	if (!len)
+		return NULL;
+
+	tsf_desc = kzalloc(sizeof(*tsf_desc), GFP_NOWAIT);
+	if (tsf_desc == NULL) {
+		hiedmacv310_error("get tsf desc fail!\n");
+		return NULL;
+	}
+
+	tsf_desc->llis_vaddr = dma_pool_alloc(hiedmac->pool, GFP_NOWAIT,
+					      &tsf_desc->llis_busaddr);
+	if (!tsf_desc->llis_vaddr) {
+		hiedmacv310_error("malloc memory from pool fail !\n");
+		goto err_alloc_lli;
+	}
+
+	config |= HIEDMAC_CONFIG_SRC_INC | HIEDMAC_CONFIG_DST_INC;
+	config |= HIEDMAC_CXCONFIG_MEM_TYPE << HIEDMAC_CXCONFIG_TSF_TYPE_SHIFT;
+	/*  max burst width is 16 ,but reg value set 0xf */
+	config |= (HIEDMAC_MAX_BURST_WIDTH - 1) << HIEDMAC_CONFIG_SRC_BURST_SHIFT;
+	config |= (HIEDMAC_MAX_BURST_WIDTH - 1) << HIEDMAC_CONFIG_DST_BURST_SHIFT;
+	config |= HIEDMAC_MEM_BIT_WIDTH << HIEDMAC_CONFIG_SRC_WIDTH_SHIFT;
+	config |= HIEDMAC_MEM_BIT_WIDTH << HIEDMAC_CONFIG_DST_WIDTH_SHIFT;
+	tsf_desc->ccfg = config;
+	ret = hiedmac_fill_sg_for_m2m_copy(&sg_head, dst, src, len);
+	if (ret)
+		goto err_fill_sg;
+	ret = hiedmac_fill_lli_for_desc(&sg_head, tsf_desc);
+	free_dsg(&sg_head);
+	if (ret)
+		goto err_fill_sg;
+	return vchan_tx_prep(&edmac_dma_chan->virt_chan, &tsf_desc->virt_desc, flags);
+
+err_fill_sg:
+	dma_pool_free(hiedmac->pool, tsf_desc->llis_vaddr, tsf_desc->llis_busaddr);
+err_alloc_lli:
+	kfree(tsf_desc);
+	return NULL;
+}
+
+
+static struct dma_async_tx_descriptor *hiedmac_prep_dma_cyclic(
+	struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,
+	size_t period_len, enum dma_transfer_direction direction,
+	unsigned long flags)
+{
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(chan);
+	struct hiedmacv310_driver_data *hiedmac = edmac_dma_chan->host;
+	struct transfer_desc *tsf_desc = NULL;
+	dma_addr_t slave_addr = 0;
+	LIST_HEAD(sg_head);
+	int ret;
+
+	tsf_desc = hiedmac_init_tsf_desc(chan, direction, &slave_addr);
+	if (!tsf_desc)
+		return NULL;
+
+	tsf_desc->llis_vaddr = dma_pool_alloc(hiedmac->pool, GFP_NOWAIT,
+			&tsf_desc->llis_busaddr);
+	if (!tsf_desc->llis_vaddr) {
+		hiedmacv310_error("malloc memory from pool fail !\n");
+		goto err_alloc_lli;
+	}
+
+	tsf_desc->cyclic = true;
+	ret = hiedmac_fill_sg_for_cyclic(&sg_head, slave_addr, buf_addr, buf_len, period_len, direction);
+	if (ret)
+		goto err_fill_sg;
+	ret = hiedmac_fill_lli_for_desc(&sg_head, tsf_desc);
+	free_dsg(&sg_head);
+	if (ret)
+		goto err_fill_sg;
+	return vchan_tx_prep(&edmac_dma_chan->virt_chan, &tsf_desc->virt_desc, flags);
+
+err_fill_sg:
+	dma_pool_free(hiedmac->pool, tsf_desc->llis_vaddr, tsf_desc->llis_busaddr);
+err_alloc_lli:
+	kfree(tsf_desc);
+	return NULL;
+}
+
+static void hiedmac_phy_reassign(struct hiedmacv310_phy_chan *phy_chan,
+				 struct hiedmacv310_dma_chan *chan)
+{
+	phy_chan->serving = chan;
+	chan->phychan = phy_chan;
+	chan->state = HIEDMAC_CHAN_RUNNING;
+
+	hiedmac_start_next_txd(chan);
+}
+
+static void hiedmac_terminate_phy_chan(struct hiedmacv310_driver_data *hiedmac,
+				       const struct hiedmacv310_dma_chan *edmac_dma_chan)
+{
+	unsigned int val;
+	struct hiedmacv310_phy_chan *phychan = edmac_dma_chan->phychan;
+	hiedmac_pause_phy_chan(edmac_dma_chan);
+	val = 0x1 << phychan->id;
+	hiedmacv310_writel(val, hiedmac->base + HIEDMAC_INT_TC1_RAW);
+	hiedmacv310_writel(val, hiedmac->base + HIEDMAC_INT_ERR1_RAW);
+	hiedmacv310_writel(val, hiedmac->base + HIEDMAC_INT_ERR2_RAW);
+}
+
+void hiedmac_phy_free(struct hiedmacv310_dma_chan *chan)
+{
+	struct hiedmacv310_driver_data *hiedmac = chan->host;
+	struct hiedmacv310_dma_chan *p = NULL;
+	struct hiedmacv310_dma_chan *next = NULL;
+
+	list_for_each_entry(p, &hiedmac->memcpy.channels, virt_chan.chan.device_node) {
+		if (p->state == HIEDMAC_CHAN_WAITING) {
+			next = p;
+			break;
+		}
+	}
+
+	if (!next) {
+		list_for_each_entry(p, &hiedmac->slave.channels, virt_chan.chan.device_node) {
+			if (p->state == HIEDMAC_CHAN_WAITING) {
+				next = p;
+				break;
+			}
+		}
+	}
+	hiedmac_terminate_phy_chan(hiedmac, chan);
+
+	if (next) {
+		spin_lock(&next->virt_chan.lock);
+		hiedmac_phy_reassign(chan->phychan, next);
+		spin_unlock(&next->virt_chan.lock);
+	} else {
+		chan->phychan->serving = NULL;
+	}
+
+	chan->phychan = NULL;
+	chan->state = HIEDMAC_CHAN_IDLE;
+}
+
+bool handle_irq(struct hiedmacv310_driver_data *hiedmac, int chan_id)
+{
+	struct hiedmacv310_dma_chan *chan = NULL;
+	struct hiedmacv310_phy_chan *phy_chan = NULL;
+	struct transfer_desc *tsf_desc = NULL;
+	unsigned int channel_tc_status, channel_err_status[ERR_STATUS_REG_NUM];
+
+	phy_chan = &hiedmac->phy_chans[chan_id];
+	chan = phy_chan->serving;
+	if (!chan) {
+		hiedmacv310_error("error interrupt on chan: %d!\n", chan_id);
+		return 0;
+	}
+	tsf_desc = chan->at;
+
+	channel_tc_status = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_TC1_RAW);
+	channel_tc_status = (channel_tc_status >> chan_id) & 0x01;
+	if (channel_tc_status)
+		hiedmacv310_writel(channel_tc_status << chan_id, hiedmac->base + HIEDMAC_INT_TC1_RAW);
+
+	channel_tc_status = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_TC2);
+	channel_tc_status = (channel_tc_status >> chan_id) & 0x01;
+	if (channel_tc_status)
+		hiedmacv310_writel(channel_tc_status << chan_id, hiedmac->base + HIEDMAC_INT_TC2_RAW);
+	channel_err_status[0] = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_ERR1);
+	channel_err_status[1] = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_ERR2);
+	channel_err_status[2] = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_ERR3);
+	if ((channel_err_status[0] | channel_err_status[1] | channel_err_status[2]) & (1 << chan_id)) {
+		hiedmacv310_error("Error in hiedmac %d!,ERR1 = 0x%x,ERR2 = 0x%x,ERR3 = 0x%x\n",
+				  chan_id, channel_err_status[0],
+				  channel_err_status[1], channel_err_status[2]);
+		hiedmacv310_writel(1 << chan_id, hiedmac->base + HIEDMAC_INT_ERR1_RAW);
+		hiedmacv310_writel(1 << chan_id, hiedmac->base + HIEDMAC_INT_ERR2_RAW);
+		hiedmacv310_writel(1 << chan_id, hiedmac->base + HIEDMAC_INT_ERR3_RAW);
+	}
+
+	spin_lock(&chan->virt_chan.lock);
+
+	if (tsf_desc->cyclic) {
+		vchan_cyclic_callback(&tsf_desc->virt_desc);
+		spin_unlock(&chan->virt_chan.lock);
+		return 1;
+	}
+	chan->at = NULL;
+	tsf_desc->done = true;
+	vchan_cookie_complete(&tsf_desc->virt_desc);
+
+	if (vchan_next_desc(&chan->virt_chan))
+		hiedmac_start_next_txd(chan);
+	else
+		hiedmac_phy_free(chan);
+	spin_unlock(&chan->virt_chan.lock);
+	return 1;
+}
+
+static irqreturn_t hiemdacv310_irq(int irq, void *dev)
+{
+	struct hiedmacv310_driver_data *hiedmac = (struct hiedmacv310_driver_data *)dev;
+	u32 mask = 0;
+	unsigned int channel_status, temp, i;
+
+	channel_status = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_STAT);
+	if (!channel_status) {
+		hiedmacv310_error("channel_status = 0x%x\n", channel_status);
+		return IRQ_NONE;
+	}
+
+	for (i = 0; i < hiedmac->channels; i++) {
+		temp = (channel_status >> i) & 0x1;
+		if (temp)
+			mask |= handle_irq(hiedmac, i) << i;
+	}
+	return mask ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static inline void hiedmac_dma_slave_init(struct hiedmacv310_dma_chan *chan)
+{
+	chan->slave = true;
+}
+
+static void hiedmac_desc_free(struct virt_dma_desc *vd)
+{
+	struct transfer_desc *tsf_desc = to_edmac_transfer_desc(&vd->tx);
+	struct hiedmacv310_dma_chan *edmac_dma_chan = to_edamc_chan(vd->tx.chan);
+	dma_descriptor_unmap(&vd->tx);
+	dma_pool_free(edmac_dma_chan->host->pool, tsf_desc->llis_vaddr, tsf_desc->llis_busaddr);
+	kfree(tsf_desc);
+}
+
+static int hiedmac_init_virt_channels(struct hiedmacv310_driver_data *hiedmac,
+				      struct dma_device *dmadev,
+				      unsigned int channels, bool slave)
+{
+	struct hiedmacv310_dma_chan *chan = NULL;
+	int i;
+	INIT_LIST_HEAD(&dmadev->channels);
+
+	for (i = 0; i < channels; i++) {
+		chan = kzalloc(sizeof(struct hiedmacv310_dma_chan), GFP_KERNEL);
+		if (!chan) {
+			hiedmacv310_error("fail to allocate memory for virt channels!");
+			return -1;
+		}
+
+		chan->host = hiedmac;
+		chan->state = HIEDMAC_CHAN_IDLE;
+		chan->signal = -1;
+
+		if (slave) {
+			chan->id = i;
+			hiedmac_dma_slave_init(chan);
+		}
+		chan->virt_chan.desc_free = hiedmac_desc_free;
+		vchan_init(&chan->virt_chan, dmadev);
+	}
+	return 0;
+}
+
+void hiedmac_free_virt_channels(struct dma_device *dmadev)
+{
+	struct hiedmacv310_dma_chan *chan = NULL;
+	struct hiedmacv310_dma_chan *next = NULL;
+
+	list_for_each_entry_safe(chan, next, &dmadev->channels, virt_chan.chan.device_node) {
+		list_del(&chan->virt_chan.chan.device_node);
+		kfree(chan);
+	}
+}
+
+static void hiedmacv310_prep_dma_device(struct platform_device *pdev,
+					struct hiedmacv310_driver_data *hiedmac)
+{
+	dma_cap_set(DMA_MEMCPY, hiedmac->memcpy.cap_mask);
+	hiedmac->memcpy.dev = &pdev->dev;
+	hiedmac->memcpy.device_free_chan_resources = hiedmac_free_chan_resources;
+	hiedmac->memcpy.device_prep_dma_memcpy = hiedmac_prep_dma_m2m_copy;
+	hiedmac->memcpy.device_tx_status = hiedmac_tx_status;
+	hiedmac->memcpy.device_issue_pending = hiedmac_issue_pending;
+	hiedmac->memcpy.device_config = hiedmac_config;
+	hiedmac->memcpy.device_pause = hiedmac_pause;
+	hiedmac->memcpy.device_resume = hiedmac_resume;
+	hiedmac->memcpy.device_terminate_all = hiedmac_terminate_all;
+	hiedmac->memcpy.directions = BIT(DMA_MEM_TO_MEM);
+	hiedmac->memcpy.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;
+
+	dma_cap_set(DMA_SLAVE, hiedmac->slave.cap_mask);
+	dma_cap_set(DMA_CYCLIC, hiedmac->slave.cap_mask);
+	hiedmac->slave.dev = &pdev->dev;
+	hiedmac->slave.device_free_chan_resources = hiedmac_free_chan_resources;
+	hiedmac->slave.device_tx_status = hiedmac_tx_status;
+	hiedmac->slave.device_issue_pending = hiedmac_issue_pending;
+	hiedmac->slave.device_prep_slave_sg = hiedmac_prep_slave_sg;
+	hiedmac->slave.device_prep_dma_cyclic = hiedmac_prep_dma_cyclic;
+	hiedmac->slave.device_config = hiedmac_config;
+	hiedmac->slave.device_resume = hiedmac_resume;
+	hiedmac->slave.device_pause = hiedmac_pause;
+	hiedmac->slave.device_terminate_all = hiedmac_terminate_all;
+	hiedmac->slave.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+	hiedmac->slave.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;
+}
+
+static int hiedmacv310_init_chan(struct hiedmacv310_driver_data *hiedmac)
+{
+	int i, ret;
+	hiedmac->phy_chans = kzalloc((hiedmac->channels * sizeof(
+				     struct hiedmacv310_phy_chan)),
+				     GFP_KERNEL);
+	if (!hiedmac->phy_chans) {
+		hiedmacv310_error("malloc for phy chans fail!");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < hiedmac->channels; i++) {
+		struct hiedmacv310_phy_chan *phy_ch = &hiedmac->phy_chans[i];
+		phy_ch->id = i;
+		phy_ch->base = hiedmac->base + hiedmac_cx_base(i);
+		spin_lock_init(&phy_ch->lock);
+		phy_ch->serving = NULL;
+	}
+
+	ret = hiedmac_init_virt_channels(hiedmac, &hiedmac->memcpy, hiedmac->channels,
+					 false);
+	if (ret) {
+		hiedmacv310_error("fail to init memory virt channels!");
+		goto  free_phychans;
+	}
+
+	ret = hiedmac_init_virt_channels(hiedmac, &hiedmac->slave, hiedmac->slave_requests,
+					 true);
+	if (ret) {
+		hiedmacv310_error("fail to init slave virt channels!");
+		goto  free_memory_virt_channels;
+	}
+	return 0;
+
+free_memory_virt_channels:
+	hiedmac_free_virt_channels(&hiedmac->memcpy);
+free_phychans:
+	kfree(hiedmac->phy_chans);
+	return -ENOMEM;
+}
+
+static void hiedmacv310_free_chan(struct hiedmacv310_driver_data *hiedmac)
+{
+	hiedmac_free_virt_channels(&hiedmac->slave);
+	hiedmac_free_virt_channels(&hiedmac->memcpy);
+	kfree(hiedmac->phy_chans);
+}
+
+static void hiedmacv310_prep_phy_device(const struct hiedmacv310_driver_data *hiedmac)
+{
+	clk_prepare_enable(hiedmac->clk);
+	clk_prepare_enable(hiedmac->axi_clk);
+	reset_control_deassert(hiedmac->rstc);
+
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_TC1_RAW);
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_TC2_RAW);
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_ERR1_RAW);
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_ERR2_RAW);
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_ERR3_RAW);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_TC1_MASK);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_TC2_MASK);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_ERR1_MASK);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_ERR2_MASK);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_ERR3_MASK);
+}
+
+static struct hiedmacv310_driver_data* hiedmacv310_prep_hiedmac_device(struct platform_device *pdev)
+{
+	int ret;
+	struct hiedmacv310_driver_data *hiedmac = NULL;
+	ssize_t trasfer_size;
+
+	ret = dma_set_mask_and_coherent(&(pdev->dev), DMA_BIT_MASK(64));
+	if (ret)
+		return NULL;
+
+	hiedmac = kzalloc(sizeof(*hiedmac), GFP_KERNEL);
+	if (!hiedmac) {
+		hiedmacv310_error("malloc for hiedmac fail!");
+		return NULL;
+	}
+
+	hiedmac->dev = pdev;
+
+	ret = get_of_probe(hiedmac);
+	if (ret) {
+		hiedmacv310_error("get dts info fail!");
+		goto free_hiedmac;
+	}
+
+	hiedmacv310_prep_dma_device(pdev, hiedmac);
+	hiedmac->max_transfer_size = MAX_TRANSFER_BYTES;
+	trasfer_size = MAX_TSFR_LLIS * EDMACV300_LLI_WORDS * sizeof(u32);
+
+	hiedmac->pool = dma_pool_create(DRIVER_NAME, &(pdev->dev),
+					trasfer_size, EDMACV300_POOL_ALIGN, 0);
+	if (!hiedmac->pool) {
+		hiedmacv310_error("create pool fail!");
+		goto free_hiedmac;
+	}
+
+	ret = hiedmacv310_init_chan(hiedmac);
+	if (ret) {
+		goto free_pool;
+	}
+	return hiedmac;
+
+free_pool:
+	dma_pool_destroy(hiedmac->pool);
+free_hiedmac:
+	kfree(hiedmac);
+	return NULL;
+}
+
+static void free_hiedmac_device(struct hiedmacv310_driver_data *hiedmac)
+{
+	hiedmacv310_free_chan(hiedmac);
+	dma_pool_destroy(hiedmac->pool);
+	kfree(hiedmac);
+}
+
+static int __init hiedmacv310_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct hiedmacv310_driver_data *hiedmac = NULL;
+
+	hiedmac = hiedmacv310_prep_hiedmac_device(pdev);
+	if (hiedmac == NULL) {
+		return -ENOMEM;
+	}
+
+	ret = request_irq(hiedmac->irq, hiemdacv310_irq, 0, DRIVER_NAME, hiedmac);
+	if (ret) {
+		hiedmacv310_error("fail to request irq");
+		goto free_hiedmac;
+	}
+	hiedmacv310_prep_phy_device(hiedmac);
+	ret = dma_async_device_register(&hiedmac->memcpy);
+	if (ret) {
+		hiedmacv310_error("%s failed to register memcpy as an async device - %d\n", __func__, ret);
+		goto free_irq_res;
+	}
+
+	ret = dma_async_device_register(&hiedmac->slave);
+	if (ret) {
+		hiedmacv310_error("%s failed to register slave as an async device - %d\n", __func__, ret);
+		goto free_memcpy_device;
+	}
+	return 0;
+
+free_memcpy_device:
+	dma_async_device_unregister(&hiedmac->memcpy);
+free_irq_res:
+	free_irq(hiedmac->irq, hiedmac);
+free_hiedmac:
+	free_hiedmac_device(hiedmac);
+	return -ENOMEM;
+}
+
+static int hiemda_remove(struct platform_device *pdev)
+{
+	int err = 0;
+	return err;
+}
+
+static const struct of_device_id hiedmacv310_match[] = {
+	{ .compatible = "hisilicon,hiedmacv310" },
+	{},
+};
+
+static struct platform_driver hiedmacv310_driver = {
+	.remove = hiemda_remove,
+	.driver = {
+		.name = "hiedmacv310",
+		.of_match_table = hiedmacv310_match,
+	},
+};
+
+static int __init hiedmacv310_init(void)
+{
+	return platform_driver_probe(&hiedmacv310_driver, hiedmacv310_probe);
+}
+subsys_initcall(hiedmacv310_init);
+
+static void __exit hiedmacv310_exit(void)
+{
+	platform_driver_unregister(&hiedmacv310_driver);
+}
+module_exit(hiedmacv310_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hisilicon");
diff --git a/drivers/dma/hiedmacv310.h b/drivers/dma/hiedmacv310.h
new file mode 100644
index 000000000..1fc093945
--- /dev/null
+++ b/drivers/dma/hiedmacv310.h
@@ -0,0 +1,153 @@
+/*
+ * driver/dma/hiedmacv310.h
+ *
+ * The Hiedma Controller v310 Device Driver for HiSilicon
+ *
+ * Copyright (c) 2020 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#ifndef __HIEDMACV310_H__
+#define __HIEDMACV310_H__
+
+/* debug control */
+#define HIEDMACV310_CONFIG_TRACE_LEVEL 3
+#define HIEDMACV310_TRACE_LEVEL 0
+#define HIEDMACV310_REG_TRACE_LEVEL 3
+#define HIEDMACV310_TRACE_FMT KERN_INFO
+
+#ifdef DEBUG_HIEDMAC
+#define hiedmacv310_trace(level, msg...) do { \
+	if ((level) >= HIEDMACV310_TRACE_LEVEL) { \
+		printk(HIEDMACV310_TRACE_FMT"%s:%d: ", __func__, __LINE__); \
+		printk(msg); \
+		printk("\n"); \
+	} \
+} while (0)
+
+
+#define hiedmacv310_assert(cond) do { \
+	if (!(cond)) { \
+		printk(KERN_ERR "Assert:hiedmacv310:%s:%d\n", \
+				__func__, \
+				__LINE__); \
+		BUG(); \
+	} \
+} while (0)
+
+#define hiedmacv310_error(s...) do { \
+	printk(KERN_ERR "hiedmacv310:%s:%d: ", __func__, __LINE__); \
+	printk(s); \
+	printk("\n"); \
+} while (0)
+
+#else
+
+#define hiedmacv310_trace(level, msg...)
+#define hiedmacv310_assert(level, msg...)
+#define hiedmacv310_error(level, msg...)
+
+#endif
+
+#define hiedmacv310_readl(addr) ((unsigned int)readl((void *)(addr)))
+
+#define hiedmacv310_writel(v, addr) do { writel(v, (void *)(addr)); \
+} while (0)
+
+
+#define MAX_TRANSFER_BYTES  0xffff
+
+/* reg offset */
+#define HIEDMAC_INT_STAT                  0x0
+#define HIEDMAC_INT_TC1                   0x4
+#define HIEDMAC_INT_TC2                   0x8
+#define HIEDMAC_INT_ERR1                  0xc
+#define HIEDMAC_INT_ERR2                  0x10
+#define HIEDMAC_INT_ERR3                  0x14
+
+#define HIEDMAC_INT_TC1_MASK              0x18
+#define HIEDMAC_INT_TC2_MASK              0x1c
+#define HIEDMAC_INT_ERR1_MASK             0x20
+#define HIEDMAC_INT_ERR2_MASK             0x24
+#define HIEDMAC_INT_ERR3_MASK             0x28
+
+#define HIEDMAC_INT_TC1_RAW               0x600
+#define HIEDMAC_INT_TC2_RAW               0x608
+#define HIEDMAC_INT_ERR1_RAW              0x610
+#define HIEDMAC_INT_ERR2_RAW              0x618
+#define HIEDMAC_INT_ERR3_RAW              0x620
+
+#define hiedmac_cx_curr_cnt0(cn)          (0x404 + (cn) * 0x20)
+#define hiedmac_cx_curr_src_addr_l(cn)    (0x408 + (cn) * 0x20)
+#define hiedmac_cx_curr_src_addr_h(cn)    (0x40c + (cn) * 0x20)
+#define hiedmac_cx_curr_dest_addr_l(cn)    (0x410 + (cn) * 0x20)
+#define hiedmac_cx_curr_dest_addr_h(cn)    (0x414 + (cn) * 0x20)
+
+#define HIEDMAC_CH_PRI                    0x688
+#define HIEDMAC_CH_STAT                   0x690
+#define HIEDMAC_DMA_CTRL                  0x698
+
+#define hiedmac_cx_base(cn)               (0x800 + (cn) * 0x40)
+#define hiedmac_cx_lli_l(cn)              (0x800 + (cn) * 0x40)
+#define hiedmac_cx_lli_h(cn)              (0x804 + (cn) * 0x40)
+#define hiedmac_cx_cnt0(cn)               (0x81c + (cn) * 0x40)
+#define hiedmac_cx_src_addr_l(cn)         (0x820 + (cn) * 0x40)
+#define hiedmac_cx_src_addr_h(cn)         (0x824 + (cn) * 0x40)
+#define hiedmac_cx_dest_addr_l(cn)        (0x828 + (cn) * 0x40)
+#define hiedmac_cx_dest_addr_h(cn)        (0x82c + (cn) * 0x40)
+#define hiedmac_cx_config(cn)             (0x830 + (cn) * 0x40)
+
+#define HIEDMAC_ALL_CHAN_CLR        0xff
+#define HIEDMAC_INT_ENABLE_ALL_CHAN 0xff
+
+
+#define HIEDMAC_CONFIG_SRC_INC          (1 << 31)
+#define HIEDMAC_CONFIG_DST_INC          (1 << 30)
+
+#define HIEDMAC_CONFIG_SRC_WIDTH_SHIFT  16
+#define HIEDMAC_CONFIG_DST_WIDTH_SHIFT  12
+#define HIEDMAC_WIDTH_8BIT              0b0
+#define HIEDMAC_WIDTH_16BIT             0b1
+#define HIEDMAC_WIDTH_32BIT             0b10
+#define HIEDMAC_WIDTH_64BIT             0b11
+#ifdef CONFIG_64BIT
+#define HIEDMAC_MEM_BIT_WIDTH HIEDMAC_WIDTH_64BIT
+#else
+#define HIEDMAC_MEM_BIT_WIDTH HIEDMAC_WIDTH_32BIT
+#endif
+
+#define HIEDMAC_MAX_BURST_WIDTH         16
+#define HIEDMAC_MIN_BURST_WIDTH         1
+#define HIEDMAC_CONFIG_SRC_BURST_SHIFT  24
+#define HIEDMAC_CONFIG_DST_BURST_SHIFT  20
+
+#define HIEDMAC_LLI_ALIGN   0x40
+#define HIEDMAC_LLI_DISABLE 0x0
+#define HIEDMAC_LLI_ENABLE 0x2
+
+#define HIEDMAC_CXCONFIG_SIGNAL_SHIFT   0x4
+#define HIEDMAC_CXCONFIG_MEM_TYPE       0x0
+#define HIEDMAC_CXCONFIG_DEV_MEM_TYPE   0x1
+#define HIEDMAC_CXCONFIG_TSF_TYPE_SHIFT 0x2
+#define HIEDMAC_CXCONFIG_LLI_START      0x1
+
+#define HIEDMAC_CXCONFIG_ITC_EN     0x1
+#define HIEDMAC_CXCONFIG_ITC_EN_SHIFT   0x1
+
+#define CCFG_EN 0x1
+
+#define HIEDMAC_CONTROL_SRC_WIDTH_MASK GENMASK(18, 16)
+#define HIEDMAC_CONTROL_DST_WIDTH_MASK GENMASK(14, 12)
+#endif
diff --git a/drivers/gpio/gpio-pl061.c b/drivers/gpio/gpio-pl061.c
index f1b53dd1d..0825ad601 100644
--- a/drivers/gpio/gpio-pl061.c
+++ b/drivers/gpio/gpio-pl061.c
@@ -289,6 +289,9 @@ static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
 	struct pl061 *pl061;
 	struct gpio_irq_chip *girq;
 	int ret, irq;
+#ifdef CONFIG_ARCH_HISI_BVT
+	int gpio_idx;
+#endif
 
 	pl061 = devm_kzalloc(dev, sizeof(*pl061), GFP_KERNEL);
 	if (pl061 == NULL)
@@ -301,7 +304,20 @@ static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
 	raw_spin_lock_init(&pl061->lock);
 	pl061->gc.request = gpiochip_generic_request;
 	pl061->gc.free = gpiochip_generic_free;
+#ifdef CONFIG_ARCH_HISI_BVT
+	if (dev->of_node) {
+		gpio_idx = of_alias_get_id(dev->of_node, "gpio");
+		if (gpio_idx < 0)
+			return -ENOMEM;
+		pl061->gc.base = gpio_idx * PL061_GPIO_NR;
+	}
+
+	if (pl061->gc.base < 0)
+		pl061->gc.base = -1;
+#else
 	pl061->gc.base = -1;
+#endif
+
 	pl061->gc.get_direction = pl061_get_direction;
 	pl061->gc.direction_input = pl061_direction_input;
 	pl061->gc.direction_output = pl061_direction_output;
diff --git a/drivers/gpu/drm/hisilicon/Kconfig b/drivers/gpu/drm/hisilicon/Kconfig
index cc5a244db..d69de65db 100644
--- a/drivers/gpu/drm/hisilicon/Kconfig
+++ b/drivers/gpu/drm/hisilicon/Kconfig
@@ -5,3 +5,4 @@
 
 source "drivers/gpu/drm/hisilicon/hibmc/Kconfig"
 source "drivers/gpu/drm/hisilicon/kirin/Kconfig"
+source "drivers/gpu/drm/hisilicon/hismart/Kconfig"
diff --git a/drivers/gpu/drm/hisilicon/Makefile b/drivers/gpu/drm/hisilicon/Makefile
index 69dec6084..4d4968e65 100644
--- a/drivers/gpu/drm/hisilicon/Makefile
+++ b/drivers/gpu/drm/hisilicon/Makefile
@@ -5,3 +5,4 @@
 
 obj-$(CONFIG_DRM_HISI_HIBMC) += hibmc/
 obj-$(CONFIG_DRM_HISI_KIRIN) += kirin/
+obj-$(CONFIG_DRM_HISI_HISMART) += hismart/
diff --git a/drivers/gpu/drm/hisilicon/hismart/Kconfig b/drivers/gpu/drm/hisilicon/hismart/Kconfig
new file mode 100644
index 000000000..ffc8564a8
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/Kconfig
@@ -0,0 +1,8 @@
+config DRM_HISI_HISMART
+	tristate "DRM Support for Hisilicon Smart Media / Smart Vision SoC chipset"
+	depends on DRM && (ARM || ARM64)
+	select DRM_KMS_HELPER
+	select DRM_GEM_CMA_HELPER
+	help
+	  Choose this option to enable DRM on Hisilicon Smart Media / Smart Vision SoC chipset
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/Makefile b/drivers/gpu/drm/hisilicon/hismart/Makefile
new file mode 100644
index 000000000..e89172f24
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/Makefile
@@ -0,0 +1,27 @@
+KERNEL_DIR := $(srctree)
+SDK_ROOT_DIR = $(shell cd $(KERNEL_DIR)/../../../../../device/soc/hisilicon/hi3516dv300/sdk_linux/drv && /bin/pwd)
+$(warning SDK_ROOT_DIR=  $(SDK_ROOT_DIR))
+EXTRA_CFLAGS +=  -I$(SDK_ROOT_DIR)/mpp/cbb/vo/vo_dev/drm_hal \
+		 -I$(SDK_ROOT_DIR)/mpp/component/hifb/drm_hal \
+		 -I$(SDK_ROOT_DIR)/mpp/component/hdmi/src/mkp/drm_hal \
+		 -I$(SDK_ROOT_DIR)/mpp/cbb/include \
+		 -I$(SDK_ROOT_DIR)/mpp/cbb/include/adapt \
+		 -I$(SDK_ROOT_DIR)/mpp/cbb/based/arch/hi3516cv500/include/hi3516cv500 \
+		 -I$(SDK_ROOT_DIR)/mpp/cbb/vo/vo_dev/include \
+		 -I$(SDK_ROOT_DIR)/mpp/cbb/vo/vo_dev/include/adapt \
+		 -I$(SDK_ROOT_DIR)/mpp/cbb/vo/include/adapt \
+		 -I$(SDK_ROOT_DIR)/mpp/cbb/vo/include \
+		 -I$(SDK_ROOT_DIR)/osal/include
+$(warning CONFIG_DRM_HISI_HISMART = $(CONFIG_DRM_HISI_HISMART))
+hi_drm-y := \
+	hi_drm_drv.o \
+	hi_drm_crtc.o \
+	hi_adp_crtc.o \
+	hi_drm_hdmitx.o \
+	hi_adp_hdmitx.o \
+	hi_drm_func_ext.o \
+	hi_drm_mipitx.o \
+	hi_adp_mipitx.o
+
+obj-y += hi_drm.o
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/drm_hal_mipitx.h b/drivers/gpu/drm/hisilicon/hismart/drm_hal_mipitx.h
new file mode 100644
index 000000000..88192d01f
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/drm_hal_mipitx.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __DRM_HAL_MIPITX_H__
+#define __DRM_HAL_MIPITX_H__
+
+/* output timming */
+enum IntfSync {
+    OUTPUT_USER = 0,          /* User timing */
+    OUTPUT_PAL,               /* PAL standard */
+    OUTPUT_NTSC,              /* NTSC standard */
+    OUTPUT_1080P24,           /* 1920 x 1080 at 24 Hz. */
+    OUTPUT_1080P25,           /* 1920 x 1080 at 25 Hz. */
+    OUTPUT_1080P30,           /* 1920 x 1080 at 30 Hz. */
+    OUTPUT_720P50,            /* 1280 x  720 at 50 Hz. */
+    OUTPUT_720P60,            /* 1280 x  720 at 60 Hz. */
+    OUTPUT_1080I50,           /* 1920 x 1080 at 50 Hz, interlace. */
+    OUTPUT_1080I60,           /* 1920 x 1080 at 60 Hz, interlace. */
+    OUTPUT_1080P50,           /* 1920 x 1080 at 50 Hz. */
+    OUTPUT_1080P60,           /* 1920 x 1080 at 60 Hz. */
+    OUTPUT_576P50,            /* 720  x  576 at 50 Hz. */
+    OUTPUT_480P60,            /* 720  x  480 at 60 Hz. */
+    OUTPUT_800X600_60,        /* VESA 800 x 600 at 60 Hz (non-interlaced) */
+    OUTPUT_1024X768_60,       /* VESA 1024 x 768 at 60 Hz (non-interlaced) */
+    OUTPUT_1280X1024_60,      /* VESA 1280 x 1024 at 60 Hz (non-interlaced) */
+    OUTPUT_1366X768_60,       /* VESA 1366 x 768 at 60 Hz (non-interlaced) */
+    OUTPUT_1440X900_60,       /* VESA 1440 x 900 at 60 Hz (non-interlaced) CVT Compliant */
+    OUTPUT_1280X800_60,       /* 1280*800@60Hz VGA@60Hz */
+    OUTPUT_1600X1200_60,      /* VESA 1600 x 1200 at 60 Hz (non-interlaced) */
+    OUTPUT_1680X1050_60,      /* VESA 1680 x 1050 at 60 Hz (non-interlaced) */
+    OUTPUT_1920X1200_60,      /* VESA 1920 x 1600 at 60 Hz (non-interlaced) CVT (Reduced Blanking) */
+    OUTPUT_640X480_60,        /* VESA 640 x 480 at 60 Hz (non-interlaced) CVT */
+    OUTPUT_960H_PAL,          /* ITU-R BT.1302 960 x 576 at 50 Hz (interlaced) */
+    OUTPUT_960H_NTSC,         /* ITU-R BT.1302 960 x 480 at 60 Hz (interlaced) */
+    OUTPUT_1920X2160_30,      /* 1920x2160_30 */
+    OUTPUT_2560X1440_30,      /* 2560x1440_30 */
+    OUTPUT_2560X1440_60,      /* 2560x1440_60 */
+    OUTPUT_2560X1600_60,      /* 2560x1600_60 */
+    OUTPUT_3840X2160_24,      /* 3840x2160_24 */
+    OUTPUT_3840X2160_25,      /* 3840x2160_25 */
+    OUTPUT_3840X2160_30,      /* 3840x2160_30 */
+    OUTPUT_3840X2160_50,      /* 3840x2160_50 */
+    OUTPUT_3840X2160_60,      /* 3840x2160_60 */
+    OUTPUT_4096X2160_24,      /* 4096x2160_24 */
+    OUTPUT_4096X2160_25,      /* 4096x2160_25 */
+    OUTPUT_4096X2160_30,      /* 4096x2160_30 */
+    OUTPUT_4096X2160_50,      /* 4096x2160_50 */
+    OUTPUT_4096X2160_60,      /* 4096x2160_60 */
+    OUTPUT_320X240_60,        /* For ota5182 at 60 Hz (8bit) */
+    OUTPUT_320X240_50,        /* For ili9342 at 50 Hz (6bit) */
+    OUTPUT_240X320_50,        /* Hi3559AV100: For ili9341 at 50 Hz (6bit) */
+    OUTPUT_240X320_60,        /* For ili9341 at 60 Hz (16bit) */
+    OUTPUT_800X600_50,        /* For LCD     at 50 Hz (24bit) */
+    OUTPUT_720X1280_60,       /* For MIPI DSI Tx 720 x1280 at 60 Hz */
+    OUTPUT_1080X1920_60,      /* For MIPI DSI Tx 1080x1920 at 60 Hz */
+    OUTPUT_7680X4320_30,      /* For HDMI2.1 at 30 Hz */
+};
+
+struct DispInfo {
+    unsigned int width;
+    unsigned int hbp;
+    unsigned int hfp;
+    unsigned int hsw;
+    unsigned int height;
+    unsigned int vbp;
+    unsigned int vfp;
+    unsigned int vsw;
+    unsigned int frameRate;
+    unsigned int intfType;
+    enum IntfSync intfSync;
+    unsigned int minLevel;
+    unsigned int maxLevel;
+    unsigned int defLevel;
+};
+
+struct DispOperations {
+    int (*init)(unsigned int dev_id);
+    int (*on)(unsigned int dev_id);
+    int (*off)(unsigned int dev_id);
+    int (*setBacklight)(unsigned int dev_id, unsigned int level);
+    int (*getDispInfo)(unsigned int dev_id, struct DispInfo *info);
+};
+
+struct DispOperations *GetDispOps(void);
+
+#endif /* __DRM_HAL_MIPITX_H__ */
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_adp_crtc.c b/drivers/gpu/drm/hisilicon/hismart/hi_adp_crtc.c
new file mode 100755
index 000000000..897f7838f
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_adp_crtc.c
@@ -0,0 +1,777 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#include "hi_adp_crtc.h"
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_address.h>
+#include <video/videomode.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_util.h>
+#include <drm/drm_framebuffer.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include "hi_drm_drv.h"
+#include "drm_hal_common.h"
+#include "drm_hal_display.h"
+#include "drm_hal_gfx.h"
+#include "hi_drm_func_ext.h"
+
+struct hi_drm_plane {
+    struct drm_plane base;
+    struct hi_drm_crtc *root_hi_crtc; /* which hi_crtc this plane belongs to */
+    enum drm_hal_gfx_layer id; /* layer id */
+    unsigned int status; /* 0: closed, 1: opened */
+};
+
+struct hi_drm_crtc {
+    struct drm_crtc base;
+    /* each crtc can have several planes */
+    struct hi_drm_plane primary[HI_DRM_MAX_PRIMARY_NUM];
+    struct hi_drm_plane cursor;
+    struct hi_drm_plane overlay[HI_DRM_MAX_OVERLAY_NUM];
+    enum drm_hal_disp_chn id; /* display id */
+    adp_crtc_callback adp_crtc_cb;
+    unsigned int status; /* 0: closed, 1: opened */
+    bool vb_enable;
+};
+
+struct hi_drm_crtc_global {
+    struct hi_drm_crtc crtcs[HI_DRM_MAX_CRTC_NUM];
+    struct drm_hal_disp_dev *disp_dev; /* the pointer to drm hal display api */
+    struct drm_hal_gfx_dev *gfx_dev; /* the pointer to drm hal graphics api */
+};
+
+#define to_hi_crtc(x) container_of(x, struct hi_drm_crtc, base)
+#define to_hi_plane(x) container_of(x, struct hi_drm_plane, base)
+
+static struct hi_drm_crtc_global *g_hi_crtcs = NULL;
+
+static struct drm_hal_disp_dev* adp_crtc_get_disp_func(void)
+{
+    int ret;
+
+    if (g_hi_crtcs->disp_dev != NULL) {
+        return g_hi_crtcs->disp_dev;
+    }
+
+    ret = drm_get_export_func(MOD_ID_DISP, (hi_void **)&g_hi_crtcs->disp_dev);
+    if (ret != HI_SUCCESS) {
+        return NULL;
+    }
+
+    return (struct drm_hal_disp_dev *)g_hi_crtcs->disp_dev;
+}
+
+static struct drm_hal_gfx_dev* adp_crtc_get_gfx_func(void)
+{
+    int ret;
+
+    if (g_hi_crtcs->gfx_dev != NULL) {
+        return g_hi_crtcs->gfx_dev;
+    }
+
+    ret = drm_get_export_func(MOD_ID_GFX, (hi_void **)&g_hi_crtcs->gfx_dev);
+    if (ret != HI_SUCCESS) {
+        return NULL;
+    }
+
+    return (struct drm_hal_gfx_dev *)g_hi_crtcs->gfx_dev;
+}
+
+static void adp_gfx_get_capability(struct drm_hal_gfx_capability *cap)
+{
+    cap->layer_cap[DRM_HAL_GFX_G0].available = 1;
+    cap->layer_cap[DRM_HAL_GFX_G0].connected_disp_chn = DRM_HAL_DISP_0;
+    cap->layer_cap[DRM_HAL_GFX_G0].max_w = 1920; /* 1920 max width */
+    cap->layer_cap[DRM_HAL_GFX_G0].max_h = 1080; /* 1080 max height */
+    cap->layer_cap[DRM_HAL_GFX_G0].format_num = 2; /* 2:support 2 color format */
+    cap->layer_cap[DRM_HAL_GFX_G0].formats[0] = DRM_HAL_FMT_ARGB8888;
+    cap->layer_cap[DRM_HAL_GFX_G0].formats[1] = DRM_HAL_FMT_ARGB1555;
+
+    cap->layer_cap[DRM_HAL_GFX_G1].available = 0;
+
+    cap->layer_cap[DRM_HAL_GFX_G2].available = 0;
+
+    cap->layer_cap[DRM_HAL_GFX_G3].available = 1;
+    cap->layer_cap[DRM_HAL_GFX_G3].connected_disp_chn = DRM_HAL_DISP_0;
+    cap->layer_cap[DRM_HAL_GFX_G3].max_w = 256; /* 256 max width */
+    cap->layer_cap[DRM_HAL_GFX_G3].max_h = 256; /* 256 max height */
+    cap->layer_cap[DRM_HAL_GFX_G3].format_num = 2; /* 2:support 2 color format */
+    cap->layer_cap[DRM_HAL_GFX_G3].formats[0] = DRM_HAL_FMT_ARGB8888;
+    cap->layer_cap[DRM_HAL_GFX_G3].formats[1] = DRM_HAL_FMT_ARGB1555;
+
+    return;
+}
+
+int hi_adp_plane_get_by_index(struct drm_crtc *crtc, struct drm_plane **plane, enum drm_plane_type type, int index)
+{
+    int i;
+    int matched = 0;
+    struct drm_hal_gfx_capability cap;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+
+    /* currently only support primary plane, need support cursor plane later */
+    if (type != DRM_PLANE_TYPE_PRIMARY) {
+        HI_DRM_ERR("plane type %d not support!\n", type);
+        return -1;
+    }
+
+    if (index >= HI_DRM_MAX_PRIMARY_NUM) {
+        HI_DRM_ERR("invalid index: %d!\n", index);
+        return -1;
+    }
+
+    adp_gfx_get_capability(&cap);
+
+    for (i = 0; i < DRM_HAL_GFX_MAX; i++) {
+        if (cap.layer_cap[i].available != 0 &&
+            cap.layer_cap[i].connected_disp_chn == hi_crtc->id) {
+            if (matched++ == index)
+                break;
+        }
+    }
+    hi_crtc->primary[index].id = i;
+    hi_crtc->primary[index].root_hi_crtc = hi_crtc;
+    *plane = &hi_crtc->primary[index].base;
+
+    return 0;
+}
+
+static int hi_adp_crtc_set_csc(void)
+{
+    int ret;
+    hi_vo_csc csc = {0};
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    HI_DRM_CHECK_PTR_RETURN(disp_dev);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->get_csc);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->set_csc);
+
+    ret = disp_dev->get_csc(DRM_HAL_GFX_G0, &csc);
+    if (ret != 0) {
+        HI_DRM_ERR("disp_dev->get_csc error, ret=%#x\n", ret);
+        return ret;
+    }
+
+    csc.csc_matrix = VO_CSC_MATRIX_IDENTITY;
+    ret = disp_dev->set_csc(DRM_HAL_GFX_G0, &csc);
+    if (ret != 0) {
+        HI_DRM_ERR("disp_dev->set_csc error, ret=%#x\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+int hi_adp_plane_reset_csc(struct drm_plane *plane)
+{
+    int ret = 0;
+    struct drm_connector *connector;
+    struct drm_connector_list_iter conn_iter;
+    enum drm_connector_status mipi_status = 0;
+    enum drm_connector_status hdmi_status = 0;
+
+    drm_connector_list_iter_begin(plane->dev, &conn_iter);
+    drm_for_each_connector_iter(connector, &conn_iter) {
+        if (connector->connector_type == DRM_MODE_CONNECTOR_DSI) {
+            mipi_status = connector->status;
+        } else if (connector->connector_type == DRM_MODE_CONNECTOR_HDMIA) {
+            hdmi_status = connector->status;
+        }
+    }
+    if (hdmi_status != connector_status_connected && mipi_status == connector_status_connected) {
+        ret = hi_adp_crtc_set_csc();
+    }
+    drm_connector_list_iter_end(&conn_iter);
+    return ret;
+}
+
+int hi_adp_plane_open(struct drm_plane *plane)
+{
+    int ret;
+    struct hi_drm_plane *hi_plane = to_hi_plane(plane);
+    struct drm_hal_gfx_dev *gfx_dev = adp_crtc_get_gfx_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_plane);
+    HI_DRM_CHECK_PTR_RETURN(gfx_dev);
+    HI_DRM_CHECK_PTR_RETURN(gfx_dev->open);
+    HI_DRM_CHECK_PTR_RETURN(gfx_dev->enable);
+    HI_DRM_CHECK_PTR_RETURN(gfx_dev->close);
+
+    /* plane already opened */
+    if (hi_plane->status == 1) {
+        return 0;
+    }
+    /* ensure the relied crtc has been opened */
+    ret = hi_adp_crtc_open(&hi_plane->root_hi_crtc->base);
+    if (ret != 0) {
+        return -1;
+    }
+
+    ret = gfx_dev->open(hi_plane->id);
+    if (ret != 0) {
+        goto err_crtc_close;
+    }
+
+    ret = gfx_dev->enable(hi_plane->id);
+    if (ret != 0) {
+        goto err_dev_close;
+    }
+    hi_plane->status = 1;
+
+    return 0;
+
+err_dev_close:
+    gfx_dev->close(hi_plane->id);
+err_crtc_close:
+    hi_adp_crtc_close(&hi_plane->root_hi_crtc->base);
+    return ret;
+}
+
+static int adp_plane_close(struct drm_plane *plane)
+{
+    int ret;
+    struct hi_drm_plane *hi_plane = to_hi_plane(plane);
+    struct drm_hal_gfx_dev *gfx_dev = adp_crtc_get_gfx_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_plane);
+    HI_DRM_CHECK_PTR_RETURN(gfx_dev);
+    HI_DRM_CHECK_PTR_RETURN(gfx_dev->disable);
+    HI_DRM_CHECK_PTR_RETURN(gfx_dev->close);
+
+    /* plane already closed */
+    if (hi_plane->status == 0) {
+        return 0;
+    }
+
+    ret = gfx_dev->disable(hi_plane->id);
+    if (ret != 0) {
+        return -1;
+    }
+
+    ret = gfx_dev->close(hi_plane->id);
+    if (ret != 0) {
+        return -1;
+    }
+    hi_plane->status = 0;
+    return 0;
+}
+
+int hi_adp_plane_close(struct drm_plane *plane)
+{
+    return adp_plane_close(plane);
+}
+
+static void adp_format_translate(u32 drm_fmt, enum drm_hal_color_fmt *hal_fmt)
+{
+    switch (drm_fmt) {
+        case DRM_FORMAT_ARGB8888:
+            /* fall-through */
+        case DRM_FORMAT_XRGB8888:
+            *hal_fmt = DRM_HAL_FMT_ARGB8888;
+            break;
+        case DRM_FORMAT_RGB888:
+            *hal_fmt = DRM_HAL_FMT_RGB888;
+            break;
+        case DRM_FORMAT_RGB565:
+            *hal_fmt = DRM_HAL_FMT_RGB565;
+            break;
+        case DRM_FORMAT_ARGB1555:
+            /* fall-through */
+        case DRM_FORMAT_XRGB1555:
+            *hal_fmt = DRM_HAL_FMT_ARGB1555;
+            break;
+        default:
+            *hal_fmt = DRM_HAL_FMT_MAX;
+            break;
+    }
+    return;
+}
+
+void hi_adp_plane_update(struct drm_plane *plane)
+{
+    int ret;
+    struct drm_plane_state *state = plane->state;
+    struct drm_framebuffer *fb = state->fb;
+    struct hi_drm_plane *hi_plane = to_hi_plane(plane);
+    struct drm_hal_rect hal_rect;
+    enum drm_hal_color_fmt hal_fmt;
+    struct drm_gem_object *gem = NULL;
+    struct drm_gem_cma_object *cma_gem = NULL;
+    struct drm_hal_gfx_dev *gfx_dev = adp_crtc_get_gfx_func();
+
+    HI_DRM_FUNC_ENTER();
+    /* no framebuffer or status not ready */
+    if (fb == NULL || IS_ERR_OR_NULL(hi_plane) || IS_ERR_OR_NULL(hi_plane->root_hi_crtc) ||
+        IS_ERR_OR_NULL(gfx_dev) || IS_ERR_OR_NULL(gfx_dev->set_attr) || IS_ERR_OR_NULL(gfx_dev->refresh) ||
+        hi_plane->root_hi_crtc->status == 0) {
+        return;
+    }
+
+    /* for cma gem only. */
+    gem = drm_gem_fb_get_obj(fb, 0);
+    cma_gem = to_drm_gem_cma_obj(gem);
+    /* no memory */
+    if (IS_ERR_OR_NULL(cma_gem)) {
+        return;
+    }
+
+    /* rect */
+    hal_rect.x = 0;
+    hal_rect.y = 0;
+    hal_rect.w = fb->width;
+    hal_rect.h = fb->height;
+    ret = gfx_dev->set_attr(hi_plane->id, DRM_HAL_GFX_ATTR_SIZE, &hal_rect);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    /* format */
+    adp_format_translate(fb->format->format, &hal_fmt);
+    ret = gfx_dev->set_attr(hi_plane->id, DRM_HAL_GFX_ATTR_FORMAT, &hal_fmt);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    /* stride */
+    ret = gfx_dev->set_attr(hi_plane->id, DRM_HAL_GFX_ATTR_STRIDE, &fb->pitches[0]);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    /* buffer address */
+    ret = gfx_dev->set_attr(hi_plane->id, DRM_HAL_GFX_ATTR_BUFFER, &cma_gem->paddr);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    /* enable the registers */
+    ret = gfx_dev->refresh(hi_plane->id);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+    HI_DRM_FUNC_EXIT();
+    return;
+}
+
+/* adp crtc global init */
+int hi_adp_crtc_init(void)
+{
+    g_hi_crtcs = kzalloc(sizeof(struct hi_drm_crtc_global), GFP_KERNEL);
+    if (g_hi_crtcs == NULL) {
+        return -ENOMEM;
+    }
+
+    return 0;
+}
+
+void hi_adp_crtc_deinit(void)
+{
+    struct drm_hal_gfx_dev *gfx_dev = adp_crtc_get_gfx_func();
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    if (gfx_dev->deinit != NULL) {
+        gfx_dev->deinit();
+    }
+    if (disp_dev->deinit != NULL) {
+        disp_dev->deinit();
+    }
+    if (g_hi_crtcs != NULL) {
+        kfree(g_hi_crtcs);
+        g_hi_crtcs = NULL;
+    }
+    return;
+}
+
+void hi_adp_crtc_get_cap(struct hi_adp_crtc_cap *cap)
+{
+    if (cap != NULL) {
+        cap->crtc_num = 1;
+    }
+    return;
+}
+
+int hi_adp_crtc_get_by_index(struct drm_crtc **crtc, int index)
+{
+    if (index >= HI_DRM_MAX_CRTC_NUM) {
+        HI_DRM_ERR("invalid index %d\n", index);
+        return -1;
+    }
+
+    HI_DRM_CHECK_PTR_RETURN(g_hi_crtcs);
+    *crtc = &g_hi_crtcs->crtcs[index].base;
+    /* translate the index to drm hal enum */
+    switch (index) {
+        case 0:
+            g_hi_crtcs->crtcs[index].id = DRM_HAL_DISP_0;
+            break;
+        case 1:
+            g_hi_crtcs->crtcs[index].id = DRM_HAL_DISP_1;
+            break;
+        default:
+            return -1;
+    }
+    return 0;
+}
+
+int hi_adp_crtc_open(struct drm_crtc *crtc)
+{
+    int ret;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->open);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->enable);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->close);
+
+    if (hi_crtc->status >= 1) {
+        HI_DRM_INFO("crtc already opened!\n");
+        return 0;
+    }
+
+    HI_DRM_INFO("prepare to open display: %d\n", hi_crtc->id);
+
+    ret = disp_dev->open(hi_crtc->id);
+    if (ret != 0) {
+        HI_DRM_ERR("disp_dev->open error, ret=%#x\n", ret);
+        goto err_ret;
+    }
+
+    ret = disp_dev->enable(hi_crtc->id);
+    if (ret != 0) {
+        HI_DRM_ERR("disp_dev->enable error, ret=%#x\n", ret);
+        goto err_disp_close;
+    }
+
+    hi_crtc->status = 1;
+    hi_crtc->vb_enable = false;
+
+    return 0;
+err_disp_close:
+    (void)disp_dev->close(hi_crtc->id);
+err_ret:
+    return ret;
+}
+
+int hi_adp_crtc_close(struct drm_crtc *crtc)
+{
+    int ret;
+    int i;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->disable);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->close);
+
+    if (hi_crtc->status == 0) {
+        HI_DRM_INFO("crtc already closed!\n");
+        return 0;
+    }
+
+    ret = disp_dev->disable(hi_crtc->id);
+    if (ret != 0) {
+        HI_DRM_ERR("disp_dev->disable error, ret=%#x\n", ret);
+    }
+
+    /* close the crtc planes here to avoid the crtc vblank timeout issue!!! */
+    for (i = 0; i < HI_DRM_MAX_PRIMARY_NUM; i++) {
+        if (hi_crtc->primary[i].status == 1) {
+            (void)adp_plane_close(&hi_crtc->primary[i].base);
+        }
+    }
+
+    if (hi_crtc->cursor.status == 1) {
+        (void)adp_plane_close(&hi_crtc->cursor.base);
+    }
+
+    ret |= disp_dev->close(hi_crtc->id);
+    if (ret != 0) {
+        HI_DRM_ERR("disp_dev->close error, ret=%#x\n", ret);
+    }
+    hi_crtc->status = 0;
+    return ret;
+}
+
+int hi_adp_crtc_set_mode(struct drm_crtc *crtc, const struct drm_display_mode *mode)
+{
+    int ret;
+    struct drm_hal_timing timing;
+    enum drm_hal_timing_fmt fmt;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->set_attr);
+
+    timing.clock = mode->clock;
+    timing.hdisplay = mode->hdisplay;
+    timing.hskew = mode->hskew;
+    timing.hsync_end = mode->hsync_end;
+    timing.hsync_start = mode->hsync_start;
+    timing.htotal = mode->htotal;
+    timing.vdisplay = mode->vdisplay;
+    timing.vscan = mode->vscan;
+    timing.vsync_end = mode->vsync_end;
+    timing.vsync_start = mode->vsync_start;
+    timing.vtotal = mode->vtotal;
+
+    fmt = hi_adp_crtc_timing_translate(&timing);
+    ret = disp_dev->set_attr(hi_crtc->id, DRM_HAL_DISP_ATTR_TIMING, (void *)&fmt);
+    if (ret != 0) {
+        HI_DRM_ERR("disp_dev->set_attr timing error, ret=%#x\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+/* userfor mipitx */
+int hi_adp_crtc_add_user_intf(struct drm_crtc *crtc)
+{
+    int ret;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    hi_vo_user_intfsync_info intf_sync_attr = {0};
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    HI_DRM_CHECK_PTR_RETURN(crtc);
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->attach_user_intf_sync);
+
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->attach_user_intf_sync);
+    intf_sync_attr.clk_reverse = HI_TRUE;
+    intf_sync_attr.dev_div = 1;
+    intf_sync_attr.pre_div = 1;
+    intf_sync_attr.user_intf_sync_attr.clk_source = VO_CLK_SOURCE_PLL;
+    intf_sync_attr.user_intf_sync_attr.user_sync_pll.fbdiv = 257;
+    intf_sync_attr.user_intf_sync_attr.user_sync_pll.frac = 10442139;
+    intf_sync_attr.user_intf_sync_attr.user_sync_pll.refdiv = 4;
+    intf_sync_attr.user_intf_sync_attr.user_sync_pll.postdiv1 = 7;
+    intf_sync_attr.user_intf_sync_attr.user_sync_pll.postdiv2 = 7;
+    ret = disp_dev->attach_user_intf_sync(hi_crtc->id, &intf_sync_attr, 0);
+    if (ret != 0) {
+        HI_DRM_ERR("attach_user_intf_sync error, ret=%#x\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+int hi_adp_crtc_add_intf(struct drm_crtc *crtc, unsigned int intf_type, unsigned int intf_id)
+{
+    int ret;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->attach_intf);
+
+    ret = disp_dev->attach_intf(hi_crtc->id, intf_type, (void *)(&intf_id));
+    if (ret != 0) {
+        HI_DRM_ERR("dd->attach_intf error, ret=%#x\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+int hi_adp_crtc_del_intf(struct drm_crtc *crtc, unsigned int intf_type, unsigned int intf_id)
+{
+    int ret;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->detach_intf);
+
+    ret = disp_dev->detach_intf(hi_crtc->id, intf_type, (void *)(&intf_id));
+    if (ret != 0) {
+        HI_DRM_ERR("dd->detach_intf error, ret=%#x\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+int hi_adp_crtc_add_user_intf_sync(struct drm_crtc *crtc, hi_vo_user_intfsync_info *intf_sync_attr,
+    unsigned int intf_id)
+{
+    int ret;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    struct drm_hal_disp_dev *disp_dev = adp_crtc_get_disp_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev);
+    HI_DRM_CHECK_PTR_RETURN(disp_dev->attach_user_intf_sync);
+    ret = disp_dev->attach_user_intf_sync(hi_crtc->id, intf_sync_attr, (void *)(&intf_id));
+    if (ret != 0) {
+        HI_DRM_ERR("attach_user_intf_sync error, ret=%#x\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+
+static struct hi_drm_crtc *adp_get_crtc_by_layer(enum drm_hal_gfx_layer layer)
+{
+    int i;
+    struct drm_hal_gfx_capability cap = {0};
+
+    if (layer >= DRM_HAL_GFX_MAX) {
+        return NULL;
+    }
+
+    adp_gfx_get_capability(&cap);
+
+    if (cap.layer_cap[layer].available == 0) {
+        return NULL;
+    }
+
+    for (i = 0; i < HI_DRM_MAX_CRTC_NUM; i++) {
+        if (g_hi_crtcs->crtcs[i].id == cap.layer_cap[layer].connected_disp_chn) {
+            return &g_hi_crtcs->crtcs[i];
+        }
+    }
+    return NULL;
+}
+
+int hi_adp_disp_cb(enum drm_hal_gfx_layer layer, enum drm_hal_gfx_cb_type type, void *para)
+{
+    struct hi_drm_crtc *hi_crtc = adp_get_crtc_by_layer(layer);
+
+    HI_DRM_CHECK_PTR_RETURN(hi_crtc);
+
+    if (type == DRM_HAL_GFX_CB_INTR_100 && hi_crtc->adp_crtc_cb != NULL && hi_crtc->status != 0) {
+        return hi_crtc->adp_crtc_cb(&hi_crtc->base, HI_ADP_CRTC_VBLANK, para);
+    }
+    return 0;
+}
+
+int hi_adp_crtc_reg_callback(struct drm_crtc *crtc, adp_crtc_callback cb)
+{
+    int ret;
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    struct drm_plane *primary = crtc->primary;
+    struct hi_drm_plane *hi_plane = to_hi_plane(primary);
+    struct drm_hal_gfx_dev *gfx_dev = adp_crtc_get_gfx_func();
+
+    if (IS_ERR_OR_NULL(hi_crtc) || IS_ERR_OR_NULL(hi_plane) ||
+        IS_ERR_OR_NULL(gfx_dev) || IS_ERR_OR_NULL(gfx_dev->register_cb)) {
+        return -1;
+    }
+
+    /* the callback function has already be refistered */
+    if (hi_crtc->adp_crtc_cb != NULL) {
+        return 0;
+    }
+    /*
+     * register the callback to the layer of primary plane
+     * it is better that we can use the DHD interrupts from the display API, maybe we can improve this later
+     */
+    ret = gfx_dev->register_cb(hi_plane->id, DRM_HAL_GFX_CB_INTR_100, hi_adp_disp_cb);
+    if (ret != 0) {
+        HI_DRM_ERR("gfx dev register callback error\n");
+        return ret;
+    }
+    hi_crtc->adp_crtc_cb = cb;
+    return 0;
+}
+
+void hi_adp_crtc_set_vblank(struct drm_crtc *crtc, bool enable)
+{
+    struct hi_drm_crtc *hi_crtc = to_hi_crtc(crtc);
+    hi_crtc->vb_enable = enable;
+    return;
+}
+
+struct adp_crtc_timing_map {
+    enum drm_hal_timing_fmt timing_fmt;
+    struct drm_hal_timing timing;
+};
+
+static struct adp_crtc_timing_map g_adp_crtc_timing_map[] = {
+    {DRM_HAL_TIMING_FMT_1080P_60, {148500, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0}},
+    {DRM_HAL_TIMING_FMT_1080P_50, {148500, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1089, 1125, 0}},
+    {DRM_HAL_TIMING_FMT_1080P_59_94, {148352, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0}},
+    {DRM_HAL_TIMING_FMT_1080P_30, {74250, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0}},
+    {DRM_HAL_TIMING_FMT_1080P_25, {74250, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1089, 1125, 0}},
+    {DRM_HAL_TIMING_FMT_1080P_24, {74250, 1920, 2558, 2602, 2750, 0, 1080, 1084, 1089, 1125, 0}},
+    {DRM_HAL_TIMING_FMT_1080I_60, {74250, 1920, 2008, 2052, 2200, 0, 540, 542, 547, 562, 0}},
+    {DRM_HAL_TIMING_FMT_1080I_50, {74250, 1920, 2448, 2492, 2640, 0, 540, 542, 547, 562, 0}},
+    {DRM_HAL_TIMING_FMT_720P_60, {74250, 1280, 1390, 1430, 1650, 0, 720, 725, 730, 750, 0}},
+    {DRM_HAL_TIMING_FMT_720P_50, {74250, 1280, 1720, 1760, 1980, 0, 720, 725, 730, 750, 0}},
+    {DRM_HAL_TIMING_FMT_576P_50, {27000, 720, 732, 796, 864, 0, 576, 581, 586, 625, 0}},
+    {DRM_HAL_TIMING_FMT_480P_60, {27000, 720, 736, 798, 858, 0, 480, 489, 495, 525, 0}},
+    {DRM_HAL_TIMING_FMT_PAL, {13500, 720, 732, 795, 864, 0, 288, 290, 293, 312, 0}},
+    {DRM_HAL_TIMING_FMT_NTSC, {13500, 720, 739, 801, 858, 0, 240, 244, 247, 262, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_800X600_60, {40000, 800, 840, 968, 1056, 0, 600, 601, 605, 628, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_1024X768_60, {48400, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_1280X800_60, {83500, 1280, 1352, 1480, 1680, 0, 800, 803, 809, 831, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_1280X1024_60, {108000, 1280, 1328, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_1366X768_60, {85500, 1366, 1436, 1579, 1792, 0, 768, 771, 774, 798, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_1440X900_60, {106500, 1440, 1488, 1520, 1600, 0, 900, 903, 909, 926, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_1600X1200_60, {162000, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_1680X1050_60, {146250, 1680, 1784, 1960, 2240, 0, 1050, 1053, 1059, 1089, 0}},
+    {DRM_HAL_TIMING_FMT_VESA_1920X1200_60, {193250, 1920, 1968, 2000, 2080, 0, 1200, 1203, 1209, 1235, 0}},
+    {DRM_HAL_TIMING_FMT_2560X1440_60, {238750, 2560, 2608, 2640, 2720, 0, 1440, 1442, 1447, 1481, 0}},
+    {DRM_HAL_TIMING_FMT_2560X1600_60, {268500, 2560, 2608, 2640, 2720, 0, 1600, 1603, 1609, 1646, 0}},
+    {DRM_HAL_TIMING_FMT_3840X2160P_24, {297000, 3840, 5116, 5204, 5500, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_3840X2160P_25, {297000, 3840, 4896, 4984, 5280, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_3840X2160P_30, {297000, 3840, 4016, 4104, 4400, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_3840X2160P_50, {594000, 3840, 4896, 4984, 5280, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_3840X2160P_60, {594000, 3840, 4016, 4104, 4400, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_4096X2160P_24, {297000, 4096, 5116, 5204, 5500, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_4096X2160P_25, {297000, 4096, 5064, 5152, 5280, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_4096X2160P_30, {297000, 4096, 4184, 4272, 4400, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_4096X2160P_50, {594000, 4096, 5064, 5152, 5280, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_4096X2160P_60, {594000, 4096, 4184, 4272, 4400, 0, 2160, 2168, 2178, 2250, 0}},
+    {DRM_HAL_TIMING_FMT_USER, {155493, 400, 528, 560, 620, 0, 400, 963, 968, 974, 0}},
+};
+
+enum drm_hal_timing_fmt hi_adp_crtc_timing_translate(struct drm_hal_timing *timing)
+{
+    int i;
+
+    for (i = 0; i < sizeof(g_adp_crtc_timing_map) / sizeof(struct adp_crtc_timing_map); i++) {
+        if (g_adp_crtc_timing_map[i].timing.clock == timing->clock &&
+            g_adp_crtc_timing_map[i].timing.hdisplay == timing->hdisplay &&
+            g_adp_crtc_timing_map[i].timing.hsync_start == timing->hsync_start &&
+            g_adp_crtc_timing_map[i].timing.hsync_end == timing->hsync_end &&
+            g_adp_crtc_timing_map[i].timing.htotal == timing->htotal &&
+            g_adp_crtc_timing_map[i].timing.hskew == timing->hskew &&
+            g_adp_crtc_timing_map[i].timing.vdisplay == timing->vdisplay &&
+            g_adp_crtc_timing_map[i].timing.vsync_start == timing->vsync_start &&
+            g_adp_crtc_timing_map[i].timing.vsync_end == timing->vsync_end &&
+            g_adp_crtc_timing_map[i].timing.vtotal == timing->vtotal &&
+            g_adp_crtc_timing_map[i].timing.vscan == timing->vscan) {
+            break;
+        }
+    }
+
+    HI_DRM_INFO("find matched: i = %d!\n", i);
+
+    if (i == sizeof(g_adp_crtc_timing_map) / sizeof(struct adp_crtc_timing_map)) {
+        HI_DRM_ERR("can not find the matched format!\n");
+        HI_DRM_ERR("org timing: %d %d %d %d %d %d %d %d %d %d %d\n", timing->clock, timing->hdisplay,
+            timing->hsync_start, timing->hsync_end, timing->htotal, timing->hskew, timing->vdisplay,
+            timing->vsync_start, timing->vsync_end, timing->vtotal, timing->vscan);
+        return DRM_HAL_TIMING_FMT_MAX;
+    }
+    return g_adp_crtc_timing_map[i].timing_fmt;
+}
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_adp_crtc.h b/drivers/gpu/drm/hisilicon/hismart/hi_adp_crtc.h
new file mode 100644
index 000000000..31f13ff5f
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_adp_crtc.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __HI_ADP_CRTC_H__
+#define __HI_ADP_CRTC_H__
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_mode.h>
+#include "drm_hal_common.h"
+#include "hi_comm_vo_adapt.h"
+
+#define HI_DRM_MAX_CRTC_NUM     2
+#define HI_DRM_MAX_PRIMARY_NUM  2
+#define HI_DRM_MAX_OVERLAY_NUM  2
+
+enum hi_adp_crtc_event {
+    HI_ADP_CRTC_VBLANK,
+};
+
+struct hi_adp_crtc_cap {
+    int crtc_num;
+};
+
+int hi_adp_crtc_init(void);
+
+void hi_adp_crtc_deinit(void);
+
+void hi_adp_crtc_get_cap(struct hi_adp_crtc_cap *cap);
+
+int hi_adp_plane_get_by_index(struct drm_crtc *crtc, struct drm_plane **plane, enum drm_plane_type type, int index);
+
+int hi_adp_plane_open(struct drm_plane *plane);
+
+int hi_adp_plane_close(struct drm_plane *plane);
+
+void hi_adp_plane_update(struct drm_plane *plane);
+
+int hi_adp_crtc_get_by_index(struct drm_crtc **crtc, int index);
+
+int hi_adp_crtc_open(struct drm_crtc *crtc);
+
+int hi_adp_crtc_close(struct drm_crtc *crtc);
+
+int hi_adp_crtc_set_mode(struct drm_crtc *crtc, const struct drm_display_mode *mode);
+
+int hi_adp_crtc_add_user_intf(struct drm_crtc *crtc);
+
+int hi_adp_crtc_add_intf(struct drm_crtc *crtc, unsigned int intf_type, unsigned int intf_id);
+
+int hi_adp_crtc_del_intf(struct drm_crtc *crtc, unsigned int intf_type, unsigned int intf_id);
+
+int hi_adp_crtc_add_user_intf_sync(struct drm_crtc *crtc, hi_vo_user_intfsync_info *intf_sync_attr,
+    unsigned int intf_id);
+
+typedef int (*adp_crtc_callback)(struct drm_crtc *crtc, enum hi_adp_crtc_event event, void *para);
+
+int hi_adp_crtc_reg_callback(struct drm_crtc *crtc, adp_crtc_callback cb);
+
+void hi_adp_crtc_set_vblank(struct drm_crtc *crtc, bool enable);
+
+enum drm_hal_timing_fmt hi_adp_crtc_timing_translate(struct drm_hal_timing *timing);
+
+int hi_adp_plane_reset_csc(struct drm_plane *plane);
+
+#endif /* __HI_ADP_CRTC_H__ */
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_adp_hdmitx.c b/drivers/gpu/drm/hisilicon/hismart/hi_adp_hdmitx.c
new file mode 100644
index 000000000..7b72a0639
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_adp_hdmitx.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#include "hi_adp_hdmitx.h"
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_address.h>
+#include <video/videomode.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_util.h>
+#include "hi_drm_drv.h"
+#include "hi_adp_crtc.h"
+#include "drm_hal_common.h"
+#include "drm_hal_hdmitx.h"
+#include "drm_hal_display.h"
+#include "hi_drm_func_ext.h"
+
+#define HI_DRM_MAX_EDID_NUM   10
+
+struct hi_drm_hdmitx {
+    struct drm_connector conn;
+    struct drm_encoder encoder;
+
+    unsigned int drm_hdmi_id;
+    enum drm_hal_hdmitx_id hi_hdmi_id;
+
+    unsigned int open; /* 0: close, 1: open */
+    unsigned int enable; /* 0: disable, 1: enable */
+};
+
+#define to_hi_hdmitx_by_conn(x) container_of(x, struct hi_drm_hdmitx, conn)
+#define to_hi_hdmitx_by_encoder(x) container_of(x, struct hi_drm_hdmitx, encoder)
+
+struct hi_drm_hdmitx_global {
+    struct hi_drm_hdmitx hdmitx[HI_DRM_MAX_HDMI_NUM];
+    struct drm_hal_hdmitx_dev *hdmi_dev;
+};
+
+static struct hi_drm_hdmitx_global *g_hi_hdmitx = NULL;
+
+static struct drm_hal_hdmitx_dev* adp_hdmitx_get_intf_func(void)
+{
+    int ret;
+
+    if (g_hi_hdmitx->hdmi_dev != NULL) {
+        return g_hi_hdmitx->hdmi_dev;
+    }
+
+    ret = drm_get_export_func(MOD_ID_HDMI, (hi_void **)&g_hi_hdmitx->hdmi_dev);
+    if (ret != HI_SUCCESS) {
+        return NULL;
+    }
+
+    return (struct drm_hal_hdmitx_dev *)g_hi_hdmitx->hdmi_dev;
+}
+
+static int hdmitx_channel_check_open(struct hi_drm_hdmitx *hdmitx)
+{
+    int ret;
+    struct drm_hal_hdmitx_dev *hdmi_dev = adp_hdmitx_get_intf_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hdmitx);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev->open);
+
+    if (hdmitx->open == 1) {
+        return 0;
+    }
+
+    ret = hdmi_dev->open(hdmitx->hi_hdmi_id);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return ret;
+    }
+    hdmitx->open = 1;
+    return 0;
+}
+
+static int hdmitx_channel_check_close(struct hi_drm_hdmitx *hdmitx)
+{
+    int ret;
+    struct drm_hal_hdmitx_dev *hdmi_dev = adp_hdmitx_get_intf_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hdmitx);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev->close);
+
+    if (hdmitx->open == 0) {
+        return 0;
+    }
+
+    ret = hdmi_dev->close(hdmitx->hi_hdmi_id);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return ret;
+    }
+    hdmitx->open = 0;
+    return 0;
+}
+
+static int hdmitx_channel_check_enable(struct hi_drm_hdmitx *hdmitx)
+{
+    int ret;
+    struct drm_hal_hdmitx_dev *hdmi_dev = adp_hdmitx_get_intf_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hdmitx);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev->enable);
+
+    if (hdmitx->enable == 1) {
+        return 0;
+    }
+
+    ret = hdmi_dev->enable(hdmitx->hi_hdmi_id);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return ret;
+    }
+    hdmitx->enable = 1;
+    return 0;
+}
+
+static int hdmitx_channel_check_disable(struct hi_drm_hdmitx *hdmitx)
+{
+    int ret;
+    struct drm_hal_hdmitx_dev *hdmi_dev = adp_hdmitx_get_intf_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hdmitx);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev->disable);
+
+    if (hdmitx->enable == 0) {
+        return 0;
+    }
+
+    ret = hdmi_dev->disable(hdmitx->hi_hdmi_id);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return ret;
+    }
+    hdmitx->enable = 0;
+    return 0;
+}
+
+int hi_adp_hdmitx_get_edid(struct drm_connector *conn, void *edid, int len)
+{
+    int ret;
+    struct hi_drm_hdmitx *hi_hdmitx = to_hi_hdmitx_by_conn(conn);
+    struct drm_hal_hdmitx_dev *hdmi_dev = adp_hdmitx_get_intf_func();
+
+    HI_DRM_CHECK_PTR_RETURN(edid);
+    HI_DRM_CHECK_PTR_RETURN(hi_hdmitx);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev->read_edid);
+
+    ret = hdmitx_channel_check_open(hi_hdmitx);
+    if (ret != 0) {
+        return ret;
+    }
+
+    ret = hdmi_dev->read_edid(hi_hdmitx->hi_hdmi_id, edid, len);
+    if (ret <= 0) {
+        return -1;
+    }
+    return 0;
+}
+
+enum drm_connector_status hi_adp_hdmitx_detect(struct drm_connector *conn, bool force)
+{
+    int ret;
+    enum drm_hal_hdmitx_connect_status stat;
+    struct hi_drm_hdmitx *hi_hdmitx = to_hi_hdmitx_by_conn(conn);
+    struct drm_hal_hdmitx_dev *hdmi_dev = adp_hdmitx_get_intf_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_hdmitx);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev->get_status);
+
+    ret = hdmitx_channel_check_open(hi_hdmitx);
+    if (ret != 0) {
+        return ret;
+    }
+
+    ret = hdmi_dev->get_status(hi_hdmitx->hi_hdmi_id, DRM_HAL_HDMITX_STAT_CONNECTOR, &stat);
+    if (ret != 0) {
+        return connector_status_unknown;
+    }
+
+    HI_DRM_INFO("hdmitx status detected: %d\n", stat);
+
+    switch (stat) {
+        case DRM_HAL_HDMITX_CONNECTED:
+            return connector_status_connected;
+        case DRM_HAL_HDMITX_DISCONNECTED:
+            return connector_status_disconnected;
+        case DRM_HAL_HDMITX_UNKNOWN:
+            return connector_status_unknown;
+        default:
+            return connector_status_unknown;
+    }
+    return connector_status_unknown;
+}
+
+int hi_adp_hdmitx_enable(struct drm_encoder *encoder)
+{
+    int ret;
+    struct hi_drm_hdmitx *hi_hdmitx = to_hi_hdmitx_by_encoder(encoder);
+
+    HI_DRM_CHECK_PTR_RETURN(hi_hdmitx);
+
+    ret = hdmitx_channel_check_open(hi_hdmitx);
+    if (ret != 0) {
+        return ret;
+    }
+
+    ret = hdmitx_channel_check_enable(hi_hdmitx);
+    if (ret != 0) {
+        goto err_check_close;
+    }
+    return 0;
+err_check_close:
+    hdmitx_channel_check_close(hi_hdmitx);
+    return ret;
+}
+
+int hi_adp_hdmitx_disable(struct drm_encoder *encoder)
+{
+    int ret;
+    struct hi_drm_hdmitx *hi_hdmitx = to_hi_hdmitx_by_encoder(encoder);
+
+    HI_DRM_CHECK_PTR_RETURN(hi_hdmitx);
+
+    ret = hdmitx_channel_check_disable(hi_hdmitx);
+    if (ret != 0) {
+        return ret;
+    }
+
+    ret = hdmitx_channel_check_close(hi_hdmitx);
+    if (ret != 0) {
+        return ret;
+    }
+    return 0;
+}
+
+int hi_adp_hdmitx_set_mode(struct drm_encoder *encoder, struct drm_display_mode *mode,
+    struct drm_connector_state *conn_state)
+{
+    int ret;
+    struct drm_hal_hdmitx_attr hdmi_attr = {0};
+    struct drm_hal_timing timing;
+    struct hi_drm_hdmitx *hi_hdmitx = to_hi_hdmitx_by_encoder(encoder);
+    struct drm_hal_hdmitx_dev *hdmi_dev = adp_hdmitx_get_intf_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_hdmitx);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev->get_attr);
+    HI_DRM_CHECK_PTR_RETURN(hdmi_dev->set_attr);
+
+    ret = hdmitx_channel_check_open(hi_hdmitx);
+    if (ret != 0) {
+        return ret;
+    }
+
+    if (hi_hdmitx->enable == 1) {
+        return 0;
+    }
+
+    /* dispatch the mode to the connected crtc */
+    ret = hi_adp_crtc_set_mode(conn_state->crtc, mode);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    /* attach the interface to crtc */
+    ret = hi_adp_crtc_add_intf(conn_state->crtc, DRM_HAL_DISP_INTF_HDMITX, hi_hdmitx->hi_hdmi_id);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    ret = hdmi_dev->get_attr(hi_hdmitx->hi_hdmi_id, &hdmi_attr);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    timing.clock = mode->clock;
+    timing.hdisplay = mode->hdisplay;
+    timing.hskew = mode->hskew;
+    timing.hsync_end = mode->hsync_end;
+    timing.hsync_start = mode->hsync_start;
+    timing.htotal = mode->htotal;
+    timing.vdisplay = mode->vdisplay;
+    timing.vscan = mode->vscan;
+    timing.vsync_end = mode->vsync_end;
+    timing.vsync_start = mode->vsync_start;
+    timing.vtotal = mode->vtotal;
+    hdmi_attr.fmt = hi_adp_crtc_timing_translate(&timing);
+    ret = hdmi_dev->set_attr(hi_hdmitx->hi_hdmi_id, &hdmi_attr);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+    return 0;
+}
+
+int hi_adp_hdmitx_get_by_index(unsigned int drm_hdmi_id, struct drm_connector **conn, struct drm_encoder **encoder)
+{
+    HI_DRM_CHECK_PTR_RETURN(g_hi_hdmitx);
+
+    /* only support 1xHDMI yet */
+    if (drm_hdmi_id != DRM_MODE_CONNECTOR_HDMIA) {
+        return -1;
+    }
+
+    g_hi_hdmitx->hdmitx[0].drm_hdmi_id = drm_hdmi_id;
+    g_hi_hdmitx->hdmitx[0].hi_hdmi_id = DRM_HAL_HDMITX_0;
+    *conn = &g_hi_hdmitx->hdmitx[0].conn;
+    *encoder = &g_hi_hdmitx->hdmitx[0].encoder;
+    return 0;
+}
+
+int hi_adp_hdmitx_init(void)
+{
+    g_hi_hdmitx = kzalloc(sizeof(struct hi_drm_hdmitx_global), GFP_KERNEL);
+    if (g_hi_hdmitx == NULL) {
+        return -ENOMEM;
+    }
+
+    return 0;
+}
+
+void hi_adp_hdmitx_deinit(void)
+{
+    kfree(g_hi_hdmitx);
+    g_hi_hdmitx = NULL;
+}
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_adp_hdmitx.h b/drivers/gpu/drm/hisilicon/hismart/hi_adp_hdmitx.h
new file mode 100644
index 000000000..4c7f08883
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_adp_hdmitx.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __HI_ADP_HDMITX_H__
+#define __HI_ADP_HDMITX_H__
+
+#include <drm/drm_connector.h>
+#include <drm/drm_encoder.h>
+#include <drm/drm_modes.h>
+
+#define HI_DRM_MAX_HDMI_NUM 2
+
+int hi_adp_hdmitx_init(void);
+void hi_adp_hdmitx_deinit(void);
+int hi_adp_hdmitx_get_by_index(unsigned int drm_hdmi_id, struct drm_connector **conn, struct drm_encoder **encoder);
+int hi_adp_hdmitx_get_edid(struct drm_connector *conn, void *edid, int len);
+enum drm_connector_status hi_adp_hdmitx_detect(struct drm_connector *conn, bool force);
+int hi_adp_hdmitx_enable(struct drm_encoder *encoder);
+int hi_adp_hdmitx_disable(struct drm_encoder *encoder);
+int hi_adp_hdmitx_set_mode(struct drm_encoder *encoder, struct drm_display_mode *mode,
+    struct drm_connector_state *conn_state);
+
+#endif /* __HI_ADP_HDMITX_H__ */
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_adp_mipitx.c b/drivers/gpu/drm/hisilicon/hismart/hi_adp_mipitx.c
new file mode 100755
index 000000000..1902f1e8f
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_adp_mipitx.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#include "hi_adp_mipitx.h"
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_address.h>
+#include <video/videomode.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_util.h>
+#include <drm/drm_panel.h>
+#include "hi_drm_drv.h"
+#include "hi_adp_crtc.h"
+#include "drm_hal_mipitx.h"
+#include "drm_hal_display.h"
+
+#define MIPI_PHYSICAL_WIDTH 60
+#define MIPI_PHYSICAL_HEIGHT 120
+#define BRIGHTNESS_MAX       255
+#define DEFAULT_BRIGHTNESS   255
+
+struct ext_drm_tv_property {
+    struct drm_property *tv_brightness_property;
+};
+
+struct hi_drm_mipitx {
+    struct drm_connector conn;
+    struct drm_encoder encoder;
+
+    unsigned int drm_mipi_id;
+    unsigned int enable; /* 0: disable, 1: enable */
+    struct ext_drm_tv_property private;
+};
+
+#define to_hi_mipitx_by_conn(x) container_of(x, struct hi_drm_mipitx, conn)
+#define to_hi_mipitx_by_encoder(x) container_of(x, struct hi_drm_mipitx, encoder)
+
+struct hi_drm_mipitx_global {
+    struct hi_drm_mipitx mipitx;
+    struct DispOperations *mipi_dev;
+};
+
+static struct drm_display_mode default_mode = {
+    .clock = 155493, /* 155493 khz */
+    .hdisplay = 400, /* 400 width */
+    .hsync_start = 480 + 48, /* 480 48 alg data */
+    .hsync_end = 480 + 48 + 32, /* 480 48 32 alg data */
+    .htotal = 480 + 48 + 32 + 60, /* 480 48 32 60 alg data */
+    .vdisplay = 400, /* 400 height */
+    .vsync_start = 960 + 3, /* 960 3 alg data */
+    .vsync_end = 960 + 3 + 5, /* 960 3 5 alg data */
+    .vtotal = 960 + 3 + 5 + 6, /* 960 3  5 6 alg data */
+    .flags = 0, /* 0 alg data */
+};
+
+static struct hi_drm_mipitx_global *g_hi_mipitx = NULL;
+
+static struct DispOperations *adp_get_mipitx_func(void)
+{
+    int ret;
+
+    if (g_hi_mipitx->mipi_dev != NULL) {
+        return g_hi_mipitx->mipi_dev;
+    }
+
+    ///TODO:
+    g_hi_mipitx->mipi_dev = GetDispOps();
+    if (IS_ERR_OR_NULL(g_hi_mipitx->mipi_dev) || IS_ERR_OR_NULL(g_hi_mipitx->mipi_dev->init)) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return NULL;
+    }
+
+    ret = g_hi_mipitx->mipi_dev->init(DRM_HAL_GFX_G0);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return NULL;
+    }
+
+    return (struct DispOperations *)g_hi_mipitx->mipi_dev;
+}
+
+
+int hi_adp_mipitx_get_modes(struct drm_connector *connector)
+{
+    struct drm_display_mode *mode;
+    mode = drm_mode_duplicate(connector->dev, &default_mode);
+    if (mode == NULL) {
+        drm_hal_err("drm_mode_duplicate failure!\n");
+        return -ENOMEM;
+    }
+    drm_mode_set_name(mode);
+    drm_mode_probed_add(connector, mode);
+    connector->display_info.width_mm = MIPI_PHYSICAL_WIDTH;
+    connector->display_info.height_mm = MIPI_PHYSICAL_HEIGHT;
+    return 1;
+}
+
+int hi_adp_mipitx_set_mode(struct drm_encoder *encoder, struct drm_display_mode *mode,
+    struct drm_connector_state *conn_state)
+{
+    int ret;
+    struct hi_drm_mipitx *hi_mipitx = to_hi_mipitx_by_encoder(encoder);
+
+    HI_DRM_CHECK_PTR_RETURN(hi_mipitx);
+
+    if (hi_mipitx->enable == 1) {
+        return 0;
+    }
+
+    ret = hi_adp_crtc_add_user_intf(conn_state->crtc);
+    if (ret != 0) {
+        return ret;
+    }
+    /* dispatch the mode to the connected crtc */
+    ret = hi_adp_crtc_set_mode(conn_state->crtc, mode);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    /* attach the interface to crtc */
+    ret = hi_adp_crtc_add_intf(conn_state->crtc, DRM_HAL_DISP_INTF_MIPITX, hi_mipitx->drm_mipi_id);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+    }
+
+    return 0;
+}
+
+int hi_adp_mipitx_enable(struct drm_encoder *encoder)
+{
+    int ret;
+    struct hi_drm_mipitx *hi_mipitx = to_hi_mipitx_by_encoder(encoder);
+    struct DispOperations *mipi_dev = adp_get_mipitx_func();
+    HI_DRM_CHECK_PTR_RETURN(hi_mipitx);
+    HI_DRM_CHECK_PTR_RETURN(mipi_dev);
+    HI_DRM_CHECK_PTR_RETURN(mipi_dev->setBacklight);
+
+    if (hi_mipitx->enable == 1) {
+        return 0;
+    }
+
+    ret = mipi_dev->on(DRM_HAL_GFX_G0);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return ret;
+    }
+
+    hi_mipitx->enable = 1;
+    return 0;
+}
+
+int hi_adp_mipitx_disable(struct drm_encoder *encoder)
+{
+    int ret;
+    struct hi_drm_mipitx *hi_mipitx = to_hi_mipitx_by_encoder(encoder);
+    struct DispOperations *mipi_dev = adp_get_mipitx_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_mipitx);
+    HI_DRM_CHECK_PTR_RETURN(mipi_dev);
+    HI_DRM_CHECK_PTR_RETURN(mipi_dev->off);
+
+    if (hi_mipitx->enable == 0) {
+        return 0;
+    }
+
+    ret = mipi_dev->off(DRM_HAL_GFX_G0);
+    if (ret != 0) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return ret;
+    }
+
+    hi_mipitx->enable = 0;
+    return 0;
+}
+
+int adp_conn_atomic_set_property(struct drm_connector *connector, struct drm_connector_state *state,
+    struct drm_property *property, uint64_t val)
+{
+    struct hi_drm_mipitx *hi_mipitx = to_hi_mipitx_by_conn(connector);
+    if (property == hi_mipitx->private.tv_brightness_property) {
+        state->tv.brightness = val;
+    } else {
+        HI_DRM_ERR("[CONNECTOR:%d:%s] unknown property [PROP:%d%s]\n", connector->base.id,
+            connector->name, property->base.id, property->name);
+        return -EINVAL;
+    }
+    return 0;
+}
+
+int adp_conn_atomic_get_property(struct drm_connector *connector, const struct drm_connector_state *state,
+    struct drm_property *property, uint64_t *val)
+{
+    struct hi_drm_mipitx *hi_mipitx = to_hi_mipitx_by_conn(connector);
+
+    if (property == hi_mipitx->private.tv_brightness_property) {
+        *val = state->tv.brightness;
+    } else {
+        HI_DRM_ERR("[CONNECTOR:%d:%s] unknown property [PROP:%d%s]\n", connector->base.id,
+            connector->name, property->base.id, property->name);
+        return -EINVAL;
+    }
+    return 0;
+}
+
+int adp_mipi_set_brightness(struct drm_connector *connector,uint32_t brightness)
+{
+    int ret;
+    struct hi_drm_mipitx *hi_mipitx = to_hi_mipitx_by_conn(connector);
+    struct DispOperations *mipi_dev = adp_get_mipitx_func();
+
+    HI_DRM_CHECK_PTR_RETURN(hi_mipitx);
+    HI_DRM_CHECK_PTR_RETURN(mipi_dev);
+    HI_DRM_CHECK_PTR_RETURN(mipi_dev->setBacklight);
+    if (connector == NULL) {
+        return 0;
+    }
+    if (brightness < 0 || brightness >255) {
+        HI_DRM_INFO("brightness value out of range[0~255]!");
+        return 0;
+    }
+    ret = mipi_dev->setBacklight(DRM_HAL_GFX_G0, brightness);
+    if (ret != 0) {
+        drm_hal_err("error, ret = %#x!\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+int adp_conn_private_properties_init(struct drm_device *dev, struct drm_connector *connector)
+{
+    struct hi_drm_mipitx *hi_mipitx = to_hi_mipitx_by_conn(connector);
+
+    hi_mipitx->private.tv_brightness_property = drm_property_create_range(dev, 0, "brightness", 0, BRIGHTNESS_MAX);
+    if (hi_mipitx->private.tv_brightness_property == NULL) {
+        HI_DRM_ERR("tv_brightness_property create error\n");
+        return -ENOMEM;
+    }
+    drm_object_attach_property(&connector->base, hi_mipitx->private.tv_brightness_property, DEFAULT_BRIGHTNESS);
+    return 0;
+}
+
+void adp_conn_private_properties_deinit(struct drm_device *dev, struct drm_connector *connector)
+{
+    struct hi_drm_mipitx *hi_mipitx = to_hi_mipitx_by_conn(connector);
+
+    if (hi_mipitx->private.tv_brightness_property != NULL) {
+        drm_property_destroy(dev, hi_mipitx->private.tv_brightness_property);
+        hi_mipitx->private.tv_brightness_property = NULL;
+    }
+    return;
+}
+
+int hi_adp_mipitx_get_by_index(unsigned int drm_mipi_id, struct drm_connector **conn, struct drm_encoder **encoder)
+{
+    HI_DRM_CHECK_PTR_RETURN(g_hi_mipitx);
+
+    if (drm_mipi_id != DRM_MODE_CONNECTOR_DSI) {
+        return -1;
+    }
+
+    g_hi_mipitx->mipitx.drm_mipi_id = drm_mipi_id;
+    *conn = &g_hi_mipitx->mipitx.conn;
+    *encoder = &g_hi_mipitx->mipitx.encoder;
+
+    return 0;
+}
+
+int hi_adp_mipitx_init(void)
+{
+    int ret = -1;
+    g_hi_mipitx = kzalloc(sizeof(struct hi_drm_mipitx_global), GFP_KERNEL);
+    if (g_hi_mipitx == NULL) {
+        drm_hal_err("error, ret=%#x!\n", ret);
+        return -ENOMEM;
+    }
+
+    return 0;
+}
+
+void hi_adp_mipitx_deinit(void)
+{
+    if (IS_ERR_OR_NULL(g_hi_mipitx)) {
+        return;
+    }
+
+    kfree(g_hi_mipitx);
+    g_hi_mipitx = NULL;
+}
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_adp_mipitx.h b/drivers/gpu/drm/hisilicon/hismart/hi_adp_mipitx.h
new file mode 100644
index 000000000..a006da477
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_adp_mipitx.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __HI_ADP_MIPITX_H__
+#define __HI_ADP_MIPITX_H__
+
+#include <drm/drm_connector.h>
+#include <drm/drm_encoder.h>
+
+int hi_adp_mipitx_init(void);
+void hi_adp_mipitx_deinit(void);
+int hi_adp_mipitx_get_by_index(unsigned int drm_mipi_id, struct drm_connector **conn, struct drm_encoder **encoder);
+int hi_adp_mipitx_enable(struct drm_encoder *encoder);
+int hi_adp_mipitx_disable(struct drm_encoder *encoder);
+int hi_adp_mipitx_get_modes(struct drm_connector *connector);
+int hi_adp_mipitx_set_mode(struct drm_encoder *encoder, struct drm_display_mode *mode,
+    struct drm_connector_state *conn_state);
+
+int adp_conn_private_properties_init(struct drm_device *dev, struct drm_connector *connector);
+void adp_conn_private_properties_deinit(struct drm_device *dev, struct drm_connector *connector);
+int adp_conn_atomic_set_property(struct drm_connector *connector, struct drm_connector_state *state,
+    struct drm_property *property, uint64_t val);
+int adp_conn_atomic_get_property(struct drm_connector *connector, const struct drm_connector_state *state,
+    struct drm_property *property, uint64_t *val);
+int adp_mipi_set_brightness(struct drm_connector *connector,uint32_t brightness);
+
+#endif /* __HI_ADP_MIPITX_H__ */
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_crtc.c b/drivers/gpu/drm/hisilicon/hismart/hi_drm_crtc.c
new file mode 100755
index 000000000..ee41abf3b
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_crtc.c
@@ -0,0 +1,389 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#include "hi_drm_crtc.h"
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_address.h>
+#include <video/videomode.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_util.h>
+#include <drm/drm_vblank.h>
+#include "hi_drm_drv.h"
+#include "hi_adp_crtc.h"
+
+static const uint32_t hi_graphics_formats[] = {
+    DRM_FORMAT_ARGB8888,
+    DRM_FORMAT_XRGB8888,
+    DRM_FORMAT_RGB888,
+    DRM_FORMAT_RGB565,
+    DRM_FORMAT_ARGB1555,
+    DRM_FORMAT_ARGB4444,
+};
+
+static int hi_drm_plane_atomic_check(struct drm_plane *plane, struct drm_plane_state *state)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    /* open the plane at the begining */
+    ret = hi_adp_plane_open(plane);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_plane_open err, ret=%#x\n", ret);
+        return ret;
+    }
+
+    /*
+     * 1. after open gfx,default csc is RGB to YUV
+     * 2. hdmi use default csc
+     * 3. mipi close csc
+     */
+    ret = hi_adp_plane_reset_csc(plane);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_plane_reset_csc err, ret=%#x\n", ret);
+        return ret;
+    }
+
+    HI_DRM_FUNC_EXIT();
+    return 0;
+}
+
+static void hi_drm_plane_atomic_update(struct drm_plane *plane, struct drm_plane_state *old_state)
+{
+    HI_DRM_FUNC_ENTER();
+    hi_adp_plane_update(plane);
+    HI_DRM_FUNC_EXIT();
+}
+
+static const struct drm_plane_helper_funcs hi_drm_plane_helper_funcs = {
+    .atomic_check = hi_drm_plane_atomic_check,
+    .atomic_update = hi_drm_plane_atomic_update,
+};
+
+static void hi_drm_plane_destroy(struct drm_plane *plane)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_plane_close(plane);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_plane_close err, ret=%#x\n", ret);
+    }
+    drm_plane_cleanup(plane);
+    HI_DRM_FUNC_EXIT();
+}
+
+static const struct drm_plane_funcs hi_drm_plane_funcs = {
+    .update_plane = drm_atomic_helper_update_plane,
+    .disable_plane = drm_atomic_helper_disable_plane,
+    .destroy = hi_drm_plane_destroy,
+    .reset = drm_atomic_helper_plane_reset,
+    .atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+    .atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static int hi_drm_plane_init(struct drm_device *drm, struct drm_plane *plane, uint32_t possible_crtcs)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = drm_universal_plane_init(drm, plane, possible_crtcs, &hi_drm_plane_funcs, hi_graphics_formats,
+        ARRAY_SIZE(hi_graphics_formats), NULL, DRM_PLANE_TYPE_PRIMARY, NULL);
+    if (ret != 0) {
+        HI_DRM_ERR("drm_universal_plane_init err, ret=%#x\n", ret);
+        return ret;
+    }
+    drm_plane_helper_add(plane, &hi_drm_plane_helper_funcs);
+    HI_DRM_FUNC_EXIT();
+    return 0;
+}
+
+static void hi_drm_crtc_atomic_enable(struct drm_crtc *crtc, struct drm_crtc_state *old_state)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_crtc_open(crtc);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_crtc_open error, ret = %#x\n", ret);
+        return;
+    }
+    drm_crtc_vblank_on(crtc);
+    HI_DRM_FUNC_EXIT();
+}
+
+static void hi_drm_crtc_atomic_disable(struct drm_crtc *crtc, struct drm_crtc_state *old_state)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_crtc_close(crtc);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_crtc_close err, ret=%#x\n", ret);
+        return;
+    }
+    drm_crtc_vblank_off(crtc);
+    HI_DRM_FUNC_EXIT();
+}
+
+static void hi_drm_crtc_atomic_flush(struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state)
+{
+    struct drm_pending_vblank_event *event = crtc->state->event;
+    HI_DRM_FUNC_ENTER();
+
+    if (event == NULL) {
+        return;
+    }
+    crtc->state->event = NULL;
+    spin_lock_irq(&crtc->dev->event_lock);
+    if (drm_crtc_vblank_get(crtc) == 0) {
+        drm_crtc_arm_vblank_event(crtc, event);
+    } else {
+        drm_crtc_send_vblank_event(crtc, event);
+    }
+    spin_unlock_irq(&crtc->dev->event_lock);
+    HI_DRM_FUNC_EXIT();
+}
+
+static bool hi_drm_crtc_mode_fixup(struct drm_crtc *crtc,
+				const struct drm_display_mode *mode,
+				struct drm_display_mode *adjusted_mode)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_INFO("mode: %d %d %d %d %d %d %d %d %d %d %d\n",
+                crtc->state->mode.clock,
+                crtc->state->mode.hdisplay,
+                crtc->state->mode.hsync_start,
+                crtc->state->mode.hsync_end,
+                crtc->state->mode.htotal,
+                crtc->state->mode.hskew,
+                crtc->state->mode.vdisplay,
+                crtc->state->mode.vsync_start,
+                crtc->state->mode.vsync_end,
+                crtc->state->mode.vtotal,
+                crtc->state->mode.vscan);
+
+    HI_DRM_INFO("mode: %d %d %d %d %d %d %d %d %d %d %d\n",
+                mode->clock,
+                mode->hdisplay,
+                mode->hsync_start,
+                mode->hsync_end,
+                mode->htotal,
+                mode->hskew,
+                mode->vdisplay,
+                mode->vsync_start,
+                mode->vsync_end,
+                mode->vtotal,
+                mode->vscan);
+    ret = hi_adp_crtc_set_mode(crtc, mode);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_crtc_set_mode err, ret=%#x\n", ret);
+    }
+    HI_DRM_FUNC_EXIT();
+    return true;
+}
+
+static void hi_drm_crtc_atomic_begin(struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state)
+{
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_FUNC_EXIT();
+    return;
+}
+
+static const struct drm_crtc_helper_funcs hi_drm_crtc_helper_funcs = {
+    .mode_fixup = hi_drm_crtc_mode_fixup,
+    .atomic_enable = hi_drm_crtc_atomic_enable,
+    .atomic_disable = hi_drm_crtc_atomic_disable,
+    .atomic_begin = hi_drm_crtc_atomic_begin,
+    .atomic_flush = hi_drm_crtc_atomic_flush,
+};
+
+int hi_drm_crtc_callback(struct drm_crtc *crtc, enum hi_adp_crtc_event event, void *para)
+{
+    if (event != HI_ADP_CRTC_VBLANK) {
+        return -1;
+    }
+
+    if (drm_crtc_handle_vblank(crtc) != true) {
+        return -1;
+    }
+    return 0;
+}
+
+static int hi_drm_crtc_enable_vblank(struct drm_crtc *crtc)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+
+    ret = hi_adp_crtc_reg_callback(crtc, hi_drm_crtc_callback);
+    if (ret != 0) {
+        return ret;
+    }
+
+    hi_adp_crtc_set_vblank(crtc, true);
+
+    HI_DRM_FUNC_EXIT();
+
+    return 0;
+}
+
+static void hi_drm_crtc_disable_vblank(struct drm_crtc *crtc)
+{
+    HI_DRM_FUNC_ENTER();
+
+    hi_adp_crtc_set_vblank(crtc, false);
+
+    hi_adp_crtc_reg_callback(crtc, NULL);
+
+    HI_DRM_FUNC_EXIT();
+}
+
+static void hi_drm_crtc_destroy(struct drm_crtc *crtc)
+{
+    int ret;
+
+    HI_DRM_FUNC_ENTER();
+    /* ensure the crtc closed in the final cleanup call */
+    ret = hi_adp_crtc_close(crtc);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_crtc_close err, ret=%#x\n", ret);
+    }
+    drm_crtc_cleanup(crtc);
+    HI_DRM_FUNC_EXIT();
+}
+
+static const struct drm_crtc_funcs hi_drm_crtc_funcs = {
+    .set_config = drm_atomic_helper_set_config,
+    .page_flip = drm_atomic_helper_page_flip,
+    .destroy = hi_drm_crtc_destroy,
+    .reset = drm_atomic_helper_crtc_reset,
+    .atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+    .atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+    .enable_vblank = hi_drm_crtc_enable_vblank,
+    .disable_vblank = hi_drm_crtc_disable_vblank,
+};
+
+static void hi_drm_crtc_init_by_index(struct drm_device *drm, int index)
+{
+    int ret;
+    struct drm_plane *primary = NULL;
+    struct drm_crtc *crtc = NULL;
+
+    HI_DRM_FUNC_ENTER();
+    /* get the crtc resource */
+    ret = hi_adp_crtc_get_by_index(&crtc, index);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_crtc_get_by_index err, ret=%#x\n", ret);
+        return;
+    }
+
+    /* get the primary 0 plane on this crtc */
+    ret = hi_adp_plane_get_by_index(crtc, &primary, DRM_PLANE_TYPE_PRIMARY, 0);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_plane_get_by_index err, ret=%#x\n", ret);
+        return;
+    }
+
+    ret = hi_drm_plane_init(drm, primary, index + 1);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_drm_plane_init err, ret=%#x\n", ret);
+        return;
+    }
+
+    ret = drm_crtc_init_with_planes(drm, crtc, primary, NULL, &hi_drm_crtc_funcs, NULL);
+    if (ret != 0) {
+        HI_DRM_ERR("drm_crtc_init_with_planes error, ret = %#x\n", ret);
+        return;
+    }
+    drm_crtc_helper_add(crtc, &hi_drm_crtc_helper_funcs);
+    HI_DRM_INFO("crtc %p index %d, plane id %d\n", crtc, crtc->index, primary->index);
+    HI_DRM_FUNC_EXIT();
+    return;
+}
+
+static void hi_drm_crtc_cleanup_by_index(struct drm_device *drm, int index)
+{
+    int ret;
+    struct drm_crtc *crtc = NULL;
+
+    ret = hi_adp_crtc_get_by_index(&crtc, index);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_crtc_get_by_index err, ret=%#x\n", ret);
+        return;
+    }
+    hi_drm_plane_destroy(crtc->primary);
+    hi_drm_crtc_destroy(crtc);
+}
+
+int hi_drm_crtc_init(struct drm_device *drm)
+{
+    int ret;
+    int i;
+    struct hi_adp_crtc_cap cap;
+
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_crtc_init();
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_crtc_init error, ret=%#x\n", ret);
+        return ret;
+    }
+
+    hi_adp_crtc_get_cap(&cap);
+
+    for (i = 0; i < cap.crtc_num; i++) {
+        hi_drm_crtc_init_by_index(drm, i);
+    }
+    HI_DRM_FUNC_EXIT();
+    return 0;
+}
+
+void hi_drm_crtc_cleanup(struct drm_device *drm)
+{
+    int i;
+    struct hi_adp_crtc_cap cap;
+
+    HI_DRM_FUNC_ENTER();
+    hi_adp_crtc_get_cap(&cap);
+    for (i = 0; i < cap.crtc_num; i++) {
+        hi_drm_crtc_cleanup_by_index(drm, i);
+    }
+    hi_adp_crtc_deinit();
+    HI_DRM_FUNC_EXIT();
+}
+
+void hi_drm_crtc_lastclose(struct drm_device *drm)
+{
+    int ret;
+    int i;
+    int j;
+    struct hi_adp_crtc_cap cap;
+    struct drm_crtc *crtc = NULL;
+    struct drm_plane *plane = NULL;
+
+    HI_DRM_FUNC_ENTER();
+
+    hi_adp_crtc_get_cap(&cap);
+    for (i = 0; i < cap.crtc_num; i++) {
+        ret = hi_adp_crtc_get_by_index(&crtc, i);
+        if (ret != 0) {
+            continue;
+        }
+        HI_DRM_INFO("now close the crtc, id=%d\n", i);
+        (void)hi_adp_crtc_close(crtc);
+        /* only support primary plane yet */
+        for (j = 0; j < HI_DRM_MAX_PRIMARY_NUM; j++) {
+            ret = hi_adp_plane_get_by_index(crtc, &plane, DRM_PLANE_TYPE_PRIMARY, j);
+            if (ret != 0) {
+                continue;
+            }
+            HI_DRM_INFO("now close the plane, id=%d\n", j);
+            (void)hi_adp_plane_close(plane);
+        }
+    }
+    HI_DRM_FUNC_EXIT();
+}
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_crtc.h b/drivers/gpu/drm/hisilicon/hismart/hi_drm_crtc.h
new file mode 100644
index 000000000..ebe7aac6f
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_crtc.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __HI_DRM_CTRC_H__
+#define __HI_DRM_CTRC_H__
+
+#include <drm/drm_device.h>
+
+int hi_drm_crtc_init(struct drm_device *drm);
+void hi_drm_crtc_cleanup(struct drm_device *drm);
+void hi_drm_crtc_lastclose(struct drm_device *drm);
+
+#endif /* __HI_DRM_CTRC_H__ */
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_drv.c b/drivers/gpu/drm/hisilicon/hismart/hi_drm_drv.c
new file mode 100755
index 000000000..075cb248c
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_drv.c
@@ -0,0 +1,385 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#include "hi_drm_drv.h"
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/of_platform.h>
+#include <linux/spinlock.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_util.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_vblank.h>
+#include "hi_drm_crtc.h"
+#include "hi_drm_hdmitx.h"
+#include "hi_drm_mipitx.h"
+#include "hisilicon_drm.h"
+#include "osal_list.h"
+#include "hi_adp_mipitx.h"
+#define DRIVER_NAME "hisilicon"
+#define DRIVER_DESC "hisilicon Soc DRM"
+#define DRIVER_DATE "20200602"
+#define DRIVER_MAJOR    1
+#define DRIVER_MINOR    0
+
+#define HI_DRM_MAX_WIDTH    8192
+#define HI_DRM_MAX_HEIGHT   8192
+
+struct hi_drm_phys {
+    unsigned long long phys_addr;
+    unsigned long long size;
+    struct osal_list_head list;
+};
+OSAL_LIST_HEAD(g_phys_addr);
+
+static struct drm_device *drm_dev;
+
+static const struct file_operations hi_drm_driver_fops = {
+    .owner = THIS_MODULE,
+    .open = drm_open,
+    .poll = drm_poll,
+    .read = drm_read,
+    .unlocked_ioctl = drm_ioctl,
+    .compat_ioctl = drm_compat_ioctl,
+    .release = drm_release,
+    .mmap = drm_gem_cma_mmap,
+};
+
+static void hi_drm_lastclose(struct drm_device *dev)
+{
+    HI_DRM_INFO("=========== come to the last close! ===========\n");
+
+    hi_drm_crtc_lastclose(dev);
+}
+
+static int hi_drm_get_prime_phyaddr(struct drm_device *dev, void *data, struct drm_file *file)
+{
+    struct drm_hisilicon_phyaddr *arg = data;
+    struct drm_gem_object *gem_obj = NULL;
+    struct sg_table *sgt = NULL;
+    struct page *page = NULL;
+    int ret;
+    uint32_t handle = 0;
+    ret = drm_gem_prime_fd_to_handle(dev, file, arg->fd, &handle);
+    if (ret) {
+        HI_DRM_ERR("fd %d to handle failed", arg->fd);
+        return -1;
+    }
+    gem_obj = drm_gem_object_lookup(file, handle);
+    if (gem_obj == NULL) {
+        HI_DRM_ERR("gem object not finde fd %d, handle 0x%x", arg->fd, handle);
+        return -1;
+    }
+    sgt = drm_gem_cma_prime_get_sg_table(gem_obj);
+    if (sgt == NULL) {
+        HI_DRM_ERR("gem prime get sg_table failed");
+        drm_gem_object_put(gem_obj);
+        return -1;
+    }
+    page = sg_page(sgt->sgl);
+    arg->phyaddr = PFN_PHYS(page_to_pfn(page));
+    drm_gem_object_put(gem_obj);
+    return 0;
+}
+
+static const struct drm_ioctl_desc hidrm_ioctls[] = {
+    DRM_IOCTL_DEF_DRV(HISILICON_GEM_FD_TO_PHYADDR, hi_drm_get_prime_phyaddr, DRM_UNLOCKED),
+};
+
+int drm_check_dumb_phy_addr(unsigned long long addr_start, unsigned long long size)
+{
+    struct hi_drm_phys *p = NULL;
+    unsigned long long addr_end = addr_start + size;
+    unsigned long long temp_start, temp_end;
+    /* if address is valid */
+    osal_list_for_each_entry(p, &g_phys_addr, list) {
+        temp_start = p->phys_addr;
+        temp_end = p->phys_addr + p->size;
+        if ((addr_start >= temp_start) && (addr_end <= temp_end)) {
+            return 0;
+        }
+    }
+    HI_DRM_ERR("drm_check_dumb_phy_addr, addr_start-addr_end [0x%llx-0x%llx]\n", addr_start, addr_end);
+    return -1;
+}
+EXPORT_SYMBOL(drm_check_dumb_phy_addr);
+
+static int hi_drm_gem_cma_dumb_create(struct drm_file *file_priv, struct drm_device *drm,
+    struct drm_mode_create_dumb *args)
+{
+    int ret;
+    struct drm_gem_object *gem_obj = NULL;
+    struct sg_table *sgt = NULL;
+    struct page *page = NULL;
+    struct hi_drm_phys *node = NULL;
+    ret = drm_gem_cma_dumb_create(file_priv, drm, args);
+    if (ret != 0) {
+        return ret;
+    }
+
+    node = kmalloc(sizeof(struct hi_drm_phys), GFP_KERNEL);
+    if (node == NULL) {
+        HI_DRM_ERR("kmalloc node failed\n");
+        return 0;
+    }
+    (void)memset(node, 0, sizeof(struct hi_drm_phys));
+
+    /* get phyaddr and size */
+    gem_obj = drm_gem_object_lookup(file_priv, args->handle);
+    if (gem_obj == NULL) {
+        HI_DRM_ERR("gem object not finde handle 0x%x", args->handle);
+        kfree(node);
+        return -1;
+    }
+    sgt = drm_gem_cma_prime_get_sg_table(gem_obj);
+    if (sgt == NULL) {
+        HI_DRM_ERR("gem prime get sg_table failed");
+        drm_gem_object_put(gem_obj);
+        kfree(node);
+        return -1;
+    }
+    page = sg_page(sgt->sgl);
+    node->phys_addr = PFN_PHYS(page_to_pfn(page));
+    node->size = args->size;
+    drm_gem_object_put(gem_obj);
+    osal_list_add(&node->list, &g_phys_addr);
+    return 0;
+}
+
+static void hi_drm_gem_cma_free_object(struct drm_gem_object *gem_obj)
+{
+    struct sg_table *sgt = NULL;
+    struct page *page = NULL;
+    struct hi_drm_phys *p = NULL;
+    unsigned long long phyaddr;
+
+    sgt = drm_gem_cma_prime_get_sg_table(gem_obj);
+    if (sgt == NULL) {
+        HI_DRM_ERR("gem prime get sg_table failed");
+        return;
+    }
+    page = sg_page(sgt->sgl);
+    phyaddr = PFN_PHYS(page_to_pfn(page));
+
+    drm_gem_cma_free_object(gem_obj);
+    osal_list_for_each_entry(p, &g_phys_addr, list) {
+        if (p->phys_addr == phyaddr) {
+            osal_list_del(&p->list);
+            kfree(p);
+            return;
+        }
+    }
+    HI_DRM_ERR("list has no node to del\n");
+    return;
+}
+
+static struct drm_driver hi_drm_driver = {
+    .driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_RENDER | DRIVER_ATOMIC,
+    .lastclose = hi_drm_lastclose,
+    .dumb_create = hi_drm_gem_cma_dumb_create,
+    .gem_vm_ops = &drm_gem_cma_vm_ops,
+    .gem_free_object_unlocked = hi_drm_gem_cma_free_object,
+    .prime_handle_to_fd = drm_gem_prime_handle_to_fd,
+    .prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+    .gem_prime_import = drm_gem_prime_import,
+    .gem_prime_export = drm_gem_prime_export,
+    .gem_prime_get_sg_table = drm_gem_cma_prime_get_sg_table,
+    .gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
+    .gem_prime_vmap = drm_gem_cma_prime_vmap,
+    .gem_prime_vunmap = drm_gem_cma_prime_vunmap,
+    .gem_prime_mmap = drm_gem_cma_prime_mmap,
+    .fops = &hi_drm_driver_fops,
+    .name = DRIVER_NAME,
+    .desc = DRIVER_DESC,
+    .date = DRIVER_DATE,
+    .major = DRIVER_MAJOR,
+    .minor = DRIVER_MINOR,
+    .ioctls = hidrm_ioctls,
+    .num_ioctls = ARRAY_SIZE(hidrm_ioctls),
+};
+
+static struct drm_framebuffer *hi_drm_fb_create(struct drm_device *dev,
+    struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd)
+{
+    return drm_gem_fb_create(dev, file_priv, mode_cmd);
+}
+
+int hi_drm_atomic_helper_commit(struct drm_device *dev, struct drm_atomic_state *state, bool nonblock)
+{
+    struct drm_connector *connector = NULL;
+    struct drm_connector_state *old_connector_state = NULL;
+    struct drm_connector_state *new_connector_state = NULL;
+    int i;
+
+    for_each_oldnew_connector_in_state(state, connector, old_connector_state, new_connector_state, i) {
+        if ((connector->connector_type == DRM_MODE_CONNECTOR_DSI) &&
+            (old_connector_state->tv.brightness != new_connector_state->tv.brightness)) {
+            adp_mipi_set_brightness(connector, new_connector_state->tv.brightness);
+        }
+    }
+    return drm_atomic_helper_commit(dev, state, nonblock);
+}
+
+static const struct drm_mode_config_funcs hi_drm_mode_config_funcs = {
+    .fb_create = hi_drm_fb_create,
+    .atomic_check = drm_atomic_helper_check,
+    .atomic_commit = hi_drm_atomic_helper_commit,
+};
+
+static void hi_drm_mode_config_init(struct drm_device *dev)
+{
+    dev->mode_config.min_width = 0;
+    dev->mode_config.min_height = 0;
+    dev->mode_config.max_width = HI_DRM_MAX_WIDTH;
+    dev->mode_config.max_height = HI_DRM_MAX_HEIGHT;
+    dev->mode_config.funcs = &hi_drm_mode_config_funcs;
+}
+
+static int hi_drm_kms_init(struct drm_device *drm)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    drm_mode_config_init(drm);
+    hi_drm_mode_config_init(drm);
+    ret = hi_drm_crtc_init(drm);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_drm_crtc_init err, ret=%#x\n", ret);
+        goto err_mode_cleanup;
+    }
+    ret = hi_drm_hdmitx_init(drm);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_drm_hdmitx_init err, ret=%#x\n", ret);
+        goto err_crtc_cleanup;
+    }
+    ret = hi_drm_mipitx_init(drm);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_drm_mipitx_init err, ret=%#x\n", ret);
+        goto err_hdmi_connector_cleanup;
+    }
+    ret = drm_vblank_init(drm, drm->mode_config.num_crtc);
+    if (ret != 0) {
+        HI_DRM_ERR("drm_vblank_init err, ret=%#x\n", ret);
+        goto err_all_connector_cleanup;
+    }
+
+    drm->irq_enabled = true;
+    drm_mode_config_reset(drm);
+    HI_DRM_FUNC_EXIT();
+    return 0;
+err_all_connector_cleanup:
+    hi_drm_mipitx_cleanup(drm);
+err_hdmi_connector_cleanup:
+    hi_drm_hdmitx_cleanup(drm);
+err_crtc_cleanup:
+    hi_drm_crtc_cleanup(drm);
+err_mode_cleanup:
+    drm_mode_config_cleanup(drm);
+    return ret;
+}
+
+static void hi_drm_kms_cleanup(struct drm_device *drm)
+{
+    HI_DRM_FUNC_ENTER();
+
+    hi_drm_hdmitx_cleanup(drm);
+
+    hi_drm_crtc_cleanup(drm);
+
+    drm_mode_config_cleanup(drm);
+
+    HI_DRM_FUNC_EXIT();
+}
+
+static int hi_drm_platform_probe(struct platform_device *pdev)
+{
+    struct drm_driver *driver = &hi_drm_driver;
+    struct hi_drm_private *private = NULL;
+    struct device *dev = &pdev->dev;
+    int ret;
+
+    HI_DRM_FUNC_ENTER();
+
+    drm_dev = drm_dev_alloc(driver, dev);
+    if (IS_ERR(drm_dev)) {
+        return PTR_ERR(drm_dev);
+    }
+
+    private = devm_kzalloc(drm_dev->dev, sizeof(struct hi_drm_private), GFP_KERNEL);
+    if (private == NULL) {
+        ret = -ENOMEM;
+        goto err_put_drm_dev;
+    }
+
+    drm_dev->dev_private = private;
+
+    ret = hi_drm_kms_init(drm_dev);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_drm_kms_init err, ret=%#x\n", ret);
+        goto err_drm_priv_free;
+    }
+
+    ret = drm_dev_register(drm_dev, 0);
+    if (ret != 0) {
+        HI_DRM_ERR("drm_dev_init err, ret=%#x\n", ret);
+        goto err_drm_kms_cleanup;
+    }
+
+    HI_DRM_FUNC_EXIT();
+
+    return 0;
+
+err_drm_kms_cleanup:
+    hi_drm_kms_cleanup(drm_dev);
+err_drm_priv_free:
+    devm_kfree(drm_dev->dev, drm_dev->dev_private);
+    drm_dev->dev_private = NULL;
+err_put_drm_dev:
+    drm_dev_put(drm_dev);
+    return ret;
+}
+
+static int hi_drm_platform_remove(struct platform_device *pdev)
+{
+    devm_kfree(drm_dev->dev, drm_dev->dev_private);
+    drm_dev->dev_private = NULL;
+
+    drm_dev_unregister(drm_dev);
+
+    hi_drm_kms_cleanup(drm_dev);
+
+    drm_dev_put(drm_dev);
+
+    return 0;
+}
+
+static const struct of_device_id hi_drm_dt_ids[] = {
+    { .compatible = "hisilicon,hi-drm", },
+    { /* sentinel */ },
+};
+
+static struct platform_driver hi_drm_platform_driver = {
+    .probe = hi_drm_platform_probe,
+    .remove = hi_drm_platform_remove,
+    .driver = {
+        .name = "hi-drm",
+        .of_match_table = hi_drm_dt_ids,
+    },
+};
+
+module_platform_driver(hi_drm_platform_driver);
+
+MODULE_DESCRIPTION("hisilicon DRM driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_drv.h b/drivers/gpu/drm/hisilicon/hismart/hi_drm_drv.h
new file mode 100755
index 000000000..c399f78b6
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_drv.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __HI_DRM_DRV_H__
+#define __HI_DRM_DRV_H__
+
+#include <drm/drm_util.h>
+
+#define HI_DRM_FUNC_ENTER() DRM_DEBUG("function %s enter...\n", __FUNCTION__)
+#define HI_DRM_FUNC_EXIT() DRM_DEBUG("function %s exit...\n", __FUNCTION__)
+#define HI_DRM_ERR(fmt...) DRM_ERROR(fmt)
+#define HI_DRM_WARN(fmt...) DRM_WARN(fmt)
+#define HI_DRM_INFO(fmt...) DRM_DEBUG(fmt)
+
+#define HI_DRM_CHECK_PTR_RETURN(ptr) do { \
+    if (IS_ERR_OR_NULL(ptr)) { \
+        return -PTR_ERR(ptr); \
+    } \
+} while (0)
+
+struct hi_drm_private {
+    void *reserved;
+};
+
+#endif /* __HI_DRM_DRV_H__ */
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_func_ext.c b/drivers/gpu/drm/hisilicon/hismart/hi_drm_func_ext.c
new file mode 100644
index 000000000..f29e7f998
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_func_ext.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#include "hi_drm_func_ext.h"
+#include <linux/module.h>
+#include <linux/stddef.h>
+
+hi_drm_export_func g_drm_ext_func = {
+    .disp_func = NULL,
+    .gfx_func = NULL,
+    .hdmi_func = NULL,
+};
+
+int drm_get_export_func(enum hi_mod_ext_id mod_id, void **func)
+{
+    if (func == NULL) {
+        return -1;
+    }
+    switch (mod_id) {
+        case MOD_ID_DISP:
+            *func = g_drm_ext_func.disp_func;
+            break;
+        case MOD_ID_GFX:
+            *func = g_drm_ext_func.gfx_func;
+            break;
+        case MOD_ID_HDMI:
+            *func = g_drm_ext_func.hdmi_func;
+            break;
+        default:
+            return -1;
+    }
+    return 0;
+}
+
+hi_drm_export_func *drm_export_func_register()
+{
+    return &g_drm_ext_func;
+}
+EXPORT_SYMBOL(drm_export_func_register);
\ No newline at end of file
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_func_ext.h b/drivers/gpu/drm/hisilicon/hismart/hi_drm_func_ext.h
new file mode 100644
index 000000000..83a96b22b
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_func_ext.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __HI_DRM_FUNC_EXT_H__
+#define __HI_DRM_FUNC_EXT_H__
+
+enum hi_mod_ext_id {
+    MOD_ID_DISP,
+    MOD_ID_GFX,
+    MOD_ID_HDMI,
+    MOD_ID_MAX
+};
+
+typedef struct {
+    void *disp_func;
+    void *gfx_func;
+    void *hdmi_func;
+}hi_drm_export_func;
+
+int drm_get_export_func(enum hi_mod_ext_id, void **);
+hi_drm_export_func *drm_export_func_register(void);
+
+#endif /* __HI_DRM_FUNC_EXT_H__ */
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_hdmitx.c b/drivers/gpu/drm/hisilicon/hismart/hi_drm_hdmitx.c
new file mode 100755
index 000000000..1d11d98a2
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_hdmitx.c
@@ -0,0 +1,233 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#include "hi_drm_hdmitx.h"
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_address.h>
+#include <video/videomode.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_util.h>
+#include <drm/drm_probe_helper.h>
+#include "hi_drm_drv.h"
+#include "hi_adp_hdmitx.h"
+#include "hi_adp_crtc.h"
+
+static int hi_conn_get_modes(struct drm_connector *connector)
+{
+    int ret;
+    int count;
+    struct edid *edid = NULL;
+    void *data = NULL;
+    const int max_edid_num = 4;
+
+    HI_DRM_FUNC_ENTER();
+    data = kzalloc(sizeof(struct edid) * max_edid_num, GFP_KERNEL);
+    if (data == NULL) {
+        return -ENOMEM;
+    }
+
+    ret = hi_adp_hdmitx_get_edid(connector, data, sizeof(struct edid) * max_edid_num);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_hdmitx_get_edid err, ret=%#x\n", ret);
+        goto hdmitx_free_data;
+    }
+
+    edid = (struct edid *)data;
+    ret = drm_connector_update_edid_property(connector, edid);
+    if (ret != 0) {
+        HI_DRM_ERR("drm_mode_connector_update_edid_property err, ret=%#x\n", ret);
+        goto hdmitx_free_data;
+    }
+    count = drm_add_edid_modes(connector, edid);
+    kfree(data);
+    HI_DRM_FUNC_EXIT();
+    return count;
+hdmitx_free_data:
+    kfree(data);
+    return ret;
+}
+
+static enum drm_connector_status hi_conn_detect(struct drm_connector *connector, bool force)
+{
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_FUNC_EXIT();
+    return hi_adp_hdmitx_detect(connector, force);
+}
+
+static const struct drm_connector_helper_funcs hi_conn_helper_funcs = {
+    .get_modes = hi_conn_get_modes,
+};
+
+static const struct drm_connector_funcs hi_connector_funcs = {
+    .fill_modes = drm_helper_probe_single_connector_modes,
+    .detect = hi_conn_detect,
+    .destroy = drm_connector_cleanup,
+    .reset = drm_atomic_helper_connector_reset,
+    .atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+    .atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static int hi_encoder_atomic_check(struct drm_encoder *encoder, struct drm_crtc_state *crtc_state,
+    struct drm_connector_state *conn_state)
+{
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_INFO("mode: %d %d %d %d %d %d %d %d %d %d %d\n",
+                crtc_state->mode.clock,
+                crtc_state->mode.hdisplay,
+                crtc_state->mode.hsync_start,
+                crtc_state->mode.hsync_end,
+                crtc_state->mode.htotal,
+                crtc_state->mode.hskew,
+                crtc_state->mode.vdisplay,
+                crtc_state->mode.vsync_start,
+                crtc_state->mode.vsync_end,
+                crtc_state->mode.vtotal,
+                crtc_state->mode.vscan);
+    hi_adp_hdmitx_set_mode(encoder, &crtc_state->mode, conn_state);
+    HI_DRM_FUNC_EXIT();
+
+    return 0;
+}
+
+static void hi_encoder_enable(struct drm_encoder *encoder)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_hdmitx_enable(encoder);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_hdmitx_enable err, ret=%#x\n", ret);
+    }
+    HI_DRM_FUNC_EXIT();
+}
+
+static void hi_encoder_disable(struct drm_encoder *encoder)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+
+    ret = hi_adp_hdmitx_disable(encoder);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_hdmitx_enable err, ret=%#x\n", ret);
+    }
+    HI_DRM_FUNC_EXIT();
+}
+
+static enum drm_mode_status hi_encoder_mode_valid(struct drm_encoder *encoder, const struct drm_display_mode *mode)
+{
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_FUNC_EXIT();
+    return MODE_OK;
+}
+
+static void hi_encoder_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,
+    struct drm_display_mode *adj_mode)
+{
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_FUNC_EXIT();
+}
+
+static const struct drm_encoder_helper_funcs hi_encoder_helper_funcs = {
+    .atomic_check = hi_encoder_atomic_check,
+    .mode_valid = hi_encoder_mode_valid,
+    .mode_set = hi_encoder_mode_set,
+    .enable = hi_encoder_enable,
+    .disable = hi_encoder_disable
+};
+
+static void hi_drm_encoder_destroy(struct drm_encoder *encoder)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+
+    ret = hi_adp_hdmitx_disable(encoder);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_hdmitx_disable err, ret=%#x\n", ret);
+    }
+    drm_encoder_cleanup(encoder);
+    HI_DRM_FUNC_EXIT();
+}
+
+static const struct drm_encoder_funcs hi_encoder_funcs = {
+    .destroy = hi_drm_encoder_destroy,
+};
+
+static void hdmitx_init_by_index(struct drm_device *drm, unsigned int id)
+{
+    int ret;
+    struct drm_connector *conn = NULL;
+    struct drm_encoder *encoder = NULL;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_hdmitx_get_by_index(id, &conn, &encoder);
+    if (ret != 0) {
+        HI_DRM_INFO("hdmi id %u not support!\n", id);
+        return;
+    }
+
+    if (id == DRM_MODE_CONNECTOR_HDMIA) {
+        encoder->possible_crtcs = 1; /* 1: dhd0 */
+    } else {
+        encoder->possible_crtcs = 2; /* 2: dhd1 */
+    }
+
+    drm_encoder_init(drm, encoder, &hi_encoder_funcs, DRM_MODE_ENCODER_TMDS, NULL);
+    drm_encoder_helper_add(encoder, &hi_encoder_helper_funcs);
+    drm_connector_init(drm, conn, &hi_connector_funcs, id);
+    drm_connector_helper_add(conn, &hi_conn_helper_funcs);
+    drm_connector_attach_encoder(conn, encoder);
+    HI_DRM_FUNC_EXIT();
+}
+
+static void hdmitx_deinit_by_index(struct drm_device *drm, unsigned int id)
+{
+    int ret;
+    struct drm_connector *conn = NULL;
+    struct drm_encoder *encoder = NULL;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_hdmitx_get_by_index(id, &conn, &encoder);
+    if (ret != 0) {
+        HI_DRM_INFO("hdmi id %u not support!\n", id);
+        return;
+    }
+    /* ensure disabled at the final cleanup call */
+    ret = hi_adp_hdmitx_disable(encoder);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_hdmitx_disable err, ret=%#x\n", ret);
+    }
+
+    drm_connector_cleanup(conn);
+    drm_encoder_cleanup(encoder);
+    HI_DRM_FUNC_EXIT();
+}
+
+int hi_drm_hdmitx_init(struct drm_device *drm)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_hdmitx_init();
+    if (ret != 0) {
+        return ret;
+    }
+    hdmitx_init_by_index(drm, DRM_MODE_CONNECTOR_HDMIA);
+    HI_DRM_FUNC_EXIT();
+    return 0;
+}
+
+void hi_drm_hdmitx_cleanup(struct drm_device *drm)
+{
+    HI_DRM_FUNC_ENTER();
+    hdmitx_deinit_by_index(drm, DRM_MODE_CONNECTOR_HDMIA);
+    hi_adp_hdmitx_deinit();
+    HI_DRM_FUNC_EXIT();
+}
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_hdmitx.h b/drivers/gpu/drm/hisilicon/hismart/hi_drm_hdmitx.h
new file mode 100644
index 000000000..22285a50e
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_hdmitx.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __HI_DRM_HDMITX_H__
+#define __HI_DRM_HDMITX_H__
+
+#include <drm/drm_device.h>
+
+int hi_drm_hdmitx_init(struct drm_device *drm);
+void hi_drm_hdmitx_cleanup(struct drm_device *drm);
+
+#endif /* __HI_DRM_HDMITX_H__ */
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_mipitx.c b/drivers/gpu/drm/hisilicon/hismart/hi_drm_mipitx.c
new file mode 100755
index 000000000..7f5d10cc3
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_mipitx.c
@@ -0,0 +1,189 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#include "hi_drm_mipitx.h"
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_address.h>
+#include <video/videomode.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_util.h>
+#include <drm/drm_probe_helper.h>
+#include "hi_drm_drv.h"
+#include "hi_adp_mipitx.h"
+#include "hi_adp_crtc.h"
+
+static int hi_dsi_conn_get_modes(struct drm_connector *connector)
+{
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_FUNC_EXIT();
+    return hi_adp_mipitx_get_modes(connector);
+}
+
+static const struct drm_connector_helper_funcs hi_mipi_dsi_conn_helper_funcs = {
+    .get_modes = hi_dsi_conn_get_modes,
+};
+
+static enum drm_connector_status hi_dsi_connector_detect(struct drm_connector *connector, bool force)
+{
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_FUNC_EXIT();
+    return connector_status_connected;
+}
+
+static const struct drm_connector_funcs hi_mipi_dsi_connector_funcs = {
+    .detect = hi_dsi_connector_detect,
+    .fill_modes = drm_helper_probe_single_connector_modes,
+    .destroy = drm_connector_cleanup,
+    .reset = drm_atomic_helper_connector_reset,
+    .atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+    .atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+    .atomic_set_property = adp_conn_atomic_set_property,
+    .atomic_get_property = adp_conn_atomic_get_property,
+};
+
+static int hi_mipi_dsi_encoder_atomic_check(struct drm_encoder *encoder, struct drm_crtc_state *crtc_state,
+    struct drm_connector_state *conn_state)
+{
+    HI_DRM_FUNC_ENTER();
+    /* set mode,  attach the interface to crtc, mipi on and set blacklight */
+    hi_adp_mipitx_set_mode(encoder, &crtc_state->mode, conn_state);
+    HI_DRM_FUNC_EXIT();
+    return 0;
+}
+
+static enum drm_mode_status hi_mipi_dsi_encoder_mode_valid(struct drm_encoder *encoder,
+    const struct drm_display_mode *mode)
+{
+    HI_DRM_FUNC_ENTER();
+    HI_DRM_FUNC_EXIT();
+    return MODE_OK;
+}
+
+static void hi_mipi_dsi_encoder_enable(struct drm_encoder *encoder)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_mipitx_enable(encoder);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_mipi_dsi_encoder_enable err, ret=%#x\n", ret);
+    }
+    HI_DRM_FUNC_EXIT();
+    return;
+}
+
+static void hi_mipi_dsi_encoder_disable(struct drm_encoder *encoder)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_mipitx_disable(encoder);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_mipi_dsi_encoder_disable err, ret=%#x\n", ret);
+    }
+    HI_DRM_FUNC_EXIT();
+    return;
+}
+
+static const struct drm_encoder_helper_funcs hi_mipi_dsi_encoder_helper_funcs = {
+    .atomic_check = hi_mipi_dsi_encoder_atomic_check,
+    .mode_valid = hi_mipi_dsi_encoder_mode_valid,
+    .enable = hi_mipi_dsi_encoder_enable, /* SetBacklight */
+    .disable = hi_mipi_dsi_encoder_disable, /* off */
+};
+
+static const struct drm_encoder_funcs hi_mipi_dsi_encoder_funcs = {
+    .destroy = drm_encoder_cleanup,
+};
+
+static void mipitx_init_by_index(struct drm_device *drm, unsigned int id)
+{
+    int ret;
+    struct drm_connector *conn = NULL;
+    struct drm_encoder *encoder = NULL;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_mipitx_get_by_index(id, &conn, &encoder);
+    if (ret != 0) {
+        HI_DRM_INFO("mipi id %u not support!\n", id);
+        return;
+    }
+
+    /* bind crtc */
+    if (id == DRM_MODE_CONNECTOR_DSI) {
+        encoder->possible_crtcs = 1; /* 1: dhd0 */
+    } else {
+        encoder->possible_crtcs = 2; /* 2: dhd1 */
+    }
+
+    drm_encoder_init(drm, encoder, &hi_mipi_dsi_encoder_funcs, DRM_MODE_ENCODER_DSI, NULL);
+    drm_encoder_helper_add(encoder, &hi_mipi_dsi_encoder_helper_funcs);
+    drm_connector_init(drm, conn, &hi_mipi_dsi_connector_funcs, id);
+    drm_connector_helper_add(conn, &hi_mipi_dsi_conn_helper_funcs);
+    drm_connector_attach_encoder(conn, encoder);
+    ret = adp_conn_private_properties_init(drm, conn);
+    if (ret != 0) {
+        HI_DRM_ERR("adp_conn_private_properties_init failed\n");
+        drm_connector_cleanup(conn);
+        return;
+    }
+    HI_DRM_FUNC_EXIT();
+    return;
+}
+
+static void mipitx_deinit_by_index(struct drm_device *drm, unsigned int id)
+{
+    int ret;
+    struct drm_connector *conn = NULL;
+    struct drm_encoder *encoder = NULL;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_mipitx_get_by_index(id, &conn, &encoder);
+    if (ret != 0) {
+        HI_DRM_INFO("mipi id %u not support!\n", id);
+        return;
+    }
+
+    /* ensure disabled at the final cleanup call */
+    ret = hi_adp_mipitx_disable(encoder);
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_hdmitx_disable err, ret=%#x\n", ret);
+    }
+    adp_conn_private_properties_deinit(drm, conn);
+    drm_connector_cleanup(conn);
+    drm_encoder_cleanup(encoder);
+    HI_DRM_FUNC_EXIT();
+    return;
+}
+
+int hi_drm_mipitx_init(struct drm_device *drm)
+{
+    int ret;
+    HI_DRM_FUNC_ENTER();
+    ret = hi_adp_mipitx_init();
+    if (ret != 0) {
+        HI_DRM_ERR("hi_adp_mipitx_init err, ret=%#x\n", ret);
+        return ret;
+    }
+    mipitx_init_by_index(drm, DRM_MODE_CONNECTOR_DSI);
+    HI_DRM_FUNC_EXIT();
+    return 0;
+}
+
+void hi_drm_mipitx_cleanup(struct drm_device *drm)
+{
+    HI_DRM_FUNC_ENTER();
+    mipitx_deinit_by_index(drm, DRM_MODE_CONNECTOR_DSI);
+    hi_adp_mipitx_deinit();
+    HI_DRM_FUNC_EXIT();
+    return;
+}
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/hi_drm_mipitx.h b/drivers/gpu/drm/hisilicon/hismart/hi_drm_mipitx.h
new file mode 100644
index 000000000..34d2f0a37
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hi_drm_mipitx.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hisilicon DRM driver
+ * Author: Hisilicon multimedia software group
+ * Create: 2020-7-29
+ */
+
+#ifndef __HI_DRM_MIPITX_H__
+#define __HI_DRM_MIPITX_H__
+
+#include <drm/drm_device.h>
+
+int hi_drm_mipitx_init(struct drm_device *drm);
+void hi_drm_mipitx_cleanup(struct drm_device *drm);
+
+#endif /* __HI_DRM_MIPITX_H__ */
+
diff --git a/drivers/gpu/drm/hisilicon/hismart/hisilicon_drm.h b/drivers/gpu/drm/hisilicon/hismart/hisilicon_drm.h
new file mode 100644
index 000000000..5f247a1a9
--- /dev/null
+++ b/drivers/gpu/drm/hisilicon/hismart/hisilicon_drm.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2016-2019. All rights reserved.
+ * Description: On behalf of a display device, hwcomposer is called for composition and sent for display
+ * Author: Hisilicon gfx group
+ * Created: 2021.01.01
+ */
+#ifndef HISILICON_DRM_H
+#define HISILICON_DRM_H
+
+#include <drm/drm.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+#define DRM_HISILICON_GEM_FD_TO_PHYADDR 0x1
+
+struct drm_hisilicon_phyaddr {
+    /* * return the physical address */
+    __u64 phyaddr;
+    /* * dmabuf file descriptor */
+    __s32 fd;
+};
+
+#define DRM_IOCTL_HISILICON_GEM_FD_TO_PHYADDR \
+    DRM_IOWR(DRM_COMMAND_BASE + DRM_HISILICON_GEM_FD_TO_PHYADDR, struct drm_hisilicon_phyaddr)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* HISILICON_DRM_H */
diff --git a/drivers/hi_vdmav100/Kconfig b/drivers/hi_vdmav100/Kconfig
new file mode 100644
index 000000000..ecaa952b9
--- /dev/null
+++ b/drivers/hi_vdmav100/Kconfig
@@ -0,0 +1,26 @@
+menuconfig HI_VDMA_V100
+	tristate "Hisilicon VDMA Controller V100"
+	depends on ARCH_HI3556AV100 || ARCH_HI3519AV100 || ARCH_HI3568V100
+	default n if ARCH_HI3556AV100 || ARCH_HI3519AV100 || ARCH_HI3568V100
+	help
+	  This is the driver for hisilicon VDMA controoller
+	  IP.
+
+if HI_VDMA_V100
+
+config HI_VDMA_CHN_NUM
+	int "HI_VDMAV100 max channel number"
+	default 32
+
+config HI_VDMA_TRANSFER_THRESHOLD
+        int "Hi VDMA data transfer threshold KBytes"
+        range 4 16384
+        default "128" if (ARCH_HI3556AV100 || ARCH_HI3519AV100 || ARCH_HI3568V100)
+
+config HI_VDMA_MISC_DEV
+	bool "HI_VDMAV100 misc dev"
+	default y if (ARCH_HI3556AV100 || ARCH_HI3519AV100 || ARCH_HI3568V100)
+	depends on HI_VDMA_V100
+
+
+endif
diff --git a/drivers/hi_vdmav100/Makefile b/drivers/hi_vdmav100/Makefile
new file mode 100644
index 000000000..ccac799b5
--- /dev/null
+++ b/drivers/hi_vdmav100/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_HI_VDMA_V100) += hi_vdmav100.o
+obj-$(CONFIG_HI_VDMA_MISC_DEV) += hi_vdmav100_misc.o
diff --git a/drivers/hi_vdmav100/hi_vdma.h b/drivers/hi_vdmav100/hi_vdma.h
new file mode 100644
index 000000000..3644fe621
--- /dev/null
+++ b/drivers/hi_vdmav100/hi_vdma.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2015 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __VDMA_USER_H__
+#define __VDMA_USER_H__
+
+struct hivdmac_host {
+	struct device *dev;
+	struct clk *clk;
+	struct reset_control *rstc;
+	void __iomem *regbase;
+
+	int irq;
+};
+
+#define VDMA_DATA_CMD   0x6
+
+struct dmac_user_para {
+	uintptr_t src;
+	uintptr_t dst;
+	unsigned int size;
+};
+
+extern int hi_vdma_m2m_copy(void *dst, const void *src, size_t count);
+
+
+#endif
diff --git a/drivers/hi_vdmav100/hi_vdmav100.c b/drivers/hi_vdmav100/hi_vdmav100.c
new file mode 100644
index 000000000..0199ddd23
--- /dev/null
+++ b/drivers/hi_vdmav100/hi_vdmav100.c
@@ -0,0 +1,534 @@
+/*
+ * clock driver for hisilicon hi3519 or hi3559 soc
+ *
+ * Copyright (c) 2015 HiSilicon Technologies Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/string.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mod_devicetable.h>
+#include <linux/vmalloc.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/mm_types.h>
+#include <linux/mmu_context.h>
+#include <asm/tlbflush.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+
+#include "hi_vdmav100.h"
+#include "hi_vdma.h"
+
+#define user_addr(ptr)   (((uintptr_t)ptr < TASK_SIZE) \
+            && ((uintptr_t)ptr > 0))
+
+int vdma_flag = 0;
+EXPORT_SYMBOL(vdma_flag);
+
+void __iomem *hi_reg_vdma_base_va;
+
+spinlock_t my_lock;
+spinlock_t reg_lock;
+
+unsigned int irq_flag;
+
+unsigned int wake_channel_flag[DMAC_MAX_CHANNELS];
+
+wait_queue_head_t dmac_wait_queue[DMAC_MAX_CHANNELS];
+
+int hi_g_channel_status[DMAC_MAX_CHANNELS];
+
+/*
+ *  dmac interrupt handle function
+ */
+irqreturn_t vdma_isr(int irq, void *dev_id)
+{
+	unsigned int dma_intr_status, channel_intr_status;
+	unsigned int i;
+
+	if (hi_reg_vdma_base_va == NULL)
+		return -1;
+	dmac_readw(hi_reg_vdma_base_va + DMAC_INT_STATUS, dma_intr_status);
+
+	/* decide which channel has trigger the interrupt */
+	for (i = 0; i < DMAC_MAX_CHANNELS; i++) {
+		if (((dma_intr_status >> i) & 0x1) == 1) {
+			dmac_readw(hi_reg_vdma_base_va
+				   + DMAC_CxINTR_RAW(i),
+				   channel_intr_status);
+
+			/* clear the channel error interrupt */
+			dmac_writew(hi_reg_vdma_base_va
+				    + DMAC_CxINTR_RAW(i),
+				    channel_intr_status);
+
+			if ((channel_intr_status & CX_INT_STAT)
+					== CX_INT_STAT) {
+				/* transfer finish interrupt */
+				if ((channel_intr_status & CX_INT_TC_RAW)
+						== CX_INT_TC_RAW) {
+					wake_channel_flag[i] = DMA_TRANS_OK;
+
+					/* save the current channel transfer *
+					 * status to hi_g_channel_status[i] */
+					hi_g_channel_status[i] =
+						DMAC_CHN_SUCCESS;
+
+					wake_up(&dmac_wait_queue[i]);
+					goto exit;
+				}
+
+				wake_channel_flag[i] = DMA_TRANS_FAULT;
+				pr_err("%d channel!,intr_raw=%x\n",
+				       i, channel_intr_status);
+				hi_g_channel_status[i] =
+					-DMAC_CHN_CONFIG_ERROR;
+
+				wake_up(&dmac_wait_queue[i]);
+				goto exit;
+			}
+		}
+	}
+
+exit:
+	return IRQ_HANDLED;
+}
+
+/*
+ *  allocate channel.
+ */
+int hi_vdma_channel_allocate(void *pisr)
+{
+	unsigned int  i, channelinfo, tmp, channel_intr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&my_lock, flags);
+
+	if (hi_reg_vdma_base_va == NULL)
+		return 0;
+	dmac_readw(hi_reg_vdma_base_va + DMAC_CHANNEL_STATUS, channelinfo);
+
+	for (i = 0; i < CHANNEL_NUM; i++) {
+		if (hi_g_channel_status[i] == DMAC_CHN_VACANCY) {
+			dmac_readw(hi_reg_vdma_base_va + DMAC_CxINTR_RAW(i),
+				   channel_intr);
+			tmp = channelinfo >> i;
+			/* check the vdma channel data transfer is finished ? */
+			if (((tmp & 0x01) == 0x00) && (channel_intr == 0x00)) {
+				hi_g_channel_status[i] = DMAC_CHN_ALLOCAT;
+				spin_unlock_irqrestore(&my_lock, flags);
+				return i; /* return channel number */
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&my_lock, flags);
+	return DMAC_CHANNEL_INVALID;
+}
+
+/*
+ *  free channel
+ */
+int hi_vdma_channel_free(unsigned int channel)
+{
+	hi_g_channel_status[channel] = DMAC_CHN_VACANCY;
+
+	return 0;
+}
+
+/*
+ *  channel enable
+ *  start a vdma transfer immediately
+ */
+int hi_vdma_channelstart(unsigned int channel,
+			 const unsigned int *src, const unsigned int *dest)
+{
+	struct mm_struct *mm = NULL;
+	unsigned int reg[DMAC_MAX_CHANNELS];
+
+	if (channel >= DMAC_MAX_CHANNELS) {
+		pr_err("channel number is out of scope(%d).\n",
+		       DMAC_MAX_CHANNELS);
+		return -EINVAL;
+	}
+
+	hi_g_channel_status[channel] = DMAC_NOT_FINISHED;
+
+	mm = current->mm;
+	if (!mm) {
+		mm = &init_mm;
+	}
+
+	if (mm->pgd == NULL)
+		return -EINVAL;
+	/* set ttbr */
+	/* get TTBR from the page */
+	reg[channel] = __pa(mm->pgd);
+
+	/* only [31:10] is the ttbr */
+	reg[channel] &= 0xfffffc00;
+
+	/* set the RGN,AFE,AFFD,TRE */
+	reg[channel] |= TTB_RGN | AFE | TRE;
+
+	if (user_addr(dest)) {
+		reg[channel] &= ~DEST_IS_KERNEL;
+	} else {
+		reg[channel] |= DEST_IS_KERNEL;
+	}
+
+	if (user_addr(src)) {
+		reg[channel] &= ~SRC_IS_KERNEL;
+	} else {
+		reg[channel] |= SRC_IS_KERNEL;
+	}
+
+	if (in_atomic() || in_interrupt()) {
+		/* disable the channel interrupt */
+		reg[channel] &= ~DMAC_INTR_ENABLE;
+	} else {
+		/* enable the channel interrupt */
+		reg[channel] |= DMAC_INTR_ENABLE;
+	}
+
+	reg[channel] |= DMAC_CHANNEL_ENABLE;
+
+	if (hi_reg_vdma_base_va == NULL)
+		return 0;
+	/* set the TTBR register */
+	dmac_writew(hi_reg_vdma_base_va + DMAC_CxTTBR(channel),
+		    reg[channel]);
+	return 0;
+}
+
+/*
+ *  Apply VDMA interrupt resource
+ *  init channel state
+ */
+int hi_vdma_driver_init(struct hivdmac_host *dma)
+{
+	unsigned int i;
+	unsigned int tmp_reg = 0;
+
+	if (hi_reg_vdma_base_va == NULL)
+		return 0;
+	dmac_readw(hi_reg_vdma_base_va + DMAC_GLOBLE_CTRL, tmp_reg);
+	tmp_reg |= AUTO_CLK_GT_EN;
+	dmac_writew(hi_reg_vdma_base_va + DMAC_GLOBLE_CTRL, tmp_reg);
+
+	/* set rd dust address is ram 0 */
+	dmac_writew(hi_reg_vdma_base_va + DMAC_RD_DUSTB_ADDR, 0x04c11000);
+
+	/* set wr dust address is ram 0x1000 */
+	dmac_writew(hi_reg_vdma_base_va + DMAC_WR_DUSTB_ADDR, 0x04c11000);
+
+	/* set prrr register */
+	dmac_writew(hi_reg_vdma_base_va + DMAC_MMU_PRRR, PRRR);
+	/* set nmrr register */
+	dmac_writew(hi_reg_vdma_base_va + DMAC_MMU_NMRR, NMRR);
+
+	/* config global reg for VDMA */
+	tmp_reg |= EVENT_BROADCAST_EN | WR_CMD_NUM_PER_ARB |
+		   RD_CMD_NUM_PER_ARB | WR_OTD_NUM | RD_OTD_NUM | WFE_EN;
+	dmac_writew(hi_reg_vdma_base_va + DMAC_GLOBLE_CTRL, tmp_reg);
+
+	for (i = 0; i < CHANNEL_NUM; i++) {
+		hi_g_channel_status[i] = DMAC_CHN_VACANCY;
+		init_waitqueue_head(&dmac_wait_queue[i]);
+	}
+
+	spin_lock_init(&my_lock);
+	spin_lock_init(&reg_lock);
+
+	return 0;
+}
+
+/*
+ *  wait for transfer end
+ */
+int hi_vdma_wait(unsigned int channel)
+{
+	unsigned long data_jiffies_timeout = jiffies + DMA_TIMEOUT_HZ;
+	unsigned int channel_intr_raw;
+
+	while (1) {
+		if (hi_reg_vdma_base_va == NULL)
+			return 0;
+		/* read the status of current interrupt */
+		dmac_readw(hi_reg_vdma_base_va + DMAC_CxINTR_RAW(channel),
+			   channel_intr_raw);
+
+		/* clear the interrupt */
+		dmac_writew(hi_reg_vdma_base_va
+			    + DMAC_CxINTR_RAW(channel),
+			    channel_intr_raw);
+
+		if (channel >= DMAC_MAX_CHANNELS)
+			return 0;
+		/* save the current channel transfer status to *
+		 * hi_g_channel_status[i] */
+		if ((channel_intr_raw & CX_INT_STAT) == CX_INT_STAT) {
+			/* transfer finish interrupt */
+			if ((channel_intr_raw & CX_INT_TC_RAW) ==
+					CX_INT_TC_RAW) {
+				hi_g_channel_status[channel] = DMAC_CHN_SUCCESS;
+				return DMAC_CHN_SUCCESS;
+			}
+
+			/* transfer abort interrupt */
+			pr_debug("data transfer error in VDMA %x channel!",
+				 channel);
+			pr_debug("intr_raw=%x\n", channel_intr_raw);
+			hi_g_channel_status[channel] =
+				-DMAC_CHN_CONFIG_ERROR;
+			return -DMAC_CHN_CONFIG_ERROR;
+		}
+
+		if (!time_before(jiffies, data_jiffies_timeout)) { /* timeout */
+			pr_err("wait interrupt timeout, channel=%d, func:%s, line:%d\n",
+			       channel, __func__, __LINE__);
+			return -1;
+		}
+	}
+
+	return -1;
+}
+
+/*
+ *  execute memory to memory vdma transfer
+ */
+static int hi_vdma_m2m_transfer(const unsigned int *psource,
+				const unsigned int *pdest,
+				unsigned int uwtransfersize)
+{
+	unsigned int ulchnn;
+	int ret = 0;
+
+	ulchnn = (unsigned int)hi_vdma_channel_allocate(NULL);
+
+	if (ulchnn == DMAC_CHANNEL_INVALID) {
+		pr_err("DMAC_CHANNEL_INVALID.\n");
+
+		return -1;
+	}
+
+	wake_channel_flag[ulchnn] = 0;
+
+	dmac_writew(hi_reg_vdma_base_va + DMAC_CxLENGTH(ulchnn),
+		    uwtransfersize);
+	dmac_writew(hi_reg_vdma_base_va + DMAC_CxSRCADDR(ulchnn),
+		    (uintptr_t)psource);
+	dmac_writew(hi_reg_vdma_base_va + DMAC_CxDESTADDR(ulchnn),
+		    (uintptr_t)pdest);
+
+	if (hi_vdma_channelstart(ulchnn, psource, pdest) != 0) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (hi_vdma_wait(ulchnn) != DMAC_CHN_SUCCESS) {
+		ret = -1;
+		goto exit;
+	}
+
+exit:
+	hi_vdma_channel_free(ulchnn);
+
+	return ret;
+}
+EXPORT_SYMBOL(hi_vdma_m2m_transfer);
+
+int hi_vdma_m2m_copy(void *dst, const void *src, size_t count)
+{
+	int ret;
+
+	if (((uintptr_t)dst & 0xff) || ((uintptr_t)src & 0xff)) {
+		return -1;
+	}
+	if (((uintptr_t)src < (uintptr_t)dst) &&
+			(((uintptr_t)src + count) > (uintptr_t)dst)) {
+		return -1;
+	}
+	if (((uintptr_t)src >= (uintptr_t)dst) &&
+			((uintptr_t)src < ((uintptr_t)dst + count))) {
+		return -1;
+	}
+	if (abs((uintptr_t)dst - (uintptr_t)src) < PAGE_SIZE) {
+		return -1;
+	}
+
+	ret = hi_vdma_m2m_transfer((unsigned int *)src, dst, count);
+
+	if (ret < 0) {
+		return ret;
+	} else {
+		return 0;
+	}
+}
+EXPORT_SYMBOL(hi_vdma_m2m_copy);
+
+static int hivdmac_probe(struct platform_device *platdev)
+{
+	unsigned int i;
+	struct hivdmac_host *dma = NULL;
+	struct resource *res = NULL;
+	int ret;
+	dma = devm_kzalloc(&platdev->dev, sizeof(*dma), GFP_KERNEL);
+	if (!dma) {
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(platdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&platdev->dev, "no mmio resource\n");
+		return -ENODEV;
+	}
+
+	dma->regbase = devm_ioremap_resource(&platdev->dev, res);
+	if (IS_ERR(dma->regbase)) {
+		return PTR_ERR(dma->regbase);
+	}
+
+	dma->clk = devm_clk_get(&platdev->dev, NULL);
+	if (IS_ERR(dma->clk)) {
+		return PTR_ERR(dma->clk);
+	}
+
+	clk_prepare_enable(dma->clk);
+
+	dma->rstc = devm_reset_control_get(&platdev->dev, "dma-reset");
+	if (IS_ERR(dma->rstc)) {
+		return PTR_ERR(dma->rstc);
+	}
+
+	dma->irq = platform_get_irq(platdev, 0);
+	if (unlikely(dma->irq < 0)) {
+		return -ENODEV;
+	}
+	hi_reg_vdma_base_va = dma->regbase;
+	pr_debug("vdma reg base is %p\n", hi_reg_vdma_base_va);
+	dma->dev = &platdev->dev;
+
+	ret = hi_vdma_driver_init(dma);
+	if (ret) {
+		return -ENODEV;
+	}
+
+	platform_set_drvdata(platdev, dma);
+
+	for (i = 0; i < CONFIG_HI_VDMA_CHN_NUM; i++) {
+		hi_g_channel_status[i] = DMAC_CHN_VACANCY;
+	}
+
+	vdma_flag = 1;
+	printk("hivdmav100 driver inited.\n");
+	return ret;
+}
+
+static int hivdmac_remove(struct platform_device *platdev)
+{
+	int i;
+	struct hivdmac_host *dma = platform_get_drvdata(platdev);
+
+	clk_disable_unprepare(dma->clk);
+
+	for (i = 0; i < CONFIG_HI_VDMA_CHN_NUM; i++) {
+		hi_g_channel_status[i] = DMAC_CHN_VACANCY;
+	}
+
+	vdma_flag = 0;
+	printk("hivdmav100 driver deinited.\n");
+
+	return 0;
+}
+
+static int hivdmac_suspend(struct platform_device *platdev,
+			   pm_message_t state)
+{
+	int i;
+	struct hivdmac_host *dma = platform_get_drvdata(platdev);
+
+	clk_prepare_enable(dma->clk);
+
+	for (i = 0; i < CONFIG_HI_VDMA_CHN_NUM; i++) {
+		hi_g_channel_status[i] = DMAC_CHN_VACANCY;
+	}
+
+	clk_disable_unprepare(dma->clk);
+
+	vdma_flag = 0;
+
+	return 0;
+}
+
+static int hivdmac_resume(struct platform_device *platdev)
+{
+	int i;
+	struct hivdmac_host *dma = platform_get_drvdata(platdev);
+
+	hi_vdma_driver_init(dma);
+
+	for (i = 0; i < CONFIG_HI_VDMA_CHN_NUM; i++) {
+		hi_g_channel_status[i] = DMAC_CHN_VACANCY;
+	}
+
+	vdma_flag = 1;
+
+	return 0;
+}
+
+static const struct of_device_id hisi_vdmac_dt_ids[] = {
+	{.compatible = "hisilicon,hisi-vdmac"},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, hisi_vdmac_dt_ids);
+
+static struct platform_driver hisi_vdmac_driver = {
+	.driver = {
+		.name   = "hisi-vdmac",
+		.of_match_table = hisi_vdmac_dt_ids,
+	},
+	.probe      = hivdmac_probe,
+	.remove     = hivdmac_remove,
+	.suspend    = hivdmac_suspend,
+	.resume     = hivdmac_resume,
+};
+
+module_platform_driver(hisi_vdmac_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("BVT_OSDRV");
diff --git a/drivers/hi_vdmav100/hi_vdmav100.h b/drivers/hi_vdmav100/hi_vdmav100.h
new file mode 100644
index 000000000..8b8d3e6c0
--- /dev/null
+++ b/drivers/hi_vdmav100/hi_vdmav100.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2015 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __HI_VDMA_H__
+#define __HI_VDMA_H__
+
+#define  dmac_writew(addr, value) \
+    ((*(volatile unsigned int *)(addr)) = (value))
+
+#define  dmac_readw(addr, v) \
+    (v = (*(volatile unsigned int *)(addr)))
+
+#define DMAC_GLOBLE_CTRL    0x000
+#define WFE_EN          (0x1 << 23)
+#define EVENT_BROADCAST_EN  (0x1 << 21)
+#define AUTO_CLK_GT_EN      (0x1 << 17)
+#define AUTO_PRI_EN     (0x1 << 16)
+#define WR_CMD_NUM_PER_ARB  (0x4 << 12)
+#define RD_CMD_NUM_PER_ARB  (0x4 << 8)
+#define WR_OTD_NUM      (0xF << 4)
+#define RD_OTD_NUM      (0xF)
+
+#define DMAC_PRI_THRESHOLD  0x004
+/* PRRR and NMRR define */
+#define DMAC_MMU_NMRR  0x008
+#define DMAC_MMU_PRRR  0x00C
+/* read and write dustb address register define */
+#define DMAC_RD_DUSTB_ADDR      0x010
+#define DMAC_WR_DUSTB_ADDR      0x014
+/* channel status register define */
+#define DMAC_CHANNEL_STATUS     0x01c
+#define DMAC_WORK_DURATION      0x020
+#define DMAC_INT_STATUS       0x02c
+/* the definition for DMAC channel register */
+#define DMAC_CHANNEL_BASE           0x100
+#define DMAC_CxSRCADDR(i)   (DMAC_CHANNEL_BASE + 0x00 + 0x20 * i)
+#define DMAC_CxDESTADDR(i)  (DMAC_CHANNEL_BASE + 0x04 + 0x20 * i)
+#define DMAC_CxLENGTH(i)    (DMAC_CHANNEL_BASE + 0x08 + 0x20 * i)
+#define DMAC_CxTTBR(i)      (DMAC_CHANNEL_BASE + 0x0C + 0x20 * i)
+#define DMAC_CxMISC(i)      (DMAC_CHANNEL_BASE + 0x10 + 0x20 * i)
+#define DMAC_CxINTR_RAW(i)  (DMAC_CHANNEL_BASE + 0x14 + 0x20 * i)
+#define CX_INT_STAT    (0x1 << 4)
+#define CX_INT_TC_RAW  (0x1 << 3)
+#define CX_INT_TE_RAW  (0x1 << 2)
+#define CX_INT_TM_RAW  (0x1 << 1)
+#define CX_INT_AP_RAW  (0x1 << 0)
+
+#define DMAC_INTR_ENABLE               (0x1 << 8)
+
+/* channel enable */
+#define DMAC_CHANNEL_ENABLE     (0x1 << 9)
+
+/* access flag enable */
+#define AFE         (0x1 << 6)
+
+/* user and kernel define */
+#define DEST_IS_KERNEL      (0x1 << 2)
+#define SRC_IS_KERNEL       (0x1 << 1)
+
+/* for TTBR */
+#define TTB_RGN         (0x1 << 3) /* outer cache write back allocate */
+
+/* for ap and cache remap */
+
+/* remap enable,ap access check enable */
+#define TRE 0x001
+
+#define PRRR     0xff0a81a8
+#define NMRR     0x40e040e0
+
+#define DMAC_SYNC_VAL               0x0
+
+/* definition for the return value */
+#define DMAC_ERROR_BASE             100
+#define DMAC_CHANNEL_INVALID            (DMAC_ERROR_BASE + 1)
+
+#define DMAC_TRXFERSIZE_INVALID         (DMAC_ERROR_BASE + 2)
+#define DMAC_SOURCE_ADDRESS_INVALID     (DMAC_ERROR_BASE + 3)
+#define DMAC_DESTINATION_ADDRESS_INVALID    (DMAC_ERROR_BASE + 4)
+#define DMAC_MEMORY_ADDRESS_INVALID     (DMAC_ERROR_BASE + 5)
+#define DMAC_PERIPHERAL_ID_INVALID      (DMAC_ERROR_BASE + 6)
+#define DMAC_DIRECTION_ERROR            (DMAC_ERROR_BASE + 7)
+#define DMAC_TRXFER_ERROR           (DMAC_ERROR_BASE + 8)
+#define DMAC_LLIHEAD_ERROR          (DMAC_ERROR_BASE + 9)
+#define DMAC_SWIDTH_ERROR           (DMAC_ERROR_BASE + 0xa)
+#define DMAC_LLI_ADDRESS_INVALID        (DMAC_ERROR_BASE + 0xb)
+#define DMAC_TRANS_CONTROL_INVALID      (DMAC_ERROR_BASE + 0xc)
+#define DMAC_MEMORY_ALLOCATE_ERROR      (DMAC_ERROR_BASE + 0xd)
+#define DMAC_NOT_FINISHED           (DMAC_ERROR_BASE + 0xe)
+
+#define DMAC_TIMEOUT                (DMAC_ERROR_BASE + 0xf)
+#define DMAC_CHN_SUCCESS            (DMAC_ERROR_BASE + 0x10)
+#define DMAC_CHN_CONFIG_ERROR           (DMAC_ERROR_BASE + 0x11)
+#define DMAC_CHN_DATA_ERROR         (DMAC_ERROR_BASE + 0x12)
+#define DMAC_CHN_TIMEOUT            (DMAC_ERROR_BASE + 0x13)
+#define DMAC_CHN_ALLOCAT            (DMAC_ERROR_BASE + 0x14)
+#define DMAC_CHN_VACANCY            (DMAC_ERROR_BASE + 0x15)
+
+#define DMAC_MAX_CHANNELS           CONFIG_HI_VDMA_CHN_NUM
+
+#define CHANNEL_NUM DMAC_MAX_CHANNELS
+
+#define DMA_TRANS_OK          0x1
+#define DMA_PAGE_FAULT      0x2
+#define DMA_TRANS_FAULT     0x3
+#define DMA_TIMEOUT_HZ      (3 * HZ)
+
+extern int g_channel_status[DMAC_MAX_CHANNELS];
+#endif
diff --git a/drivers/hi_vdmav100/hi_vdmav100_misc.c b/drivers/hi_vdmav100/hi_vdmav100_misc.c
new file mode 100644
index 000000000..777a7c47c
--- /dev/null
+++ b/drivers/hi_vdmav100/hi_vdmav100_misc.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2015 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/vmalloc.h>
+#include <asm/pgtable.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <linux/spinlock.h>
+#include <linux/kernel.h>
+#include <linux/ioctl.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/mm_types.h>
+#include <linux/mmu_context.h>
+#include <asm/tlbflush.h>
+#include <linux/uaccess.h>
+
+#include "hi_vdma.h"
+
+#define hidmac_error(s...) do { \
+    pr_err("hidmac:%s:%d: ", __func__, __LINE__); \
+    printk(s); \
+    printk("\n"); \
+} while (0)
+
+
+static long hi_vdma_ioctl(struct file *filep, unsigned int cmd,
+			  unsigned long arg)
+{
+	long ret = 0;
+	struct dmac_user_para para;
+
+	if (copy_from_user((void *)&para, (void *)(uintptr_t)arg, sizeof(para))) {
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+	case VDMA_DATA_CMD:
+		ret = hi_vdma_m2m_copy((void *)para.dst, (void *)para.src, para.size);
+		break;
+	default:
+		hidmac_error("unknown command :%x\n", cmd);
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+static int hi_vdma_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int hi_vdma_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations hi_vdma_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = hi_vdma_ioctl,
+	.open = hi_vdma_open,
+	.release = hi_vdma_release,
+};
+
+static struct miscdevice hi_vdma_misc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "hi_vdma",
+	.fops = &hi_vdma_fops,
+};
+
+static int __init hi_vdma_init(void)
+{
+	int ret;
+
+	ret = misc_register(&hi_vdma_misc_device);
+
+	return ret;
+}
+
+static void __exit hi_vdma_exit(void)
+{
+	misc_deregister(&hi_vdma_misc_device);
+}
+
+module_init(hi_vdma_init);
+module_exit(hi_vdma_exit);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Hisilicon VDMA MISC Driver");
diff --git a/drivers/hidmac/Kconfig b/drivers/hidmac/Kconfig
new file mode 100644
index 000000000..dcb3e08bf
--- /dev/null
+++ b/drivers/hidmac/Kconfig
@@ -0,0 +1,21 @@
+#
+# Sensor device configuration
+#
+
+config HI_DMAC
+	tristate "Hisilicon DMAC Controller support"
+	depends on (ARCH_HISI_BVT)
+	help
+	  The Direction Memory Access(DMA) is a high-speed data transfer
+	  operation. It supports data read/write between peripherals and
+	  memories without using the CPU.
+	  Hisilicon DMA Controller(DMAC) directly transfers data between
+	  a memory and a peripheral, between peripherals, or between memories.
+	  This avoids the CPU intervention and reduces the interrupt handling
+	  overhead of the CPU.
+
+if HI_DMAC
+config HI_DMAC_CHANNEL_NUM
+	int "hi dmac channel num"
+	default "4"
+endif
diff --git a/drivers/hidmac/Makefile b/drivers/hidmac/Makefile
new file mode 100644
index 000000000..7e41f4c37
--- /dev/null
+++ b/drivers/hidmac/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the hi dmac drivers.
+#
+
+obj-$(CONFIG_HI_DMAC)	+= hi_pl08x.o
+
diff --git a/drivers/hidmac/hi_pl08x.c b/drivers/hidmac/hi_pl08x.c
new file mode 100644
index 000000000..4281caf7e
--- /dev/null
+++ b/drivers/hidmac/hi_pl08x.c
@@ -0,0 +1,1303 @@
+/*
+ *
+ * Copyright (c) 2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/gfp.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <asm/io.h>
+#include <linux/hidmac.h>
+
+#include "hi_pl08x.h"
+
+#ifdef CONFIG_ARCH_HI3536DV100
+#include "hidmac_hi3536dv100.h"
+#endif
+
+#ifdef CONFIG_ARCH_HI3518EV20X
+#include "hidmac_hi3518ev20x.h"
+#endif
+
+#ifdef CONFIG_ARCH_HI3516A
+#include "hidmac_hi3516a.h"
+#endif
+
+#ifdef CONFIG_ARCH_HI3521A
+#include "hidmac_hi3521a.h"
+#endif
+
+#ifdef CONFIG_ARCH_HI3531A
+#include "hidmac_hi3531a.h"
+#endif
+
+#define RX  0
+#define TX  1
+static int dmac_channel[CHANNEL_NUM] = {0, 1, 2, 3};
+int g_channel_status[CHANNEL_NUM];
+
+/* #define DEBUG */
+
+#define DEBUG
+#ifdef DEBUG
+#define dma_err printk
+#else
+#define dma_err(fmt, ...) do {} while (0)
+#endif
+
+/*
+ * Define Memory range
+ */
+mem_addr mem_num[MEM_MAX_NUM] = {
+	{DDRAM_ADRS, DDRAM_SIZE},
+	{FLASH_BASE, FLASH_SIZE}
+};
+
+typedef void REG_ISR(int *p_dma_chn, int *p_dma_status);
+REG_ISR *function[CHANNEL_NUM];
+
+struct hidmac_host {
+	struct clk *clk;
+	struct reset_control *rstc;
+	void __iomem *regbase;
+
+	int irq;
+};
+
+void __iomem *dma_regbase;
+unsigned int pllihead[2];
+
+#define CLR_INT(i)  ((*(unsigned int *)(dma_regbase+0x008)) = (1 << i))
+
+/*
+ * dmac interrupt handle function
+ */
+irqreturn_t dmac_isr(int irq, void *dev_id)
+{
+	struct hidmac_host *dma = dev_id;
+	unsigned int channel_status;
+	unsigned int channel_tc_status, channel_err_status;
+	unsigned int i;
+
+	/* read the status of current interrupt */
+	dmac_readw(dma->regbase + DMAC_INTSTATUS, channel_status);
+
+	/* decide which channel has trigger the interrupt */
+	for (i = 0; i < DMAC_MAX_CHANNELS; i++) {
+		if ((((channel_status >> i) & 0x1) == 0x01)) {
+			/* The INT status should be read first then clear it */
+			dmac_readw(dma->regbase + DMAC_INTTCSTATUS, channel_tc_status);
+			dmac_readw(dma->regbase + DMAC_INTERRORSTATUS, channel_err_status);
+			CLR_INT(i);
+			if (g_channel_status[i] == DMAC_CHN_VACANCY
+					&& (function[i]) == NULL) {
+				if ((0x01 == ((channel_tc_status >> i) & 0x01)))
+					dmac_writew(dma->regbase + DMAC_INTTCCLEAR,
+						    (0x01 << i));
+				else if ((0x01 == ((channel_err_status
+						    >> i) & 0x01)))
+					dmac_writew(dma->regbase + DMAC_INTERRCLR,
+						    (0x01 << i));
+				continue;
+			}
+
+			/* save the current channel transfer */
+			/* status to g_channel_status[i] */
+			if ((0x01 == ((channel_tc_status >> i) & 0x01))) {
+				g_channel_status[i] = DMAC_CHN_SUCCESS;
+				dmac_writew(dma->regbase + DMAC_INTTCCLEAR, (0x01 << i));
+			} else if ((0x01 == ((channel_err_status >> i) & 0x01))) {
+				g_channel_status[i] = -DMAC_CHN_ERROR;
+				dmac_writew(dma->regbase + DMAC_INTERRCLR, (0x01 << i));
+			} else {
+				pr_err("Isr Error in DMAC_IntHandeler");
+				pr_err("%d! channel\n", i);
+			}
+
+			if ((function[i]) != NULL) {
+				function[i](&i, &g_channel_status[i]);
+			}
+		}
+	}
+
+	return IRQ_RETVAL(1);
+}
+
+/*
+ *  update the state of channels
+ */
+#define HI_DMA_UPDATE_TIMEOUT  5000000
+static int dma_update_status(unsigned int channel)
+{
+	unsigned int channel_status;
+	unsigned int channel_tc_status[3];
+	unsigned int channel_err_status[3];
+	unsigned int i = channel;
+	unsigned int time = 0;
+	unsigned int j;
+
+	while (1) {
+		for (j = 0; j < 3; j++) {
+			dmac_readw(dma_regbase + DMAC_RAWINTTCSTATUS, channel_status);
+			channel_tc_status[j] = (channel_status >> i) & 0x01;
+			dmac_readw(dma_regbase + DMAC_RAWINTERRORSTATUS, channel_status);
+			channel_err_status[j] = (channel_status >> i) & 0x01;
+		}
+
+		if ((channel_tc_status[0] == 0x1) &&
+				(channel_tc_status[1] == 0x1) &&
+				(channel_tc_status[2] == 0x1)) {
+			g_channel_status[i] = DMAC_CHN_SUCCESS;
+			dmac_writew(dma_regbase + DMAC_INTTCCLEAR, (0x01 << i));
+			break;
+		} else if ((channel_err_status[0] == 0x1) &&
+				(channel_err_status[1] == 0x1) &&
+				(channel_err_status[2] == 0x1)) {
+			g_channel_status[i] = -DMAC_CHN_ERROR;
+			dma_err("Error in DMAC %d finish!\n", i);
+			dmac_writew(dma_regbase + DMAC_INTERRCLR, (0x01 << i));
+			break;
+		}
+
+		if (++time == HI_DMA_UPDATE_TIMEOUT) {
+			dma_err("Timeout in DMAC %d!\n", i);
+			g_channel_status[i] = -DMAC_CHN_TIMEOUT;
+			break;
+		}
+	}
+
+	return g_channel_status[i];
+}
+
+/*
+ *  check the state of channels
+ */
+static int dmac_check_over(unsigned int channel)
+{
+	int status = 0;
+
+	if (-DMAC_CHN_ERROR == g_channel_status[channel]) {
+		dma_err("Error transfer %d finished\n", channel);
+		dmac_writew(dma_regbase + DMAC_CxCONFIG(channel), DMAC_CxDISABLE);
+		g_channel_status[channel] = DMAC_CHN_VACANCY;
+		status = -DMAC_CHN_ERROR;
+	} else if (g_channel_status[channel] == DMAC_NOT_FINISHED) {
+		status = DMAC_NOT_FINISHED;
+	} else if (g_channel_status[channel] == DMAC_CHN_ALLOCAT) {
+		status = DMAC_CHN_ALLOCAT;
+	} else if (g_channel_status[channel] == DMAC_CHN_VACANCY) {
+		status = DMAC_CHN_VACANCY;
+	} else if (-DMAC_CHN_TIMEOUT == g_channel_status[channel]) {
+		dma_err("transfer %d timeout!\n", channel);
+		status = -DMAC_CHN_TIMEOUT;
+	} else if (g_channel_status[channel] == DMAC_CHN_SUCCESS) {
+		/* The transfer of Channel %d has finished successfully! */
+		status = DMAC_CHN_SUCCESS;
+	} else {
+		dmac_writew(dma_regbase + DMAC_CxCONFIG(channel), DMAC_CxDISABLE);
+		g_channel_status[channel] = DMAC_CHN_VACANCY;
+		status = -DMAC_CHN_ERROR;
+	}
+	return status;
+}
+
+spinlock_t my_lcok = __SPIN_LOCK_UNLOCKED(old_style_spin_init);
+unsigned long flags;
+
+/*
+ *  allocate channel.
+ */
+int dmac_channel_allocate(void *pisr)
+{
+	unsigned int i, channelinfo, g_channelinfo;
+
+	for (i = 0; i < CHANNEL_NUM; i++) {
+		dmac_check_over(dmac_channel[i]);
+	}
+
+	dmac_readw(dma_regbase + DMAC_ENBLDCHNS, g_channelinfo);
+	g_channelinfo = g_channelinfo & 0x00ff;
+
+	for (i = 0; i < CHANNEL_NUM; i++) {
+		if (g_channel_status[dmac_channel[i]] == DMAC_CHN_VACANCY) {
+			channelinfo = g_channelinfo >> dmac_channel[i];
+			if (0x00 == (channelinfo & 0x01)) {
+				/* clear the interrupt in this channel */
+				dmac_writew(dma_regbase + DMAC_INTERRCLR,
+					    (0x01 << dmac_channel[i]));
+				dmac_writew(dma_regbase + DMAC_INTTCCLEAR,
+					    (0x01 << dmac_channel[i]));
+
+				g_channel_status[dmac_channel[i]]
+					= DMAC_CHN_ALLOCAT;
+				return dmac_channel[i];
+			}
+		}
+	}
+
+	dma_err("no to alloc\n");
+	return -EINVAL;
+}
+EXPORT_SYMBOL(dmac_channel_allocate);
+
+int dmac_register_isr(unsigned int channel, void *pisr)
+{
+	if (channel > CHANNEL_NUM - 1) {
+		dma_err("channel which choosed %d is error !\n", channel);
+		return -1;
+	}
+
+	if (g_channel_status[channel] != DMAC_CHN_VACANCY) {
+		dma_err("dma chn %d is in used!\n", channel);
+		return -1;
+	}
+
+	/* clear the interrupt in this channel */
+	dmac_writew(dma_regbase + DMAC_INTERRCLR, (0x01 << channel));
+	dmac_writew(dma_regbase + DMAC_INTTCCLEAR, (0x01 << channel));
+
+	function[channel] = (void *)pisr;
+	g_channel_status[channel] = DMAC_CHN_ALLOCAT;
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_register_isr);
+
+/*
+ *  free channel
+ */
+int dmac_channel_free(unsigned int channel)
+{
+	if (channel >= DMAC_MAX_CHANNELS) {
+		dma_err("channel larger than total.\n");
+		return -EINVAL;
+	}
+
+	g_channel_status[channel] = DMAC_CHN_VACANCY;
+	return 0;
+}
+EXPORT_SYMBOL(dmac_channel_free);
+
+static unsigned int dmac_check_request(unsigned int peripheral_addr,
+				       int direction)
+{
+	int i;
+	/* check request pipe with peripheral_addr */
+	for (i = direction; i < DMAC_MAX_PERIPHERALS; i = i + 2) {
+		if (g_peripheral[i].peri_addr == peripheral_addr) {
+			return i;
+		}
+	}
+
+	dma_err("Invalid devaddr\n");
+
+	return -1;
+}
+
+/*
+ *  init dmac register
+ *  clear interrupt flags
+ *  called by dma_driver_init
+ */
+int dmac_init(struct hidmac_host *dma)
+{
+	unsigned int i, tempvalue;
+	int ret;
+
+	clk_prepare_enable(dma->clk);
+	reset_control_deassert(dma->rstc);
+
+	dmac_readw(dma->regbase + DMAC_CONFIG, tempvalue);
+	if (tempvalue == 0) {
+		dmac_writew(dma->regbase + DMAC_CONFIG,
+			    DMAC_CONFIG_VAL);
+		dmac_writew(dma->regbase + DMAC_INTTCCLEAR, 0xFF);
+		dmac_writew(dma->regbase + DMAC_INTERRCLR, 0xFF);
+		for (i = 0; i < DMAC_MAX_CHANNELS; i++) {
+			dmac_writew(dma->regbase + DMAC_CxCONFIG(i),
+				    DMAC_CxDISABLE);
+			function[i] = NULL;
+		}
+	}
+
+	/* creat LLI */
+	/* alloc space for dma lli, as the source is uncontinuous, so... */
+	ret = allocate_dmalli_space(pllihead, 1);
+	if (ret < 0) {
+		return -1;
+	}
+
+	if (request_irq(dma->irq, dmac_isr, 0, "hi_dma", dma)) {
+		dma_err("DMA Irq %d request failed\n", dma->irq);
+		free_dmalli_space(pllihead, 1);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ *  alloc_dma_lli_space
+ *  output:
+ *             ppheadlli[0]: memory physics address
+ *             ppheadlli[1]: virtual address
+ *
+ */
+int allocate_dmalli_space(unsigned int *ppheadlli, unsigned int page_num)
+{
+	dma_addr_t dma_phys;
+	void *dma_virt;
+
+	dma_virt = dma_alloc_coherent(NULL, page_num * PAGE_SIZE,
+				      &dma_phys, GFP_DMA | GFP_KERNEL);
+	if (dma_virt == NULL) {
+		dma_err("can't get dma mem from system\n");
+		return -1;
+	}
+
+	ppheadlli[0] = (unsigned int)(dma_phys);
+	ppheadlli[1] = (unsigned int)(dma_virt);
+
+	return 0;
+}
+EXPORT_SYMBOL(allocate_dmalli_space);
+
+/*
+ *  free_dma_lli_space
+ */
+int free_dmalli_space(unsigned int *ppheadlli, unsigned int page_num)
+{
+	dma_addr_t dma_phys;
+	unsigned int dma_virt;
+
+	dma_phys = (dma_addr_t)(ppheadlli[0]);
+	dma_virt = ppheadlli[1];
+
+	dma_free_coherent(NULL, page_num * PAGE_SIZE,
+			  (void *)dma_virt, dma_phys);
+
+	ppheadlli[0] = 0;
+	ppheadlli[1] = 0;
+	return 0;
+}
+EXPORT_SYMBOL(free_dmalli_space);
+
+/*
+ * config register for memory to memory DMA transfer without LLI
+ * note:
+ * it is necessary to call dmac_channelstart for channel enable
+ */
+int dmac_start_m2m(unsigned int  channel, unsigned int psource,
+		   unsigned int pdest, unsigned int uwnumtransfers)
+{
+	unsigned int uwchannel_num, tmp_trasnsfer;
+
+	if (uwnumtransfers > (MAXTRANSFERSIZE << 2)) {
+		dma_err("Invalidate transfer size,size=%x\n", uwnumtransfers);
+		return -EINVAL;
+	}
+
+	uwchannel_num = channel;
+
+	if ((uwchannel_num == DMAC_CHANNEL_INVALID) ||
+			(uwchannel_num > CHANNEL_NUM)) {
+		pr_err("failure of DMAC channel allocation in M2M function!\n");
+		return -EFAULT;
+	}
+
+	dmac_writew(dma_regbase + DMAC_CxSRCADDR(uwchannel_num), psource);
+	dmac_writew(dma_regbase + DMAC_CxDESTADDR(uwchannel_num), pdest);
+	dmac_writew(dma_regbase + DMAC_CxLLI(uwchannel_num), 0);
+	tmp_trasnsfer = (uwnumtransfers >> 2) & 0xfff;
+	tmp_trasnsfer = tmp_trasnsfer | (DMAC_CxCONTROL_M2M & (~0xfff));
+	dmac_writew(dma_regbase + DMAC_CxCONTROL(uwchannel_num), tmp_trasnsfer);
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(uwchannel_num), DMAC_CxCONFIG_M2M);
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_start_m2m);
+
+/*
+ *  channel enable
+ *  start a dma transfer immediately
+ */
+int dmac_channelstart(unsigned int u32channel)
+{
+	unsigned int reg_value;
+
+	if (u32channel >= DMAC_MAX_CHANNELS) {
+		dma_err("channel larger %d\n", DMAC_MAX_CHANNELS);
+		return -EINVAL;
+	}
+
+	g_channel_status[u32channel] = DMAC_NOT_FINISHED;
+	dmac_readw(dma_regbase + DMAC_CxCONFIG(u32channel), reg_value);
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(u32channel),
+		    (reg_value | DMAC_CHANNEL_ENABLE));
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_channelstart);
+
+/*
+ *  wait for transfer end
+ */
+int dmac_wait(int channel)
+{
+	int ret_result;
+	int ret = 0;
+
+	if (channel < 0) {
+		return -1;
+	}
+
+	while (1) {
+		ret_result = dma_update_status(channel);
+		if (ret_result == -DMAC_CHN_ERROR) {
+			dma_err("Transfer Error.\n");
+			ret = -1;
+			goto end;
+		} else  if (ret_result == DMAC_NOT_FINISHED) {
+			udelay(10);
+		} else if (ret_result == DMAC_CHN_SUCCESS) {
+			ret = DMAC_CHN_SUCCESS;
+			goto end;
+		} else if (ret_result == DMAC_CHN_VACANCY) {
+			ret = DMAC_CHN_SUCCESS;
+			goto end;
+		} else if (ret_result == -DMAC_CHN_TIMEOUT) {
+			dma_err("Timeout.\n");
+			dmac_writew(dma_regbase + DMAC_CxCONFIG(channel), DMAC_CxDISABLE);
+			g_channel_status[channel] = DMAC_CHN_VACANCY;
+			ret = -1;
+			goto end;
+		}
+	}
+end:
+	dmac_channelclose(channel);
+	return ret;
+}
+EXPORT_SYMBOL(dmac_wait);
+
+/*
+ *  buile LLI for memory to memory DMA transfer
+ */
+int dmac_buildllim2m_isp(unsigned int *ppheadlli, unsigned int *psource,
+			 unsigned int *pdest, unsigned int *length,
+			 unsigned int lli_num)
+{
+	unsigned int address, phy_address;
+	unsigned int j;
+
+	if (ppheadlli != NULL) {
+		phy_address = (unsigned int)(ppheadlli[0]);
+		dma_debug("phy_address: 0x%X\n", phy_address);
+		address = (unsigned int)(ppheadlli[1]);
+		dma_debug("address: 0x%X\n", address);
+		for (j = 0; j < lli_num; j++) {
+			dma_debug("psource[%d]: 0x%X\n", j, psource[j]);
+			dmac_writew(address, psource[j]);
+			address += 4;
+			phy_address += 4;
+			dma_debug("pdest[%d]: 0x%X\n", j, pdest[j]);
+			dmac_writew(address, pdest[j]);
+			address += 4;
+			phy_address += 4;
+
+			/* if the last node, next_lli_addr = 0 */
+			if (j == (lli_num - 1)) {
+				dmac_writew(address, 0);
+			} else
+				dmac_writew(address,
+					    (((phy_address + 8) & (~0x03)) |
+					    DMAC_CxLLI_LM));
+
+			address += 4;
+			phy_address += 4;
+
+			if (j == (lli_num - 1)) {
+				dmac_writew(address,
+					    ((DMAC_CxCONTROL_LLIM2M_ISP &
+					      (~0xfff)) | (length[j]) |
+					      0x80000000));
+			} else {
+				dmac_writew(address,
+					    (((DMAC_CxCONTROL_LLIM2M_ISP & (~0xfff)) |
+					      (length[j])) & 0x7fffffff));
+			}
+
+			address += 4;
+			phy_address += 4;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_buildllim2m_isp);
+
+/*
+ *  buile LLI for memory to memory DMA transfer
+ */
+int dmac_buildllim2m(unsigned int *ppheadlli, unsigned int pdest,
+		     unsigned int psource, unsigned int totaltransfersize,
+		     unsigned int uwnumtransfers)
+{
+	unsigned int lli_num = 0;
+	unsigned int last_lli = 0;
+	unsigned int address, phy_address, srcaddr, denstaddr;
+	unsigned int j;
+
+	lli_num = (totaltransfersize / uwnumtransfers);
+
+	if ((totaltransfersize % uwnumtransfers) != 0) {
+		last_lli = 1, ++lli_num;
+	}
+
+	if (ppheadlli != NULL) {
+		phy_address = (unsigned int)(ppheadlli[0]);
+		address = (unsigned int)(ppheadlli[1]);
+		for (j = 0; j < lli_num; j++) {
+			srcaddr = (psource + (j * uwnumtransfers));
+			dmac_writew(address, srcaddr);
+			address += 4;
+			phy_address += 4;
+			denstaddr = (pdest + (j * uwnumtransfers));
+			dmac_writew(address, denstaddr);
+			address += 4;
+			phy_address += 4;
+			if (j == (lli_num - 1)) {
+				dmac_writew(address, 0);
+			} else
+				dmac_writew(address,
+					    (((phy_address + 8) & (~0x03)) |
+					     DMAC_CxLLI_LM));
+
+			address += 4;
+			phy_address += 4;
+
+			if ((j == (lli_num - 1)) && (last_lli == 0))
+				dmac_writew(address, ((DMAC_CxCONTROL_LLIM2M &
+						      (~0xfff)) |
+						      (uwnumtransfers >> 2) |
+						      0x80000000));
+			else if ((j == (lli_num - 1)) && (last_lli == 1))
+				dmac_writew(address,
+					    ((DMAC_CxCONTROL_LLIM2M &
+					     (~0xfff)) |
+					     ((totaltransfersize %
+					       uwnumtransfers) >> 2) |
+					     0x80000000));
+			else
+				dmac_writew(address,
+					    (((DMAC_CxCONTROL_LLIM2M & (~0xfff)) |
+					      (uwnumtransfers >> 2)) & 0x7fffffff));
+
+			address += 4;
+			phy_address += 4;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_buildllim2m);
+
+/*
+ *  disable channel
+ *  used before the operation of register configuration
+ */
+int dmac_channelclose(unsigned int channel)
+{
+	unsigned int reg_value, count;
+
+	if (channel >= DMAC_MAX_CHANNELS) {
+		dma_err("channel larger than total.\n");
+		return -EINVAL;
+	}
+
+	dmac_readw(dma_regbase + DMAC_CxCONFIG(channel), reg_value);
+
+#define CHANNEL_CLOSE_IMMEDIATE
+#ifdef CHANNEL_CLOSE_IMMEDIATE
+	reg_value &= 0xFFFFFFFE;
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(channel), reg_value);
+#else
+	reg_value |= DMAC_CONFIGURATIONx_HALT_DMA_ENABLE;
+	/* ignore incoming dma request */
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(channel), reg_value);
+	dmac_readw(dma_regbase + DMAC_CxCONFIG(channel), reg_value);
+	/* if FIFO is empty */
+	while ((reg_value & DMAC_CONFIGURATIONx_ACTIVE)
+			== DMAC_CONFIGURATIONx_ACTIVE) {
+		dmac_readw(dma_regbase + DMAC_CxCONFIG(channel), reg_value);
+	}
+	reg_value &= 0xFFFFFFFE;
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(channel), reg_value);
+#endif
+
+	dmac_readw(dma_regbase + DMAC_ENBLDCHNS, reg_value);
+	reg_value = reg_value & 0x00ff;
+	count = 0;
+	while (((reg_value >> channel) & 0x1) == 1) {
+		dmac_readw(dma_regbase + DMAC_ENBLDCHNS, reg_value);
+		reg_value = reg_value & 0x00ff;
+		if (count++ > 10000) {
+			dma_err("close failure.\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_channelclose);
+
+/*
+ *  load configuration from LLI for memory to memory
+ */
+int dmac_start_llim2m(unsigned int channel, unsigned int *pfirst_lli)
+{
+	unsigned int uwchannel_num;
+	dmac_lli  plli;
+	unsigned int first_lli;
+
+	if (pfirst_lli == NULL) {
+		dma_err("Invalidate LLI head!\n");
+		return -EFAULT;
+	}
+
+	uwchannel_num = channel;
+	if ((uwchannel_num == DMAC_CHANNEL_INVALID) ||
+			(uwchannel_num > 7)) {
+		dma_err("failure of DMAC channel allocation in");
+		dma_err("LLIM2M function,channel=%x!\n ", uwchannel_num);
+		return -EINVAL;
+	}
+
+	memset(&plli, 0, sizeof(plli));
+	first_lli = (unsigned int)pfirst_lli[1];
+	dmac_readw(first_lli, plli.src_addr);
+	dmac_readw(first_lli + 4, plli.dst_addr);
+	dmac_readw(first_lli + 8, plli.next_lli);
+	dmac_readw(first_lli + 12, plli.lli_transfer_ctrl);
+
+	dmac_channelclose(uwchannel_num);
+	dmac_writew(dma_regbase + DMAC_INTTCCLEAR, (0x1 << uwchannel_num));
+	dmac_writew(dma_regbase + DMAC_INTERRCLR, (0x1 << uwchannel_num));
+	dmac_writew(dma_regbase + DMAC_SYNC, 0x0);
+
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(uwchannel_num),
+		    DMAC_CxDISABLE);
+	dmac_writew(dma_regbase + DMAC_CxSRCADDR(uwchannel_num),
+		    (unsigned int)(plli.src_addr));
+	dmac_writew(dma_regbase + DMAC_CxDESTADDR(uwchannel_num),
+		    (unsigned int)(plli.dst_addr));
+	dmac_writew(dma_regbase + DMAC_CxLLI(uwchannel_num),
+		    (unsigned int)(plli.next_lli));
+	dmac_writew(dma_regbase + DMAC_CxCONTROL(uwchannel_num),
+		    (unsigned int)(plli.lli_transfer_ctrl));
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(uwchannel_num),
+		    DMAC_CxCONFIG_LLIM2M);
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_start_llim2m);
+
+/*
+ *  load configuration from LLI for memory and peripheral
+ */
+int dmac_start_llim2p(unsigned int channel, unsigned int *pfirst_lli,
+		      unsigned int uwperipheralid)
+{
+	unsigned int uwchannel_num;
+	dmac_lli plli;
+	unsigned int first_lli;
+	unsigned int temp = 0;
+
+	if (pfirst_lli == NULL) {
+		dma_err("Invalidate LLI head!\n");
+		return -EINVAL;
+	}
+	uwchannel_num = channel;
+	if ((uwchannel_num == DMAC_CHANNEL_INVALID) ||
+	    (uwchannel_num > CHANNEL_NUM)) {
+		dma_err("failure of DMAC channel allocation in");
+		dma_err("LLIM2P function, channel=%x!\n ", uwchannel_num);
+		return -EINVAL;
+	}
+
+	memset(&plli, 0, sizeof(plli));
+	first_lli = (unsigned int)pfirst_lli[1];
+	dmac_readw(first_lli, plli.src_addr);
+	dmac_readw(first_lli + 4, plli.dst_addr);
+	dmac_readw(first_lli + 8, plli.next_lli);
+	dmac_readw(first_lli + 12, plli.lli_transfer_ctrl);
+
+	dmac_channelclose(uwchannel_num);
+	dmac_writew(dma_regbase + DMAC_INTTCCLEAR, (0x1 << uwchannel_num));
+	dmac_writew(dma_regbase + DMAC_INTERRCLR, (0x1 << uwchannel_num));
+	dmac_writew(dma_regbase + DMAC_SYNC, 0x0);
+
+	dmac_readw(dma_regbase + DMAC_CxCONFIG(uwchannel_num), temp);
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(uwchannel_num),
+		    temp | DMAC_CxDISABLE);
+	dmac_writew(dma_regbase + DMAC_CxSRCADDR(uwchannel_num),
+		    plli.src_addr);
+	dmac_writew(dma_regbase + DMAC_CxDESTADDR(uwchannel_num),
+		    plli.dst_addr);
+	dmac_writew(dma_regbase + DMAC_CxLLI(uwchannel_num),
+		    plli.next_lli);
+	dmac_writew(dma_regbase + DMAC_CxCONTROL(uwchannel_num),
+		    plli.lli_transfer_ctrl);
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_start_llim2p);
+
+/*
+ *  enable memory and peripheral dma transfer
+ *  note:
+ *  it is necessary to call dmac_channelstart to enable channel
+ */
+int dmac_start_m2p(unsigned int channel, unsigned int memaddr,
+		   unsigned int uwperipheralid, unsigned int uwnumtransfers,
+		   unsigned int next_lli_addr)
+{
+	unsigned int uwtrans_control = 0;
+	unsigned int addtmp, tmp;
+	unsigned int uwdst_addr = 0;
+	unsigned int uwsrc_addr = 0;
+	unsigned int uwwidth;
+	int uwchannel_num;
+
+	addtmp = memaddr;
+
+	if ((uwperipheralid > 15)) {
+		dma_err("Invalid peripheral id%x\n", uwperipheralid);
+		return -EINVAL;
+	}
+
+	uwchannel_num = (int)channel;
+	if ((uwchannel_num == DMAC_CHANNEL_INVALID) ||
+	    (uwchannel_num > CHANNEL_NUM) || (uwchannel_num < 0)) {
+		dma_err("failure alloc\n");
+		return -EFAULT;
+	}
+
+	/* must modified with different peripheral */
+	uwwidth = g_peripheral[uwperipheralid].transfer_width;
+
+	/* check transfer direction *
+	 * even number-->TX, odd number-->RX */
+	uwsrc_addr = memaddr;
+	uwdst_addr = (unsigned int)(g_peripheral[uwperipheralid].peri_addr);
+
+	tmp = uwnumtransfers >> uwwidth;
+	if (tmp & (~0x0fff)) {
+		dma_err("Invalidate size%x\n", uwnumtransfers);
+		return -EINVAL;
+	}
+
+	tmp = tmp & 0xfff;
+	uwtrans_control = tmp |
+			  (g_peripheral[uwperipheralid].transfer_ctrl & (~0xfff));
+	dmac_writew(dma_regbase + DMAC_INTTCCLEAR,
+		    (0x1 << (unsigned int)uwchannel_num));
+	dmac_writew(dma_regbase + DMAC_INTERRCLR, (0x1 << (unsigned int)uwchannel_num));
+	dmac_writew(dma_regbase + DMAC_CxSRCADDR(uwchannel_num),
+		    (unsigned int)uwsrc_addr);
+	dmac_writew(dma_regbase + DMAC_CxDESTADDR(uwchannel_num),
+		    (unsigned int)uwdst_addr);
+	dmac_writew(dma_regbase + DMAC_CxCONTROL(uwchannel_num),
+		    (unsigned int)uwtrans_control);
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(uwchannel_num),
+		    (g_peripheral[uwperipheralid].transfer_cfg));
+
+	return 0;
+}
+
+/*
+ *  enable memory and peripheral dma transfer
+ *  note:
+ *  it is necessary to call dmac_channelstart to enable channel
+ */
+int dmac_start_p2m(unsigned int channel, unsigned int memaddr,
+		   unsigned int uwperipheralid, unsigned int uwnumtransfers,
+		   unsigned int next_lli_addr)
+{
+	unsigned int uwtrans_control = 0;
+	unsigned int addtmp, tmp;
+	unsigned int uwdst_addr = 0;
+	unsigned int uwsrc_addr = 0;
+	unsigned int uwwidth;
+	int uwchannel_num;
+
+	addtmp = memaddr;
+
+	if ((uwperipheralid > 15)) {
+		dma_err("Invalid peripheral id%x\n", uwperipheralid);
+		return -EINVAL;
+	}
+
+	uwchannel_num = (int)channel;
+	if ((uwchannel_num == DMAC_CHANNEL_INVALID) ||
+			(uwchannel_num > 3) || (uwchannel_num < 0)) {
+		dma_err("failure alloc\n");
+		return -EFAULT;
+	}
+
+	/* must modified with different peripheral */
+	uwwidth = g_peripheral[uwperipheralid].transfer_width;
+
+	/* check transfer direction *
+	 * even number-->TX, odd number-->RX */
+	uwsrc_addr = (unsigned int)(g_peripheral[uwperipheralid].peri_addr);
+	uwdst_addr = memaddr;
+
+	tmp = uwnumtransfers >> uwwidth;
+	if (tmp & (~0x0fff)) {
+		dma_err("Invalidate size%x\n", uwnumtransfers);
+		return -EINVAL;
+	}
+
+	tmp = tmp & 0xfff;
+	uwtrans_control = tmp |
+			  (g_peripheral[uwperipheralid].transfer_ctrl & (~0xfff));
+	dmac_writew(dma_regbase + DMAC_INTTCCLEAR,
+		    (0x1 << (unsigned int)uwchannel_num));
+	dmac_writew(dma_regbase + DMAC_INTERRCLR, (0x1 << (unsigned int)uwchannel_num));
+	dmac_writew(dma_regbase + DMAC_CxSRCADDR(uwchannel_num),
+		    (unsigned int)uwsrc_addr);
+	dmac_writew(dma_regbase + DMAC_CxDESTADDR(uwchannel_num),
+		    (unsigned int)uwdst_addr);
+	dmac_writew(dma_regbase + DMAC_CxCONTROL(uwchannel_num),
+		    (unsigned int)uwtrans_control);
+	dmac_writew(dma_regbase + DMAC_CxCONFIG(uwchannel_num),
+		    (g_peripheral[uwperipheralid].transfer_cfg));
+
+	return 0;
+}
+
+/*
+ *  execute memory to memory dma transfer without LLI
+ */
+int dmac_m2m_transfer(unsigned int source, unsigned int dest,
+		      unsigned int length)
+{
+	unsigned int ulchnn;
+	unsigned int dma_size = 0;
+	unsigned int dma_count, left_size;
+
+	left_size = length;
+	dma_count = 0;
+	ulchnn = dmac_channel_allocate(NULL);
+
+	ulchnn = 2;
+
+	dma_err("use channel %d\n", ulchnn);
+
+	while ((left_size >> 2) >= 0xffc) {
+		dma_size   = 0xffc;
+		left_size -= (dma_size << 2);
+		dma_err("left_size is %x.", left_size);
+		dmac_start_m2m(ulchnn,
+			       (unsigned int)(source +
+					      dma_count *
+					      (dma_size << 2)),
+			       (unsigned int)(dest +
+					      dma_count *
+					      (dma_size << 2)),
+			       (dma_size << 2));
+		if (dmac_channelstart(ulchnn) != 0) {
+			dma_err("start channel error...\n");
+			return -1;
+		}
+
+		if (dmac_wait(ulchnn) != DMAC_CHN_SUCCESS) {
+			dma_err("dma transfer error...\n");
+			return -1;
+		}
+
+		dma_count++;
+	}
+
+	dmac_start_m2m(ulchnn, (source + dma_count * (dma_size << 2)),
+		       (dest + dma_count * (dma_size << 2)), (left_size << 2));
+
+	if (dmac_channelstart(ulchnn) != 0) {
+		return -1;
+	}
+
+	if (dmac_wait(ulchnn) != DMAC_CHN_SUCCESS) {
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_m2m_transfer);
+
+/*
+ *  execute memory to peripheral dma transfer without LLI
+ */
+int dmac_m2p_transfer(unsigned int memaddr, unsigned int uwperipheralid,
+		      unsigned int length)
+{
+	unsigned int dma_size = 0;
+	unsigned int dma_count, left_size, ulchnn, uwwidth;
+
+	left_size = length;
+	dma_count = 0;
+
+	ulchnn = dmac_channel_allocate(NULL);
+	if (ulchnn == DMAC_CHANNEL_INVALID) {
+		return -1;
+	}
+
+	uwwidth = g_peripheral[uwperipheralid].transfer_width;
+
+	while ((left_size >> uwwidth) >= 0xffc) {
+		dma_size = 0xffc;
+		left_size -= (dma_size << uwwidth);
+
+		if (dmac_start_m2p(ulchnn,
+				   (unsigned int)(memaddr + dma_count * dma_size),
+				   uwperipheralid, (dma_size << uwwidth), 0) < 0) {
+			return -1;
+		}
+
+		if (dmac_channelstart(ulchnn) != 0) {
+			return -1;
+		}
+
+		if (dmac_wait(ulchnn) != DMAC_CHN_SUCCESS) {
+			dmac_channel_free(ulchnn);
+			return -1;
+		}
+
+		dma_count++;
+	}
+
+	pr_debug("memaddr=0x%x\n", (unsigned int)(memaddr +
+			dma_count * dma_size));
+
+	if (dmac_start_m2p(ulchnn,
+			   (unsigned int)(memaddr + dma_count * dma_size),
+			   uwperipheralid, left_size, 0) < 0) {
+		return -1;
+	}
+
+	if (dmac_channelstart(ulchnn) != 0) {
+		return -1;
+	}
+
+	return ulchnn;
+}
+
+/*
+ *  execute memory to peripheral dma transfer without LLI
+ */
+int dmac_p2m_transfer(unsigned int memaddr, unsigned int uwperipheralid,
+		      unsigned int length)
+{
+	unsigned int dma_size = 0;
+	unsigned int ulchnn, dma_count, left_size;
+	unsigned int uwwidth;
+
+	left_size = length;
+	dma_count = 0;
+
+	ulchnn = dmac_channel_allocate(NULL);
+	if (ulchnn == DMAC_CHANNEL_INVALID) {
+		return -1;
+	}
+
+	uwwidth = g_peripheral[uwperipheralid].transfer_width;
+
+	while ((left_size >> uwwidth) >= 0xffc) {
+		dma_size = 0xffc;
+		left_size -= (dma_size << uwwidth);
+
+		if (dmac_start_p2m(ulchnn,
+				   (unsigned int)(memaddr + dma_count * dma_size),
+				   uwperipheralid, (dma_size << uwwidth), 0) < 0) {
+			return -1;
+		}
+
+		if (dmac_channelstart(ulchnn) != 0) {
+			return -1;
+		}
+
+		if (dmac_wait(ulchnn) != DMAC_CHN_SUCCESS) {
+			dmac_channel_free(ulchnn);
+			return -1;
+		}
+
+		dma_count++;
+	}
+
+	pr_debug("memaddr=0x%x\n", (unsigned int)(memaddr +
+						  dma_count * dma_size));
+
+	if (dmac_start_p2m(ulchnn,
+			   (unsigned int)(memaddr + dma_count * dma_size),
+			   uwperipheralid, left_size, 0) < 0) {
+		return -1;
+	}
+
+	if (dmac_channelstart(ulchnn) != 0) {
+		return -1;
+	}
+
+	return ulchnn;
+}
+
+/*
+ * memory to memory dma transfer with LLI
+ *
+ * @source
+ * @dest
+ * @length
+ * @num
+ * */
+int do_dma_llim2m_isp(unsigned int *source,
+		      unsigned int *dest,
+		      unsigned int *length,
+		      unsigned int num)
+{
+	unsigned int chnn;
+	int ret;
+
+	/* the dma channel is default using 2 */
+	chnn = 2;
+
+	ret = dmac_buildllim2m_isp(pllihead, source, dest, length, num);
+	if (ret) {
+		dma_err("build lli error...\n");
+		return -1;
+	}
+
+	ret = dmac_start_llim2m(chnn, pllihead);
+	if (ret) {
+		return -1;
+	}
+
+	if (dmac_channelstart(chnn) != 0) {
+		dma_err("start channel error...\n");
+		return -1;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(do_dma_llim2m_isp);
+
+int do_dma_m2p(unsigned int memaddr, unsigned int peripheral_addr,
+	       unsigned int length)
+{
+	int ret = 0;
+	int uwperipheralid;
+
+	uwperipheralid = dmac_check_request(peripheral_addr, TX);
+	if (uwperipheralid < 0) {
+		dma_err("m2p:Invalid devaddr\n");
+		return -1;
+	}
+
+	ret = dmac_m2p_transfer(memaddr, uwperipheralid, length);
+	if (ret == -1) {
+		dma_err("m2p:trans err\n");
+		return -1;
+	}
+
+	return ret;
+}
+
+int do_dma_p2m(unsigned int memaddr, unsigned int peripheral_addr,
+	       unsigned int length)
+{
+	int ret = -1;
+	int uwperipheralid;
+
+	uwperipheralid = dmac_check_request(peripheral_addr, RX);
+	if (uwperipheralid < 0) {
+		dma_err("p2m:Invalid devaddr.\n");
+		return -1;
+	}
+
+	ret = dmac_p2m_transfer(memaddr, uwperipheralid, length);
+	if (ret == -1) {
+		dma_err("p2m:trans err\n");
+		return -1;
+	}
+
+	return ret;
+}
+
+/*
+ *  Apply DMA interrupt resource
+ *  init channel state
+ */
+static int hi_dmac_probe(struct platform_device *platdev)
+{
+	unsigned int i;
+	struct hidmac_host *dma;
+	struct resource *res;
+	int ret;
+
+	dma = devm_kzalloc(&platdev->dev, sizeof(*dma), GFP_KERNEL);
+	if (!dma) {
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(platdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&platdev->dev, "no mmio resource\n");
+		return -ENODEV;
+	}
+
+	dma->regbase = devm_ioremap_resource(&platdev->dev, res);
+	if (IS_ERR(dma->regbase)) {
+		return PTR_ERR(dma->regbase);
+	}
+
+	dma->clk = devm_clk_get(&platdev->dev, NULL);
+	if (IS_ERR(dma->clk)) {
+		return PTR_ERR(dma->clk);
+	}
+
+	dma->rstc = devm_reset_control_get(&platdev->dev, "dma-reset");
+	if (IS_ERR(dma->rstc)) {
+		return PTR_ERR(dma->rstc);
+	}
+
+	dma->irq = platform_get_irq(platdev, 0);
+	if (unlikely(dma->irq < 0)) {
+		return -ENODEV;
+	}
+
+	dma_regbase = dma->regbase;
+
+	ret = dmac_init(dma);
+	if (ret) {
+		return -ENODEV;
+	}
+
+	platform_set_drvdata(platdev, dma);
+
+	for (i = 0; i < DMAC_MAX_CHANNELS; i++) {
+		g_channel_status[i] = DMAC_CHN_VACANCY;
+	}
+
+	dev_info(&platdev->dev, "hidmac probe!\n");
+	return ret;
+}
+
+static int hi_dmac_remove(struct platform_device *platdev)
+{
+	int i;
+	struct hidmac_host *dma = platform_get_drvdata(platdev);
+
+	clk_disable_unprepare(dma->clk);
+
+	for (i = 0; i < DMAC_MAX_CHANNELS; i++) {
+		g_channel_status[i] = DMAC_CHN_VACANCY;
+	}
+
+	free_dmalli_space(pllihead, 1);
+
+	return 0;
+}
+
+static int hi_dmac_suspend(struct platform_device *platdev,
+			   pm_message_t state)
+{
+	int i;
+	struct hidmac_host *dma = platform_get_drvdata(platdev);
+
+	clk_prepare_enable(dma->clk);
+
+	for (i = 0; i < DMAC_MAX_CHANNELS; i++) {
+		g_channel_status[i] = DMAC_CHN_VACANCY;
+	}
+
+	clk_disable_unprepare(dma->clk);
+
+	return 0;
+}
+
+static int hi_dmac_resume(struct platform_device *platdev)
+{
+	int i;
+	struct hidmac_host *dma = platform_get_drvdata(platdev);
+	unsigned int tempvalue;
+
+	clk_prepare_enable(dma->clk);
+	reset_control_deassert(dma->rstc);
+
+	dmac_readw(dma->regbase + DMAC_CONFIG, tempvalue);
+	if (tempvalue == 0) {
+		dmac_writew(dma->regbase + DMAC_CONFIG,
+			    DMAC_CONFIG_VAL);
+		dmac_writew(dma->regbase + DMAC_INTTCCLEAR, 0xFF);
+		dmac_writew(dma->regbase + DMAC_INTERRCLR, 0xFF);
+		for (i = 0; i < DMAC_MAX_CHANNELS; i++) {
+			dmac_writew(dma->regbase + DMAC_CxCONFIG(i),
+				    DMAC_CxDISABLE);
+			function[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < DMAC_MAX_CHANNELS; i++) {
+		g_channel_status[i] = DMAC_CHN_VACANCY;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id hisi_dmac_dt_ids[] = {
+	{ .compatible = "hisilicon,hisi-dmac" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hisi_dmac_dt_ids);
+
+static struct platform_driver hisi_dmac_driver = {
+	.driver = {
+		.name   = "hisi-dmac",
+		.of_match_table = hisi_dmac_dt_ids,
+	},
+	.probe      = hi_dmac_probe,
+	.remove     = hi_dmac_remove,
+	.suspend    = hi_dmac_suspend,
+	.resume     = hi_dmac_resume,
+};
+
+module_platform_driver(hisi_dmac_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hisilicon");
+MODULE_DESCRIPTION("HiSilicon DMA Controller driver");
diff --git a/drivers/hidmac/hi_pl08x.h b/drivers/hidmac/hi_pl08x.h
new file mode 100644
index 000000000..1c3babf22
--- /dev/null
+++ b/drivers/hidmac/hi_pl08x.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef __HI_DMAC_H__
+#define __HI_DMAC_H__
+
+#define  dmac_writew(addr, value) \
+    writel(value, (void *)(addr))
+#define  dmac_readw(addr, v) \
+    v = readl((void *)(addr))
+
+#ifdef DMA_DEBUG
+#define dma_debug printk
+#else
+#define dma_debug(fmt, ...) do {} while (0);
+#endif
+
+#define DMAC_CONFIGURATIONx_HALT_DMA_ENABLE (0x01L<<18)
+#define DMAC_CONFIGURATIONx_ACTIVE      (0x01L<<17)
+#define DMAC_CONFIGURATIONx_CHANNEL_ENABLE  1
+#define DMAC_CONFIGURATIONx_CHANNEL_DISABLE 0
+
+/* definition for the return value */
+#define DMAC_ERROR_BASE             100
+#define DMAC_CHANNEL_INVALID            (DMAC_ERROR_BASE+1)
+
+#define DMAC_TRXFERSIZE_INVALID         (DMAC_ERROR_BASE+2)
+#define DMAC_SOURCE_ADDRESS_INVALID     (DMAC_ERROR_BASE+3)
+#define DMAC_DESTINATION_ADDRESS_INVALID    (DMAC_ERROR_BASE+4)
+#define DMAC_MEMORY_ADDRESS_INVALID     (DMAC_ERROR_BASE+5)
+#define DMAC_PERIPHERAL_ID_INVALID      (DMAC_ERROR_BASE+6)
+#define DMAC_DIRECTION_ERROR            (DMAC_ERROR_BASE+7)
+#define DMAC_TRXFER_ERROR           (DMAC_ERROR_BASE+8)
+#define DMAC_LLIHEAD_ERROR          (DMAC_ERROR_BASE+9)
+#define DMAC_SWIDTH_ERROR           (DMAC_ERROR_BASE+0xa)
+#define DMAC_LLI_ADDRESS_INVALID        (DMAC_ERROR_BASE+0xb)
+#define DMAC_TRANS_CONTROL_INVALID      (DMAC_ERROR_BASE+0xc)
+#define DMAC_MEMORY_ALLOCATE_ERROR      (DMAC_ERROR_BASE+0xd)
+#define DMAC_NOT_FINISHED           (DMAC_ERROR_BASE+0xe)
+
+#define DMAC_TIMEOUT                (DMAC_ERROR_BASE+0xf)
+#define DMAC_CHN_SUCCESS            (DMAC_ERROR_BASE+0x10)
+#define DMAC_CHN_ERROR              (DMAC_ERROR_BASE+0x11)
+#define DMAC_CHN_TIMEOUT            (DMAC_ERROR_BASE+0x12)
+#define DMAC_CHN_ALLOCAT            (DMAC_ERROR_BASE+0x13)
+#define DMAC_CHN_VACANCY            (DMAC_ERROR_BASE+0x14)
+
+#define DMAC_CONFIGURATIONx_ACTIVE_NOT      0
+
+/* the means the bit in the channel control register */
+#define DMAC_TRANS_SIZE         0xff0
+
+/* DMAC peripheral structure */
+typedef struct dmac_peripheral {
+	/* peripherial ID */
+	unsigned int peri_id;
+	/* peripheral data register address */
+	unsigned int peri_addr;
+	/* default channel control word */
+	unsigned int transfer_ctrl;
+	/* default channel configuration word */
+	unsigned int transfer_cfg;
+	/* default channel configuration word */
+	unsigned int transfer_width;
+} dmac_peripheral;
+
+typedef struct mem_addr {
+	unsigned int addr_base;
+	unsigned int size;
+} mem_addr;
+
+typedef unsigned int dma_addr_t;
+/* #define PAGE_SIZE 0x1000 */
+
+#endif /* End of #ifndef __HI_INC_ECSDMACC_H__ */
diff --git a/drivers/hiedmac/Kconfig b/drivers/hiedmac/Kconfig
new file mode 100644
index 000000000..183747be8
--- /dev/null
+++ b/drivers/hiedmac/Kconfig
@@ -0,0 +1,29 @@
+#
+# Sensor device configuration
+#
+
+config HIEDMAC
+	tristate "Hisilicon EDMAC Controller support"
+	depends on (ARCH_HISI_BVT && !HIEDMACV310)
+	help
+	  The Direction Memory Access(EDMA) is a high-speed data transfer
+	  operation. It supports data read/write between peripherals and
+	  memories without using the CPU.
+	  Hisilicon EDMA Controller(EDMAC) directly transfers data between
+	  a memory and a peripheral, between peripherals, or between memories.
+	  This avoids the CPU intervention and reduces the interrupt handling
+	  overhead of the CPU.
+
+if HIEDMAC
+
+config HIEDMAC_CHANNEL_NUM
+	int "hiedmac channel num"
+	default "8"
+
+config HIEDMAC_INTERRUPT
+	bool "Hisilicon EDMAC Controller interrupt mode support"
+	depends on HIEDMAC
+	help
+	  open Hisilicon EDMAC Controller interrupt mode
+
+endif
diff --git a/drivers/hiedmac/Makefile b/drivers/hiedmac/Makefile
new file mode 100644
index 000000000..a1b4b8b76
--- /dev/null
+++ b/drivers/hiedmac/Makefile
@@ -0,0 +1,4 @@
+#
+# Makefile for the hiedmac drivers.
+#
+obj-$(CONFIG_HIEDMAC)	+= hiedmacv310.o
diff --git a/drivers/hiedmac/hiedmacv310.c b/drivers/hiedmac/hiedmacv310.c
new file mode 100644
index 000000000..282ac3eaa
--- /dev/null
+++ b/drivers/hiedmac/hiedmacv310.c
@@ -0,0 +1,946 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_dma.h>
+#include <linux/pm_runtime.h>
+#include <linux/seq_file.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/hiedmac.h>
+
+#include "hiedmacv310.h"
+
+#if defined(CONFIG_ARCH_HI3531DV200) || defined(CONFIG_ARCH_HI3535AV100)
+#include "hiedma_hi3531dv200.h"
+#endif
+
+#if defined(CONFIG_ARCH_HI3521DV200) || defined(CONFIG_ARCH_HI3520DV500)
+#include "hiedma_hi3521dv200.h"
+#endif
+
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3569V100)
+#include "hiedma_hi3559av100.h"
+#endif
+
+#if defined(CONFIG_ARCH_HI3519AV100) || defined(CONFIG_ARCH_HI3556AV100) || \
+    defined(CONFIG_ARCH_HI3568V100)
+#include "hiedma_hi3519av100.h"
+#endif
+
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+#include "hiedma_hi3516cv500.h"
+#endif
+
+#if defined(CONFIG_ARCH_HI3516EV200) || defined(CONFIG_ARCH_HI3516EV300) || \
+    defined(CONFIG_ARCH_HI3518EV300) || defined(CONFIG_ARCH_HI3516DV200)
+#include "hiedma_hi3516ev200.h"
+#endif
+
+int g_channel_status[HIEDMAC_CHANNEL_NUM];
+DMAC_ISR *function[HIEDMAC_CHANNEL_NUM];
+unsigned long pllihead[2] = {0, 0};
+void __iomem *dma_regbase;
+int hiedmacv310_trace_level_n = HIEDMACV310_TRACE_LEVEL;
+
+struct hiedmac_host {
+	struct platform_device *pdev;
+	void __iomem *base;
+	struct regmap *misc_regmap;
+	unsigned int misc_ctrl_base;
+	void __iomem *crg_ctrl;
+	unsigned int id;
+	struct clk *clk;
+	struct clk *axi_clk;
+	unsigned int irq;
+	struct reset_control *rstc;
+	unsigned int channels;
+	unsigned int slave_requests;
+};
+
+#define DRIVER_NAME "hiedmacv310"
+
+int dmac_channel_allocate(void)
+{
+	unsigned int i;
+
+	for (i = 0; i < HIEDMAC_CHANNEL_NUM; i++) {
+		if (g_channel_status[i] == DMAC_CHN_VACANCY) {
+			g_channel_status[i] = DMAC_CHN_ALLOCAT;
+			return i;
+		}
+	}
+
+	hiedmacv310_error("no to alloc\n");
+	return -1;
+}
+EXPORT_SYMBOL(dmac_channel_allocate);
+
+/*
+ *	update the state of channels
+ */
+static int hiedmac_update_status(unsigned int channel)
+{
+	unsigned int channel_status;
+	unsigned int channel_tc_status;
+	unsigned int channel_err_status[3];
+	unsigned int i = channel;
+	unsigned long update_jiffies_timeout;
+
+	update_jiffies_timeout = jiffies + HIEDMAC_UPDATE_TIMEOUT;
+
+	while (1) {
+		channel_status = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_STAT);
+		channel_status = (channel_status >> i) & 0x01;
+		if (channel_status) {
+			channel_tc_status = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_TC1);
+			channel_tc_status = (channel_tc_status >> i) & 0x01;
+			if (channel_tc_status) {
+				hiedmacv310_writel(1 << i, dma_regbase + HIEDMAC_INT_TC1_RAW);
+				g_channel_status[i] = DMAC_CHN_SUCCESS;
+				break;
+			}
+
+			channel_tc_status = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_TC2);
+			channel_tc_status = (channel_tc_status >> i) & 0x01;
+			if (channel_tc_status) {
+				hiedmacv310_writel(1 << i, dma_regbase + HIEDMAC_INT_TC2_RAW);
+				g_channel_status[i] = DMAC_CHN_SUCCESS;
+				break;
+			}
+
+			channel_err_status[0] = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_ERR1);
+			channel_err_status[0] = (channel_err_status[0] >> i) & 0x01;
+			channel_err_status[1] = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_ERR2);
+			channel_err_status[1] = (channel_err_status[1] >> i) & 0x01;
+			channel_err_status[2] = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_ERR3);
+			channel_err_status[2] = (channel_err_status[2] >> i) & 0x01;
+
+			if (channel_err_status[0] | channel_err_status[1] | channel_err_status[2]) {
+				hiedmacv310_error("Error in HIEDMAC %d finish!\n", i);
+				channel_err_status[0] = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_ERR1);
+				channel_err_status[1] = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_ERR2);
+				channel_err_status[2] = hiedmacv310_readl(dma_regbase + HIEDMAC_INT_ERR3);
+				g_channel_status[i] = -DMAC_CHN_ERROR;
+				hiedmacv310_writel(1 << i, dma_regbase + HIEDMAC_INT_ERR1_RAW);
+				hiedmacv310_writel(1 << i, dma_regbase + HIEDMAC_INT_ERR2_RAW);
+				hiedmacv310_writel(1 << i, dma_regbase + HIEDMAC_INT_ERR3_RAW);
+				break;
+			}
+		}
+
+		if (!time_before(jiffies, update_jiffies_timeout)) {
+			hiedmacv310_error("Timeout in DMAC %d!\n", i);
+			g_channel_status[i] = -DMAC_CHN_TIMEOUT;
+			break;
+		}
+	}
+
+	return g_channel_status[i];
+}
+
+/*
+ * register user's function
+ */
+int dmac_register_isr(unsigned int channel, void *pisr)
+{
+	if (channel < 0 || channel > HIEDMAC_CHANNEL_NUM - 1) {
+		hiedmacv310_error("invalid channel,channel=%0d\n", channel);
+		return -EINVAL;
+	}
+
+	function[channel] = (void *)pisr;
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_register_isr);
+
+/*
+ *	free channel
+ */
+int dmac_channel_free(unsigned int channel)
+{
+	if ((channel >= 0) && (channel < HIEDMAC_CHANNEL_NUM))
+		g_channel_status[channel] = DMAC_CHN_VACANCY;
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_channel_free);
+
+static unsigned int dmac_check_request(unsigned int peripheral_addr,
+				       int direction)
+{
+	int i;
+
+	for (i = direction; i < EDMAC_MAX_PERIPHERALS; i += 2) {
+		if (g_peripheral[i].peri_addr == peripheral_addr)
+			return i;
+	}
+	hiedmacv310_error("Invalid devaddr\n");
+	return -1;
+}
+
+void edmac_channel_free(int channel)
+{
+	if ((channel >= 0) && (channel < HIEDMAC_CHANNEL_NUM))
+		g_channel_status[channel] = DMAC_CHN_VACANCY;
+}
+/*
+ *	wait for transfer end
+ */
+int dmac_wait(int channel)
+{
+	int ret_result;
+	int ret = 0;
+
+	if (channel < 0)
+		return -1;
+
+	while (1) {
+		ret_result = hiedmac_update_status(channel);
+		if (ret_result == -DMAC_CHN_ERROR) {
+			hiedmacv310_error("Transfer Error.\n");
+			ret = -1;
+			goto end;
+		} else  if (ret_result == DMAC_NOT_FINISHED)
+			udelay(10);
+		else if (ret_result == DMAC_CHN_SUCCESS) {
+			ret = DMAC_CHN_SUCCESS;
+			goto end;
+		} else if (ret_result == DMAC_CHN_VACANCY) {
+			ret = DMAC_CHN_SUCCESS;
+			goto end;
+		} else if (ret_result == -DMAC_CHN_TIMEOUT) {
+			hiedmacv310_error("Timeout.\n");
+			hiedmacv310_writel(HIEDMAC_Cx_DISABLE,
+					   dma_regbase + HIEDMAC_Cx_CONFIG(channel));
+			g_channel_status[channel] = DMAC_CHN_VACANCY;
+			ret = -1;
+			return ret;
+		}
+	}
+end:
+	hiedmacv310_writel(HIEDMAC_Cx_DISABLE,
+			   dma_regbase + HIEDMAC_Cx_CONFIG(channel));
+	edmac_channel_free(channel);
+	return ret;
+}
+EXPORT_SYMBOL(dmac_wait);
+
+/*
+ *	execute memory to peripheral dma transfer without LLI
+ */
+int dmac_m2p_transfer(unsigned long long memaddr, unsigned int uwperipheralid,
+		      unsigned int length)
+{
+	unsigned int ulchnn;
+	unsigned int uwwidth;
+	unsigned int temp;
+
+	ulchnn = dmac_channel_allocate();
+	if (-1 == ulchnn)
+		return -1;
+
+	hiedmacv310_trace(4, "ulchnn = %d\n", ulchnn);
+	uwwidth = g_peripheral[uwperipheralid].transfer_width;
+	if (length >> uwwidth >= HIEDMAC_TRANS_MAXSIZE) {
+		hiedmacv310_error("The length is more than 64k!\n");
+		return -1;
+	}
+
+	hiedmacv310_writel(memaddr & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_SRC_ADDR_L(ulchnn));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel((memaddr >> 32) & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_SRC_ADDR_H(ulchnn));
+#endif
+	hiedmacv310_trace(4, "HIEDMAC_Cx_SRC_ADDR_L = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_SRC_ADDR_L(ulchnn)));
+
+	hiedmacv310_writel(g_peripheral[uwperipheralid].peri_addr & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_DEST_ADDR_L(ulchnn));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel((g_peripheral[uwperipheralid].peri_addr >> 32) & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_DEST_ADDR_H(ulchnn));
+#endif
+	hiedmacv310_trace(4, "HIEDMAC_Cx_DEST_ADDR_L = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_DEST_ADDR_L(ulchnn)));
+
+	hiedmacv310_writel(0, dma_regbase + HIEDMAC_Cx_LLI_L(ulchnn));
+	hiedmacv310_trace(4, "HIEDMAC_Cx_LLI_L = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_LLI_L(ulchnn)));
+
+	hiedmacv310_writel(length, dma_regbase + HIEDMAC_Cx_CNT0(ulchnn));
+	hiedmacv310_trace(4, "HIEDMAC_Cx_CNT0 = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_CNT0(ulchnn)));
+
+	temp = g_peripheral[uwperipheralid].transfer_cfg | uwwidth <<
+	       EDMA_SRC_WIDTH_OFFSET |
+	       (uwperipheralid << PERI_ID_OFFSET) |
+	       EDMA_CH_ENABLE;
+	hiedmacv310_trace(4, "HIEDMAC_Cx_CONFIG = 0x%x\n", temp);
+	hiedmacv310_writel(temp, dma_regbase + HIEDMAC_Cx_CONFIG(ulchnn));
+	return ulchnn;
+}
+
+/*
+ *	execute memory to peripheral dma transfer without LLI
+ */
+int dmac_p2m_transfer(unsigned long memaddr, unsigned int uwperipheralid,
+		      unsigned int length)
+{
+	unsigned int ulchnn;
+	unsigned int uwwidth;
+	unsigned int temp;
+
+	ulchnn = dmac_channel_allocate();
+	if (-1 == ulchnn)
+		return -1;
+
+	hiedmacv310_trace(4, "ulchnn = %d\n", ulchnn);
+	uwwidth = g_peripheral[uwperipheralid].transfer_width;
+	if (length >> uwwidth >= HIEDMAC_TRANS_MAXSIZE) {
+		hiedmacv310_error("The length is more than 64k!\n");
+		return -1;
+	}
+
+	hiedmacv310_writel(memaddr & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_DEST_ADDR_L(ulchnn));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel((memaddr >> 32) & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_DEST_ADDR_H(ulchnn));
+#endif
+	hiedmacv310_trace(4, "HIEDMAC_Cx_DEST_ADDR_L = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_DEST_ADDR_L(ulchnn)));
+
+	hiedmacv310_writel(g_peripheral[uwperipheralid].peri_addr & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_SRC_ADDR_L(ulchnn));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel(0, dma_regbase + HIEDMAC_Cx_SRC_ADDR_H(ulchnn));
+#endif
+	hiedmacv310_trace(4, "HIEDMAC_Cx_SRC_ADDR_L = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_SRC_ADDR_L(ulchnn)));
+
+	hiedmacv310_writel(0, dma_regbase + HIEDMAC_Cx_LLI_L(ulchnn));
+	hiedmacv310_trace(4, "HIEDMAC_Cx_LLI_L = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_LLI_L(ulchnn)));
+
+	hiedmacv310_writel(length, dma_regbase + HIEDMAC_Cx_CNT0(ulchnn));
+	hiedmacv310_trace(4, "HIEDMAC_Cx_CNT0 = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_CNT0(ulchnn)));
+
+	temp = g_peripheral[uwperipheralid].transfer_cfg | uwwidth <<
+	       EDMA_SRC_WIDTH_OFFSET |
+	       (uwperipheralid << PERI_ID_OFFSET) |
+	       EDMA_CH_ENABLE;
+	hiedmacv310_trace(4, "HIEDMAC_Cx_CONFIG = 0x%x\n", temp);
+	hiedmacv310_writel(temp, dma_regbase + HIEDMAC_Cx_CONFIG(ulchnn));
+	return ulchnn;
+}
+
+int do_dma_m2p(unsigned long long memaddr, unsigned int peripheral_addr,
+	       unsigned int length)
+{
+	int ret = 0;
+	int uwperipheralid;
+
+	uwperipheralid = dmac_check_request(peripheral_addr, EDMAC_TX);
+	if (uwperipheralid < 0) {
+		hiedmacv310_error("m2p:Invalid devaddr\n");
+		return -1;
+	}
+
+	ret = dmac_m2p_transfer(memaddr, uwperipheralid, length);
+	if (ret == -1) {
+		hiedmacv310_error("m2p:trans err\n");
+		return -1;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(do_dma_m2p);
+
+int do_dma_p2m(unsigned long memaddr, unsigned int peripheral_addr,
+	       unsigned int length)
+{
+	int ret = -1;
+	int uwperipheralid;
+
+	uwperipheralid = dmac_check_request(peripheral_addr, EDMAC_RX);
+	if (uwperipheralid < 0) {
+		hiedmacv310_error("p2m:Invalid devaddr.\n");
+		return -1;
+	}
+
+	ret = dmac_p2m_transfer(memaddr, uwperipheralid, length);
+	if (ret == -1) {
+		hiedmacv310_error("p2m:trans err\n");
+		return -1;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(do_dma_p2m);
+
+/*
+ *	buile LLI for memory to memory DMA transfer
+ */
+int dmac_buildllim2m(unsigned long *ppheadlli,
+		     unsigned long psource,
+		     unsigned long pdest,
+		     unsigned int totaltransfersize,
+		     unsigned int uwnumtransfers)
+{
+	int lli_num = 0;
+	unsigned long phy_address;
+	int j;
+	dmac_lli  *plli = NULL;
+
+	if (uwnumtransfers == 0)
+		return -EINVAL;
+
+	lli_num = (totaltransfersize / uwnumtransfers);
+	if ((totaltransfersize % uwnumtransfers) != 0)
+		lli_num++;
+
+	hiedmacv310_trace(4, "lli_num:%d\n", lli_num);
+
+	phy_address = ppheadlli[0];
+	plli = (dmac_lli *)ppheadlli[1];
+	hiedmacv310_trace(4, "phy_address: 0x%lx\n", phy_address);
+	hiedmacv310_trace(4, "address: 0x%p\n", plli);
+	for (j = 0; j < lli_num; j++) {
+		memset(plli, 0x0, sizeof(dmac_lli));
+		/*
+		 * at the last transfer, chain_en should be set to 0x0;
+		 * others tansfer,chain_en should be set to 0x2;
+		 */
+		plli->next_lli = (phy_address + (j + 1) * sizeof(dmac_lli)) &
+				  (~(HIEDMAC_LLI_ALIGN - 1));
+		if (j < lli_num - 1) {
+			plli->next_lli |= HIEDMAC_LLI_ENABLE;
+			plli->count = uwnumtransfers;
+		} else {
+			plli->next_lli |= HIEDMAC_LLI_DISABLE;
+			plli->count = totaltransfersize % uwnumtransfers;
+		}
+
+		plli->src_addr = psource;
+		plli->dest_addr = pdest;
+		plli->config = HIEDMAC_CxCONFIG_M2M_LLI;
+
+		psource += uwnumtransfers;
+		pdest += uwnumtransfers;
+		plli++;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_buildllim2m);
+
+/*
+ *	load configuration from LLI for memory to memory
+ */
+int dmac_start_llim2m(unsigned int channel, unsigned long *pfirst_lli)
+{
+	unsigned int i = channel;
+	dmac_lli  *plli;
+
+	plli = (dmac_lli *)pfirst_lli[1];
+	hiedmacv310_trace(4, "plli.src_addr: 0x%lx\n", plli->src_addr);
+	hiedmacv310_trace(4, "plli.dst_addr: 0x%lx\n", plli->dest_addr);
+	hiedmacv310_trace(4, "plli.next_lli: 0x%lx\n", plli->next_lli);
+	hiedmacv310_trace(4, "plli.count: 0x%d\n", plli->count);
+
+	hiedmacv310_writel(plli->dest_addr & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_LLI_L(i));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel((plli->dest_addr >> 32) & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_LLI_H(i));
+#endif
+	hiedmacv310_writel(plli->count, dma_regbase + HIEDMAC_Cx_CNT0(i));
+
+	hiedmacv310_writel(plli->src_addr & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_SRC_ADDR_L(i));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel((plli->src_addr >> 32) & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_SRC_ADDR_H(i));
+#endif
+	hiedmacv310_writel(plli->dest_addr & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_DEST_ADDR_L(i));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel((plli->dest_addr >> 32) & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_DEST_ADDR_H(i));
+#endif
+	hiedmacv310_writel(plli->config | EDMA_CH_ENABLE,
+			   dma_regbase + HIEDMAC_Cx_CONFIG(i));
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_start_llim2m);
+
+/*
+ * config register for memory to memory DMA transfer without LLI
+ */
+int dmac_start_m2m(unsigned int  channel, unsigned long psource,
+		   unsigned long pdest, unsigned int uwnumtransfers)
+{
+	unsigned int i = channel;
+
+	if (uwnumtransfers > HIEDMAC_TRANS_MAXSIZE || uwnumtransfers == 0) {
+		hiedmacv310_error("Invalidate transfer size,size=%x\n", uwnumtransfers);
+		return -EINVAL;
+	}
+	hiedmacv310_trace(4, "channel[%d],source=0x%lx,dest=0x%lx,length=%d\n",
+			  channel, psource, pdest, uwnumtransfers);
+
+	hiedmacv310_writel(psource & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_SRC_ADDR_L(i));
+	hiedmacv310_trace(4, "HIEDMAC_Cx_SRC_ADDR_L = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_SRC_ADDR_L(i)));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel((psource >> 32) & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_SRC_ADDR_H(i));
+	hiedmacv310_trace(4, "HIEDMAC_Cx_SRC_ADDR_H = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_SRC_ADDR_H(i)));
+#endif
+	hiedmacv310_writel(pdest & 0xffffffff, dma_regbase + HIEDMAC_Cx_DEST_ADDR_L(i));
+	hiedmacv310_trace(4, "HIEDMAC_Cx_DEST_ADDR_L = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_DEST_ADDR_L(i)));
+#ifdef CONFIG_ARM64
+	hiedmacv310_writel((pdest >> 32) & 0xffffffff,
+			   dma_regbase + HIEDMAC_Cx_DEST_ADDR_H(i));
+	hiedmacv310_trace(4, "HIEDMAC_Cx_DEST_ADDR_H = 0x%x\n",
+			  hiedmacv310_readl(dma_regbase + HIEDMAC_Cx_DEST_ADDR_H(i)));
+#endif
+	hiedmacv310_writel(0, dma_regbase + HIEDMAC_Cx_LLI_L(i));
+
+	hiedmacv310_writel(uwnumtransfers, dma_regbase + HIEDMAC_Cx_CNT0(i));
+
+	hiedmacv310_writel(HIEDMAC_CxCONFIG_M2M | EDMA_CH_ENABLE,
+			   dma_regbase + HIEDMAC_Cx_CONFIG(i));
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_start_m2m);
+
+/*
+ *	execute memory to memory dma transfer without LLI
+ */
+int dmac_m2m_transfer(unsigned long source, unsigned long dest,
+		      unsigned int length)
+{
+	unsigned int dma_size = 0;
+	unsigned int ulchnn, dma_count, left_size;
+
+	left_size = length;
+	dma_count = 0;
+	ulchnn = dmac_channel_allocate();
+	if (ulchnn < 0) {
+		return -EINVAL;
+	}
+
+	hiedmacv310_trace(6, "using channel[%d],source=0x%lx,dest=0x%lx,length=%d\n",
+			  ulchnn, source, dest, length);
+
+	while (left_size) {
+		if (left_size >= HIEDMAC_TRANS_MAXSIZE)
+			dma_size = HIEDMAC_TRANS_MAXSIZE;
+		else
+			dma_size = left_size;
+		dmac_start_m2m(ulchnn,
+			       source + dma_count * dma_size,
+			       dest + dma_count * dma_size,
+			       dma_size);
+
+		if (dmac_wait(ulchnn) != DMAC_CHN_SUCCESS) {
+			hiedmacv310_error("dma transfer error...\n");
+			return -1;
+		}
+		left_size -= dma_size;
+		dma_count++;
+		hiedmacv310_trace(4, "left_size is %d.\n", left_size);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dmac_m2m_transfer);
+
+/*
+ * memory to memory dma transfer with LLI
+ *
+ * @source
+ * @dest
+ * @length
+ * */
+int do_dma_llim2m(unsigned long source,
+		  unsigned long dest,
+		  unsigned long length)
+{
+	int ret = 0;
+	unsigned chnn;
+
+	chnn = dmac_channel_allocate();
+	if (chnn < 0) {
+		ret = -1;
+		goto end;
+	}
+	hiedmacv310_trace(4, "chnn:%d,src:%lx,dst:%lx,len:%ld.\n", chnn, source, dest,
+			  length);
+
+	if (pllihead[0] == 0) {
+		hiedmacv310_error("ppheadlli[0] is NULL.\n");
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	ret = dmac_buildllim2m(pllihead, source, dest, length, HIEDMAC_TRANS_MAXSIZE);
+	if (ret) {
+		hiedmacv310_error("build lli error...\n");
+		ret = -EIO;
+		goto end;
+	}
+	ret = dmac_start_llim2m(chnn, pllihead);
+	if (ret) {
+		hiedmacv310_error("start lli error...\n");
+		ret = -EIO;
+		goto end;
+	}
+
+end:
+	return ret;
+}
+EXPORT_SYMBOL(do_dma_llim2m);
+
+/*
+ *	alloc_dma_lli_space
+ *	output:
+ *             ppheadlli[0]: memory physics address
+ *             ppheadlli[1]: virtual address
+ *
+ */
+int allocate_dmalli_space(struct device *dev, unsigned long *ppheadlli,
+			  unsigned int page_num)
+{
+	dma_addr_t dma_phys;
+	void *dma_virt;
+
+	dma_virt = dma_alloc_coherent(dev, page_num * PAGE_SIZE,
+				      &dma_phys, GFP_DMA);
+	if (dma_virt == NULL) {
+		hiedmacv310_error("can't get dma mem from system\n");
+		return -1;
+	}
+
+	ppheadlli[0] = (unsigned long)(dma_phys);
+	ppheadlli[1] = (unsigned long)(dma_virt);
+
+	if (dma_phys & (HIEDMAC_LLI_ALIGN - 1)) {
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(allocate_dmalli_space);
+
+static int hiedmac_priv_init(struct hiedmac_host *hiedmac,
+			     edmac_peripheral *peripheral_info)
+{
+	struct regmap *misc = hiedmac->misc_regmap;
+	int i = 0;
+	unsigned int count = 0;
+	unsigned int offset = 0;
+	unsigned ctrl = 0;
+
+	for (i = 0; i < EDMAC_MAX_PERIPHERALS; i++) {
+		if (peripheral_info[i].host_sel == hiedmac->id) {
+			if (count > 32) {
+				hiedmacv310_error("request table is not true!\n");
+				return -1;
+			}
+			if (misc != NULL) {
+				offset = hiedmac->misc_ctrl_base + (count & (~0x3));
+				regmap_read(misc, offset, &ctrl);
+				ctrl &= ~(0x3f << ((count & 0x3) << 3));
+				ctrl |= peripheral_info[i].peri_id << ((count & 0x3) << 3);
+				regmap_write(misc, offset, ctrl);
+			}
+			peripheral_info[i].dynamic_periphery_num = count;
+			count++;
+		}
+	}
+
+	return 0;
+}
+
+static int get_of_probe(struct hiedmac_host *hiedmac)
+{
+	struct resource *res = NULL;
+	struct platform_device *platdev = hiedmac->pdev;
+	struct device_node *np = platdev->dev.of_node;
+	int ret;
+
+	ret = of_property_read_u32((&platdev->dev)->of_node,
+				   "devid", &(hiedmac->id));
+	if (ret) {
+		hiedmacv310_error("get hiedmac id fail\n");
+		return -ENODEV;
+	}
+
+	hiedmac->clk = devm_clk_get(&(platdev->dev), "apb_pclk");
+	if (IS_ERR(hiedmac->clk)) {
+		hiedmacv310_error("get hiedmac clk fail\n");
+		return PTR_ERR(hiedmac->clk);
+	}
+
+	hiedmac->axi_clk = devm_clk_get(&(platdev->dev), "axi_aclk");
+	if (IS_ERR(hiedmac->axi_clk)) {
+		hiedmacv310_error("get hiedmac axi clk fail\n");
+		return PTR_ERR(hiedmac->axi_clk);
+	}
+
+	hiedmac->rstc = devm_reset_control_get(&(platdev->dev), "dma-reset");
+	if (IS_ERR(hiedmac->rstc)) {
+		hiedmacv310_error("get hiedmac rstc fail\n");
+		return PTR_ERR(hiedmac->rstc);
+	}
+
+	res = platform_get_resource(platdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		hiedmacv310_error("no reg resource\n");
+		return -ENODEV;
+	}
+
+	hiedmac->base = devm_ioremap_resource(&(platdev->dev), res);
+	if (IS_ERR(hiedmac->base)) {
+		hiedmacv310_error("get hiedmac base fail\n");
+		return PTR_ERR(hiedmac->base);
+	}
+	if (!of_find_property(np, "misc_regmap", NULL) ||
+			!of_find_property(np, "misc_ctrl_base", NULL)) {
+		hiedmac->misc_regmap = 0;
+	} else {
+		hiedmac->misc_regmap = syscon_regmap_lookup_by_phandle(np, "misc_regmap");
+		if (IS_ERR(hiedmac->misc_regmap)) {
+			hiedmacv310_error("get hiedmac misc fail\n");
+			return PTR_ERR(hiedmac->misc_regmap);
+		}
+
+		ret = of_property_read_u32((&platdev->dev)->of_node,
+					   "misc_ctrl_base", &(hiedmac->misc_ctrl_base));
+		if (ret) {
+			hiedmacv310_error("get dma-misc_ctrl_base fail\n");
+			return -ENODEV;
+		}
+	}
+	hiedmac->irq = platform_get_irq(platdev, 0);
+	if (unlikely(hiedmac->irq < 0))
+		return -ENODEV;
+
+	ret = of_property_read_u32((&platdev->dev)->of_node,
+				   "dma-channels", &(hiedmac->channels));
+	if (ret) {
+		hiedmacv310_error("get dma-channels fail\n");
+		return -ENODEV;
+	}
+	ret = of_property_read_u32((&platdev->dev)->of_node,
+				   "dma-requests", &(hiedmac->slave_requests));
+	if (ret) {
+		hiedmacv310_error("get dma-requests fail\n");
+		return -ENODEV;
+	}
+	hiedmacv310_trace(2, "dma-channels = %d, dma-requests = %d\n",
+			  hiedmac->channels, hiedmac->slave_requests);
+
+	hiedmac_priv_init(hiedmac, (edmac_peripheral *)&g_peripheral);
+
+	return 0;
+}
+
+/* Don't need irq mode now */
+#if defined(CONFIG_HIEDMAC_INTERRUPT)
+static irqreturn_t hiemdacv310_irq(int irq, void *dev)
+{
+	struct hiedmac_host *hiedmac = (struct hiedmac_host *)dev;
+	unsigned int channel_err_status[3];
+	unsigned int channel_tc_status = 0;
+	unsigned int channel_status = 0;
+	int i = 0;
+	unsigned int mask = 0;
+
+	channel_status = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_STAT);
+	if (!channel_status) {
+		hiedmacv310_error("channel_status = 0x%x\n", channel_status);
+		return IRQ_NONE;
+	}
+
+	for (i = 0; i < hiedmac->channels; i++) {
+		channel_status = (channel_status >> i) & 0x1;
+		if (channel_status) {
+			channel_tc_status = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_TC1_RAW);
+			channel_tc_status = (channel_tc_status >> i) & 0x01;
+			if (channel_tc_status)
+				hiedmacv310_writel(channel_tc_status << i, hiedmac->base + HIEDMAC_INT_TC1_RAW);
+
+			channel_tc_status = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_TC2);
+			channel_tc_status = (channel_tc_status >> i) & 0x01;
+			if (channel_tc_status)
+				hiedmacv310_writel(channel_tc_status << i, hiedmac->base + HIEDMAC_INT_TC2_RAW);
+
+			channel_err_status[0] = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_ERR1);
+			channel_err_status[0] = (channel_err_status[0] >> i) & 0x01;
+			channel_err_status[1] = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_ERR2);
+			channel_err_status[1] = (channel_err_status[1] >> i) & 0x01;
+			channel_err_status[2] = hiedmacv310_readl(hiedmac->base + HIEDMAC_INT_ERR3);
+			channel_err_status[2] = (channel_err_status[2] >> i) & 0x01;
+
+			if (channel_err_status[0] | channel_err_status[1] | channel_err_status[2]) {
+				hiedmacv310_error("Error in hiedmac %d finish!,ERR1 = 0x%x,ERR2 = 0x%x,ERR3 = 0x%x\n",
+						  i, channel_err_status[0], channel_err_status[1], channel_err_status[2]);
+				hiedmacv310_writel(1 << i, hiedmac->base + HIEDMAC_INT_ERR1_RAW);
+				hiedmacv310_writel(1 << i, hiedmac->base + HIEDMAC_INT_ERR2_RAW);
+				hiedmacv310_writel(1 << i, hiedmac->base + HIEDMAC_INT_ERR3_RAW);
+			}
+			if ((function[i]) != NULL)
+				function[i](i, g_channel_status[i]);
+
+			mask |= (1 << i);
+			hiedmacv310_writel(HIEDMAC_Cx_DISABLE, dma_regbase + HIEDMAC_Cx_CONFIG(i));
+			edmac_channel_free(i);
+		}
+	}
+
+	return mask ? IRQ_HANDLED : IRQ_NONE;
+}
+#endif
+
+static int __init hiedmacv310_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	int i = 0;
+	struct hiedmac_host *hiedmac = NULL;
+
+	hiedmac = kzalloc(sizeof(*hiedmac), GFP_KERNEL);
+	if (!hiedmac) {
+		hiedmacv310_error("malloc for hiedmac fail!");
+		ret = -ENOMEM;
+		return ret;
+	}
+	hiedmac->pdev = pdev;
+
+	ret = get_of_probe(hiedmac);
+	if (ret) {
+		hiedmacv310_error("get dts info fail!");
+		goto free_hiedmac;
+	}
+
+	clk_prepare_enable(hiedmac->clk);
+	clk_prepare_enable(hiedmac->axi_clk);
+
+	reset_control_deassert(hiedmac->rstc);
+
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_TC1_RAW);
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_TC2_RAW);
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_ERR1_RAW);
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_ERR2_RAW);
+	hiedmacv310_writel(HIEDMAC_ALL_CHAN_CLR, hiedmac->base + HIEDMAC_INT_ERR3_RAW);
+
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_TC1_MASK);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_TC2_MASK);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_ERR1_MASK);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_ERR2_MASK);
+	hiedmacv310_writel(HIEDMAC_INT_ENABLE_ALL_CHAN,
+			   hiedmac->base + HIEDMAC_INT_ERR3_MASK);
+
+	for (i = 0; i < HIEDMAC_CHANNEL_NUM; i++)
+		g_channel_status[i] = DMAC_CHN_VACANCY;
+
+	dma_regbase = hiedmac->base;
+
+	ret = allocate_dmalli_space(&(hiedmac->pdev->dev), pllihead,
+				    HIEDMAC_LLI_PAGE_NUM);
+	if (ret < 0)
+		goto free_hiedmac;
+
+#if defined(CONFIG_HIEDMAC_INTERRUPT)
+	/* register irq if necessary !*/
+	ret = request_irq(hiedmac->irq, hiemdacv310_irq, 0, DRIVER_NAME, hiedmac);
+	if (ret) {
+		hiedmacv310_error("fail to request irq");
+		goto free_hiedmac;
+	}
+#endif
+	return 0;
+
+free_hiedmac:
+	kfree(hiedmac);
+
+	return ret;
+}
+
+static int hiemda_remove(struct platform_device *pdev)
+{
+	int err = 0;
+	return err;
+}
+
+static const struct of_device_id hiedmacv310_match[] = {
+	{ .compatible = "hisilicon,hiedmacv310_n" },
+	{},
+};
+
+static struct platform_driver hiedmacv310_driver = {
+	.remove = hiemda_remove,
+	.driver = {
+		.name   = "hiedmacv310_n",
+		.of_match_table = hiedmacv310_match,
+	},
+};
+
+static int __init hiedmacv310_init(void)
+{
+	return platform_driver_probe(&hiedmacv310_driver, hiedmacv310_probe);
+}
+subsys_initcall(hiedmacv310_init);
+
+static void __exit hiedmacv310_exit(void)
+{
+	platform_driver_unregister(&hiedmacv310_driver);
+}
+module_exit(hiedmacv310_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hisilicon");
diff --git a/drivers/hiedmac/hiedmacv310.h b/drivers/hiedmac/hiedmacv310.h
new file mode 100644
index 000000000..4344d8940
--- /dev/null
+++ b/drivers/hiedmac/hiedmacv310.h
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __HIEDMACV310_H__
+#define __HIEDMACV310_H__
+
+/* debug control */
+extern int hiedmacv310_trace_level_n;
+#define HIEDMACV310_TRACE_LEVEL 5
+
+#define HIEDMACV310_TRACE_FMT KERN_INFO
+
+typedef void DMAC_ISR(unsigned int channel, int status);
+
+#define HIEDMAC_UPDATE_TIMEOUT  (30 * HZ)
+#define HIEDMAC_TRANS_MAXSIZE     (64 * 1024 - 1)
+
+#define DEBUG_HIEDMAC
+#ifdef  DEBUG_HIEDMAC
+
+#define hiedmacv310_trace(level, msg...) do { \
+    if ((level) >= hiedmacv310_trace_level_n) { \
+        printk(HIEDMACV310_TRACE_FMT"%s:%d: ", __func__, __LINE__); \
+        printk(msg); \
+        printk("\n"); \
+    } \
+} while (0)
+
+
+#define hiedmacv310_assert(cond) do { \
+    if (!(cond)) { \
+        printk(KERN_ERR "Assert:hiedmacv310:%s:%d\n", \
+                __func__, \
+                __LINE__); \
+        BUG(); \
+    } \
+} while (0)
+
+#define hiedmacv310_error(s...) do { \
+    printk(KERN_ERR "hiedmacv310:%s:%d: ", __func__, __LINE__); \
+    printk(s); \
+    printk("\n"); \
+} while (0)
+
+#else
+
+#define hiedmacv310_trace(level, msg...) do { } while (0)
+#define hiedmacv310_assert(level, msg...) do { } while (0)
+#define hiedmacv310_error(level, msg...) do { } while (0)
+
+#endif
+
+#define hiedmacv310_readl(addr) ({unsigned int reg = readl((void *)(addr)); \
+        reg; })
+
+#define hiedmacv310_writel(v, addr) do { writel(v, (void *)(addr)); \
+} while (0)
+
+
+#define MAX_TRANSFER_BYTES  0xffff
+
+/* reg offset */
+#define HIEDMAC_INT_STAT                  (0x0)
+#define HIEDMAC_INT_TC1                   (0x4)
+#define HIEDMAC_INT_TC2                   (0x8)
+#define HIEDMAC_INT_ERR1                  (0xc)
+#define HIEDMAC_INT_ERR2                  (0x10)
+#define HIEDMAC_INT_ERR3                  (0x14)
+#define HIEDMAC_INT_TC1_MASK              (0x18)
+#define HIEDMAC_INT_TC2_MASK              (0x1c)
+#define HIEDMAC_INT_ERR1_MASK             (0x20)
+#define HIEDMAC_INT_ERR2_MASK             (0x24)
+#define HIEDMAC_INT_ERR3_MASK             (0x28)
+
+#define HIEDMAC_INT_TC1_RAW               (0x600)
+#define HIEDMAC_INT_TC2_RAW               (0x608)
+#define HIEDMAC_INT_ERR1_RAW              (0x610)
+#define HIEDMAC_INT_ERR2_RAW              (0x618)
+#define HIEDMAC_INT_ERR3_RAW              (0x620)
+
+#define HIEDMAC_Cx_CURR_CNT0(cn)          (0x404 + cn * 0x20)
+#define HIEDMAC_Cx_CURR_SRC_ADDR_L(cn)    (0x408 + cn * 0x20)
+#define HIEDMAC_Cx_CURR_SRC_ADDR_H(cn)    (0x40c + cn * 0x20)
+#define HIEDMAC_Cx_CURR_DEST_ADDR_L(cn)    (0x410 + cn * 0x20)
+#define HIEDMAC_Cx_CURR_DEST_ADDR_H(cn)    (0x414 + cn * 0x20)
+
+#define HIEDMAC_CH_PRI                    (0x688)
+#define HIEDMAC_CH_STAT                   (0x690)
+#define HIEDMAC_DMA_CTRL                  (0x698)
+
+#define HIEDMAC_Cx_BASE(cn)               (0x800 + cn * 0x40)
+#define HIEDMAC_Cx_LLI_L(cn)              (0x800 + cn * 0x40)
+#define HIEDMAC_Cx_LLI_H(cn)              (0x804 + cn * 0x40)
+#define HIEDMAC_Cx_CNT0(cn)               (0x81c + cn * 0x40)
+#define HIEDMAC_Cx_SRC_ADDR_L(cn)         (0x820 + cn * 0x40)
+#define HIEDMAC_Cx_SRC_ADDR_H(cn)         (0x824 + cn * 0x40)
+#define HIEDMAC_Cx_DEST_ADDR_L(cn)         (0x828 + cn * 0x40)
+#define HIEDMAC_Cx_DEST_ADDR_H(cn)         (0x82c + cn * 0x40)
+#define HIEDMAC_Cx_CONFIG(cn)             (0x830 + cn * 0x40)
+
+#define HIEDMAC_CxCONFIG_M2M            0xCFF33000
+#define HIEDMAC_CxCONFIG_M2M_LLI        0xCFF00000
+#define HIEDMAC_CxCONFIG_CHN_START  0x1
+#define HIEDMAC_Cx_DISABLE           0x0
+
+#define HIEDMAC_ALL_CHAN_CLR        (0xff)
+#define HIEDMAC_INT_ENABLE_ALL_CHAN (0xff)
+
+
+#define HIEDMAC_CONFIG_SRC_INC          (1<<31)
+#define HIEDMAC_CONFIG_DST_INC          (1<<30)
+
+#define HIEDMAC_CONFIG_SRC_WIDTH_SHIFT  (16)
+#define HIEDMAC_CONFIG_DST_WIDTH_SHIFT  (12)
+#define HIEDMAC_WIDTH_8BIT              (0x0)
+#define HIEDMAC_WIDTH_16BIT             (0x1)
+#define HIEDMAC_WIDTH_32BIT             (0x10)
+#define HIEDMAC_WIDTH_64BIT             (0x11)
+
+#define HIEDMAC_MAX_BURST_WIDTH         (16)
+#define HIEDMAC_MIN_BURST_WIDTH         (1)
+#define HIEDMAC_CONFIG_SRC_BURST_SHIFT  (24)
+#define HIEDMAC_CONFIG_DST_BURST_SHIFT  (20)
+
+#define HIEDMAC_LLI_ALIGN   0x40
+#define HIEDMAC_LLI_DISABLE 0x0
+#define HIEDMAC_LLI_ENABLE 0x2
+
+#define HIEDMAC_CXCONFIG_SIGNAL_SHIFT   (0x4)
+#define HIEDMAC_CXCONFIG_MEM_TYPE       (0x0)
+#define HIEDMAC_CXCONFIG_DEV_MEM_TYPE   (0x1)
+#define HIEDMAC_CXCONFIG_TSF_TYPE_SHIFT (0x2)
+#define HIEDMAC_CxCONFIG_LLI_START      (0x1)
+
+#define HIEDMAC_CXCONFIG_ITC_EN     (0x1)
+#define HIEDMAC_CXCONFIG_ITC_EN_SHIFT   (0x1)
+
+#define CCFG_EN 0x1
+
+/* DMAC peripheral structure */
+typedef struct edmac_peripheral {
+	/* peripherial ID */
+	unsigned int peri_id;
+	/* peripheral data register address */
+	unsigned long peri_addr;
+	/* config requset */
+	int host_sel;
+#define DMAC_HOST0 0
+#define DMAC_HOST1 1
+#define DMAC_NOT_USE (-1)
+	/* default channel configuration word */
+	unsigned int transfer_cfg;
+	/* default channel configuration word */
+	unsigned int transfer_width;
+	unsigned int dynamic_periphery_num;
+} edmac_peripheral;
+
+
+#define PERI_ID_OFFSET  4
+#define EDMA_SRC_WIDTH_OFFSET 16
+#define EDMA_DST_WIDTH_OFFSET 12
+#define EDMA_CH_ENABLE  1
+
+#define PERI_8BIT_MODE  0
+#define PERI_16BIT_MODE 1
+#define PERI_32BIT_MODE 2
+#define PERI_64BIT_MODE 3
+
+#define HIEDMAC_LLI_PAGE_NUM 0x4 /* 4*4K*65535B/64≈16MB */
+#endif
diff --git a/drivers/hisilicon/Kconfig b/drivers/hisilicon/Kconfig
new file mode 100644
index 000000000..ab5884c08
--- /dev/null
+++ b/drivers/hisilicon/Kconfig
@@ -0,0 +1,4 @@
+menu "Hisilicon driver support"
+
+source "drivers/hisilicon/cma/Kconfig"
+endmenu
diff --git a/drivers/hisilicon/Makefile b/drivers/hisilicon/Makefile
new file mode 100644
index 000000000..0ba50a756
--- /dev/null
+++ b/drivers/hisilicon/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_CMA)			+= cma/
diff --git a/drivers/hisilicon/cma/Kconfig b/drivers/hisilicon/cma/Kconfig
new file mode 100644
index 000000000..7472dccd8
--- /dev/null
+++ b/drivers/hisilicon/cma/Kconfig
@@ -0,0 +1,16 @@
+
+config CMA_MEM_SHARED
+	bool "Support sharing CMA memory with the heap"
+	depends on CMA && DMA_CMA
+	default no
+	help
+	  Support sharing CMA memory with the heap.
+
+config CMA_ADVANCE_SHARE
+	bool "Support cma advance share"
+	depends on CMA && DMA_CMA
+	select CMA_MEM_SHARED
+	default no
+	help
+	  Support advance sharing CMA memory with the heap.
+	  CMA Multiplex Ratio will be improved when this macro defined.
diff --git a/drivers/hisilicon/cma/Makefile b/drivers/hisilicon/cma/Makefile
new file mode 100644
index 000000000..eefda7f57
--- /dev/null
+++ b/drivers/hisilicon/cma/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_CMA) += hi_cma.o
diff --git a/drivers/hisilicon/cma/hi_cma.c b/drivers/hisilicon/cma/hi_cma.c
new file mode 100644
index 000000000..6ce2e2b45
--- /dev/null
+++ b/drivers/hisilicon/cma/hi_cma.c
@@ -0,0 +1,203 @@
+/*
+ * hi_cma.c
+ *
+ * Copyright (c) 2019 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/hi_cma.h>
+
+static u32 num_zones;
+static struct cma_zone hisi_zone[ZONE_MAX];
+static int use_bootargs;
+
+unsigned int get_cma_size(void)
+{
+	u32 i;
+	u64 total = 0;
+
+	for (i = 0; i < num_zones; i++) {
+		total += hisi_zone[i].nbytes;
+	}
+
+	/* unit is M */
+	return (unsigned int)(total >> 20);
+}
+
+int is_hicma_address(phys_addr_t phys, unsigned long size)
+{
+	phys_addr_t start, end;
+	u32 i;
+
+	for (i = 0; i < num_zones; i++) {
+		start = hisi_zone[i].phys_start;
+		end = hisi_zone[i].phys_start + hisi_zone[i].nbytes;
+
+		if ((phys >= start) && ((phys + size) <= end)) {
+			/*
+			 * Yes, found!
+			 */
+			return 1;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(is_hicma_address);
+
+static int __init hisi_mmz_parse_cmdline(char *s)
+{
+	char *line = NULL, *tmp = NULL;
+	char tmpline[256];
+
+	if (s == NULL) {
+		pr_info("There is no cma zone!\n");
+		return 0;
+	}
+	strncpy(tmpline, s, sizeof(tmpline) - 1);
+	tmpline[sizeof(tmpline) - 1] = '\0';
+	tmp = tmpline;
+
+	while ((line = strsep(&tmp, ":")) != NULL) {
+		int i;
+		char *argv[6];
+
+		for (i = 0; (argv[i] = strsep(&line, ",")) != NULL;)
+			if (++i == ARRAY_SIZE(argv)) {
+				break;
+			}
+
+		if (num_zones >= ZONE_MAX)
+			return 0;
+		hisi_zone[num_zones].pdev.coherent_dma_mask = DMA_BIT_MASK(64);
+		if (i == 4) {
+			strlcpy(hisi_zone[num_zones].name, argv[0], NAME_LEN_MAX);
+			hisi_zone[num_zones].gfp = (uintptr_t)memparse(argv[1], NULL);
+			hisi_zone[num_zones].phys_start = (uintptr_t)memparse(argv[2], NULL);
+			hisi_zone[num_zones].nbytes = (uintptr_t)memparse(argv[3], NULL);
+		}
+
+		else if (i == 6) {
+			strlcpy(hisi_zone[num_zones].name, argv[0], NAME_LEN_MAX);
+			hisi_zone[num_zones].gfp = (uintptr_t)memparse(argv[1], NULL);
+			hisi_zone[num_zones].phys_start = (uintptr_t)memparse(argv[2], NULL);
+			hisi_zone[num_zones].nbytes = (uintptr_t)memparse(argv[3], NULL);
+			hisi_zone[num_zones].alloc_type = (uintptr_t)memparse(argv[4], NULL);
+			hisi_zone[num_zones].block_align = (uintptr_t)memparse(argv[5], NULL);
+		} else {
+			pr_err("hisi ion parameter is not correct\n");
+			continue;
+		}
+
+		num_zones++;
+	}
+	if (num_zones != 0) {
+		use_bootargs = 1;
+	}
+
+	return 0;
+}
+early_param("mmz", hisi_mmz_parse_cmdline);
+
+phys_addr_t hisi_get_zones_start(void)
+{
+	u32 i;
+	phys_addr_t lowest_zone_base = memblock_end_of_DRAM();
+
+	for (i = 0; i < num_zones; i++) {
+		if (lowest_zone_base > hisi_zone[i].phys_start) {
+			lowest_zone_base = hisi_zone[i].phys_start;
+		}
+	}
+
+	return lowest_zone_base;
+}
+EXPORT_SYMBOL(hisi_get_zones_start);
+
+struct cma_zone *hisi_get_cma_zone(const char *name)
+{
+	u32 i = 0;
+
+	if (name == NULL)
+		return NULL;
+	for (i = 0; i < num_zones; i++)
+		if (strcmp(hisi_zone[i].name, name) == 0) {
+			break;
+		}
+
+	if (i == num_zones) {
+		return NULL;
+	}
+
+	return &hisi_zone[i];
+}
+EXPORT_SYMBOL(hisi_get_cma_zone);
+
+struct device *hisi_get_cma_device(const char *name)
+{
+	u32 i = 0;
+
+	 if (name == NULL)
+                 return NULL;
+
+	for (i = 0; i < num_zones; i++)
+		if (strcmp(hisi_zone[i].name, name) == 0) {
+			break;
+		}
+
+	if (i == num_zones) {
+		return NULL;
+	}
+
+	return &hisi_zone[i].pdev;
+}
+EXPORT_SYMBOL(hisi_get_cma_device);
+
+int __init hisi_declare_heap_memory(void)
+{
+	struct cma *cma;
+	u32 i;
+	int ret = 0;
+
+	if (use_bootargs == 0) {
+		pr_info("cma zone is not set!\n");
+		return ret;
+	}
+
+	for (i = 0; i < num_zones; i++) {
+		ret = dma_contiguous_reserve_area(hisi_zone[i].nbytes,
+			hisi_zone[i].phys_start, 0, &cma, true);
+		if (ret) {
+			panic("declare cma zone %s base: %lux size:%lux MB failed. ret:%d",
+				hisi_zone[i].name, (unsigned long)hisi_zone[i].phys_start,
+				(unsigned long)hisi_zone[i].nbytes >> 20, ret);
+		} else {
+			hisi_zone[i].pdev.cma_area = cma;
+		}
+
+		hisi_zone[i].phys_start =
+			cma_get_base(hisi_zone[i].pdev.cma_area);
+		hisi_zone[i].nbytes = cma_get_size(hisi_zone[i].pdev.cma_area);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(hisi_declare_heap_memory);
+
+static int hisi_mmz_setup(struct reserved_mem *rmem)
+{
+	return 0;
+}
+RESERVEDMEM_OF_DECLARE(cma, "hisi-mmz", hisi_mmz_setup);
+
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 7e693dcbd..c428abba0 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -640,6 +640,16 @@ config I2C_GPIO_FAULT_INJECTOR
 	  faults to an I2C bus, so another bus master can be stress-tested.
 	  This is for debugging. If unsure, say 'no'.
 
+config I2C_HIBVT
+	tristate "Hisilicon BVT I2C Controller"
+	depends on ARCH_HISI_BVT
+	help
+	  Say Y here to include support for Hisilicon BVT I2C controller in the
+	  Hisilicon BVT SoCs.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-hibvt.
+
 config I2C_HIGHLANDER
 	tristate "Highlander FPGA SMBus interface"
 	depends on SH_HIGHLANDER || COMPILE_TEST
@@ -1420,4 +1430,20 @@ config I2C_FSI
 	  This driver can also be built as a module. If so, the module will be
 	  called as i2c-fsi.
 
+config DMA_MSG_MIN_LEN
+	int "Hisilicon I2C support DMA minimum LEN"
+	depends on I2C_HIBVT
+	range 1 4090
+	default 5
+	help
+		The i2c_msg minimum LEN of i2c support DMA,range from 1 to 4091
+
+config DMA_MSG_MAX_LEN
+	int "Hisilicon I2C support DMA maximum LEN"
+	depends on I2C_HIBVT
+	range DMA_MSG_MIN_LEN 4090
+	default 4090
+	help
+		The i2c_msg maximum LEN of i2c support DMA,range from i2c_msg minimum LEN to 4090,
+		because DMA for 0xFFC one-time  largest data transfers;
 endmenu
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 683c49fac..2c615a7c1 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -63,6 +63,7 @@ obj-$(CONFIG_I2C_EG20T)		+= i2c-eg20t.o
 obj-$(CONFIG_I2C_EMEV2)		+= i2c-emev2.o
 obj-$(CONFIG_I2C_EXYNOS5)	+= i2c-exynos5.o
 obj-$(CONFIG_I2C_GPIO)		+= i2c-gpio.o
+obj-$(CONFIG_I2C_HIBVT)		+= i2c-hibvt.o
 obj-$(CONFIG_I2C_HIGHLANDER)	+= i2c-highlander.o
 obj-$(CONFIG_I2C_HIX5HD2)	+= i2c-hix5hd2.o
 obj-$(CONFIG_I2C_IBM_IIC)	+= i2c-ibm_iic.o
diff --git a/drivers/i2c/busses/i2c-hibvt.c b/drivers/i2c/busses/i2c-hibvt.c
new file mode 100644
index 000000000..4c7cd494a
--- /dev/null
+++ b/drivers/i2c/busses/i2c-hibvt.c
@@ -0,0 +1,1451 @@
+/*
+ * Hisilicon BVT I2C Controller Driver
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <asm/string.h>
+
+#if defined(CONFIG_HI_DMAC)
+#include <linux/hidmac.h>
+#endif
+
+#if defined(CONFIG_HIEDMAC)
+#include <linux/hiedmac.h>
+#endif
+
+/*
+ * I2C Registers offsets
+ */
+#define HIBVT_I2C_GLB		0x0
+#define HIBVT_I2C_SCL_H		0x4
+#define HIBVT_I2C_SCL_L		0x8
+#define HIBVT_I2C_DATA1		0x10
+#define HIBVT_I2C_TXF		0x20
+#define HIBVT_I2C_RXF		0x24
+#define HIBVT_I2C_CMD_BASE	0x30
+#define HIBVT_I2C_LOOP1		0xb0
+#define HIBVT_I2C_DST1		0xb4
+#define HIBVT_I2C_LOOP2     0xb8
+#define HIBVT_I2C_DST2      0xbc
+#define HIBVT_I2C_TX_WATER	0xc8
+#define HIBVT_I2C_RX_WATER	0xcc
+#define HIBVT_I2C_CTRL1		0xd0
+#define HIBVT_I2C_CTRL2		0xd4
+#define HIBVT_I2C_STAT		0xd8
+#define HIBVT_I2C_INTR_RAW	0xe0
+#define HIBVT_I2C_INTR_EN	0xe4
+#define HIBVT_I2C_INTR_STAT	0xe8
+
+/*
+ * I2C Global Config Register -- HIBVT_I2C_GLB
+ */
+#define GLB_EN_MASK		BIT(0)
+#define GLB_SDA_HOLD_MASK	GENMASK(23, 8)
+#define GLB_SDA_HOLD_SHIFT	(8)
+#define should_copy_to_continuous_mem(addr) true
+
+/*
+ * I2C Timing CMD Register -- HIBVT_I2C_CMD_BASE + n * 4 (n = 0, 1, 2, ... 31)
+ */
+#define CMD_EXIT	0x0
+#define CMD_TX_S	0x1
+#define CMD_TX_D1_2	0x4
+#define CMD_TX_D1_1	0x5
+#define CMD_TX_FIFO	0x9
+#define CMD_RX_FIFO	0x12
+#define CMD_RX_ACK	0x13
+#define CMD_IGN_ACK	0x15
+#define CMD_TX_ACK	0x16
+#define CMD_TX_NACK	0x17
+#define CMD_JMP1	0x18
+#define CMD_JMP2    0x19
+#define CMD_UP_TXF	0x1d
+#define CMD_TX_RS	0x1e
+#define CMD_TX_P	0x1f
+
+/*
+ * I2C Control Register 1 -- HIBVT_I2C_CTRL1
+ */
+#define CTRL1_CMD_START_MASK	BIT(0)
+#define CTRL1_DMA_OP_MASK	(0x3 << 8)
+#define CTRL1_DMA_R		(0x3 << 8)
+#define CTRL1_DMA_W		(0x2 << 8)
+
+/*
+ * I2C Status Register -- HIBVT_I2C_STAT
+ */
+#define STAT_RXF_NOE_MASK	BIT(16) /* RX FIFO not empty flag */
+#define STAT_TXF_NOF_MASK	BIT(19) /* TX FIFO not full flag */
+
+/*
+ * I2C Interrupt status and mask Register --
+ * HIBVT_I2C_INTR_RAW, HIBVT_I2C_STAT, HIBVT_I2C_INTR_STAT
+ */
+#define INTR_ABORT_MASK		(BIT(0) | BIT(11))
+#define INTR_RX_MASK		BIT(2)
+#define INTR_TX_MASK		BIT(4)
+#define INTR_CMD_DONE_MASK	BIT(12)
+#define INTR_USE_MASK		(INTR_ABORT_MASK \
+				|INTR_RX_MASK \
+				| INTR_TX_MASK \
+				| INTR_CMD_DONE_MASK)
+#define INTR_ALL_MASK		GENMASK(31, 0)
+
+#define I2C_DEFAULT_FREQUENCY	100000
+#define I2C_TXF_DEPTH		64
+#define I2C_RXF_DEPTH		64
+#define I2C_TXF_WATER		32
+#define I2C_RXF_WATER		32
+#define I2C_WAIT_TIMEOUT	0x400
+#define I2C_IRQ_TIMEOUT		(msecs_to_jiffies(1000))
+
+struct hibvt_i2c_dev {
+	struct device *dev;
+	struct i2c_adapter adap;
+	resource_size_t phybase;
+	void __iomem *base;
+	struct clk *clk;
+	int irq;
+
+	unsigned int		freq;
+	struct i2c_msg *msg;
+	unsigned int		msg_num;
+	unsigned int		msg_idx;
+	unsigned int		msg_buf_ptr;
+	struct completion	msg_complete;
+
+	spinlock_t		lock;
+	int			status;
+};
+static inline void hibvt_i2c_disable(const struct hibvt_i2c_dev *i2c);
+static inline void hibvt_i2c_cfg_irq(const struct hibvt_i2c_dev *i2c,
+				     unsigned int flag);
+static inline unsigned int hibvt_i2c_clr_irq(const struct hibvt_i2c_dev *i2c);
+static inline void hibvt_i2c_enable(const struct hibvt_i2c_dev *i2c);
+
+#define CHECK_SDA_IN_SHIFT     (16)
+#define GPIO_MODE_SHIFT        (8)
+#define FORCE_SCL_OEN_SHIFT    (4)
+#define FORCE_SDA_OEN_SHIFT    (0)
+
+static void hibvt_i2c_rescue(const struct hibvt_i2c_dev *i2c)
+{
+	unsigned int val;
+	unsigned int time_cnt;
+	int index;
+
+	hibvt_i2c_disable(i2c);
+	hibvt_i2c_cfg_irq(i2c, 0);
+	hibvt_i2c_clr_irq(i2c);
+
+	val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT) |
+	      (0x1 << FORCE_SDA_OEN_SHIFT);
+	writel(val, i2c->base + HIBVT_I2C_CTRL2);
+
+	time_cnt = 0;
+	do {
+		for (index = 0; index < 9; index++) {
+			val = (0x1 << GPIO_MODE_SHIFT) | 0x1;
+			writel(val, i2c->base + HIBVT_I2C_CTRL2);
+
+			udelay(5);
+
+			val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT) |
+			      (0x1 << FORCE_SDA_OEN_SHIFT);
+			writel(val, i2c->base + HIBVT_I2C_CTRL2);
+
+			udelay(5);
+		}
+
+		time_cnt++;
+		if (time_cnt > I2C_WAIT_TIMEOUT) {
+			dev_err(i2c->dev, "wait Timeout!\n");
+			goto disable_rescue;
+		}
+
+		val = readl(i2c->base + HIBVT_I2C_CTRL2);
+	} while (!(val & (0x1 << CHECK_SDA_IN_SHIFT)));
+
+	val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT) |
+	      (0x1 << FORCE_SDA_OEN_SHIFT);
+	writel(val, i2c->base + HIBVT_I2C_CTRL2);
+
+	val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT);
+	writel(val, i2c->base + HIBVT_I2C_CTRL2);
+
+	udelay(10);
+
+	val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT) |
+	      (0x1 << FORCE_SDA_OEN_SHIFT);
+	writel(val, i2c->base + HIBVT_I2C_CTRL2);
+
+disable_rescue:
+	val = (0x1 << FORCE_SCL_OEN_SHIFT) | 0x1;
+	writel(val, i2c->base + HIBVT_I2C_CTRL2);
+}
+
+static inline void hibvt_i2c_disable(const struct hibvt_i2c_dev *i2c)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + HIBVT_I2C_GLB);
+	val &= ~GLB_EN_MASK;
+	writel(val, i2c->base + HIBVT_I2C_GLB);
+}
+
+static inline void hibvt_i2c_enable(const struct hibvt_i2c_dev *i2c)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + HIBVT_I2C_GLB);
+	val |= GLB_EN_MASK;
+	writel(val, i2c->base + HIBVT_I2C_GLB);
+}
+
+static inline void hibvt_i2c_cfg_irq(const struct hibvt_i2c_dev *i2c,
+				     unsigned int flag)
+{
+	writel(flag, i2c->base + HIBVT_I2C_INTR_EN);
+}
+
+static inline void hibvt_i2c_disable_irq(const struct hibvt_i2c_dev *i2c,
+		unsigned int flag)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + HIBVT_I2C_INTR_EN);
+	val &= ~flag;
+	writel(val, i2c->base + HIBVT_I2C_INTR_EN);
+}
+
+static inline unsigned int hibvt_i2c_clr_irq(const struct hibvt_i2c_dev *i2c)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + HIBVT_I2C_INTR_STAT);
+	writel(INTR_ALL_MASK, i2c->base + HIBVT_I2C_INTR_RAW);
+
+	return val;
+}
+
+static inline void hibvt_i2c_cmdreg_set(const struct hibvt_i2c_dev *i2c,
+					unsigned int cmd, unsigned int *offset)
+{
+	dev_dbg(i2c->dev, "hii2c reg: offset=0x%x, cmd=0x%x...\n",
+		*offset * 4, cmd);
+	writel(cmd, i2c->base + HIBVT_I2C_CMD_BASE + *offset * 4);
+	(*offset)++;
+}
+
+/*
+ * config i2c slave addr
+ */
+static inline void hibvt_i2c_set_addr(const struct hibvt_i2c_dev *i2c)
+{
+	struct i2c_msg *msg = i2c->msg;
+	u16 addr;
+
+	if (msg->flags & I2C_M_TEN) {
+		/* First byte is 11110XX0 where XX is upper 2 bits */
+		addr = ((msg->addr & 0x300) << 1) | 0xf000;
+		if (msg->flags & I2C_M_RD)
+			addr |= 1 << 8;
+
+		/* Second byte is the remaining 8 bits */
+		addr |= msg->addr & 0xff;
+	} else {
+		addr = (msg->addr & 0x7f) << 1;
+		if (msg->flags & I2C_M_RD)
+			addr |= 1;
+	}
+
+	writel(addr, i2c->base + HIBVT_I2C_DATA1);
+}
+
+/*
+ * Start command sequence
+ */
+static inline void hibvt_i2c_start_cmd(const struct hibvt_i2c_dev *i2c)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + HIBVT_I2C_CTRL1);
+	val |= CTRL1_CMD_START_MASK;
+	writel(val, i2c->base + HIBVT_I2C_CTRL1);
+}
+
+static int hibvt_i2c_wait_rx_noempty(const struct hibvt_i2c_dev *i2c)
+{
+	unsigned int time_cnt = 0;
+	unsigned int val;
+
+	do {
+		val = readl(i2c->base + HIBVT_I2C_STAT);
+		if (val & STAT_RXF_NOE_MASK)
+			return 0;
+
+		udelay(50);
+	} while (time_cnt++ < I2C_WAIT_TIMEOUT);
+
+	hibvt_i2c_rescue(i2c);
+
+	dev_err(i2c->dev, "wait rx no empty timeout, RIS: 0x%x, SR: 0x%x\n",
+		readl(i2c->base + HIBVT_I2C_INTR_RAW), val);
+	return -EIO;
+}
+
+static int hibvt_i2c_wait_tx_nofull(const struct hibvt_i2c_dev *i2c)
+{
+	unsigned int time_cnt = 0;
+	unsigned int val;
+
+	do {
+		val = readl(i2c->base + HIBVT_I2C_STAT);
+		if (val & STAT_TXF_NOF_MASK)
+			return 0;
+
+		udelay(50);
+	} while (time_cnt++ < I2C_WAIT_TIMEOUT);
+
+	hibvt_i2c_rescue(i2c);
+
+	dev_err(i2c->dev, "wait rx no empty timeout, RIS: 0x%x, SR: 0x%x\n",
+		readl(i2c->base + HIBVT_I2C_INTR_RAW), val);
+	return -EIO;
+}
+
+static int hibvt_i2c_wait_idle(const struct hibvt_i2c_dev *i2c)
+{
+	unsigned int time_cnt = 0;
+	unsigned int val;
+
+	do {
+		val = readl(i2c->base + HIBVT_I2C_INTR_RAW);
+		if (val & (INTR_ABORT_MASK)) {
+			dev_err(i2c->dev, "wait idle abort!, RIS: 0x%x\n",
+				val);
+			return -EIO;
+		}
+
+		if (val & INTR_CMD_DONE_MASK)
+			return 0;
+
+		udelay(50);
+	} while (time_cnt++ < I2C_WAIT_TIMEOUT);
+
+	hibvt_i2c_rescue(i2c);
+
+	dev_err(i2c->dev, "wait idle timeout, RIS: 0x%x, SR: 0x%x\n",
+		val, readl(i2c->base + HIBVT_I2C_STAT));
+
+	return -EIO;
+}
+
+static void hibvt_i2c_set_freq(struct hibvt_i2c_dev *i2c)
+{
+	unsigned int max_freq, freq;
+	unsigned int clk_rate;
+	unsigned int val;
+
+	freq = i2c->freq;
+	clk_rate = clk_get_rate(i2c->clk);
+	max_freq = clk_rate >> 1;
+
+	if (freq > max_freq) {
+		i2c->freq = max_freq;
+		freq = i2c->freq;
+	}
+
+	if (!freq) {
+		pr_err("hibvt_i2c_set_freq:freq can't be zero!");
+		return;
+	}
+
+	if (freq <= 100000) {
+		/* in normal mode               F_scl: freq
+		   i2c_scl_hcnt = (F_i2c / F_scl) * 0.5
+		   i2c_scl_hcnt = (F_i2c / F_scl) * 0.5
+		 */
+		val = clk_rate / (freq * 2);
+		writel(val, i2c->base + HIBVT_I2C_SCL_H);
+		writel(val, i2c->base + HIBVT_I2C_SCL_L);
+	} else {
+		/* in fast mode         F_scl: freq
+		   i2c_scl_hcnt = (F_i2c / F_scl) * 0.36
+		   i2c_scl_hcnt = (F_i2c / F_scl) * 0.64
+		 */
+		val = ((clk_rate / 100) * 36) / freq;
+		writel(val, i2c->base + HIBVT_I2C_SCL_H);
+		val = ((clk_rate / 100) * 64) / freq;
+		writel(val, i2c->base + HIBVT_I2C_SCL_L);
+	}
+
+	val = readl(i2c->base + HIBVT_I2C_GLB);
+	val &= ~GLB_SDA_HOLD_MASK;
+	val |= ((0xa << GLB_SDA_HOLD_SHIFT) & GLB_SDA_HOLD_MASK);
+	writel(val, i2c->base + HIBVT_I2C_GLB);
+}
+
+/*
+ * set i2c controller TX and RX FIFO water
+ */
+static inline void hibvt_i2c_set_water(const struct hibvt_i2c_dev *i2c)
+{
+	writel(I2C_TXF_WATER, i2c->base + HIBVT_I2C_TX_WATER);
+	writel(I2C_RXF_WATER, i2c->base + HIBVT_I2C_RX_WATER);
+}
+
+/*
+ * initialise the controller, set i2c bus interface freq
+ */
+static void hibvt_i2c_hw_init(struct hibvt_i2c_dev *i2c)
+{
+	hibvt_i2c_disable(i2c);
+	hibvt_i2c_disable_irq(i2c, INTR_ALL_MASK);
+	hibvt_i2c_set_freq(i2c);
+	hibvt_i2c_set_water(i2c);
+}
+
+/*
+ * hibvt_i2c_cfg_cmd - config i2c controller command sequence
+ *
+ * After all the timing command is configured,
+ * and then start the command, you can i2c communication,
+ * and then only need to read and write i2c fifo.
+ */
+static void hibvt_i2c_cfg_cmd(const struct hibvt_i2c_dev *i2c)
+{
+	struct i2c_msg *msg = i2c->msg;
+	int offset = 0;
+
+	if (i2c->msg_idx == 0)
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_S, &offset);
+	else
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_RS, &offset);
+
+	if (msg->flags & I2C_M_TEN) {
+		if (i2c->msg_idx == 0) {
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_D1_2, &offset);
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_D1_1, &offset);
+		} else {
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_D1_2, &offset);
+		}
+	} else {
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_D1_1, &offset);
+	}
+
+	if (msg->flags & I2C_M_IGNORE_NAK)
+		hibvt_i2c_cmdreg_set(i2c, CMD_IGN_ACK, &offset);
+	else
+		hibvt_i2c_cmdreg_set(i2c, CMD_RX_ACK, &offset);
+
+	if (msg->flags & I2C_M_RD) {
+		if (msg->len >= 2) {
+			writel(offset, i2c->base + HIBVT_I2C_DST1);
+			writel(msg->len - 2, i2c->base + HIBVT_I2C_LOOP1);
+			hibvt_i2c_cmdreg_set(i2c, CMD_RX_FIFO, &offset);
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_ACK, &offset);
+			hibvt_i2c_cmdreg_set(i2c, CMD_JMP1, &offset);
+		}
+		hibvt_i2c_cmdreg_set(i2c, CMD_RX_FIFO, &offset);
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_NACK, &offset);
+	} else {
+		writel(offset, i2c->base + HIBVT_I2C_DST1);
+		writel(msg->len - 1, i2c->base + HIBVT_I2C_LOOP1);
+		hibvt_i2c_cmdreg_set(i2c, CMD_UP_TXF, &offset);
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_FIFO, &offset);
+
+		if (msg->flags & I2C_M_IGNORE_NAK)
+			hibvt_i2c_cmdreg_set(i2c, CMD_IGN_ACK, &offset);
+		else
+			hibvt_i2c_cmdreg_set(i2c, CMD_RX_ACK, &offset);
+
+		hibvt_i2c_cmdreg_set(i2c, CMD_JMP1, &offset);
+	}
+
+	if ((i2c->msg_idx == (i2c->msg_num - 1)) || (msg->flags & I2C_M_STOP)) {
+		dev_dbg(i2c->dev, "run to %s %d...TX STOP\n",
+			__func__, __LINE__);
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_P, &offset);
+	}
+
+	hibvt_i2c_cmdreg_set(i2c, CMD_EXIT, &offset);
+}
+
+static void hibvt_i2c_cfg_cmd_mul_reg(struct hibvt_i2c_dev *i2c,unsigned int reg_data_width)
+{
+	struct i2c_msg *msg = i2c->msg;
+	int offset = 0;
+	int i;
+
+	if (i2c->msg_idx == 0) {
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_S, &offset);
+	} else {
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_RS, &offset);
+	}
+
+	if (msg->flags & I2C_M_TEN) {
+		if (i2c->msg_idx == 0) {
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_D1_2, &offset);
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_D1_1, &offset);
+		} else {
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_D1_2, &offset);
+		}
+	} else {
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_D1_1, &offset);
+	}
+
+	if (msg->flags & I2C_M_IGNORE_NAK) {
+		hibvt_i2c_cmdreg_set(i2c, CMD_IGN_ACK, &offset);
+	} else {
+		hibvt_i2c_cmdreg_set(i2c, CMD_RX_ACK, &offset);
+	}
+
+	if (msg->flags & I2C_M_RD) {
+		if (msg->len >= 2) {
+			writel(offset, i2c->base + HIBVT_I2C_DST1);
+			writel(msg->len - 2, i2c->base + HIBVT_I2C_LOOP1);
+			hibvt_i2c_cmdreg_set(i2c, CMD_RX_FIFO, &offset);
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_ACK, &offset);
+			hibvt_i2c_cmdreg_set(i2c, CMD_JMP1, &offset);
+		}
+		hibvt_i2c_cmdreg_set(i2c, CMD_RX_FIFO, &offset);
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_NACK, &offset);
+	} else {
+		for(i = 0; i < reg_data_width - 1; i++){
+			hibvt_i2c_cmdreg_set(i2c, CMD_UP_TXF, &offset);
+			hibvt_i2c_cmdreg_set(i2c, CMD_TX_FIFO, &offset);
+			hibvt_i2c_cmdreg_set(i2c, CMD_RX_ACK, &offset);
+		}
+		hibvt_i2c_cmdreg_set(i2c, CMD_UP_TXF, &offset);
+		hibvt_i2c_cmdreg_set(i2c, CMD_TX_FIFO, &offset);
+		hibvt_i2c_cmdreg_set(i2c, CMD_IGN_ACK, &offset);
+	}
+
+	hibvt_i2c_cmdreg_set(i2c, CMD_TX_P, &offset);
+	if(((msg->len / reg_data_width) - 1) > 0){
+		writel(0, i2c->base + HIBVT_I2C_DST2);
+		writel((msg->len / reg_data_width) - 1, i2c->base + HIBVT_I2C_LOOP2);
+		hibvt_i2c_cmdreg_set(i2c, CMD_JMP2, &offset);
+	}
+	hibvt_i2c_cmdreg_set(i2c, CMD_EXIT, &offset);
+}
+
+static inline void check_i2c_send_complete(struct hibvt_i2c_dev *i2c)
+{
+	unsigned int val;
+	val = readl(i2c->base + HIBVT_I2C_GLB);
+	if(val & GLB_EN_MASK){
+		hibvt_i2c_wait_idle(i2c);
+		hibvt_i2c_disable(i2c);
+	}
+}
+
+#if defined(CONFIG_HI_DMAC) || defined(CONFIG_HIEDMAC)
+int dma_to_i2c(unsigned long src, unsigned int dst, unsigned int length)
+{
+	int chan;
+
+	chan = do_dma_m2p(src, dst, length);
+	if (chan == -1)
+		pr_err("dma_to_i2c error\n");
+
+	return chan;
+}
+
+int i2c_to_dma(unsigned int src, unsigned long dst,
+	       unsigned int length)
+{
+	int chan;
+
+	chan = do_dma_p2m(dst, src, length);
+	if (chan == -1)
+		pr_err("dma_p2m error...\n");
+
+	return chan;
+}
+
+static int hibvt_i2c_do_dma_write(struct hibvt_i2c_dev *i2c,
+				  unsigned long dma_dst_addr)
+{
+	int chan, val;
+	int status = 0;
+	struct i2c_msg *msg = i2c->msg;
+
+	check_i2c_send_complete(i2c);
+	hibvt_i2c_set_freq(i2c);
+	writel(0x1, i2c->base + HIBVT_I2C_TX_WATER);
+	hibvt_i2c_enable(i2c);
+	hibvt_i2c_clr_irq(i2c);
+	hibvt_i2c_set_addr(i2c);
+	hibvt_i2c_cfg_cmd(i2c);
+
+	/*  transmit DATA from DMAC to I2C in DMA mode */
+	chan = dma_to_i2c(dma_dst_addr, (i2c->phybase + HIBVT_I2C_TXF),
+			  msg->len);
+	if (chan == -1) {
+		status = -1;
+		goto fail_0;
+	}
+
+	val = readl(i2c->base + HIBVT_I2C_CTRL1);
+	val &= ~CTRL1_DMA_OP_MASK;
+	val |= CTRL1_DMA_W | CTRL1_CMD_START_MASK;
+	writel(val, i2c->base + HIBVT_I2C_CTRL1);
+
+	if (dmac_wait(chan) != DMAC_CHN_SUCCESS) {
+		status = -1;
+		goto fail_1;
+	}
+
+	status = hibvt_i2c_wait_idle(i2c);
+
+fail_1:
+	dmac_channel_free((unsigned int)chan);
+fail_0:
+	hibvt_i2c_disable(i2c);
+
+	return status;
+}
+
+static int hibvt_i2c_do_dma_write_mul_reg(struct hibvt_i2c_dev *i2c,
+				  unsigned long dma_dst_addr, unsigned int reg_data_width)
+{
+	int chan, val, status = 0;
+	struct i2c_msg *msg = i2c->msg;
+
+
+	check_i2c_send_complete(i2c);
+	hibvt_i2c_set_freq(i2c);
+	writel(0x1, i2c->base + HIBVT_I2C_TX_WATER);
+	hibvt_i2c_enable(i2c);
+	hibvt_i2c_clr_irq(i2c);
+	hibvt_i2c_set_addr(i2c);
+	hibvt_i2c_cfg_cmd_mul_reg(i2c, reg_data_width);
+
+	/*  transmit DATA from DMAC to I2C in DMA mode */
+	chan = dma_to_i2c(dma_dst_addr, (i2c->phybase + HIBVT_I2C_TXF),
+			  msg->len);
+	if (chan == -1) {
+		status = -1;
+		goto fail_0;
+	}
+
+	val = readl(i2c->base + HIBVT_I2C_CTRL1);
+	val &= ~CTRL1_DMA_OP_MASK;
+	val |= CTRL1_DMA_W | CTRL1_CMD_START_MASK;
+	writel(val, i2c->base + HIBVT_I2C_CTRL1);
+
+fail_0:
+	return status;
+}
+
+static int hibvt_i2c_do_dma_read(struct hibvt_i2c_dev *i2c,
+				 unsigned long dma_dst_addr)
+{
+	int val, chan;
+	int status = 0;
+	struct i2c_msg *msg = i2c->msg;
+
+	check_i2c_send_complete(i2c);
+	hibvt_i2c_set_freq(i2c);
+	writel(0x0, i2c->base + HIBVT_I2C_RX_WATER);
+	hibvt_i2c_enable(i2c);
+	hibvt_i2c_clr_irq(i2c);
+	hibvt_i2c_set_addr(i2c);
+	hibvt_i2c_cfg_cmd(i2c);
+
+	/* transmit DATA from I2C to DMAC in DMA mode */
+	chan = i2c_to_dma((i2c->phybase + HIBVT_I2C_RXF),
+			  dma_dst_addr, msg->len);
+	if (chan == -1) {
+		status = -1;
+		goto fail_0;
+	}
+
+	val = readl(i2c->base + HIBVT_I2C_CTRL1);
+	val &= ~CTRL1_DMA_OP_MASK;
+	val |= CTRL1_CMD_START_MASK | CTRL1_DMA_R;
+	writel(val, i2c->base + HIBVT_I2C_CTRL1);
+
+	if (dmac_wait(chan) != DMAC_CHN_SUCCESS) {
+		status = -1;
+		goto fail_1;
+	}
+
+	status = hibvt_i2c_wait_idle(i2c);
+
+fail_1:
+	dmac_channel_free((unsigned int)chan);
+fail_0:
+	hibvt_i2c_disable(i2c);
+
+	return status;
+}
+
+static int copy_to_continuous_mem(struct hibvt_i2c_dev *i2c)
+{
+	if (should_copy_to_continuous_mem(i2c->msg->buf)) {
+		i2c->msg->highmem_buf = i2c->msg->buf;
+		i2c->msg->buf = kmalloc(i2c->msg->len, GFP_KERNEL | __GFP_ATOMIC);
+		if (i2c->msg->buf == NULL) {
+			i2c->msg->buf = i2c->msg->highmem_buf;
+			dev_err(i2c->dev, "Allocate continuous memory fail.\n");
+			return -EINVAL;
+		}
+	} else {
+		i2c->msg->highmem_buf = NULL;
+	}
+	return 0;
+}
+
+static int hibvt_i2c_dma_xfer_one_msg(struct hibvt_i2c_dev *i2c)
+{
+	unsigned int status;
+	struct i2c_msg *msg = i2c->msg;
+	dma_addr_t dma_dst_addr;
+
+	dev_dbg(i2c->dev, "[%s,%d]msg->flags=0x%x, len=0x%x\n",
+		__func__, __LINE__, msg->flags, msg->len);
+
+	if (copy_to_continuous_mem(i2c))
+		return -EINVAL;
+
+	if (msg->flags & I2C_M_RD) {
+		mb();
+		dma_dst_addr = dma_map_single(i2c->dev, msg->buf,
+					      msg->len, DMA_FROM_DEVICE);
+		status = dma_mapping_error(i2c->dev, dma_dst_addr);
+		if (status) {
+			dev_err(i2c->dev, "DMA mapping failed\n");
+			goto out;
+		}
+
+		status = hibvt_i2c_do_dma_read(i2c, dma_dst_addr);
+
+		dma_unmap_single(i2c->dev, dma_dst_addr, msg->len, DMA_FROM_DEVICE);
+		mb();
+		if (i2c->msg->highmem_buf)
+			memcpy(msg->highmem_buf, msg->buf, msg->len);
+	} else {
+		if (i2c->msg->highmem_buf)
+			memcpy(msg->buf, msg->highmem_buf, msg->len);
+		mb();
+		dma_dst_addr = dma_map_single(i2c->dev, msg->buf,
+					      msg->len, DMA_TO_DEVICE);
+		status = dma_mapping_error(i2c->dev, dma_dst_addr);
+		if (status) {
+			dev_err(i2c->dev, "DMA mapping failed\n");
+			goto out;
+		}
+
+		status = hibvt_i2c_do_dma_write(i2c, dma_dst_addr);
+		dma_unmap_single(i2c->dev, dma_dst_addr, msg->len, DMA_TO_DEVICE);
+		mb();
+	}
+
+out:
+	if (i2c->msg->highmem_buf) {
+		kfree(msg->buf);
+		msg->buf = msg->highmem_buf;
+		msg->highmem_buf = NULL;
+	}
+
+	if (!status) {
+		status = hibvt_i2c_wait_idle(i2c);
+		hibvt_i2c_disable(i2c);
+	}
+
+	return status;
+}
+
+static int hibvt_i2c_dma_xfer_one_msg_mul_reg(struct hibvt_i2c_dev *i2c, unsigned int reg_data_width)
+{
+	unsigned int status;
+	struct i2c_msg *msg = i2c->msg;
+	dma_addr_t dma_dst_addr;
+
+
+	dev_dbg(i2c->dev, "[%s,%d]msg->flags=0x%x, len=0x%x\n",
+		__func__, __LINE__, msg->flags, msg->len);
+
+	if (copy_to_continuous_mem(i2c))
+		return -EINVAL;
+
+	if (msg->flags & I2C_M_RD) {
+		mb();
+		dma_dst_addr = dma_map_single(i2c->dev, msg->buf,
+					      msg->len, DMA_FROM_DEVICE);
+		status = dma_mapping_error(i2c->dev, dma_dst_addr);
+		if (status) {
+			dev_err(i2c->dev, "DMA mapping failed\n");
+			goto out;
+		}
+
+		status = hibvt_i2c_do_dma_read(i2c, dma_dst_addr);
+
+		dma_unmap_single(i2c->dev, dma_dst_addr, msg->len, DMA_FROM_DEVICE);
+		mb();
+		if (i2c->msg->highmem_buf)
+			memcpy(msg->highmem_buf, msg->buf, msg->len);
+	} else {
+		if (i2c->msg->highmem_buf)
+			memcpy(msg->buf, msg->highmem_buf, msg->len);
+		mb();
+		dma_dst_addr = dma_map_single(i2c->dev, msg->buf,
+					      msg->len, DMA_TO_DEVICE);
+		status = dma_mapping_error(i2c->dev, dma_dst_addr);
+		if (status) {
+			dev_err(i2c->dev, "DMA mapping failed\n");
+			goto out;
+		}
+
+		status = hibvt_i2c_do_dma_write_mul_reg(i2c, dma_dst_addr, reg_data_width);
+		dma_unmap_single(i2c->dev, dma_dst_addr, msg->len, DMA_TO_DEVICE);
+		mb();
+	}
+
+out:
+	if (i2c->msg->highmem_buf) {
+		kfree(msg->buf);
+		msg->buf = msg->highmem_buf;
+		msg->highmem_buf = NULL;
+	}
+	return status;
+}
+#endif
+static int hibvt_i2c_polling_xfer_one_msg(struct hibvt_i2c_dev *i2c)
+{
+	int status;
+	unsigned int val;
+	struct i2c_msg *msg = i2c->msg;
+
+	dev_dbg(i2c->dev, "[%s,%d]msg->flags=0x%x, len=0x%x\n",
+		__func__, __LINE__, msg->flags, msg->len);
+
+	check_i2c_send_complete(i2c);
+	hibvt_i2c_enable(i2c);
+	hibvt_i2c_clr_irq(i2c);
+	hibvt_i2c_set_addr(i2c);
+	hibvt_i2c_cfg_cmd(i2c);
+	hibvt_i2c_start_cmd(i2c);
+
+	i2c->msg_buf_ptr = 0;
+
+	if (msg->flags & I2C_M_RD) {
+		while (i2c->msg_buf_ptr < msg->len) {
+			status = hibvt_i2c_wait_rx_noempty(i2c);
+			if (status)
+				goto end;
+
+			val = readl(i2c->base + HIBVT_I2C_RXF);
+			msg->buf[i2c->msg_buf_ptr] = val;
+			i2c->msg_buf_ptr++;
+		}
+	} else {
+		while (i2c->msg_buf_ptr < msg->len) {
+			status = hibvt_i2c_wait_tx_nofull(i2c);
+			if (status)
+				goto end;
+
+			val = msg->buf[i2c->msg_buf_ptr];
+			writel(val, i2c->base + HIBVT_I2C_TXF);
+			i2c->msg_buf_ptr++;
+		}
+	}
+
+	status = hibvt_i2c_wait_idle(i2c);
+end:
+	hibvt_i2c_disable(i2c);
+
+	return status;
+}
+
+static int hibvt_i2c_polling_xfer_one_msg_mul_reg(struct hibvt_i2c_dev *i2c, unsigned int reg_data_width)
+{
+	int status;
+	unsigned int val;
+	struct i2c_msg *msg = i2c->msg;
+
+	dev_dbg(i2c->dev, "[%s,%d]msg->flags=0x%x, len=0x%x\n",
+		__func__, __LINE__, msg->flags, msg->len);
+
+	check_i2c_send_complete(i2c);
+	hibvt_i2c_enable(i2c);
+	hibvt_i2c_clr_irq(i2c);
+	hibvt_i2c_set_addr(i2c);
+	hibvt_i2c_cfg_cmd_mul_reg(i2c, reg_data_width);
+	hibvt_i2c_start_cmd(i2c);
+
+	i2c->msg_buf_ptr = 0;
+
+	if (msg->flags & I2C_M_RD) {
+		while (i2c->msg_buf_ptr < msg->len) {
+			status = hibvt_i2c_wait_rx_noempty(i2c);
+			if (status) {
+				goto end;
+			}
+
+			val = readl(i2c->base + HIBVT_I2C_RXF);
+			msg->buf[i2c->msg_buf_ptr] = val;
+			i2c->msg_buf_ptr++;
+
+		}
+	} else {
+		while (i2c->msg_buf_ptr < msg->len) {
+			status = hibvt_i2c_wait_tx_nofull(i2c);
+			if (status) {
+				goto end;
+			}
+
+			val = msg->buf[i2c->msg_buf_ptr];
+			writel(val, i2c->base + HIBVT_I2C_TXF);
+			i2c->msg_buf_ptr++;
+		}
+	}
+
+end:
+	return status;
+}
+
+static irqreturn_t hibvt_i2c_isr(int irq, void *dev_id)
+{
+	struct hibvt_i2c_dev *i2c = dev_id;
+	unsigned int irq_status;
+	struct i2c_msg *msg = i2c->msg;
+
+	spin_lock(&i2c->lock);
+
+	irq_status = hibvt_i2c_clr_irq(i2c);
+	dev_dbg(i2c->dev, "%s RIS:  0x%x\n", __func__, irq_status);
+
+	if (!irq_status) {
+		dev_dbg(i2c->dev, "no irq\n");
+		goto end;
+	}
+
+	if (irq_status & INTR_ABORT_MASK) {
+		dev_err(i2c->dev, "irq handle abort, RIS: 0x%x\n",
+			irq_status);
+		i2c->status = -EIO;
+		hibvt_i2c_disable_irq(i2c, INTR_ALL_MASK);
+
+		complete(&i2c->msg_complete);
+		goto end;
+	}
+
+	if (msg->flags & I2C_M_RD) {
+		while ((readl(i2c->base + HIBVT_I2C_STAT) & STAT_RXF_NOE_MASK)
+				&& (i2c->msg_buf_ptr < msg->len)) {
+			msg->buf[i2c->msg_buf_ptr] =
+				readl(i2c->base + HIBVT_I2C_RXF);
+			i2c->msg_buf_ptr++;
+		}
+	} else {
+		while ((readl(i2c->base + HIBVT_I2C_STAT) & STAT_TXF_NOF_MASK)
+				&& (i2c->msg_buf_ptr < msg->len)) {
+			writel(msg->buf[i2c->msg_buf_ptr],
+			       i2c->base + HIBVT_I2C_TXF);
+			i2c->msg_buf_ptr++;
+		}
+	}
+
+	if (i2c->msg_buf_ptr >= msg->len)
+		hibvt_i2c_disable_irq(i2c, INTR_TX_MASK | INTR_RX_MASK);
+
+	if (irq_status & INTR_CMD_DONE_MASK) {
+		dev_dbg(i2c->dev, "cmd done\n");
+		i2c->status =  0;
+		hibvt_i2c_disable_irq(i2c, INTR_ALL_MASK);
+
+		complete(&i2c->msg_complete);
+	}
+
+end:
+	spin_unlock(&i2c->lock);
+
+	return IRQ_HANDLED;
+}
+
+static int hibvt_i2c_interrupt_xfer_one_msg(struct hibvt_i2c_dev *i2c)
+{
+	int status;
+	struct i2c_msg *msg = i2c->msg;
+	unsigned long timeout;
+	unsigned long flags;
+
+	dev_dbg(i2c->dev, "[%s,%d]msg->flags=0x%x, len=0x%x\n",
+		__func__, __LINE__, msg->flags, msg->len);
+
+	reinit_completion(&i2c->msg_complete);
+	i2c->msg_buf_ptr = 0;
+	i2c->status = -EIO;
+
+	spin_lock_irqsave(&i2c->lock, flags);
+	check_i2c_send_complete(i2c);
+	hibvt_i2c_enable(i2c);
+	hibvt_i2c_clr_irq(i2c);
+	if (msg->flags & I2C_M_RD)
+		hibvt_i2c_cfg_irq(i2c, INTR_USE_MASK & ~INTR_TX_MASK);
+	else
+		hibvt_i2c_cfg_irq(i2c, INTR_USE_MASK & ~INTR_RX_MASK);
+
+	hibvt_i2c_set_addr(i2c);
+	hibvt_i2c_cfg_cmd(i2c);
+	hibvt_i2c_start_cmd(i2c);
+	spin_unlock_irqrestore(&i2c->lock, flags);
+
+	timeout = wait_for_completion_timeout(&i2c->msg_complete,
+					      I2C_IRQ_TIMEOUT);
+
+	spin_lock_irqsave(&i2c->lock, flags);
+	if (timeout == 0) {
+		hibvt_i2c_disable_irq(i2c, INTR_ALL_MASK);
+		status = -EIO;
+		dev_err(i2c->dev, "%s timeout\n",
+			msg->flags & I2C_M_RD ? "rx" : "tx");
+	} else {
+		status = i2c->status;
+	}
+
+	hibvt_i2c_disable(i2c);
+
+	spin_unlock_irqrestore(&i2c->lock, flags);
+	return status;
+}
+
+/*
+ * Master transfer function
+ */
+static int hibvt_i2c_xfer(struct i2c_adapter *adap,
+			  struct i2c_msg *msgs, int num)
+{
+	struct hibvt_i2c_dev *i2c = i2c_get_adapdata(adap);
+	int status = -EINVAL;
+	unsigned long flags;
+
+	if (!msgs || (num <= 0)) {
+		dev_err(i2c->dev, "msgs == NULL || num <= 0, Invalid argument!\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&i2c->lock, flags);
+
+	i2c->msg = msgs;
+	i2c->msg_num = num;
+	i2c->msg_idx = 0;
+
+	while (i2c->msg_idx < i2c->msg_num) {
+#if defined(CONFIG_HI_DMAC) || defined(CONFIG_HIEDMAC)
+		if ((i2c->msg->len >= CONFIG_DMA_MSG_MIN_LEN) &&
+				(i2c->msg->len <= CONFIG_DMA_MSG_MAX_LEN)) {
+			status = hibvt_i2c_dma_xfer_one_msg(i2c);
+			if (status)
+				break;
+		} else if (i2c->irq >= 0) {
+#else
+		if (i2c->irq >= 0) {
+#endif
+			spin_unlock_irqrestore(&i2c->lock, flags);
+			status = hibvt_i2c_interrupt_xfer_one_msg(i2c);
+			spin_lock_irqsave(&i2c->lock, flags);
+			if (status)
+				break;
+		} else {
+			status = hibvt_i2c_polling_xfer_one_msg(i2c);
+			if (status)
+				break;
+		}
+		i2c->msg++;
+		i2c->msg_idx++;
+	}
+
+	if (!status || i2c->msg_idx > 0)
+		status = i2c->msg_idx;
+
+	spin_unlock_irqrestore(&i2c->lock, flags);
+	return status;
+}
+
+/* hibvt_i2c_break_polling_xfer
+ *
+ * I2c polling independent branch, Shielding interrupt interface
+ */
+static int hibvt_i2c_break_polling_xfer(const struct i2c_adapter *adap,
+					struct i2c_msg *msgs, int num)
+{
+	struct hibvt_i2c_dev *i2c = i2c_get_adapdata(adap);
+	int status = -EINVAL;
+	unsigned long flags;
+	if (!msgs || (num <= 0)) {
+		dev_err(i2c->dev, "msgs == NULL || num <= 0, Invalid argument!\n");
+		return -EINVAL;
+	}
+	spin_lock_irqsave(&i2c->lock, flags);
+	i2c->msg = msgs;
+	i2c->msg_num = num;
+	i2c->msg_idx = 0;
+	while (i2c->msg_idx < i2c->msg_num) {
+#if defined(CONFIG_HI_DMAC) || defined(CONFIG_HIEDMAC)
+		if ((i2c->msg->len >= CONFIG_DMA_MSG_MIN_LEN) &&
+				(i2c->msg->len <= CONFIG_DMA_MSG_MAX_LEN)) {
+			status = hibvt_i2c_dma_xfer_one_msg(i2c);
+			if (status)
+				break;
+		}
+#else
+		status = hibvt_i2c_polling_xfer_one_msg(i2c);
+		if (status)
+			break;
+#endif
+		i2c->msg++;
+		i2c->msg_idx++;
+	}
+	if (!status || i2c->msg_idx > 0)
+		status = i2c->msg_idx;
+	spin_unlock_irqrestore(&i2c->lock, flags);
+	return status;
+}
+
+static int hibvt_i2c_mul_reg_xfer(struct i2c_adapter *adap,
+				 struct i2c_msg *msgs, int num, unsigned int reg_data_width)
+{
+	struct hibvt_i2c_dev *i2c = i2c_get_adapdata(adap);
+	int status = -EINVAL;
+	unsigned long flags;
+	if (!msgs || (num <= 0)) {
+		dev_err(i2c->dev, "msgs == NULL || num <= 0, Invalid argument!\n");
+		return -EINVAL;
+	}
+	spin_lock_irqsave(&i2c->lock, flags);
+	i2c->msg = msgs;
+	i2c->msg_num = num;
+	i2c->msg_idx = 0;
+	while (i2c->msg_idx < i2c->msg_num) {
+		if ((i2c->msg->len >= CONFIG_DMA_MSG_MIN_LEN) && (i2c->msg->len <= CONFIG_DMA_MSG_MAX_LEN) && (i2c->msg->flags & I2C_M_DMA)) {
+#if defined(CONFIG_HIEDMAC) && defined(CONFIG_HIEDMAC_INTERRUPT)
+			status = hibvt_i2c_dma_xfer_one_msg_mul_reg(i2c, reg_data_width);
+#endif
+			if (status) {
+				break;
+			}
+		} else {
+			status = hibvt_i2c_polling_xfer_one_msg_mul_reg(i2c, reg_data_width);
+			if (status) {
+				break;
+			}
+		}
+		i2c->msg++;
+		i2c->msg_idx++;
+	}
+	if (!status || i2c->msg_idx > 0) {
+		status = i2c->msg_idx;
+	}
+	spin_unlock_irqrestore(&i2c->lock, flags);
+	return status;
+}
+/* HI I2C READ *
+ * hi_i2c_master_recv - issue a single I2C message in master receive mode
+ * @client: Handle to slave device
+ * @buf: Where to store data read from slave
+ * @count: How many bytes to read, must be less than 64k since msg.len is u16
+ *
+ * Returns negative errno, or else the number of bytes read.
+ */
+int hi_i2c_master_recv(const struct i2c_client *client, char *buf,
+		       int count)
+{
+	printk("Wrong interface call."
+	       "hi_i2c_transfer is the only interface to i2c read!!!\n");
+
+	return -EIO;
+}
+EXPORT_SYMBOL(hi_i2c_master_recv);
+
+/* HI I2C WRITE *
+ * hi_i2c_master_send - issue a single I2C message in master transmit mode
+ * @client: Handle to slave device
+ * @buf: Data that will be written to the slave
+ * @count: How many bytes to write, must be less than 64k since msg.len is u16
+ *
+ * Returns negative errno, or else the number of bytes written.
+ */
+int hi_i2c_master_send(const struct i2c_client *client,
+		       const char *buf, int count)
+{
+	struct i2c_adapter *adap = NULL;
+	struct i2c_msg msg;
+	int msgs_count;
+
+	if ((client == NULL) || (buf == NULL) || (client->adapter == NULL) ||
+			(count < 0)) {
+		printk(KERN_ERR "invalid args\n");
+		return -EINVAL;
+	}
+
+	if ((client->addr > 0x3ff) ||
+			(((client->flags & I2C_M_TEN) == 0) && (client->addr > 0x7f))) {
+		printk(KERN_ERR "dev address out of range\n");
+		return -EINVAL;
+	}
+
+	adap = client->adapter;
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = count;
+
+	msg.buf = (__u8 *)buf;
+
+	msgs_count = hibvt_i2c_break_polling_xfer(adap, &msg, 1);
+
+	return (msgs_count == 1) ? count : -EIO;
+}
+EXPORT_SYMBOL(hi_i2c_master_send);
+
+
+int hi_i2c_master_send_mul_reg(const struct i2c_client *client,
+		       const char *buf, unsigned int count, unsigned int reg_data_width)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg;
+	int msgs_count;
+
+	if ((client->addr > 0x3ff)
+	    || (((client->flags & I2C_M_TEN) == 0) && (client->addr > 0x7f))) {
+		printk(KERN_ERR "dev address out of range\n");
+		return -EINVAL;
+	}
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = count;
+
+	if ((!buf)||(count < 0)) {
+		printk(KERN_ERR "buf == NULL || count < 0, Invalid argument!\n");
+		return -EINVAL;
+	}
+	msg.buf = (__u8 *)buf;
+
+	msgs_count = hibvt_i2c_mul_reg_xfer(adap, &msg, 1,reg_data_width);
+
+	return (msgs_count == 1) ? count : -EIO;
+}
+EXPORT_SYMBOL(hi_i2c_master_send_mul_reg);
+/**
+ * hi_i2c_transfer - execute a single or combined I2C message
+ * @adap: Handle to I2C bus
+ * @msgs: One or more messages to execute before STOP is issued to
+ *  terminate the operation; each message begins with a START.
+ * @num: Number of messages to be executed.
+ *
+ * Returns negative errno, else the number of messages executed.
+ *
+ * Note that there is no requirement that each message be sent to
+ * the same slave address, although that is the most common model.
+ */
+int hi_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+		    int num)
+{
+	int msgs_count;
+
+	if ((!adap) || (!msgs)) {
+		printk(KERN_ERR "adap == NULL || msgs == NULL, Invalid argument!\n");
+		return -EINVAL;
+	}
+
+	if ((msgs[0].addr > 0x3ff) ||
+			(((msgs[0].flags & I2C_M_TEN) == 0) && (msgs[0].addr > 0x7f))) {
+		printk(KERN_ERR "msgs[0] dev address out of range\n");
+		return -EINVAL;
+	}
+
+	if ((msgs[1].addr > 0x3ff) ||
+			(((msgs[1].flags & I2C_M_TEN) == 0) && (msgs[1].addr > 0x7f))) {
+		printk(KERN_ERR "msgs[1] dev address out of range\n");
+		return -EINVAL;
+	}
+
+	msgs_count = hibvt_i2c_xfer(adap, msgs, num);
+
+	return msgs_count;
+}
+EXPORT_SYMBOL(hi_i2c_transfer);
+
+static u32 hibvt_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |
+	       I2C_FUNC_PROTOCOL_MANGLING |
+	       I2C_FUNC_SMBUS_WORD_DATA |
+	       I2C_FUNC_SMBUS_BYTE_DATA |
+	       I2C_FUNC_SMBUS_BYTE |
+	       I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm hibvt_i2c_algo = {
+	.master_xfer		= hibvt_i2c_xfer,
+	.functionality		= hibvt_i2c_func,
+};
+
+static int hibvt_i2c_probe(struct platform_device *pdev)
+{
+	int status;
+	struct hibvt_i2c_dev *i2c;
+	struct i2c_adapter *adap = NULL;
+	struct resource *res = NULL;
+
+	i2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);
+	if (!i2c)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, i2c);
+	i2c->dev = &pdev->dev;
+	spin_lock_init(&i2c->lock);
+	init_completion(&i2c->msg_complete);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(i2c->dev, "Invalid mem resource./n");
+		return -ENODEV;
+	}
+
+	i2c->phybase = res->start;
+	i2c->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(i2c->base)) {
+		dev_err(i2c->dev, "cannot ioremap resource\n");
+		return -ENOMEM;
+	}
+
+	i2c->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(i2c->clk)) {
+		dev_err(i2c->dev, "cannot get clock\n");
+		return -ENOENT;
+	}
+	clk_prepare_enable(i2c->clk);
+
+	if (of_property_read_u32(pdev->dev.of_node, "clock-frequency",
+				 &i2c->freq)) {
+		dev_warn(i2c->dev, "setting default clock-frequency@%dHz\n",
+			 I2C_DEFAULT_FREQUENCY);
+		i2c->freq = I2C_DEFAULT_FREQUENCY;
+	}
+
+	/* i2c controller initialization, disable interrupt */
+	hibvt_i2c_hw_init(i2c);
+
+	i2c->irq = platform_get_irq(pdev, 0);
+	status = devm_request_irq(&pdev->dev, i2c->irq, hibvt_i2c_isr,
+				  IRQF_SHARED, dev_name(&pdev->dev), i2c);
+	if (status) {
+		dev_dbg(i2c->dev, "falling back to polling mode");
+		i2c->irq = -1;
+	}
+
+	adap = &i2c->adap;
+	i2c_set_adapdata(adap, i2c);
+	adap->owner = THIS_MODULE;
+	strlcpy(adap->name, "hibvt-i2c", sizeof(adap->name));
+	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
+	adap->algo = &hibvt_i2c_algo;
+
+	/* Add the i2c adapter */
+	status = i2c_add_adapter(adap);
+	if (status) {
+		dev_err(i2c->dev, "failed to add bus to i2c core\n");
+		goto err_add_adapter;
+	}
+
+	dev_info(i2c->dev, "%s%d@%dhz registered\n",
+		 adap->name, adap->nr, i2c->freq);
+
+	return 0;
+
+err_add_adapter:
+	clk_disable_unprepare(i2c->clk);
+	return status;
+}
+
+static int hibvt_i2c_remove(struct platform_device *pdev)
+{
+	struct hibvt_i2c_dev *i2c = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(i2c->clk);
+	i2c_del_adapter(&i2c->adap);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int hibvt_i2c_suspend(struct device *dev)
+{
+	struct hibvt_i2c_dev *i2c = dev_get_drvdata(dev);
+
+	i2c_lock_bus(&i2c->adap, I2C_LOCK_ROOT_ADAPTER);
+	clk_disable_unprepare(i2c->clk);
+	i2c_unlock_bus(&i2c->adap, I2C_LOCK_ROOT_ADAPTER);
+
+	return 0;
+}
+
+static int hibvt_i2c_resume(struct device *dev)
+{
+	struct hibvt_i2c_dev *i2c = dev_get_drvdata(dev);
+
+	i2c_lock_bus(&i2c->adap, I2C_LOCK_ROOT_ADAPTER);
+	clk_prepare_enable(i2c->clk);
+	hibvt_i2c_hw_init(i2c);
+	i2c_unlock_bus(&i2c->adap, I2C_LOCK_ROOT_ADAPTER);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(hibvt_i2c_dev_pm, hibvt_i2c_suspend,
+			 hibvt_i2c_resume);
+
+static const struct of_device_id hibvt_i2c_match[] = {
+	{ .compatible = "hisilicon,hibvt-i2c" },
+	{ .compatible = "hisilicon,hi3516cv300-i2c" },
+	{ .compatible = "hisilicon,hi3536dv100-i2c" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, hibvt_i2c_match);
+
+static struct platform_driver hibvt_i2c_driver = {
+	.driver		= {
+		.name	= "hibvt-i2c",
+		.of_match_table = hibvt_i2c_match,
+		.pm	= &hibvt_i2c_dev_pm,
+	},
+	.probe		= hibvt_i2c_probe,
+	.remove		= hibvt_i2c_remove,
+};
+
+module_platform_driver(hibvt_i2c_driver);
+
+MODULE_AUTHOR("Hisilicon");
+MODULE_DESCRIPTION("HISILICON BVT I2C Bus driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c
index f358120d5..0693b4917 100644
--- a/drivers/i2c/i2c-dev.c
+++ b/drivers/i2c/i2c-dev.c
@@ -232,7 +232,42 @@ static int i2cdev_check_addr(struct i2c_adapter *adapter, unsigned int addr)
 
 	return result;
 }
+static noinline int i2c_config_mul_reg(struct i2c_client *client, unsigned long arg)
+{
+	struct i2c_msg msg;
+	unsigned int reg_width;
+	unsigned int data_width;
+	unsigned int reg_data_width;
+
+	if (copy_from_user(&msg,
+			   (struct i2c_msg __user *)arg,
+			   sizeof(msg)))
+		return -EFAULT;
+
+	if(client->flags & I2C_M_16BIT_REG)
+		reg_width = 2;
+	else
+		reg_width = 1;
+
+	if(client->flags & I2C_M_16BIT_DATA)
+		data_width = 2;
+	else
+		data_width = 1;
+
+	reg_data_width = reg_width + data_width;
+
+	msg.buf = memdup_user(msg.buf,msg.len);
+
+	if(msg.len == 0 || reg_data_width > msg.len || msg.len % reg_data_width != 0){
+		printk(KERN_ERR "msg.len err!!!\n");
+		return -EINVAL;
+	}
+
+	hi_i2c_master_send_mul_reg(client, msg.buf, msg.len, reg_data_width);
 
+	return 0;
+
+}
 static noinline int i2cdev_ioctl_rdwr(struct i2c_client *client,
 		unsigned nmsgs, struct i2c_msg *msgs)
 {
@@ -485,6 +520,24 @@ static long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		 */
 		client->adapter->timeout = msecs_to_jiffies(arg * 10);
 		break;
+	case I2C_CONFIG_FLAGS:
+		if (arg & I2C_M_16BIT_REG)
+			client->flags |= I2C_M_16BIT_REG;
+		else
+			client->flags &= ~I2C_M_16BIT_REG;
+
+		if (arg & I2C_M_16BIT_DATA)
+			client->flags |= I2C_M_16BIT_DATA;
+		else
+			client->flags &= ~I2C_M_16BIT_DATA;
+
+		if (arg & I2C_M_DMA)
+			client->flags |= I2C_M_DMA;
+		else
+			client->flags &= ~I2C_M_DMA;
+		return 0;
+	case I2C_CONFIG_MUL_REG:
+		return i2c_config_mul_reg(client, arg);
 	default:
 		/* NOTE:  returning a fault code here could cause trouble
 		 * in buggy userspace code.  Some old kernel bugs returned
diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
index 176f5f064..24dd82c4b 100644
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -118,6 +118,24 @@ static DEFINE_STATIC_KEY_FALSE(needs_rmw_access);
 static u8 gic_cpu_map[NR_GIC_CPU_IF] __read_mostly;
 
 static DEFINE_STATIC_KEY_TRUE(supports_deactivate_key);
+#if defined(CONFIG_ARCH_HI3556V200) || defined(CONFIG_ARCH_HI3559V200) || \
+    defined(CONFIG_ARCH_HI3516CV500)|| defined(CONFIG_ARCH_HI3516DV300)|| \
+    defined(CONFIG_ARCH_HI3562V100) || defined(CONFIG_ARCH_HI3566V100)
+#ifdef CONFIG_ARCH_HISI_BVT_AMP
+/*
+ *Uesed to process gic sgi interrupt *
+ */
+#define DIS_IRQ_CNT	6
+struct gic_sgi_handle {
+	unsigned int irq;
+	void (*handle)(unsigned int cpu_intrf,
+			unsigned int irq_num,
+			struct pt_regs *regs);
+};
+struct gic_sgi_handle dis_irq_handle[DIS_IRQ_CNT];
+EXPORT_SYMBOL(dis_irq_handle);
+#endif
+#endif
 
 static struct gic_chip_data gic_data[CONFIG_ARM_GIC_MAX_NR] __read_mostly;
 
@@ -333,6 +351,29 @@ static int gic_retrigger(struct irq_data *data)
 	return !gic_irq_set_irqchip_state(data, IRQCHIP_STATE_PENDING, true);
 }
 
+#if defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+#ifdef CONFIG_ARCH_HISI_BVT_AMP
+/* used to process dis irq */
+int dis_irq_proc(u32 irqnr, u32 irqstat, struct pt_regs *regs)
+{
+	u32 idx;
+
+	for (idx = 0; idx < DIS_IRQ_CNT; idx++) {
+		if ((irqnr == dis_irq_handle[idx].irq)
+				&& (dis_irq_handle[idx].handle)) {
+			dis_irq_handle[idx].handle(((irqstat >> 10) & 0x7),
+					irqnr, regs);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+#endif
+#endif
+
 static void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)
 {
 	u32 irqstat, irqnr;
@@ -468,7 +509,31 @@ static void gic_cpu_if_up(struct gic_chip_data *gic)
 	writel_relaxed(bypass | mode | GICC_ENABLE, cpu_base + GIC_CPU_CTRL);
 }
 
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3569V100)
+#include "irq-map-hi3559av100.h"
+static void gic_dist_init_amp(struct gic_chip_data *gic)
+{
+	unsigned int i;
+	u32 cpumask;
+	unsigned int *irq_map_int = (unsigned int *)irq_map;
+	unsigned int gic_irqs = gic->gic_irqs;
+	void __iomem *base = gic_data_dist_base(gic);
 
+	writel_relaxed(GICD_DISABLE, base + GIC_DIST_CTRL);
+
+	/*
+	 * Set all global interrupts to this CPU only.
+	 */
+	for (i = 32; i < gic_irqs; i += 4) {
+	    cpumask = irq_map_int[i / 4];
+		writel_relaxed(cpumask, base + GIC_DIST_TARGET + i * 4 / 4);
+	}
+
+	gic_dist_config(base, gic_irqs, NULL);
+
+	writel_relaxed(GICD_ENABLE, base + GIC_DIST_CTRL);
+}
+#else
 static void gic_dist_init(struct gic_chip_data *gic)
 {
 	unsigned int i;
@@ -491,6 +556,7 @@ static void gic_dist_init(struct gic_chip_data *gic)
 
 	writel_relaxed(GICD_ENABLE, base + GIC_DIST_CTRL);
 }
+#endif
 
 static int gic_cpu_init(struct gic_chip_data *gic)
 {
@@ -1161,6 +1227,9 @@ static int gic_init_bases(struct gic_chip_data *gic,
 {
 	int gic_irqs, ret;
 
+	struct device_node *np;
+	void * sysctrl_reg_base;
+	int gic_dist_init_flag;
 	if (IS_ENABLED(CONFIG_GIC_NON_BANKED) && gic->percpu_offset) {
 		/* Frankein-GIC without banked registers... */
 		unsigned int cpu;
@@ -1232,7 +1301,25 @@ static int gic_init_bases(struct gic_chip_data *gic,
 		goto error;
 	}
 
-	gic_dist_init(gic);
+#define GIC_DIST_INIT_FLAG 0x47444946
+#define GIC_DIST_INIT_FLAG_OFFSET 0x0130
+	/* 0x47444946('G''D''I''F') is abbreviation of GIC_DIST_INIT_FLAG. */
+
+	np = of_find_compatible_node(NULL, NULL, "hisilicon,sysctrl");
+	sysctrl_reg_base = of_iomap(np, 0);
+	gic_dist_init_flag = readl(sysctrl_reg_base + GIC_DIST_INIT_FLAG_OFFSET);
+
+	if(gic_dist_init_flag != GIC_DIST_INIT_FLAG) {
+		printk("Gic dist init...\n");
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3569V100)
+		gic_dist_init_amp(gic);
+#else
+		gic_dist_init(gic);
+#endif
+		writel_relaxed(GIC_DIST_INIT_FLAG, sysctrl_reg_base + GIC_DIST_INIT_FLAG_OFFSET);
+	} else
+		printk("Gic dist not init...\n");
+
 	ret = gic_cpu_init(gic);
 	if (ret)
 		goto error;
diff --git a/drivers/media/usb/gspca/ov519.c b/drivers/media/usb/gspca/ov519.c
index cd6776c31..8d06332bb 100644
--- a/drivers/media/usb/gspca/ov519.c
+++ b/drivers/media/usb/gspca/ov519.c
@@ -3482,6 +3482,11 @@ static void ov511_mode_init_regs(struct sd *sd)
 		return;
 	}
 
+	if (alt->desc.bNumEndpoints < 1) {
+		sd->gspca_dev.usb_err = -ENODEV;
+		return;
+	}
+
 	packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);
 	reg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);
 
@@ -3613,6 +3618,11 @@ static void ov518_mode_init_regs(struct sd *sd)
 		return;
 	}
 
+	if (alt->desc.bNumEndpoints < 1) {
+		sd->gspca_dev.usb_err = -ENODEV;
+		return;
+	}
+
 	packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);
 	ov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);
 
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index b8847ae04..e6bf07fe1 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -520,6 +520,17 @@ config MFD_HI655X_PMIC
 	help
 	  Select this option to enable Hisilicon hi655x series pmic driver.
 
+config MFD_HISI_FMC
+	tristate "HiSilicon Flash Memory Controller"
+	depends on OF
+	depends on ARCH_HISI_BVT
+	select MFD_CORE
+	select REGMAP_MMIO
+	help
+	  Select this option to enable the HiSilicon Flash Memory
+	  Controller(FMC) driver.
+
+
 config HTC_PASIC3
 	tristate "HTC PASIC3 LED/DS1WM chip support"
 	select MFD_CORE
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 1780019d2..992e1895f 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -211,6 +211,7 @@ obj-$(CONFIG_MFD_AT91_USART)	+= at91-usart.o
 obj-$(CONFIG_MFD_ATMEL_FLEXCOM)	+= atmel-flexcom.o
 obj-$(CONFIG_MFD_ATMEL_HLCDC)	+= atmel-hlcdc.o
 obj-$(CONFIG_MFD_ATMEL_SMC)	+= atmel-smc.o
+obj-$(CONFIG_MFD_HISI_FMC)	+= hisi_fmc.o
 obj-$(CONFIG_MFD_INTEL_LPSS)	+= intel-lpss.o
 obj-$(CONFIG_MFD_INTEL_LPSS_PCI)	+= intel-lpss-pci.o
 obj-$(CONFIG_MFD_INTEL_LPSS_ACPI)	+= intel-lpss-acpi.o
diff --git a/drivers/mfd/hisi_fmc.c b/drivers/mfd/hisi_fmc.c
new file mode 100644
index 000000000..7aa23e56d
--- /dev/null
+++ b/drivers/mfd/hisi_fmc.c
@@ -0,0 +1,134 @@
+/* HiSilicon Flash Memory Controller Driver
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/hisi_fmc.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+unsigned char hifmc_cs_user[HIFMC_MAX_CHIP_NUM];
+
+DEFINE_MUTEX(fmc_switch_mutex);
+EXPORT_SYMBOL_GPL(fmc_switch_mutex);
+
+/* ------------------------------------------------------------------------ */
+static const struct mfd_cell hisi_fmc_devs[] = {
+	{
+		.name = "hisi_spi_nor",
+		.of_compatible = "hisilicon,fmc-spi-nor",
+	},
+	{
+		.name = "hisi_spi_nand",
+		.of_compatible = "hisilicon,fmc-spi-nand",
+	},
+	{
+		.name = "hisi_nand",
+		.of_compatible = "hisilicon,fmc-nand",
+	},
+};
+
+static int hisi_fmc_probe(struct platform_device *pdev)
+{
+	struct hisi_fmc *fmc = NULL;
+	struct resource *res = NULL;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	fmc = devm_kzalloc(dev, sizeof(*fmc), GFP_KERNEL);
+	if (!fmc)
+		return -ENOMEM;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "control");
+	fmc->regbase = devm_ioremap_resource(dev, res);
+	if (IS_ERR(fmc->regbase))
+		return PTR_ERR(fmc->regbase);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "memory");
+	fmc->iobase = devm_ioremap_resource(dev, res);
+	if (IS_ERR(fmc->iobase))
+		return PTR_ERR(fmc->iobase);
+
+	fmc->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(fmc->clk))
+		return PTR_ERR(fmc->clk);
+
+	if (of_property_read_u32(dev->of_node, "max-dma-size", &fmc->dma_len)) {
+		dev_err(dev, "Please set the suitable max-dma-size value !!!\n");
+		return -ENOMEM;
+	}
+
+	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));
+	if (ret) {
+		dev_warn(dev, "Unable to set dma mask\n");
+		return ret;
+	}
+
+	fmc->buffer = dmam_alloc_coherent(dev, fmc->dma_len,
+					  &fmc->dma_buffer, GFP_KERNEL);
+	if (IS_ERR(fmc->buffer))
+		return PTR_ERR(fmc->buffer);
+
+	mutex_init(&fmc->lock);
+
+	platform_set_drvdata(pdev, fmc);
+
+	ret = mfd_add_devices(dev, 0, hisi_fmc_devs,
+			      ARRAY_SIZE(hisi_fmc_devs), NULL, 0, NULL);
+	if (ret) {
+		dev_err(dev, "add mfd devices failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hisi_fmc_remove(struct platform_device *pdev)
+{
+	struct hisi_fmc *fmc = platform_get_drvdata(pdev);
+
+	dmam_free_coherent(&pdev->dev, fmc->dma_len,
+			   fmc->buffer, fmc->dma_buffer);
+	mfd_remove_devices(&pdev->dev);
+	mutex_destroy(&fmc->lock);
+
+	return 0;
+}
+
+static const struct of_device_id hisi_fmc_of_match_tbl[] = {
+	{.compatible = "hisilicon,hisi-fmc"},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hisi_fmc_of_match_tbl);
+
+static struct platform_driver hisi_fmc_driver = {
+	.driver = {
+		.name = "hifmc",
+		.of_match_table = hisi_fmc_of_match_tbl,
+	},
+	.probe = hisi_fmc_probe,
+	.remove = hisi_fmc_remove,
+};
+module_platform_driver(hisi_fmc_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("HiSilicon Flash Memory Controller Driver");
diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c
index 94caee49d..c69c59dcb 100644
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@ -448,7 +448,7 @@ static int card_busy_detect(struct mmc_card *card, unsigned int timeout_ms,
 static int __mmc_blk_ioctl_cmd(struct mmc_card *card, struct mmc_blk_data *md,
 			       struct mmc_blk_ioc_data *idata)
 {
-	struct mmc_command cmd = {}, sbc = {};
+	struct mmc_command cmd = {};
 	struct mmc_data data = {};
 	struct mmc_request mrq = {};
 	struct scatterlist sg;
@@ -525,15 +525,15 @@ static int __mmc_blk_ioctl_cmd(struct mmc_card *card, struct mmc_blk_data *md,
 	}
 
 	if (idata->rpmb) {
-		sbc.opcode = MMC_SET_BLOCK_COUNT;
-		/*
-		 * We don't do any blockcount validation because the max size
-		 * may be increased by a future standard. We just copy the
-		 * 'Reliable Write' bit here.
-		 */
-		sbc.arg = data.blocks | (idata->ic.write_flag & BIT(31));
-		sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
-		mrq.sbc = &sbc;
+		struct mmc_command mmc_cmd = {};
+		mmc_cmd.opcode = MMC_SET_BLOCK_COUNT;
+		mmc_cmd.arg = data.blocks & 0x0000FFFF;
+		if (idata->ic.write_flag & (1 << 31))
+			mmc_cmd.arg |= 1 << 31;
+		mmc_cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+		err = mmc_wait_for_cmd(card->host, &mmc_cmd, 5);
+		if (err)
+			return err;
 	}
 
 	if ((MMC_EXTRACT_INDEX_FROM_ARG(cmd.arg) == EXT_CSD_SANITIZE_START) &&
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b5f3f160c..0b0e367bc 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1371,6 +1371,9 @@ void mmc_power_off(struct mmc_host *host)
 
 void mmc_power_cycle(struct mmc_host *host, u32 ocr)
 {
+	if (host->type == MMC_HOST_TYPE_MMC)
+		return;
+
 	mmc_power_off(host);
 	/* Wait at least 1 ms according to SD spec */
 	mmc_delay(1);
@@ -2286,9 +2289,12 @@ void mmc_rescan(struct work_struct *work)
 	mmc_bus_put(host);
 
 	mmc_claim_host(host);
+	host->card_status = MMC_CARD_UNINIT;
 	if (mmc_card_is_removable(host) && host->ops->get_cd &&
 			host->ops->get_cd(host) == 0) {
 		mmc_power_off(host);
+		if (host->ops->card_info_save)
+			host->ops->card_info_save(host);
 		mmc_release_host(host);
 		goto out;
 	}
@@ -2300,8 +2306,17 @@ void mmc_rescan(struct work_struct *work)
 				continue;
 			freq = host->f_max;
 		}
-		if (!mmc_rescan_try_freq(host, max(freq, host->f_min)))
+
+		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min))) {
+			host->card_status = MMC_CARD_INIT;
+			if (host->ops->card_info_save)
+				host->ops->card_info_save(host);
 			break;
+		} else if ((i == (ARRAY_SIZE(freqs) - 1)) ||
+			(freqs[i] <= host->f_min)) {
+			host->card_status = MMC_CARD_INIT_FAIL;
+		}
+
 		if (freqs[i] <= host->f_min)
 			break;
 	}
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 7494d5950..416fc6723 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -1414,7 +1414,9 @@ static int mmc_select_hs400es(struct mmc_card *card)
 
 	/* Set host controller to HS400 timing and frequency */
 	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
-
+#if defined(CONFIG_MMC_SDHCI_HISI) || (defined(MODULE) && defined(CONFIG_MMC_SDHCI_HISI_MODULE))
+	mmc_set_bus_speed(card);
+#endif
 	/* Controller enable enhanced strobe function */
 	host->ios.enhanced_strobe = true;
 	if (host->ops->hs400_enhanced_strobe)
@@ -1512,7 +1514,8 @@ static int mmc_select_timing(struct mmc_card *card)
 	if (!mmc_can_ext_csd(card))
 		goto bus_speed;
 
-	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400ES)
+	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400ES &&
+	    card->host->caps & MMC_CAP_8_BIT_DATA)
 		err = mmc_select_hs400es(card);
 	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
 		err = mmc_select_hs200(card);
@@ -2239,6 +2242,7 @@ int mmc_attach_mmc(struct mmc_host *host)
 	if (err)
 		return err;
 
+	host->type = MMC_HOST_TYPE_MMC;
 	mmc_attach_bus(host, &mmc_ops);
 	if (host->ocr_avail_mmc)
 		host->ocr_avail = host->ocr_avail_mmc;
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index bac343a8d..af8bf24cd 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1349,6 +1349,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	if (err)
 		return err;
 
+	host->type = MMC_HOST_TYPE_SD;
 	mmc_attach_bus(host, &mmc_sd_ops);
 	if (host->ocr_avail_sd)
 		host->ocr_avail = host->ocr_avail_sd;
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 1b0853a82..3e452090d 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1193,6 +1193,7 @@ int mmc_attach_sdio(struct mmc_host *host)
 	if (err)
 		return err;
 
+	host->type = MMC_HOST_TYPE_SDIO;
 	mmc_attach_bus(host, &mmc_sdio_ops);
 	if (host->ocr_avail_sdio)
 		host->ocr_avail = host->ocr_avail_sdio;
@@ -1306,3 +1307,40 @@ int mmc_attach_sdio(struct mmc_host *host)
 	return err;
 }
 
+#ifdef CONFIG_ARCH_HISI_BVT
+/* sdio_reset_comm has been fixed in latest kernel/msm.git for Linux
+ * 2.6.27. The implementation prior to that buggy, and needs broadcom's
+ * patch for it*/
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	u32 rocr;
+	int err;
+
+	mmc_claim_host(host);
+	mmc_retune_disable(host);
+	mmc_go_idle(host);
+	mmc_set_clock(host, host->f_min);
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		goto err;
+	rocr = mmc_select_voltage(host, ocr);
+	if (!rocr) {
+		err = -EINVAL;
+		goto err;
+	}
+	err = mmc_sdio_init_card(host, rocr, card);
+	if (err)
+		goto err;
+	mmc_release_host(host);
+	return 0;
+err:
+	printk("%s: Error resetting SDIO communications: %d\n",
+			mmc_hostname(host), err);
+	mmc_release_host(host);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
+#endif
+
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 31481c9fc..299758712 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -247,6 +247,21 @@ config MMC_SDHCI_CNS3XXX
 
 	  If unsure, say N.
 
+config MMC_SDHCI_HISI
+	tristate "SDHCI support on the Hisilicon Hi35xx SoC"
+	depends on ARCH_HI3531DV200 || ARCH_HI3535AV100 || ARCH_HI3521DV200 ||\
+		   ARCH_HI3520DV500 || ARCH_HI3559AV100 || ARCH_HI3556AV100 ||\
+		   ARCH_HI3519AV100 || ARCH_HI3516EV200 || ARCH_HI3516EV300 ||\
+                   ARCH_HI3518EV300 || ARCH_HI3516DV200 || ARCH_HI3569V100  ||\
+		   ARCH_HI3568V100
+	depends on MMC_SDHCI_PLTFM
+	help
+	  This selects the SDHCI support for Hi35xx System-on-Chip devices.
+
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
+
 config MMC_SDHCI_ESDHC_MCF
 	tristate "SDHCI support for the Freescale eSDHC ColdFire controller"
 	depends on M5441x
@@ -1077,6 +1092,21 @@ config MMC_SDHCI_OMAP
 
 	  If unsure, say N.
 
+config MMC_CQ_HCI
+	tristate "Command Queue Support"
+	depends on HAS_DMA
+	help
+	  This selects the Command Queue Host Controller Interface (CQHCI)
+	  support present in host controllers of Qualcomm Technologies, Inc
+	  amongst others.
+	  This controller supports eMMC devices with command queue support.
+
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
+
+source "drivers/mmc/host/himci/Kconfig"
+
 config MMC_SDHCI_AM654
 	tristate "Support for the SDHCI Controller in TI's AM654 SOCs"
 	depends on MMC_SDHCI_PLTFM && OF && REGMAP_MMIO
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 451c25fc2..e7ec6250e 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -94,6 +94,21 @@ obj-$(CONFIG_MMC_SDHCI_OF_AT91)		+= sdhci-of-at91.o
 obj-$(CONFIG_MMC_SDHCI_OF_ESDHC)	+= sdhci-of-esdhc.o
 obj-$(CONFIG_MMC_SDHCI_OF_HLWD)		+= sdhci-of-hlwd.o
 obj-$(CONFIG_MMC_SDHCI_OF_DWCMSHC)	+= sdhci-of-dwcmshc.o
+obj-$(CONFIG_MMC_SDHCI_HISI)		+= sdhci-of-hisi.o
+sdhci-of-hisi-objs			:= sdhci-hisi.o mci_proc.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3531DV200)	+= sdhci-hi3531dv200.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3535AV100)	+= sdhci-hi3531dv200.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3521DV200)	+= sdhci-hi3521dv200.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3520DV500)	+= sdhci-hi3521dv200.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3559AV100)	+= sdhci-hi3559av100.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3556AV100)	+= sdhci-hi3556av100.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3519AV100)	+= sdhci-hi3556av100.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3516EV200)	+= sdhci-hi3516ev200.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3516EV300)	+= sdhci-hi3516ev300.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3518EV300)	+= sdhci-hi3518ev300.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3516DV200)	+= sdhci-hi3516dv200.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3568V100)		+= sdhci-hi3556av100.o
+sdhci-of-hisi-$(CONFIG_ARCH_HI3569V100)		+= sdhci-hi3559av100.o
 obj-$(CONFIG_MMC_SDHCI_OF_SPARX5)	+= sdhci-of-sparx5.o
 obj-$(CONFIG_MMC_SDHCI_BCM_KONA)	+= sdhci-bcm-kona.o
 obj-$(CONFIG_MMC_SDHCI_IPROC)		+= sdhci-iproc.o
@@ -112,3 +127,5 @@ endif
 
 obj-$(CONFIG_MMC_SDHCI_XENON)	+= sdhci-xenon-driver.o
 sdhci-xenon-driver-y		+= sdhci-xenon.o sdhci-xenon-phy.o
+
+obj-$(CONFIG_HIMCI)	+= himci/
diff --git a/drivers/mmc/host/cqhci.c b/drivers/mmc/host/cqhci.c
index 7ba4f7141..f5614efa4 100644
--- a/drivers/mmc/host/cqhci.c
+++ b/drivers/mmc/host/cqhci.c
@@ -46,6 +46,11 @@ static inline u8 *get_link_desc(struct cqhci_host *cq_host, u8 tag)
 
 static inline dma_addr_t get_trans_desc_dma(struct cqhci_host *cq_host, u8 tag)
 {
+	if (cq_host->quirks & CQHCI_QUIRK_TXFR_DESC_SZ_SPLIT)
+		return cq_host->trans_desc_dma_base +
+		(cq_host->mmc->max_segs * tag * 2 *
+		 cq_host->trans_desc_len);
+
 	return cq_host->trans_desc_dma_base +
 		(cq_host->mmc->max_segs * tag *
 		 cq_host->trans_desc_len);
@@ -53,6 +58,11 @@ static inline dma_addr_t get_trans_desc_dma(struct cqhci_host *cq_host, u8 tag)
 
 static inline u8 *get_trans_desc(struct cqhci_host *cq_host, u8 tag)
 {
+	if (cq_host->quirks & CQHCI_QUIRK_TXFR_DESC_SZ_SPLIT)
+		return cq_host->trans_desc_base +
+			(cq_host->trans_desc_len *
+			 cq_host->mmc->max_segs * 2 * tag);
+
 	return cq_host->trans_desc_base +
 		(cq_host->trans_desc_len * cq_host->mmc->max_segs * tag);
 }
@@ -193,8 +203,12 @@ static int cqhci_host_alloc_tdl(struct cqhci_host *cq_host)
 
 	cq_host->desc_size = cq_host->slot_sz * cq_host->num_slots;
 
-	cq_host->data_size = cq_host->trans_desc_len * cq_host->mmc->max_segs *
-		cq_host->mmc->cqe_qdepth;
+	if (cq_host->quirks & CQHCI_QUIRK_TXFR_DESC_SZ_SPLIT)
+		cq_host->data_size = cq_host->trans_desc_len *
+			cq_host->mmc->max_segs * 2 * cq_host->mmc->cqe_qdepth;
+	else
+		cq_host->data_size = cq_host->trans_desc_len *
+			cq_host->mmc->max_segs * cq_host->mmc->cqe_qdepth;
 
 	pr_debug("%s: cqhci: desc_size: %zu data_sz: %zu slot-sz: %d\n",
 		 mmc_hostname(cq_host->mmc), cq_host->desc_size, cq_host->data_size,
@@ -267,6 +281,8 @@ static void __cqhci_enable(struct cqhci_host *cq_host)
 
 	cqhci_writel(cq_host, cq_host->rca, CQHCI_SSC2);
 
+	cqhci_writel(cq_host, SEND_QSR_INTERVAL, CQHCI_SSC1);
+
 	cqhci_set_irqs(cq_host, 0);
 
 	cqcfg |= CQHCI_ENABLE;
@@ -276,8 +292,6 @@ static void __cqhci_enable(struct cqhci_host *cq_host)
 	if (cqhci_readl(cq_host, CQHCI_CTL) & CQHCI_HALT)
 		cqhci_writel(cq_host, 0, CQHCI_CTL);
 
-	mmc->cqe_on = true;
-
 	if (cq_host->ops->enable)
 		cq_host->ops->enable(mmc);
 
@@ -452,7 +466,7 @@ static int cqhci_dma_map(struct mmc_host *host, struct mmc_request *mrq)
 	return sg_count;
 }
 
-static void cqhci_set_tran_desc(u8 *desc, dma_addr_t addr, int len, bool end,
+static void _cqhci_set_tran_desc(u8 *desc, dma_addr_t addr, int len, bool end,
 				bool dma64)
 {
 	__le32 *attr = (__le32 __force *)desc;
@@ -474,6 +488,27 @@ static void cqhci_set_tran_desc(u8 *desc, dma_addr_t addr, int len, bool end,
 	}
 }
 
+static void cqhci_set_tran_desc(struct cqhci_host *cq_host, u8 **desc,
+		dma_addr_t addr, int len, bool end, bool dma64, unsigned int blksz)
+{
+	int desc_len;
+
+	if (cq_host->quirks & CQHCI_QUIRK_TXFR_DESC_SZ_SPLIT &&
+		addr % SYNOPSYS_DMA_LIMIT + len > SYNOPSYS_DMA_LIMIT) {
+		if ((addr + (unsigned int)len) % SYNOPSYS_DMA_LIMIT < blksz)
+			BUG_ON(1);
+
+		desc_len = (SYNOPSYS_DMA_LIMIT - addr % SYNOPSYS_DMA_LIMIT);
+		_cqhci_set_tran_desc(*desc, addr, desc_len, false, dma64);
+
+		*desc = *desc + cq_host->trans_desc_len;
+		len -= desc_len;
+		addr += desc_len;
+	}
+
+	_cqhci_set_tran_desc(*desc, addr, len, end, dma64);
+}
+
 static int cqhci_prep_tran_desc(struct mmc_request *mrq,
 			       struct cqhci_host *cq_host, int tag)
 {
@@ -500,7 +535,7 @@ static int cqhci_prep_tran_desc(struct mmc_request *mrq,
 
 		if ((i+1) == sg_count)
 			end = true;
-		cqhci_set_tran_desc(desc, addr, len, end, dma64);
+		cqhci_set_tran_desc(cq_host, &desc, addr, len, end, dma64, data->blksz);
 		desc += cq_host->trans_desc_len;
 	}
 
@@ -951,6 +986,9 @@ static void cqhci_recovery_start(struct mmc_host *mmc)
 		cq_host->ops->disable(mmc, true);
 
 	mmc->cqe_on = false;
+
+	cqhci_deactivate(mmc);
+
 }
 
 static int cqhci_error_from_flags(unsigned int flags)
diff --git a/drivers/mmc/host/cqhci.h b/drivers/mmc/host/cqhci.h
index 89bf6adbc..05571faf0 100644
--- a/drivers/mmc/host/cqhci.h
+++ b/drivers/mmc/host/cqhci.h
@@ -80,6 +80,12 @@
 
 /* send status config 1 */
 #define CQHCI_SSC1			0x40
+/*
+ * Value n means CQE would send CMD13 during the transfer of data block
+ * BLOCK_CNT-n
+ */
+#define SEND_QSR_INTERVAL 0x70001
+
 #define CQHCI_SSC1_CBC_MASK		GENMASK(19, 16)
 
 /* send status config 2 */
@@ -138,6 +144,7 @@
 #define CQHCI_DAT_ADDR_LO(x)		(((x) & 0xFFFFFFFF) << 32)
 #define CQHCI_DAT_ADDR_HI(x)		(((x) & 0xFFFFFFFF) << 0)
 
+#define SYNOPSYS_DMA_LIMIT		0x8000000
 struct cqhci_host_ops;
 struct mmc_host;
 struct mmc_request;
@@ -164,6 +171,7 @@ struct cqhci_host {
 
 	u32 quirks;
 #define CQHCI_QUIRK_SHORT_TXFR_DESC_SZ	0x1
+#define CQHCI_QUIRK_TXFR_DESC_SZ_SPLIT	0x2
 
 	bool enabled;
 	bool halted;
diff --git a/drivers/mmc/host/himci/Kconfig b/drivers/mmc/host/himci/Kconfig
new file mode 100644
index 000000000..f3331c862
--- /dev/null
+++ b/drivers/mmc/host/himci/Kconfig
@@ -0,0 +1,23 @@
+#
+#  himci family SD/MMC device configuration
+#
+menuconfig HIMCI
+	tristate "himci driver support"
+	depends on ARCH_HI3516A || ARCH_HI3518EV20X || ARCH_HI3516CV500 || ARCH_HI3516DV300 || ARCH_HI3556V200 || ARCH_HI3559V200 || ARCH_HI3562V100 || ARCH_HI3566V100
+	default y if ARCH_HI3516A
+	select MMC_UNSAFE_RESUME
+	select MMC_EMBEDDED_SDIO
+	select MMC_BLOCK
+	select MMC_BLOCK_BOUNCE
+	help
+	  This selects the Hisilicon Synopsys MultiMedia Card Driver
+	  support. If you want use SD/MMC/SDIO driver,
+	  Say Y or M here.
+
+	  default is Y.
+
+config SEND_AUTO_STOP
+	bool "Send Auto Stop to terminate data transfer between host and SD card"
+	depends on HIMCI
+	default y
+
diff --git a/drivers/mmc/host/himci/Makefile b/drivers/mmc/host/himci/Makefile
new file mode 100644
index 000000000..6858bfcef
--- /dev/null
+++ b/drivers/mmc/host/himci/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_HIMCI) += hisi_mci.o
+hisi_mci-y	:= himci.o himci_proc.o
diff --git a/drivers/mmc/host/himci/himci.c b/drivers/mmc/host/himci/himci.c
new file mode 100644
index 000000000..65aa8d24e
--- /dev/null
+++ b/drivers/mmc/host/himci/himci.c
@@ -0,0 +1,2580 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+#define pr_fmt(fmt) "himci: " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/sd.h>
+#include <linux/slab.h>
+
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/kthread.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <linux/sizes.h>
+#include <mach/io.h>
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/reset.h>
+
+#include "himci_reg.h"
+#include "himci.h"
+#include "himci_proc.h"
+
+#ifdef CONFIG_ARCH_HI3516A
+#include "himci_hi3516a.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3518EV20X
+#include "himci_hi3518ev20x.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3516CV500
+#include "himci_hi3516cv500.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3516DV300
+#include "himci_hi3516dv300.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3556V200
+#include "himci_hi3556v200.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3559V200
+#include "himci_hi3559v200.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3562V100
+#include "himci_hi3559v200.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3566V100
+#include "himci_hi3559v200.c"
+#endif
+
+#define DRIVER_NAME "himci"
+
+#ifndef CONFIG_HISI_MC
+#define CMD_DES_PAGE_SIZE	(3 * PAGE_SIZE)
+#else
+#define CMD_DES_PAGE_SIZE	(8 * PAGE_SIZE)
+#endif
+
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+void __iomem *crg_ctrl, *misc_ctrl_1;
+#endif
+
+#if defined(CONFIG_ARCH_HI3516DV300)
+#define PWR_CTRL0_REG 0x12090000
+#define GPIO_AT_PMC_ENABLE_BIT 0x80
+#define REG_SLEEP_TIME_MS 0x30
+#endif
+
+static unsigned int detect_time = HI_MCI_DETECT_TIMEOUT;
+static unsigned int retry_count = MAX_RETRY_COUNT;
+static unsigned int request_timeout = HI_MCI_REQUEST_TIMEOUT;
+int trace_level = HIMCI_TRACE_LEVEL;
+unsigned int slot_index = 0;
+struct himci_host *mci_host[HIMCI_SLOT_NUM] = {NULL};
+#ifdef MODULE
+
+module_param(detect_time, uint, 0600);
+MODULE_PARM_DESC(detect_timer, "card detect time (default:500ms))");
+
+module_param(retry_count, uint, 0600);
+MODULE_PARM_DESC(retry_count, "retry count times (default:100))");
+
+module_param(request_timeout, uint, 0600);
+MODULE_PARM_DESC(request_timeout, "Request timeout time (default:3s))");
+
+module_param(trace_level, int, 0600);
+MODULE_PARM_DESC(trace_level, "HIMCI_TRACE_LEVEL");
+
+#endif
+
+/* reset MMC host controller */
+static void himci_sys_reset(struct himci_host *host)
+{
+	unsigned int reg_value;
+	unsigned long flags;
+
+	himci_trace(2, "reset");
+
+	local_irq_save(flags);
+
+	reg_value = himci_readl(host->base + MCI_BMOD);
+	reg_value |= BMOD_SWR;
+	himci_writel(reg_value, host->base + MCI_BMOD);
+	mdelay(10);
+
+	reg_value = himci_readl(host->base + MCI_BMOD);
+	reg_value |= BURST_16 | BURST_INCR;
+	himci_writel(reg_value, host->base + MCI_BMOD);
+
+	reg_value = himci_readl(host->base + MCI_CTRL);
+	reg_value |=  CTRL_RESET | FIFO_RESET | DMA_RESET;
+	himci_writel(reg_value, host->base + MCI_CTRL);
+
+	local_irq_restore(flags);
+}
+
+static void himci_ctrl_power(struct himci_host *host,
+			     unsigned int flag, unsigned int force)
+{
+	unsigned int port;
+
+	himci_trace(2, "begin");
+
+	port = host->port;
+
+	if (host->power_status != flag || force == FORCE_ENABLE) {
+		unsigned int reg_value;
+
+		if (flag == POWER_OFF) {
+			reg_value = himci_readl(host->base + MCI_RESET_N);
+			reg_value &= ~(MMC_RST_N << port);
+			himci_writel(reg_value, host->base + MCI_RESET_N);
+		}
+
+		reg_value = himci_readl(host->base + MCI_PWREN);
+		if (flag == POWER_OFF)
+			reg_value &= ~(0x1 << port);
+		else
+			reg_value |= (0x1 << port);
+
+		himci_writel(reg_value, host->base + MCI_PWREN);
+
+		if (flag == POWER_ON) {
+			reg_value = himci_readl(host->base + MCI_RESET_N);
+			reg_value |= (MMC_RST_N << port);
+			himci_writel(reg_value, host->base + MCI_RESET_N);
+		}
+
+		if (in_interrupt())
+			mdelay(100);
+		else
+			msleep(100);
+
+		host->power_status = flag;
+	}
+}
+
+/**********************************************
+ * 1: card off
+ * 0: card on
+ ***********************************************/
+static unsigned int himci_sys_card_detect(struct himci_host *host)
+{
+	unsigned int card_status;
+
+	card_status = readl(host->base + MCI_CDETECT);
+	card_status &= (HIMCI_CARD0 << host->port);
+	if (card_status)
+		card_status = 1;
+	else
+		card_status = 0;
+
+	return card_status;
+}
+
+/**********************************************
+ * 1: card readonly
+ * 0: card read/write
+ ***********************************************/
+static unsigned int himci_ctrl_card_readonly(struct himci_host *host)
+{
+	unsigned int card_value = himci_readl(host->base + MCI_WRTPRT);
+	return card_value & (HIMCI_CARD0 << host->port);
+}
+
+static int tuning_reset_flag = 0;
+
+static int himci_wait_cmd(struct himci_host *host)
+{
+	int wait_retry_count = 0;
+	int retry_count_cmd = 500;
+	unsigned int reg_data = 0;
+	unsigned long flags;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+
+	while (1) {
+		/*
+		 * Check if CMD::start_cmd bit is clear.
+		 * start_cmd = 0 means MMC Host controller has loaded registers
+		 * and next command can be loaded in.
+		 */
+		reg_data = himci_readl(host->base + MCI_CMD);
+		if ((reg_data & START_CMD) == 0)
+			return 0;
+
+		/* Check if Raw_Intr_Status::HLE bit is set. */
+		spin_lock_irqsave(&host->lock, flags);
+		reg_data = himci_readl(host->base + MCI_RINTSTS);
+		if (reg_data & HLE_INT_STATUS) {
+			reg_data |= HLE_INT_STATUS;
+			himci_writel(reg_data, host->base + MCI_RINTSTS);
+			spin_unlock_irqrestore(&host->lock, flags);
+
+			himci_trace(5, "Other CMD is running,"
+				    "please operate cmd again!");
+			return 1;
+		}
+
+		spin_unlock_irqrestore(&host->lock, flags);
+		udelay(1);
+
+		/* Check if number of retries for this are over. */
+		wait_retry_count++;
+		if (wait_retry_count >= retry_count_cmd) {
+			if (host->is_tuning)
+				tuning_reset_flag = 1;
+			himci_trace(3, "send cmd is timeout!");
+			return -1;
+		}
+	}
+}
+
+static int himci_control_cclk(struct himci_host *host, unsigned int flag)
+{
+	unsigned int reg;
+	union cmd_arg_u cmd_reg;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+
+	reg = himci_readl(host->base + MCI_CLKENA);
+	if (flag == ENABLE) {
+		reg |= (CCLK_ENABLE << host->port);
+		reg |= (CCLK_LOW_POWER << host->port);
+	} else {
+		reg &= ~(CCLK_ENABLE << host->port);
+		reg &= ~(CCLK_LOW_POWER << host->port);
+	}
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+	if (host->devid == 2)
+		reg &= ~(CCLK_LOW_POWER << host->port);
+#endif
+	himci_writel(reg, host->base + MCI_CLKENA);
+
+	cmd_reg.cmd_arg = himci_readl(host->base + MCI_CMD);
+	cmd_reg.bits.start_cmd = 1;
+	cmd_reg.bits.card_number = host->port;
+	cmd_reg.bits.cmd_index = 0;
+	cmd_reg.bits.data_transfer_expected = 0;
+	cmd_reg.bits.update_clk_reg_only = 1;
+	cmd_reg.bits.response_expect = 0;
+	cmd_reg.bits.send_auto_stop = 0;
+	cmd_reg.bits.wait_prvdata_complete = 0;
+	cmd_reg.bits.check_response_crc = 0;
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+	cmd_reg.bits.use_hold_reg = 1;
+#endif
+	himci_writel(cmd_reg.cmd_arg, host->base + MCI_CMD);
+	if (himci_wait_cmd(host) != 0) {
+		himci_trace(3, "disable or enable clk is timeout!");
+		return -ETIMEDOUT;
+	} else {
+		return 0;
+	}
+}
+
+static void himci_set_cclk(struct himci_host *host, unsigned int cclk)
+{
+	unsigned int reg_value;
+	union cmd_arg_u clk_cmd;
+	unsigned int hclk;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+	himci_assert(cclk);
+
+	hclk = cclk > MMC_CRG_MIN ? cclk : MMC_CRG_MIN;
+	clk_set_rate(host->clk, hclk);
+
+	hclk = clk_get_rate(host->clk);
+	host->mmc->actual_clock = hclk;
+
+	/*
+	 * set card clk divider value,
+	 * clk_divider = Fmmcclk/(Fmmc_cclk * 2)
+	 */
+	reg_value = hclk / (cclk * 2);
+	if ((hclk % (cclk * 2)) && (hclk > cclk))
+		reg_value++;
+	if (reg_value > 0xFF)
+		reg_value = 0xFF;
+
+	host->hclk = hclk;
+	host->cclk = reg_value ? (hclk / (reg_value * 2)) : hclk;
+	himci_writel((reg_value << (host->port * 8)),
+		     host->base + MCI_CLKDIV);
+
+	clk_cmd.cmd_arg = himci_readl(host->base + MCI_CMD);
+	clk_cmd.bits.start_cmd = 1;
+	clk_cmd.bits.card_number = host->port;
+	clk_cmd.bits.update_clk_reg_only = 1;
+	clk_cmd.bits.cmd_index = 0;
+	clk_cmd.bits.data_transfer_expected = 0;
+	clk_cmd.bits.response_expect = 0;
+	himci_writel(clk_cmd.cmd_arg, host->base + MCI_CMD);
+	if (himci_wait_cmd(host) != 0)
+		himci_trace(5, "set card clk divider is failed!");
+}
+
+static void himci_sys_ctrl_init(struct himci_host *host)
+{
+	reset_control_assert(host->crg_rst);
+	udelay(100);
+	reset_control_deassert(host->crg_rst);
+}
+
+static void himci_init_host(struct himci_host *host)
+{
+	unsigned int tmp_reg = 0;
+	unsigned long flags;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+
+	himci_sys_reset(host);
+
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+	/* controller config gpio */
+	tmp_reg = himci_readl(host->base + MCI_GPIO);
+	tmp_reg |= DTO_FIX_BYPASS;
+	himci_writel(tmp_reg, host->base + MCI_GPIO);
+#endif
+
+#ifdef CONFIG_ARCH_HI3518EV20X
+	/* sd use clk0 emmc use clk1 */
+	himci_writel(0x4, host->base + MCI_CLKSRC);
+#endif
+
+	/* set drv/smpl phase shift */
+	tmp_reg = 0;
+	tmp_reg |= SMPL_PHASE_DFLT | DRV_PHASE_DFLT;
+	himci_writel(tmp_reg, host->base + MCI_UHS_REG_EXT);
+
+	/* set card read threshold */
+	himci_writel(RW_THRESHOLD_SIZE, host->base + MCI_CARDTHRCTL);
+
+	/* clear MMC host intr */
+	himci_writel(ALL_INT_CLR, host->base + MCI_RINTSTS);
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->pending_events = 0;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	/* MASK MMC all host intr */
+	tmp_reg = himci_readl(host->base + MCI_INTMASK);
+	tmp_reg &= ~ALL_INT_MASK;
+	tmp_reg |= DATA_INT_MASK;
+	himci_writel(tmp_reg, host->base + MCI_INTMASK);
+
+	/* enable inner DMA mode and close intr of MMC host controler */
+	tmp_reg = himci_readl(host->base + MCI_CTRL);
+	tmp_reg &= ~INTR_EN;
+	tmp_reg |= USE_INTERNAL_DMA | INTR_EN;
+	himci_writel(tmp_reg, host->base + MCI_CTRL);
+
+	/* set timeout param */
+	himci_writel(DATA_TIMEOUT | RESPONSE_TIMEOUT, host->base + MCI_TIMEOUT);
+
+	/* set FIFO param */
+	tmp_reg = 0;
+	tmp_reg |= BURST_SIZE | RX_WMARK | TX_WMARK;
+	himci_writel(tmp_reg, host->base + MCI_FIFOTH);
+
+	host->error_count = 0;
+	host->data_error_count = 0;
+}
+
+static void himci_detect_card(struct timer_list *timer)
+{
+	struct himci_host *host = container_of(timer, struct himci_host, timer);
+	unsigned int i, curr_status, status[5];
+	unsigned int detect_retry_count = 0;
+
+	himci_assert(host);
+
+	while (1) {
+		for (i = 0; i < 5; i++) {
+			status[i] = himci_sys_card_detect(host);
+			udelay(10);
+		}
+		if ((status[0] == status[1])
+				&& (status[0] == status[2])
+				&& (status[0] == status[3])
+				&& (status[0] == status[4]))
+			break;
+
+		detect_retry_count++;
+		if (detect_retry_count >= retry_count) {
+			himci_error("this is a dithering, card detect error!");
+			goto err;
+		}
+	}
+	curr_status = status[0];
+	if (curr_status != host->card_status) {
+		himci_trace(2, "begin card_status = %d\n", host->card_status);
+		host->card_status = curr_status;
+		if (curr_status != CARD_UNPLUGED) {
+			himci_sys_ctrl_init(host);
+			himci_init_host(host);
+			pr_info("card connected!\n");
+		} else {
+			pr_info("card disconnected!\n");
+		}
+
+		mmc_detect_change(host->mmc, 0);
+	}
+err:
+	mod_timer(timer, jiffies + detect_time);
+}
+
+static void himci_idma_start(struct himci_host *host)
+{
+	unsigned int tmp;
+
+	himci_trace(2, "begin");
+	himci_writel(host->dma_paddr, host->base + MCI_DBADDR);
+	tmp = himci_readl(host->base + MCI_BMOD);
+	tmp |= BMOD_DMA_EN;
+	himci_writel(tmp, host->base + MCI_BMOD);
+}
+
+static void himci_idma_stop(struct himci_host *host)
+{
+	unsigned int tmp_reg;
+
+	himci_trace(2, "begin");
+	tmp_reg = himci_readl(host->base + MCI_BMOD);
+	tmp_reg &= ~BMOD_DMA_EN;
+	himci_writel(tmp_reg, host->base + MCI_BMOD);
+}
+
+static void himci_idma_reset(struct himci_host *host)
+{
+	u32 regval;
+
+	regval = himci_readl(host->base + MCI_BMOD);
+	regval |= BMOD_SWR;
+	himci_writel(regval, host->base + MCI_BMOD);
+
+	regval = himci_readl(host->base + MCI_CTRL);
+	regval |= CTRL_RESET | FIFO_RESET | DMA_RESET;
+	himci_writel(regval, host->base + MCI_CTRL);
+
+	udelay(1);
+	himci_writel(ALL_INT_CLR, host->base + MCI_RINTSTS);
+}
+
+static int himci_setup_data(struct himci_host *host, struct mmc_data *data)
+{
+	unsigned int sg_phyaddr, sg_length;
+	unsigned int i;
+	unsigned int ret = 0;
+	unsigned int data_size;
+	unsigned int max_des, des_cnt;
+	struct himci_des *des = NULL;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+	himci_assert(data);
+
+	host->data = data;
+
+	if (data->flags & MMC_DATA_READ)
+		host->dma_dir = DMA_FROM_DEVICE;
+	else
+		host->dma_dir = DMA_TO_DEVICE;
+
+	host->dma_sg = data->sg;
+	host->dma_sg_num = dma_map_sg(mmc_dev(host->mmc),
+				      data->sg, data->sg_len, host->dma_dir);
+	himci_assert(host->dma_sg_num);
+	himci_trace(2, "host->dma_sg_num is %d\n", host->dma_sg_num);
+	data_size = data->blksz * data->blocks;
+
+	if (data_size > (DMA_BUFFER * MAX_DMA_DES)) {
+		himci_error("mci request data_size is too big!\n");
+		ret = -1;
+		goto out;
+	}
+
+	himci_trace(2, "host->dma_paddr is 0x%08lx,host->dma_vaddr is 0x%08lx\n",
+		    (uintptr_t)host->dma_paddr,
+		    (uintptr_t)host->dma_vaddr);
+
+	max_des = (CMD_DES_PAGE_SIZE / sizeof(struct himci_des));
+	des = (struct himci_des *)host->dma_vaddr;
+	des_cnt = 0;
+
+	for (i = 0; i < host->dma_sg_num; i++) {
+		sg_length = sg_dma_len(&data->sg[i]);
+		sg_phyaddr = sg_dma_address(&data->sg[i]);
+		himci_trace(2, "sg[%d] sg_length is 0x%08X, " \
+			    "sg_phyaddr is 0x%08X\n", \
+			    i, (unsigned int)sg_length, \
+			    (unsigned int)sg_phyaddr);
+		while (sg_length) {
+			des[des_cnt].idmac_des_ctrl = DMA_DES_OWN
+						      | DMA_DES_NEXT_DES;
+			des[des_cnt].idmac_des_buf_addr = sg_phyaddr;
+			/* idmac_des_next_addr is paddr for dma */
+			des[des_cnt].idmac_des_next_addr = host->dma_paddr
+							   + (des_cnt + 1) * sizeof(struct himci_des);
+
+			/* buffer size <= 4k */
+			if (sg_length >= 0x1000) {
+				des[des_cnt].idmac_des_buf_size = 0x1000;
+				sg_length -= 0x1000;
+				sg_phyaddr += 0x1000;
+			} else {
+				/* data alignment */
+				des[des_cnt].idmac_des_buf_size = sg_length;
+				sg_length = 0;
+			}
+
+			himci_trace(2, "des[%d] vaddr  is 0x%08X", i,
+				    (unsigned int)(uintptr_t)&des[i]);
+			himci_trace(2, "des[%d].idmac_des_ctrl is 0x%08X",
+				    i, (unsigned int)des[i].idmac_des_ctrl);
+			himci_trace(2, "des[%d].idmac_des_buf_size is 0x%08X",
+				    i, (unsigned int)des[i].idmac_des_buf_size);
+			himci_trace(2, "des[%d].idmac_des_buf_addr 0x%08X",
+				    i, (unsigned int)des[i].idmac_des_buf_addr);
+			himci_trace(2, "des[%d].idmac_des_next_addr is 0x%08X",
+				    i, (unsigned int)des[i].idmac_des_next_addr);
+			des_cnt++;
+		}
+
+		himci_assert(des_cnt < max_des);
+	}
+	des[0].idmac_des_ctrl |= DMA_DES_FIRST_DES;
+	des[des_cnt - 1].idmac_des_ctrl |= DMA_DES_LAST_DES;
+	des[des_cnt - 1].idmac_des_next_addr = 0;
+out:
+	return ret;
+}
+
+static int himci_exec_cmd(struct himci_host *host,
+			  struct mmc_command *cmd, struct mmc_data *data)
+{
+	volatile union cmd_arg_u  cmd_regs;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+	himci_assert(cmd);
+
+	host->cmd = cmd;
+
+	himci_writel(cmd->arg, host->base + MCI_CMDARG);
+	himci_trace(4, "arg_reg 0x%x, val 0x%x", MCI_CMDARG, cmd->arg);
+	cmd_regs.cmd_arg = himci_readl(host->base + MCI_CMD);
+	if (data) {
+		cmd_regs.bits.data_transfer_expected = 1;
+		if (data->flags & (MMC_DATA_WRITE | MMC_DATA_READ))
+			cmd_regs.bits.transfer_mode = 0;
+
+		if (data->flags & MMC_DATA_WRITE)
+			cmd_regs.bits.read_write = 1;
+		else if (data->flags & MMC_DATA_READ)
+			cmd_regs.bits.read_write = 0;
+	} else {
+		cmd_regs.bits.data_transfer_expected = 0;
+		cmd_regs.bits.transfer_mode = 0;
+		cmd_regs.bits.read_write = 0;
+	}
+
+	cmd_regs.bits.send_auto_stop = 0;
+#ifdef CONFIG_SEND_AUTO_STOP
+	if ((host->mrq->stop) && (!(host->is_tuning)))
+		cmd_regs.bits.send_auto_stop = 1;
+#endif
+
+	if (cmd == host->mrq->stop ||
+			cmd->opcode == MMC_STOP_TRANSMISSION) {
+		cmd_regs.bits.stop_abort_cmd = 1;
+		cmd_regs.bits.wait_prvdata_complete = 0;
+	} else if (cmd->opcode == MMC_SEND_STATUS) {
+		cmd_regs.bits.stop_abort_cmd = 0;
+		cmd_regs.bits.wait_prvdata_complete = 0;
+	} else {
+		cmd_regs.bits.stop_abort_cmd = 0;
+		cmd_regs.bits.wait_prvdata_complete = 1;
+	}
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_NONE:
+		cmd_regs.bits.response_expect = 0;
+		cmd_regs.bits.response_length = 0;
+		cmd_regs.bits.check_response_crc = 0;
+		break;
+	case MMC_RSP_R1:
+	case MMC_RSP_R1B:
+		cmd_regs.bits.response_expect = 1;
+		cmd_regs.bits.response_length = 0;
+		cmd_regs.bits.check_response_crc = 1;
+		break;
+	case MMC_RSP_R2:
+		cmd_regs.bits.response_expect = 1;
+		cmd_regs.bits.response_length = 1;
+		cmd_regs.bits.check_response_crc = 1;
+		break;
+	case MMC_RSP_R3:
+	case MMC_RSP_R1 & (~MMC_RSP_CRC):
+		cmd_regs.bits.response_expect = 1;
+		cmd_regs.bits.response_length = 0;
+		cmd_regs.bits.check_response_crc = 0;
+		break;
+	default:
+		host->cmd->error = -EINVAL;
+		himci_error("himci: unhandled response type %02x\n",
+			    mmc_resp_type(cmd));
+		return -EINVAL;
+	}
+
+	himci_trace(3, "cmd->opcode = %d cmd->arg = 0x%X\n",
+		    cmd->opcode, cmd->arg);
+	if (cmd->opcode == MMC_SELECT_CARD) {
+		host->card_rca = (cmd->arg >> 16);
+	}
+	if (cmd->opcode == MMC_GO_IDLE_STATE)
+		cmd_regs.bits.send_initialization = 1;
+	else
+		cmd_regs.bits.send_initialization = 0;
+	/* CMD 11 check switch voltage */
+	if (cmd->opcode == SD_SWITCH_VOLTAGE)
+		cmd_regs.bits.volt_switch = 1;
+	else
+		cmd_regs.bits.volt_switch = 0;
+
+	cmd_regs.bits.card_number = host->port;
+	cmd_regs.bits.cmd_index = cmd->opcode;
+	cmd_regs.bits.start_cmd = 1;
+	cmd_regs.bits.update_clk_reg_only = 0;
+
+	himci_writel(DATA_INT_MASK, host->base + MCI_RINTSTS);
+	himci_writel(cmd_regs.cmd_arg, host->base + MCI_CMD);
+	himci_trace(4, "cmd_reg 0x%x, val 0x%x\n", MCI_CMD, cmd_regs.cmd_arg);
+
+	if (himci_wait_cmd(host) != 0) {
+		himci_trace(3, "send card cmd is failed!");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void himci_finish_request(struct himci_host *host,
+				 struct mmc_request *mrq)
+{
+	himci_trace(2, "begin");
+	himci_assert(host);
+	himci_assert(mrq);
+
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+	mmc_request_done(host->mmc, mrq);
+}
+
+#define CMD_ERRORS                          \
+    (R1_OUT_OF_RANGE |  /* Command argument out of range */ \
+     R1_ADDRESS_ERROR | /* Misaligned address */        \
+     R1_BLOCK_LEN_ERROR |   /* Transferred block length incorrect */ \
+     R1_WP_VIOLATION |  /* Tried to write to protected block */ \
+     R1_CC_ERROR |      /* Card controller error */     \
+     R1_ERROR)      /* General/unknown error */
+
+static void himci_cmd_done(struct himci_host *host, unsigned int stat)
+{
+	unsigned int i;
+	struct mmc_command *cmd = host->cmd;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+	himci_assert(cmd);
+
+	for (i = 0; i < 4; i++) {
+		if (mmc_resp_type(cmd) == MMC_RSP_R2) {
+			cmd->resp[i] = himci_readl(host->base +
+						   MCI_RESP3 - i * 0x4);
+			/* R2 must delay some time here ,when use UHI card,
+			   need check why */
+			udelay(1000);
+		} else
+			cmd->resp[i] = himci_readl(host->base +
+						   MCI_RESP0 + i * 0x4);
+	}
+
+	if (stat & RTO_INT_STATUS) {
+		cmd->error = -ETIMEDOUT;
+		himci_trace(3, "irq cmd status stat = 0x%x is timeout error!",
+			    stat);
+	} else if (stat & (RCRC_INT_STATUS | RE_INT_STATUS)) {
+		cmd->error = -EILSEQ;
+		himci_trace(3, "irq cmd status stat = 0x%x is response error!",
+			    stat);
+	}
+
+	if (((cmd->flags & MMC_RSP_R1) == MMC_RSP_R1) &&
+			((cmd->flags & MMC_CMD_MASK) != MMC_CMD_BCR)) {
+		if ((cmd->resp[0] & CMD_ERRORS) && !host->is_tuning) {
+			host->error_count++;
+			host->mrq->cmd->error = -EACCES;
+			himci_trace(5, "The status of the card is abnormal, cmd->resp[0]: %x",
+				    cmd->resp[0]);
+		}
+
+		/* bad card situation: the TF card returns the contradictory card statut.
+		 * that is, the card is in the ready state and in the programming state.
+		 */
+		if ((cmd->resp[0] & R1_READY_FOR_DATA) && (R1_CURRENT_STATE(cmd->resp[0]) ==
+					R1_STATE_PRG)) {
+			host->error_count++;
+			host->mrq->cmd->error = -EACCES;
+			himci_trace(5, "The status of the card is abnormal, cmd->resp[0]: %x",
+					cmd->resp[0]);
+		}
+	}
+
+	host->cmd = NULL;
+}
+
+static void himci_data_done(struct himci_host *host, unsigned int stat)
+{
+	struct mmc_data *data = host->data;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+	himci_assert(data);
+
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma_dir);
+
+	if (stat & (HTO_INT_STATUS | DRTO_INT_STATUS)) {
+		data->error = -ETIMEDOUT;
+		himci_trace(3, "irq data status stat = 0x%x is timeout error!",
+			    stat);
+	} else if (stat & (EBE_INT_STATUS | SBE_INT_STATUS |
+			   FRUN_INT_STATUS | DCRC_INT_STATUS)) {
+		data->error = -EILSEQ;
+		himci_trace(3, "irq data status stat = 0x%x is data error!",
+			    stat);
+	}
+
+	if (!data->error)
+		data->bytes_xfered = data->blocks * data->blksz;
+	else
+		data->bytes_xfered = 0;
+
+	host->data = NULL;
+}
+
+static int himci_wait_cmd_complete(struct himci_host *host)
+{
+	unsigned int cmd_retry_count = 0;
+	unsigned long cmd_jiffies_timeout;
+	unsigned int cmd_irq_reg = 0;
+	struct mmc_command *cmd = host->cmd;
+	unsigned long flags;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+	himci_assert(cmd);
+
+	cmd_jiffies_timeout = jiffies + request_timeout;
+	while (1) {
+		do {
+			spin_lock_irqsave(&host->lock, flags);
+			cmd_irq_reg = readl(host->base + MCI_RINTSTS);
+
+			if (cmd_irq_reg & CD_INT_STATUS) {
+				himci_writel((CD_INT_STATUS | RTO_INT_STATUS
+					      | RCRC_INT_STATUS | RE_INT_STATUS),
+					     host->base + MCI_RINTSTS);
+				spin_unlock_irqrestore(&host->lock, flags);
+				himci_cmd_done(host, cmd_irq_reg);
+				return 0;
+			} else if (cmd_irq_reg & VOLT_SWITCH_INT_STATUS) {
+				himci_writel(VOLT_SWITCH_INT_STATUS,
+					     host->base + MCI_RINTSTS);
+				spin_unlock_irqrestore(&host->lock, flags);
+				himci_cmd_done(host, cmd_irq_reg);
+				return 0;
+			}
+			spin_unlock_irqrestore(&host->lock, flags);
+			cmd_retry_count++;
+		} while (cmd_retry_count < retry_count);
+
+		cmd_retry_count = 0;
+
+		if (host->card_status == CARD_UNPLUGED) {
+			cmd->error = -ETIMEDOUT;
+			return -1;
+		}
+
+		if (!time_before(jiffies, cmd_jiffies_timeout)) {
+			unsigned int i = 0;
+			for (i = 0; i < 4; i++) {
+				cmd->resp[i] = himci_readl(host->base +
+							   MCI_RESP0 +
+							   i * 0x4);
+				pr_err("voltage switch read MCI_RESP");
+				pr_err("%d : 0x%x\n", i, cmd->resp[i]);
+			}
+			cmd->error = -ETIMEDOUT;
+			himci_trace(3, "wait cmd request complete is timeout!");
+			return -1;
+		}
+
+		schedule();
+	}
+}
+/*
+ * designware support send stop command automatically when
+ * read or wirte multi blocks
+ */
+#ifdef CONFIG_SEND_AUTO_STOP
+static int himci_wait_auto_stop_complete(struct himci_host *host)
+{
+	unsigned int cmd_retry_count = 0;
+	unsigned long cmd_jiffies_timeout;
+	unsigned int cmd_irq_reg = 0;
+	unsigned long flags;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+
+	cmd_jiffies_timeout = jiffies + request_timeout;
+	while (1) {
+		do {
+			spin_lock_irqsave(&host->lock, flags);
+			cmd_irq_reg = readl(host->base + MCI_RINTSTS);
+			if (cmd_irq_reg & ACD_INT_STATUS) {
+				himci_writel((ACD_INT_STATUS | RTO_INT_STATUS |
+					      RCRC_INT_STATUS |
+					      RE_INT_STATUS),
+					     host->base + MCI_RINTSTS);
+				spin_unlock_irqrestore(&host->lock, flags);
+				return 0;
+			}
+			spin_unlock_irqrestore(&host->lock, flags);
+			cmd_retry_count++;
+		} while (cmd_retry_count < retry_count);
+
+		cmd_retry_count = 0;
+		if (host->card_status == CARD_UNPLUGED)
+			return -1;
+		if (!time_before(jiffies, cmd_jiffies_timeout)) {
+			himci_trace(3, "wait auto stop complete is timeout!");
+			return -1;
+		}
+
+		schedule();
+	}
+}
+#endif
+
+static int himci_wait_data_complete(struct himci_host *host)
+{
+	unsigned int tmp_reg;
+	struct mmc_data *data = host->data;
+	long time = request_timeout;
+	unsigned long flags;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+	himci_assert(data);
+
+	time = wait_event_timeout(host->intr_wait,
+				  test_bit(HIMCI_PEND_DTO_B,
+					   &host->pending_events), time);
+
+	/* Mask MMC host data intr */
+	spin_lock_irqsave(&host->lock, flags);
+	tmp_reg = himci_readl(host->base + MCI_INTMASK);
+	tmp_reg &= ~DATA_INT_MASK;
+	himci_writel(tmp_reg, host->base + MCI_INTMASK);
+	host->pending_events &= ~HIMCI_PEND_DTO_M;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (((time <= 0)
+			&& (!test_bit(HIMCI_PEND_DTO_B, &host->pending_events)))
+			|| (host->card_status == CARD_UNPLUGED)) {
+		data->error = -ETIMEDOUT;
+		himci_trace(5, "wait data request complete is timeout! 0x%08X",
+			    host->irq_status);
+		himci_idma_stop(host);
+		himci_data_done(host, host->irq_status);
+		return -1;
+	}
+
+	himci_idma_stop(host);
+	himci_data_done(host, host->irq_status);
+	return 0;
+}
+
+static int himci_wait_card_complete(struct himci_host *host,
+				    struct mmc_data *data)
+{
+	unsigned int card_retry_count = 0;
+	unsigned long card_jiffies_timeout;
+	unsigned int card_status_reg = 0;
+
+	himci_trace(2, "begin");
+	himci_assert(host);
+
+	card_jiffies_timeout = jiffies + request_timeout;
+	while (1) {
+		do {
+			card_status_reg = readl(host->base + MCI_STATUS);
+			if (!(card_status_reg & DATA_BUSY)) {
+				himci_trace(2, "end");
+				return 0;
+			}
+			card_retry_count++;
+		} while (card_retry_count < retry_count);
+
+		card_retry_count = 0;
+
+		if (host->card_status == CARD_UNPLUGED) {
+			host->mrq->cmd->error = -ETIMEDOUT;
+			himci_trace(3, "card is unpluged!");
+			return -1;
+		}
+
+		if (!time_before(jiffies, card_jiffies_timeout)) {
+			host->mrq->cmd->error = -ETIMEDOUT;
+			himci_trace(3, "wait card ready complete is timeout!");
+			return -1;
+		}
+
+		schedule();
+	}
+}
+
+static void himci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	int byte_cnt = 0;
+	int fifo_count = 0;
+	int ret = 0;
+	unsigned int tmp_reg;
+	unsigned long flags;
+
+	himci_trace(2, "begin");
+	himci_assert(mmc);
+	himci_assert(mrq);
+	himci_assert(host);
+
+	host->mrq = mrq;
+	host->irq_status = 0;
+
+	if (host->card_status == CARD_UNPLUGED) {
+		mrq->cmd->error = -ENODEV;
+		goto request_end;
+	}
+
+	ret = himci_wait_card_complete(host, mrq->data);
+	if (ret) {
+		mrq->cmd->error = ret;
+		goto request_end;
+	}
+
+	/* prepare data */
+	if (mrq->data) {
+		ret = himci_setup_data(host, mrq->data);
+		if (ret) {
+			mrq->data->error = ret;
+			himci_trace(3, "data setup is error!");
+			goto request_end;
+		}
+
+		byte_cnt = mrq->data->blksz * mrq->data->blocks;
+		himci_writel(byte_cnt, host->base + MCI_BYTCNT);
+		himci_writel(mrq->data->blksz, host->base + MCI_BLKSIZ);
+
+		/* reset fifo */
+		tmp_reg = himci_readl(host->base + MCI_CTRL);
+		tmp_reg |= FIFO_RESET;
+		himci_writel(tmp_reg, host->base + MCI_CTRL);
+
+		do {
+			tmp_reg = himci_readl(host->base + MCI_CTRL);
+			fifo_count++;
+			if (fifo_count >= retry_count) {
+				pr_info("fifo reset is timeout!");
+				return;
+			}
+		} while (tmp_reg & FIFO_RESET);
+
+		/* start DMA */
+		himci_idma_start(host);
+	} else {
+		himci_writel(0, host->base + MCI_BYTCNT);
+		himci_writel(0, host->base + MCI_BLKSIZ);
+	}
+	if (mrq->sbc) {
+		ret = himci_exec_cmd(host, mrq->sbc, NULL);
+		if (ret) {
+			mrq->sbc->error = ret;
+			goto request_end;
+		}
+
+		/* wait command send complete */
+		ret = himci_wait_cmd_complete(host);
+		if (ret) {
+			mrq->sbc->error = ret;
+			goto request_end;
+		}
+	}
+	/* send command */
+	ret = himci_exec_cmd(host, mrq->cmd, mrq->data);
+	if (ret) {
+		mrq->cmd->error = ret;
+		himci_idma_stop(host);
+		himci_trace(3, "can't send card cmd! ret = %d", ret);
+		goto request_end;
+	}
+
+	/* wait command send complete */
+	himci_wait_cmd_complete(host);
+
+	/* start data transfer */
+	if (mrq->data) {
+		if (!(mrq->cmd->error)) {
+			/* Open MMC host data intr */
+			spin_lock_irqsave(&host->lock, flags);
+			tmp_reg = himci_readl(host->base + MCI_INTMASK);
+			tmp_reg |= DATA_INT_MASK;
+			himci_writel(tmp_reg, host->base + MCI_INTMASK);
+			spin_unlock_irqrestore(&host->lock, flags);
+
+			/* wait data transfer complete */
+			himci_wait_data_complete(host);
+		} else if (host->is_tuning) {
+			unsigned int stat;
+			unsigned int wait_retry_count = 0;
+
+			do {
+				stat = himci_readl(host->base + MCI_RINTSTS);
+				if (stat & (HTO_INT_STATUS | DRTO_INT_STATUS |
+						EBE_INT_STATUS | SBE_INT_STATUS |
+						FRUN_INT_STATUS | DCRC_INT_STATUS)) {
+					himci_writel(stat, host->base + MCI_RINTSTS);
+					himci_trace(3, "data status = 0x%x is error!", stat);
+					himci_trace(3, "udelay count = %d is error!", wait_retry_count);
+					break;
+				}
+				udelay(100);
+				wait_retry_count++;
+			} while (wait_retry_count < 1000);
+
+			/* CMD error in data command */
+			himci_idma_stop(host);
+		} else {
+			/* CMD error in data command */
+			himci_idma_stop(host);
+		}
+
+		if (mrq->stop && (!mrq->sbc
+				  || (mrq->sbc && (mrq->cmd->error || mrq->data->error)))) {
+#ifdef CONFIG_SEND_AUTO_STOP
+			int trans_cnt;
+
+			trans_cnt = himci_readl(host->base + MCI_TCBCNT);
+			/* send auto stop */
+			if ((trans_cnt == byte_cnt) && (!(host->is_tuning))) {
+				himci_trace(3, "byte_cnt = %d, trans_cnt = %d",
+					    byte_cnt, trans_cnt);
+				ret = himci_wait_auto_stop_complete(host);
+				if (ret) {
+					mrq->stop->error = -ETIMEDOUT;
+					goto request_end;
+				}
+			} else {
+#endif
+				/* send soft stop command */
+				himci_trace(3, "this time, send soft stop");
+				ret = himci_exec_cmd(host, host->mrq->stop,
+						     host->data);
+				if (ret) {
+					mrq->stop->error = ret;
+					goto request_end;
+				}
+				ret = himci_wait_cmd_complete(host);
+				if (ret)
+					goto request_end;
+#ifdef CONFIG_SEND_AUTO_STOP
+			}
+#endif
+		}
+	}
+
+request_end:
+	/* clear MMC host intr */
+	spin_lock_irqsave(&host->lock, flags);
+	himci_writel(ALL_SD_INT_CLR, host->base + MCI_RINTSTS);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (mrq->data && mrq->data->error && !host->is_tuning)
+		host->data_error_count++;
+	himci_finish_request(host, mrq);
+}
+
+static int himci_do_voltage_switch(struct himci_host *host,
+				   struct mmc_ios *ios)
+{
+	u32 ctrl;
+
+	/*
+	 * We first check whether the request is to set signalling voltage
+	 * to 3.3V. If so, we change the voltage to 3.3V and return quickly.
+	 */
+	ctrl = himci_readl(host->base + MCI_UHS_REG);
+	if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {
+		/* Set 1.8V Signal Enable in the MCI_UHS_REG to 1 */
+		himci_trace(3, "switch voltage 330");
+		ctrl &= ~(HI_SDXC_CTRL_VDD_180 << host->port);
+		himci_writel(ctrl, host->base + MCI_UHS_REG);
+
+		/* Wait for 5ms */
+		usleep_range(5000, 5500);
+
+		/* 3.3V regulator output should be stable within 5 ms */
+		ctrl = himci_readl(host->base + MCI_UHS_REG);
+		if (!(ctrl & (HI_SDXC_CTRL_VDD_180 << host->port))) {
+			/* config Pin drive capability */
+			himci_set_drv_cap(host, 0);
+			return 0;
+		} else {
+			himci_error(": Switching to 3.3V ");
+			himci_error("signalling voltage failed\n");
+			return -EIO;
+		}
+	} else if (!(ctrl & (HI_SDXC_CTRL_VDD_180 << host->port)) &&
+			(ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180)) {
+		/* Stop SDCLK */
+		himci_trace(3, "switch voltage 180");
+		himci_control_cclk(host, DISABLE);
+
+		/*
+		 * Enable 1.8V Signal Enable in the MCI_UHS_REG
+		 */
+		ctrl |= (HI_SDXC_CTRL_VDD_180 << host->port);
+		himci_writel(ctrl, host->base + MCI_UHS_REG);
+
+		/* Wait for 5ms */
+		usleep_range(8000, 8500);
+
+		ctrl = himci_readl(host->base + MCI_UHS_REG);
+		if (ctrl & (HI_SDXC_CTRL_VDD_180 << host->port)) {
+			/* Provide SDCLK again and wait for 1ms */
+			himci_control_cclk(host, ENABLE);
+			usleep_range(1000, 1500);
+
+			if (host->mmc->caps2 & MMC_CAP2_HS200) {
+				/* eMMC needn't to check the int status */
+				return 0;
+			}
+			/*
+			 * If CMD11 return CMD down, then the card
+			 * was successfully switched to 1.8V signaling.
+			 */
+			ctrl = himci_readl(host->base + MCI_RINTSTS);
+			if ((ctrl & VOLT_SWITCH_INT_STATUS)
+					&& (ctrl & CD_INT_STATUS)) {
+				himci_writel(VOLT_SWITCH_INT_STATUS | CD_INT_STATUS,
+					     host->base + MCI_RINTSTS);
+				/* config Pin drive capability */
+				himci_set_drv_cap(host, 1);
+				return 0;
+			}
+		}
+
+		/*
+		 * If we are here, that means the switch to 1.8V signaling
+		 * failed. We power cycle the card, and retry initialization
+		 * sequence by setting S18R to 0.
+		 */
+
+		ctrl &= ~(HI_SDXC_CTRL_VDD_180 << host->port);
+		himci_writel(ctrl, host->base + MCI_UHS_REG);
+
+		/* Wait for 5ms */
+		usleep_range(5000, 5500);
+
+		himci_ctrl_power(host, POWER_OFF, FORCE_DISABLE);
+		/* Wait for 1ms as per the spec */
+		usleep_range(1000, 1500);
+		himci_ctrl_power(host, POWER_ON, FORCE_DISABLE);
+
+		himci_control_cclk(host, DISABLE);
+
+		/* Wait for 1ms as per the spec */
+		usleep_range(1000, 1500);
+		himci_control_cclk(host, ENABLE);
+
+		himci_error(": Switching to 1.8V signalling ");
+		himci_error("voltage failed, retrying with S18R set to 0\n");
+		return -EAGAIN;
+	} else
+		/* No signal voltage switch required */
+		return 0;
+}
+
+static int himci_start_signal_voltage_switch(struct mmc_host *mmc,
+		struct mmc_ios *ios)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	int err;
+
+	err = himci_do_voltage_switch(host, ios);
+	return err;
+}
+
+static int himci_send_stop(struct mmc_host *host)
+{
+	struct mmc_command cmd = {0};
+	int err;
+
+	cmd.opcode = MMC_STOP_TRANSMISSION;
+	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+	return err;
+}
+
+static void himci_set_sap_phase(struct himci_host *host, u32 phase)
+{
+	unsigned int reg_value;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	reg_value = himci_readl(host->base + MCI_UHS_REG_EXT);
+	reg_value &= ~CLK_SMPL_PHS_MASK;
+	reg_value |= (phase << CLK_SMPL_PHS_SHIFT);
+	himci_writel(reg_value, host->base + MCI_UHS_REG_EXT);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+#if defined(CONFIG_ARCH_HI3516DV300) || defined(CONFIG_ARCH_HI3516CV500) || \
+    defined(CONFIG_ARCH_HI3559V200)  || defined(CONFIG_ARCH_HI3556V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+static void himci_edge_tuning_enable(struct himci_host *host)
+{
+	unsigned int val;
+	void __iomem *tmp_reg = 0;
+
+	if (host->devid == 0)
+		tmp_reg  = crg_ctrl + 0x14c;
+	else if (host->devid == 1)
+		tmp_reg = crg_ctrl + 0x164;
+	else if (host->devid == 2)
+		tmp_reg = crg_ctrl + 0x158;
+	else {
+		himci_trace(5, "Devid error, host->devid: %x", host->devid);
+		return;
+	}
+
+	himci_writel(0x80001, tmp_reg);
+
+	val = himci_readl(host->base + MCI_TUNING_CTRL);
+	val |= HW_TUNING_EN;
+	himci_writel(val, host->base + MCI_TUNING_CTRL);
+}
+
+static void himci_edge_tuning_disable(struct himci_host *host)
+{
+	unsigned int val;
+	void __iomem *tmp_reg = 0;
+
+	if (host->devid == 0)
+		tmp_reg  = crg_ctrl + 0x14c;
+	else if (host->devid == 1)
+		tmp_reg = crg_ctrl + 0x164;
+	else if (host->devid == 2)
+		tmp_reg = crg_ctrl + 0x158;
+	else {
+		himci_trace(5, "Devid error, host->devid: %x", host->devid);
+		return;
+	}
+	val = himci_readl(tmp_reg);
+	val |= (1 << 16);
+	himci_writel(val, tmp_reg);
+
+	val = himci_readl(host->base + MCI_TUNING_CTRL);
+	val &= ~HW_TUNING_EN;
+	himci_writel(val, host->base + MCI_TUNING_CTRL);
+}
+
+static int himci_send_status(struct mmc_host *mmc)
+{
+	int err;
+	struct mmc_command cmd = {0};
+	struct himci_host *host = NULL;
+
+	BUG_ON(!mmc);
+
+	host = mmc_priv(mmc);
+	cmd.opcode = MMC_SEND_STATUS;
+	if (!mmc_host_is_spi(mmc))
+		cmd.arg = (host->card_rca << 16);
+	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(mmc, &cmd, 1);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int himci_send_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	int err = 0;
+	struct himci_host *host;
+	/* fix a problem that When the I/O voltage is increased to 1.89 V or 1.91V
+	 * at high and low temperatures, the system is suspended during the reboot test.
+	 */
+	unsigned cmd_count = 1000;
+
+	host = mmc_priv(mmc);
+	himci_control_cclk(host, DISABLE);
+tuning_retry:
+	himci_idma_reset(host);
+	himci_writel(ALL_INT_CLR, host->base + MCI_RINTSTS);
+	himci_control_cclk(host, ENABLE);
+	if (tuning_reset_flag == 1) {
+		tuning_reset_flag = 0;
+		cmd_count--;
+		if (cmd_count == 0) {
+			printk("BUG_ON:controller reset is failed!!!\n");
+			return -EINVAL;
+		}
+		goto tuning_retry;
+	}
+
+	err = mmc_send_tuning(mmc, opcode, NULL);
+	himci_send_stop(mmc);
+	himci_send_status(mmc);
+	return err;
+}
+
+static u32 himci_get_sap_dll_taps(struct himci_host *host)
+{
+	u32 regval = 0;
+	void __iomem *reg_sap_dll_status = 0;
+
+	if (host->devid == 0)
+		reg_sap_dll_status = crg_ctrl + 0x150;
+	else if (host->devid == 1)
+		reg_sap_dll_status = crg_ctrl + 0x168;
+	else if (host->devid == 2)
+		reg_sap_dll_status = crg_ctrl + 0x15c;
+	else {
+		himci_trace(5, "Devid error, host->devid: %x", host->devid);
+		return 0;
+	}
+	regval = himci_readl(reg_sap_dll_status);
+
+	return (regval & 0xff);
+}
+
+static void himci_set_dll_element(struct himci_host *host, u32 element)
+{
+	u32 regval;
+	void __iomem *reg_sap_dll_ctrl = 0;
+
+	if (host->devid == 0)
+		reg_sap_dll_ctrl = crg_ctrl + 0x14c;
+	else if (host->devid == 1)
+		reg_sap_dll_ctrl = crg_ctrl + 0x164;
+	else if (host->devid == 2)
+		reg_sap_dll_ctrl = crg_ctrl + 0x158;
+	else {
+		himci_trace(5, "Devid error, host->devid: %x", host->devid);
+		return;
+	}
+	regval = himci_readl(reg_sap_dll_ctrl);
+	regval &= ~(0xFF << 8);
+	regval |= (element << 8);
+	himci_writel(regval, reg_sap_dll_ctrl);
+}
+
+/*********************************************
+ *********************************************
+ EdgeMode A:
+ |<---- totalphases(ele) ---->|
+        _____________
+ ______|||||||||||||||_______
+ edge_p2f       edge_f2p
+ (endp)         (startp)
+
+ EdgeMode B:
+ |<---- totalphases(ele) ---->|
+  ________           _________
+ ||||||||||_________|||||||||||
+ edge_f2p     edge_p2f
+ (startp)     (endp)
+
+ BestPhase:
+ if(endp < startp)
+ endp = endp + totalphases;
+ Best = ((startp + endp) / 2) % totalphases
+**********************************************
+**********************************************/
+static int himci_edgedll_mode_tuning(struct himci_host *host, u32 opcode,
+				     int edge_p2f, int edge_f2p)
+{
+	u32 index;
+	u32 found = 0;
+	u32 startp = -1;
+	u32 endp = -1;
+	u32 startp_init = 0;
+	u32 endp_init = 0;
+	u32 phaseoffset = 0;
+	u32 totalphases = 0;
+	u16 ele, start_ele, phase_dll_elements;
+	u8 mdly_tap_flag = 0;
+	int prev_err = 0, err = 0;
+	u32 phase_num = HIMCI_PHASE_SCALE;
+
+	himci_trace(3, "begin");
+
+	mdly_tap_flag = himci_get_sap_dll_taps(host);
+	phase_dll_elements = mdly_tap_flag / HIMCI_PHASE_SCALE;
+	totalphases = phase_dll_elements * phase_num;
+
+	startp_init = edge_f2p * phase_dll_elements;
+	endp_init = edge_p2f * phase_dll_elements;
+	startp = startp_init;
+	endp = endp_init;
+
+	found = 1;
+	start_ele = 2;
+
+	/* Note: edgedll tuning must from edge_p2f to edge_f2p */
+	if (edge_f2p >=  edge_p2f) {
+		phaseoffset = edge_p2f * phase_dll_elements;
+		for (index = edge_p2f; index < edge_f2p; index++) {
+			/* set phase shift */
+			himci_set_sap_phase(host, index);
+			for (ele = start_ele; ele <= phase_dll_elements; ele++) {
+				himci_set_dll_element(host, ele);
+				err = himci_send_tuning(host->mmc, opcode);
+
+				if (!err)
+					found = 1;
+
+				if (!prev_err && err && (endp == endp_init))
+					endp = phaseoffset + ele;
+
+				if (err)
+					startp = phaseoffset + ele;
+
+#ifdef TUNING_PROC_DEBUG
+				printk("\tphase:%01d ele:%02d st:%03d end:%03d error:%d\n", index, ele, startp,
+				       endp, err);
+#endif
+
+				prev_err = err;
+				err = 0;
+			}
+			phaseoffset += phase_dll_elements;
+		}
+	} else {
+		phaseoffset = edge_p2f * phase_dll_elements;
+		for (index = edge_p2f; index < phase_num; index++) {
+			/* set phase shift */
+			himci_set_sap_phase(host, index);
+			for (ele = start_ele; ele <= phase_dll_elements; ele++) {
+				himci_set_dll_element(host, ele);
+				err = himci_send_tuning(host->mmc, opcode);
+				if (!err)
+					found = 1;
+
+				if (!prev_err && err && (endp == endp_init))
+					endp = phaseoffset + ele;
+
+				if (err)
+					startp = phaseoffset + ele;
+
+#ifdef TUNING_PROC_DEBUG
+				printk("\tphase:%02d ele:%02d st:%03d end:%03d error:%d\n", index, ele, startp,
+				       endp, err);
+#endif
+
+				prev_err = err;
+				err = 0;
+			}
+			phaseoffset += phase_dll_elements;
+		}
+
+		phaseoffset = 0;
+		for (index = 0; index < edge_f2p; index++) {
+			/* set phase shift */
+			himci_set_sap_phase(host, index);
+			for (ele = start_ele; ele <= phase_dll_elements; ele++) {
+				himci_set_dll_element(host, ele);
+				err = himci_send_tuning(host->mmc, opcode);
+				if (!err)
+					found = 1;
+
+				if (!prev_err && err && (endp == endp_init))
+					endp = phaseoffset + ele;
+
+				if (err)
+					startp = phaseoffset + ele;
+
+#ifdef TUNING_PROC_DEBUG
+				printk("\tphase:%02d ele:%02d st:%03d end:%03d error:%d\n", index, ele, startp,
+				       endp, err);
+#endif
+
+				prev_err = err;
+				err = 0;
+			}
+			phaseoffset += phase_dll_elements;
+		}
+	}
+
+	if (found) {
+		printk("scan elemnts: startp:%d endp:%d\n", startp, endp);
+
+		if (endp <= startp)
+			endp += totalphases;
+
+		if (totalphases == 0) {
+			printk(KERN_NOTICE "totalphases is zero\n");
+			return -1;
+		}
+		phaseoffset = ((startp + endp) / 2) % totalphases;
+		index = (phaseoffset / phase_dll_elements);
+		ele = (phaseoffset % phase_dll_elements);
+		ele = ((ele > start_ele) ? ele : start_ele);
+
+		himci_set_sap_phase(host, index);
+		himci_set_dll_element(host, ele);
+
+		printk(KERN_NOTICE
+		       "Tuning SampleClock. mix set phase:[%02d/%02d] ele:[%02d/%02d] \n", index,
+		       (phase_num - 1), ele,
+		       phase_dll_elements);
+		himci_writel(ALL_INT_CLR, host->base + MCI_RINTSTS);
+		return 0;
+	}
+	printk(KERN_NOTICE "No valid phase shift! use default\n");
+	return -1;
+}
+
+static void himci_tuning_feedback(struct mmc_host *mmc)
+{
+	struct himci_host *host = mmc_priv(mmc);
+
+	himci_control_cclk(host, DISABLE);
+	msleep(1);
+	himci_sys_reset(host);
+	msleep(1);
+	himci_writel(ALL_INT_CLR, host->base + MCI_RINTSTS);
+	himci_control_cclk(host, ENABLE);
+	msleep(1);
+	host->pending_events = 0;
+}
+
+static int himci_check_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	int err;
+
+	err = himci_send_tuning(mmc, opcode);
+
+	return 	err;
+}
+
+static int himci_execute_mix_mode_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	u32 index, regval;
+	u32 found = 0, prefound = 0;
+	u32 edge_p2f, edge_f2p;
+	u32 edge_num = 0;
+	int err;
+	u32 phase_num = HIMCI_PHASE_SCALE;
+
+	himci_trace(3, "begin");
+	edge_p2f = 0;
+	edge_f2p = phase_num;
+
+	himci_edge_tuning_enable(host);
+
+	for (index = 0; index < HIMCI_PHASE_SCALE; index++) {
+		/* set phase shift */
+		himci_set_sap_phase(host, index);
+		err = himci_send_tuning(mmc, opcode);
+		if (!err) {
+			regval = himci_readl(host->base + MCI_TUNING_CTRL);
+			found = ((regval & FOUND_EDGE) == FOUND_EDGE);
+		} else {
+			found = 1;
+		}
+
+		if (found) {
+			edge_num++;
+		}
+		if (prefound && !found) {
+			edge_f2p = index;
+		} else if (!prefound && found) {
+			edge_p2f = index;
+		}
+#ifdef TUNING_PROC_DEBUG
+		printk("\tphase:%02d found:%02d p2f:%d f2p:%d error:%d\n", index, found,
+		       edge_p2f, edge_f2p, err);
+#endif
+		if ((edge_p2f != 0) && (edge_f2p != phase_num))
+			break;
+
+		prefound = found;
+		found = 0;
+	}
+
+	if ((edge_p2f == 0) && (edge_f2p == phase_num)) {
+		printk("unfound correct edge! check your config is correct!!\n");
+		return -1;
+	}
+	printk("scan edges:%d p2f:%d f2p:%d\n", edge_num, edge_p2f, edge_f2p);
+
+	if (edge_f2p < edge_p2f)
+		index = (edge_f2p + edge_p2f) / 2 % phase_num;
+	else
+		index = (edge_f2p + phase_num + edge_p2f) / 2 % phase_num;
+	printk("mix set temp-phase %d\n", index);
+	himci_set_sap_phase(host, index);
+	err = himci_send_tuning(mmc, opcode);
+
+	himci_edge_tuning_disable(host);
+
+	err = himci_edgedll_mode_tuning(host, opcode, edge_p2f, edge_f2p);
+	return err;
+}
+#if 0
+static int himci_execute_edge_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	unsigned int index, val;
+	unsigned int found = 0;
+	unsigned int prev_found = 0;
+	unsigned int prev_point = 0;
+	unsigned int start_point = NOT_FOUND, end_point = NOT_FOUND;
+	unsigned int phase = 0;
+
+	himci_trace(3, "begin");
+
+	himci_edge_tuning_enable(host);
+
+	for (index = 0; index < HIMCI_PHASE_SCALE; index++) {
+		himci_set_sap_phase(host, index);
+
+		mmc_send_tuning(mmc, opcode, NULL);
+
+		himci_send_stop(mmc);
+
+		val = himci_readl(host->base + MCI_TUNING_CTRL);
+		found = val & FOUND_EDGE;
+
+		himci_trace(3, "try phase:%02d, found:0x%x\n", index, found);
+
+		if (prev_found && !found) {
+			end_point = prev_point;
+		} else if (!prev_found && found) {
+			if (index != 0)
+				start_point = index;
+		}
+		if ((start_point != NOT_FOUND) && (end_point != NOT_FOUND))
+			goto scan_out;
+
+		prev_point = index;
+		prev_found = found;
+		found = 0;
+	}
+
+scan_out:
+	if ((start_point == NOT_FOUND) && (end_point == NOT_FOUND)) {
+		himci_trace(5, "%s: no valid phase shift! use default",
+			    mmc_hostname(mmc));
+		return 0;
+	}
+
+	if (start_point == NOT_FOUND)
+		start_point = end_point;
+
+	if (end_point == NOT_FOUND)
+		end_point = start_point;
+
+	pr_info("tuning %s: found edge on (s:%d, e:%d)",
+		mmc_hostname(mmc), start_point, end_point);
+
+	if (start_point > end_point)
+		end_point += HIMCI_PHASE_SCALE;
+
+	phase = ((start_point + end_point) / 2) % HIMCI_PHASE_SCALE;
+
+	phase += HIMCI_PHASE_SCALE / 2;
+	phase %= HIMCI_PHASE_SCALE;
+
+	himci_set_sap_phase(host, phase);
+
+	himci_edge_tuning_disable(host);
+
+	himci_writel(ALL_INT_CLR, host->base + MCI_RINTSTS);
+
+	pr_info("determing final phase %d\n", phase);
+
+	return 0;
+}
+#endif
+
+/*
+ * The procedure of tuning the phase shift of sampling clock
+ *
+ * 1.Set a phase shift of 0° on cclk_in_sample
+ * 2.Send the Tuning command to the card
+ * 3.increase the phase shift value of cclk_in_sample until the
+ *   correct sampling point is received such that the host does not
+ *   see any of the errors.
+ * 4.Mark this phase shift value as the starting point of the sampling
+ *   window.
+ * 5.increase the phase shift value of cclk_in_sample until the host
+ *   sees the errors starting to come again or the phase shift value
+ *   reaches 360°.
+ * 6.Mark the last successful phase shift value as the ending
+ *   point of the sampling window.
+ *
+ *     A window is established where the tuning block is matched.
+ * For example, for a scenario where the tuning block is received
+ * correctly for a phase shift window of 90°and 180°, then an appropriate
+ * sampling point is established as 135°. Once a sampling point is
+ * established, no errors should be visible in the tuning block.
+ *
+ */
+static int himci_execute_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	int err;
+
+	himci_trace(3, "begin");
+
+	host->is_tuning = 1;
+	err = himci_execute_mix_mode_tuning(mmc, opcode);
+	himci_tuning_feedback(mmc);
+	if (!err)
+		err = himci_check_tuning(mmc, opcode);
+	host->is_tuning = 0;
+	return err;
+}
+#else
+static int himci_execute_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct himci_host *host;
+	unsigned int index, count;
+	unsigned int err = 0;
+	unsigned int found = 0; /* identify if we have found a valid phase */
+	unsigned int start_point;
+	unsigned int end_point;
+	unsigned int prev_err = NOT_FOUND;
+	unsigned int raise_point = NOT_FOUND;
+	unsigned int fall_point = NOT_FOUND;
+	int phase, ret;
+
+	start_point = TUNING_START_PHASE;
+	end_point = TUNING_END_PHASE;
+
+	host = mmc_priv(mmc);
+
+	himci_writel(0x1, host->base + MCI_CARDTHRCTL);
+
+	himci_trace(3, "start sd3.0 phase tuning...");
+	host->is_tuning = 1;
+	for (index = start_point; index <= end_point; index++) {
+		/* set sample clk phase shift */
+		himci_set_sap_phase(host, index);
+
+		count = 0;
+		do {
+			ret = mmc_send_tuning(mmc, opcode, NULL);
+			himci_send_stop(mmc); /* send soft_stop tail */
+
+			if (ret) {
+				himci_trace(3, "send tuning CMD%u fail! phase:%d err:%d\n",
+					    opcode, index, ret);
+				err = 1;
+				break;
+			}
+			count++;
+		} while (count < 1);
+
+		if (!err)
+			found = 1; /* found a valid phase */
+
+		if (index > start_point) {
+			if (err && !prev_err)
+				fall_point = index - 1;
+
+			if (!err && prev_err)
+				raise_point = index;
+		}
+
+		if ((raise_point != NOT_FOUND) && (fall_point != NOT_FOUND))
+			goto tuning_out;
+
+		prev_err = err;
+		err = 0;
+	}
+
+tuning_out:
+	host->is_tuning = 0;
+	if (!found) {
+		himci_trace(5, "%s: no valid phase shift! use default",
+			    mmc_hostname(mmc));
+		himci_writel(DEFAULT_PHASE, host->base + MCI_UHS_REG_EXT);
+	} else {
+		himci_trace(3, "Tuning finished!!");
+
+		if (NOT_FOUND == raise_point)
+			raise_point = start_point;
+		if (NOT_FOUND == fall_point)
+			fall_point = end_point;
+
+		if (fall_point < raise_point) {
+			phase = (raise_point + fall_point) / 2;
+			phase = phase - (HIMCI_PHASE_SCALE / 2);
+			phase = (phase < 0) ? (HIMCI_PHASE_SCALE + phase) : phase;
+		} else
+			phase = (raise_point + fall_point) / 2;
+
+		himci_set_sap_phase(host, phase);
+
+		pr_info("tuning %s: valid phase shift [%d, %d] Final Phase %d\n",
+			mmc_hostname(mmc), raise_point, fall_point, phase);
+	}
+
+	himci_writel(RW_THRESHOLD_SIZE, host->base + MCI_CARDTHRCTL);
+
+	return 0;
+}
+#endif
+
+static void himci_set_bus_width(struct himci_host *host, struct mmc_ios *ios)
+{
+	unsigned int tmp_reg;
+
+	/* set bus_width */
+	himci_trace(3, "ios->bus_width = %d ", ios->bus_width);
+	tmp_reg = himci_readl(host->base + MCI_CTYPE);
+	tmp_reg &= ~((CARD_WIDTH_0 | CARD_WIDTH_1) << host->port);
+
+	if (ios->bus_width == MMC_BUS_WIDTH_8) {
+		tmp_reg |= (CARD_WIDTH_0 << host->port);
+		himci_writel(tmp_reg, host->base + MCI_CTYPE);
+	} else if (ios->bus_width == MMC_BUS_WIDTH_4) {
+		tmp_reg |= (CARD_WIDTH_1 << host->port);
+		himci_writel(tmp_reg, host->base + MCI_CTYPE);
+	} else {
+		himci_writel(tmp_reg, host->base + MCI_CTYPE);
+	}
+}
+
+static void himci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	u32 ctrl;
+	int ret = 0;
+
+	himci_trace(2, "begin");
+	himci_assert(mmc);
+	himci_assert(ios);
+	himci_assert(host);
+
+	himci_trace(3, "ios->power_mode = %d ", ios->power_mode);
+	if (!ios->clock) {
+		ret = himci_control_cclk(host, DISABLE);
+		if (ret)
+			return;
+	}
+
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+		himci_ctrl_power(host, POWER_OFF, FORCE_DISABLE);
+		break;
+	case MMC_POWER_UP:
+	case MMC_POWER_ON:
+		himci_ctrl_power(host, POWER_ON, FORCE_DISABLE);
+		break;
+	default:
+		break;
+	}
+	himci_trace(3, "ios->clock = %d ", ios->clock);
+	if (ios->clock) {
+		ret = himci_control_cclk(host, DISABLE);
+		if (ret)
+			return;
+		himci_set_cclk(host, ios->clock);
+		ret = himci_control_cclk(host, ENABLE);
+		if (ret)
+			return;
+
+		himci_set_default_phase(host);
+
+		/* speed mode check, if it is DDR50 set DDR mode */
+		if (ios->timing == MMC_TIMING_UHS_DDR50) {
+			ctrl = himci_readl(host->base + MCI_UHS_REG);
+			if (!((HI_SDXC_CTRL_DDR_REG << host->port) & ctrl)) {
+				ctrl |= (HI_SDXC_CTRL_DDR_REG << host->port);
+				himci_writel(ctrl, host->base + MCI_UHS_REG);
+			}
+		}
+	} else {
+		ret = himci_control_cclk(host, DISABLE);
+		if (ret)
+			return;
+		if (ios->timing != MMC_TIMING_UHS_DDR50) {
+			ctrl = himci_readl(host->base + MCI_UHS_REG);
+			if ((HI_SDXC_CTRL_DDR_REG << host->port) & ctrl) {
+				ctrl &= ~(HI_SDXC_CTRL_DDR_REG << host->port);
+				himci_writel(ctrl, host->base + MCI_UHS_REG);
+			}
+		}
+	}
+
+	himci_set_drv_cap(host, 0);
+
+	himci_set_bus_width(host, ios);
+}
+
+static void himci_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	unsigned int reg_value;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	reg_value = himci_readl(host->base + MCI_INTMASK);
+	if (enable)
+		reg_value |= SDIO_INT_MASK;
+	else
+		reg_value &= ~SDIO_INT_MASK;
+	himci_writel(reg_value, host->base + MCI_INTMASK);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static int himci_get_card_detect(struct mmc_host *mmc)
+{
+	unsigned ret;
+	struct himci_host *host = mmc_priv(mmc);
+
+	himci_trace(2, "begin");
+	ret = himci_sys_card_detect(host);
+
+	if (ret)
+		return 0;
+	else
+		return 1;
+}
+
+static int himci_get_ro(struct mmc_host *mmc)
+{
+	unsigned ret;
+	struct himci_host *host = mmc_priv(mmc);
+
+	himci_trace(2, "begin");
+	himci_assert(mmc);
+
+	ret = himci_ctrl_card_readonly(host);
+
+	return ret;
+}
+
+static void himci_hw_reset(struct mmc_host *mmc)
+{
+	unsigned int reg_value;
+	struct himci_host *host = mmc_priv(mmc);
+	unsigned int port = host->port;
+
+	reg_value = himci_readl(host->base + MCI_RESET_N);
+	reg_value &= ~(MMC_RST_N << port);
+	himci_writel(reg_value, host->base + MCI_RESET_N);
+
+	/* For eMMC, minimum is 1us but give it 10us for good measure */
+	udelay(10);
+	reg_value = himci_readl(host->base + MCI_RESET_N);
+	reg_value |= (MMC_RST_N << port);
+	himci_writel(reg_value, host->base + MCI_RESET_N);
+
+	/* For eMMC, minimum is 200us but give it 300us for good measure */
+	usleep_range(300, 1000);
+}
+
+static int himci_card_busy(struct mmc_host *mmc)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	u32 regval;
+
+	himci_trace(2, "begin");
+
+	regval = himci_readl(host->base + MCI_STATUS);
+	regval &= DATA_BUSY;
+
+	return regval;
+}
+
+static int himci_card_info_save(struct mmc_host *mmc)
+{
+	struct mmc_card *card = mmc->card;
+	struct himci_host *host = mmc_priv(mmc);
+	struct card_info *c_info = &host->c_info;
+
+	if (!card) {
+		memset(c_info, 0, sizeof(struct card_info));
+		c_info->card_connect = CARD_DISCONNECT;
+		goto out;
+	}
+
+	c_info->card_type = card->type;
+	c_info->card_state = card->state;
+
+	c_info->timing = mmc->ios.timing;
+	c_info->card_support_clock = mmc->ios.clock;
+
+	c_info->sd_bus_speed = card->sd_bus_speed;
+
+	memcpy(c_info->ssr, card->raw_ssr, ARRAY_SIZE(c_info->ssr));
+
+	c_info->card_connect = CARD_CONNECT;
+out:
+	return 0;
+}
+
+static const struct mmc_host_ops himci_ops = {
+	.request = himci_request,
+	.set_ios = himci_set_ios,
+	.get_ro = himci_get_ro,
+	.card_busy = himci_card_busy,
+	.start_signal_voltage_switch = himci_start_signal_voltage_switch,
+	.execute_tuning	= himci_execute_tuning,
+	.enable_sdio_irq = himci_enable_sdio_irq,
+	.hw_reset = himci_hw_reset,
+	.get_cd = himci_get_card_detect,
+	.card_info_save = himci_card_info_save,
+};
+
+static irqreturn_t hisd_irq(int irq, void *dev_id)
+{
+	struct himci_host *host = dev_id;
+	u32 state = 0;
+	int handle = 0;
+	u32 mstate = 0;
+
+	spin_lock(&host->lock);
+	state = himci_readl(host->base + MCI_RINTSTS);
+	spin_unlock(&host->lock);
+
+	/* bugfix: when send soft stop to SD Card, Host will report
+	   sdio interrupt, This situation needs to be avoided */
+	if (host->mmc->caps & MMC_CAP_SDIO_IRQ) {
+		if ((host->mmc->card != NULL)
+				&& (host->mmc->card->type == MMC_TYPE_SDIO)) {
+			mstate = himci_readl(host->base + MCI_INTMASK);
+			if ((state & SDIO_INT_STATUS) &&
+					(mstate & SDIO_INT_MASK)) {
+				spin_lock(&host->lock);
+				himci_writel(SDIO_INT_STATUS,
+					     host->base + MCI_RINTSTS);
+				spin_unlock(&host->lock);
+				handle = 1;
+				mmc_signal_sdio_irq(host->mmc);
+			}
+		}
+	}
+
+	if (state & DATA_INT_MASK) {
+		handle = 1;
+		host->pending_events |= HIMCI_PEND_DTO_M;
+
+		spin_lock(&host->lock);
+		host->irq_status = himci_readl(host->base + MCI_RINTSTS);
+		himci_writel(DATA_INT_MASK, host->base + MCI_RINTSTS);
+		spin_unlock(&host->lock);
+
+		wake_up(&host->intr_wait);
+	}
+
+	if (handle)
+		return IRQ_HANDLED;
+
+	return IRQ_NONE;
+}
+
+static int himci_of_parse(struct device_node *np, struct mmc_host *mmc)
+{
+	struct himci_host *host = mmc_priv(mmc);
+	int ret = mmc_of_parse(mmc);
+	int len;
+
+	if (ret)
+		return ret;
+
+	if (of_property_read_u32(np, "min-frequency", &mmc->f_min))
+		mmc->f_min = MMC_CCLK_MIN;
+
+	if (of_property_read_u32(np, "devid", &host->devid))
+		return -EINVAL;
+
+	if (of_find_property(np, "cap-mmc-hw-reset", &len))
+		mmc->caps |= MMC_CAP_HW_RESET;
+
+	if (host->devid == 0 || host->devid == 1)
+		mmc->caps |= MMC_CAP_CMD23;
+	return 0;
+}
+
+static void himci_sdio_setup(void)
+{
+#if defined(CONFIG_ARCH_HI3516DV300)
+	void __iomem *pwr_ctrl;
+	/* enable GPIO pin multiplexing in PMC module */
+	unsigned int val;
+
+	pwr_ctrl = ioremap(PWR_CTRL0_REG, 0x4);
+	if (!pwr_ctrl) {
+		printk("%s ioremap fail\n", __func__);
+		return;
+	}
+	val = readl(pwr_ctrl);
+	val = val | GPIO_AT_PMC_ENABLE_BIT;
+	writel(val, pwr_ctrl);
+	msleep(REG_SLEEP_TIME_MS);
+	iounmap(pwr_ctrl);
+#endif
+}
+
+static int himci_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = NULL;
+	struct himci_host *host = NULL;
+	struct resource *host_ioaddr_res = NULL;
+	int ret = 0, irq;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int regval;
+	static bool sdio_setup = false;
+
+	himci_trace(2, "begin");
+	pr_info("mmc host probe\n");
+	himci_assert(pdev);
+
+	if (sdio_setup == false) {
+		pr_info("sdio_setup entry!\n");
+		himci_sdio_setup();
+		sdio_setup = true;
+	}
+
+	mmc = mmc_alloc_host(sizeof(struct himci_host), &pdev->dev);
+	if (!mmc) {
+		himci_error("no mem for hi mci host controller!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	platform_set_drvdata(pdev, mmc);
+
+	mmc->ops = &himci_ops;
+
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+
+	crg_ctrl = ioremap(0x12010000, 0x1000);
+	if (!crg_ctrl) {
+		printk("%s ioremap fail\n", __func__);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	misc_ctrl_1 = ioremap(0x12030004, 0x4);
+	if (!misc_ctrl_1) {
+		printk("%s ioremap fail\n", __func__);
+		ret = -ENOMEM;
+		goto out;
+	}
+	regval = readl(misc_ctrl_1);
+	/* clear sdio0_pswitch_ctrl_sel bit */
+	regval &= ~(0x1 << 2);
+	writel(regval, misc_ctrl_1);
+	iounmap(misc_ctrl_1);
+#endif
+
+	host_ioaddr_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (NULL == host_ioaddr_res) {
+		himci_error("no ioaddr rescources config!\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (himci_of_parse(np, mmc)) {
+		himci_error("failed to parse mmc dts!\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* reload by this controller */
+#ifndef CONFIG_HISI_MC
+	mmc->max_blk_count = 2048;
+#else
+	mmc->max_blk_count = 4096;
+#endif
+	mmc->max_segs = 1024;
+	mmc->max_seg_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	host = mmc_priv(mmc);
+	pdev->id = host->devid;
+    if (host->devid >= HIMCI_SLOT_NUM) {
+        himci_error("devid is invalid!\n");
+		ret = -EINVAL;
+		goto out;
+    }
+   mci_host[host->devid] = host;
+	host->pdev = pdev;
+	host->mmc = mmc;
+#ifdef CONFIG_ARCH_HI3518EV20X
+	if (host->mmc->caps & MMC_CAP_HW_RESET)
+		host->port = 1;
+	else
+		host->port = 0;
+#else
+	host->port = 0;
+#endif
+	host->dma_vaddr = dma_alloc_coherent(&pdev->dev, CMD_DES_PAGE_SIZE,
+					     &host->dma_paddr, GFP_KERNEL);
+	if (!host->dma_vaddr) {
+		himci_error("no mem for himci dma!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	host->base = devm_ioremap_resource(&pdev->dev, host_ioaddr_res);
+	if (IS_ERR_OR_NULL(host->base)) {
+		himci_error("no mem for himci base!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	spin_lock_init(&host->lock);
+
+	host->crg_rst = devm_reset_control_get(&pdev->dev, "mmc_reset");
+	if (IS_ERR_OR_NULL(host->crg_rst)) {
+		himci_error("get rst fail.\n");
+		ret = PTR_ERR(host->crg_rst);
+		goto out;
+	}
+
+	reset_control_assert(host->crg_rst);
+	usleep_range(50, 60);
+	reset_control_deassert(host->crg_rst);
+
+	host->clk = devm_clk_get(&pdev->dev, "mmc_clk");
+	if (IS_ERR_OR_NULL(host->clk)) {
+		himci_error("get clock fail.\n");
+		ret = PTR_ERR(host->clk);
+		goto out;
+	}
+
+	clk_prepare_enable(host->clk);
+
+	host->power_status = POWER_OFF;
+
+	/* enable card */
+	himci_init_host(host);
+	host->card_status = himci_sys_card_detect(host);
+
+	timer_setup(&host->timer, himci_detect_card, 0);
+	host->timer.expires = jiffies + detect_time;
+	add_timer(&host->timer);
+
+	init_waitqueue_head(&host->intr_wait);
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		pr_err("no IRQ defined!\n");
+		goto out;
+	}
+
+	host->irq = irq;
+	ret = request_irq(irq, hisd_irq, 0, DRIVER_NAME, host);
+	if (ret) {
+		pr_err("request_irq error!\n");
+		goto out;
+	}
+
+	mmc_add_host(mmc);
+	return 0;
+out:
+	if (host) {
+		del_timer(&host->timer);
+
+		if (host->base)
+			devm_iounmap(&pdev->dev, host->base);
+
+		if (host->dma_vaddr)
+			dma_free_coherent(&pdev->dev, CMD_DES_PAGE_SIZE,
+					  host->dma_vaddr, host->dma_paddr);
+	}
+	if (mmc)
+		mmc_free_host(mmc);
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+	if (crg_ctrl)
+		iounmap(crg_ctrl);
+#endif
+	return ret;
+}
+
+static int __exit himci_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+
+	himci_trace(2, "begin");
+	himci_assert(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (mmc) {
+		struct himci_host *host = mmc_priv(mmc);
+
+		mmc_remove_host(mmc);
+		free_irq(host->irq, host);
+		del_timer_sync(&host->timer);
+		himci_ctrl_power(host, POWER_OFF, FORCE_DISABLE);
+		himci_control_cclk(host, DISABLE);
+		devm_iounmap(&pdev->dev, host->base);
+		dma_free_coherent(&pdev->dev, CMD_DES_PAGE_SIZE, host->dma_vaddr,
+				  host->dma_paddr);
+		mmc_free_host(mmc);
+	}
+	return 0;
+}
+
+static void himci_shutdown(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+
+	himci_trace(3, "shutdown");
+	if (mmc) {
+		unsigned int val;
+		struct himci_host *host = mmc_priv(mmc);
+
+		/* bugfix: host reset can trigger error intr */
+		himci_writel(0, host->base + MCI_IDINTEN);
+		himci_writel(0, host->base + MCI_INTMASK);
+
+		val = himci_readl(host->base + MCI_CTRL);
+		val |= CTRL_RESET | FIFO_RESET | DMA_RESET;
+		himci_writel(val, host->base + MCI_CTRL);
+	}
+}
+
+#ifdef CONFIG_PM
+static int himci_pltm_suspend(struct platform_device *pdev,
+			      pm_message_t state)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct himci_host *host = NULL;
+	int ret = 0;
+
+	if (mmc) {
+		host = mmc_priv(mmc);
+		del_timer_sync(&host->timer);
+
+		if (__clk_is_enabled(host->clk))
+			clk_disable_unprepare(host->clk);
+	}
+
+	return ret;
+}
+
+static int himci_pltm_resume(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct himci_host *host = NULL;
+	int ret = 0;
+
+	if (mmc) {
+		host = mmc_priv(mmc);
+
+		if (!__clk_is_enabled(host->clk))
+			clk_prepare_enable(host->clk);
+
+		himci_sys_ctrl_init(host);
+		himci_init_host(host);
+
+		add_timer(&host->timer);
+	}
+
+	return ret;
+}
+#else
+#define himci_pltm_suspend    NULL
+#define himci_pltm_resume     NULL
+#endif
+
+void hisi_sdio_rescan(int slot)
+{
+	struct mmc_host *mmc = NULL;
+	struct himci_host *host;
+
+	host = mci_host[slot];
+	if (!host || !host->mmc) {
+		himci_trace(5, "mmc%d: invalid slot!\n", slot);
+		return;
+	}
+
+	mmc = host->mmc;
+	del_timer_sync(&host->timer);
+
+	mmc_remove_host(mmc);
+
+	mmc_add_host(mmc);
+
+	add_timer(&host->timer);
+}
+EXPORT_SYMBOL(hisi_sdio_rescan);
+
+struct mmc_host *himci_get_mmc_host(int slot)
+{
+	struct himci_host *host = NULL;
+
+	if (slot >= HIMCI_SLOT_NUM || slot < 0) {
+		return NULL;
+	}
+
+	host = mci_host[slot];
+	if (host == NULL) {
+		return NULL;
+	}
+	return host->mmc;
+}
+EXPORT_SYMBOL(himci_get_mmc_host);
+
+static const struct of_device_id
+	himci_match[] __maybe_unused = {
+	{.compatible = "hisilicon,hi3516a-himci"},
+	{.compatible = "hisilicon,hi3518ev20x-himci"},
+	{.compatible = "hisilicon,hi3516cv500-himci"},
+	{.compatible = "hisilicon,hi3516dv300-himci"},
+	{.compatible = "hisilicon,hi3556v200-himci"},
+	{.compatible = "hisilicon,hi3559v200-himci"},
+	{},
+};
+
+static struct platform_driver himci_driver = {
+	.probe = himci_probe,
+	.remove = himci_remove,
+	.shutdown = himci_shutdown,
+	.suspend = himci_pltm_suspend,
+	.resume = himci_pltm_resume,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(himci_match),
+	},
+};
+
+static int __init himci_init(void)
+{
+	int ret;
+
+	himci_trace(2, "begin");
+
+	/*
+	 * We should register SDIO1 first to make sure that
+	 * the eMMC device,which connected to SDIO1 is mmcblk0.
+	 */
+
+	ret = platform_driver_register(&himci_driver);
+	if (ret) {
+		platform_driver_unregister(&himci_driver);
+		himci_error("Himci driver register failed!");
+		return ret;
+	}
+
+	/* device proc entry */
+	ret = mci_proc_init();
+	if (ret)
+		himci_error("device proc init is failed!");
+
+	return ret;
+}
+
+static void __exit himci_exit(void)
+{
+	himci_trace(2, "begin");
+
+	mci_proc_shutdown();
+
+	platform_driver_unregister(&himci_driver);
+}
+
+module_init(himci_init);
+module_exit(himci_exit);
+
+#ifdef MODULE
+MODULE_AUTHOR("Hisilicon Drive Group");
+MODULE_DESCRIPTION("MMC/SD driver for the Hisilicon MMC/SD Host Controller");
+MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/mmc/host/himci/himci.h b/drivers/mmc/host/himci/himci.h
new file mode 100644
index 000000000..d882e847f
--- /dev/null
+++ b/drivers/mmc/host/himci/himci.h
@@ -0,0 +1,156 @@
+#ifndef _HI_MCI_H_
+#define _HI_MCI_H_
+
+#include <linux/mmc/mmc.h>
+
+extern int trace_level;
+#define HIMCI_TRACE_LEVEL 5
+/*
+   0 - all message
+   1 - dump all register read/write
+   2 - flow trace
+   3 - timeout err and protocol err
+   */
+
+#define HIMCI_TRACE_FMT KERN_INFO
+
+#define NOT_FOUND -1
+#define POWER_ON 1
+#define POWER_OFF 0
+#define FORCE_ENABLE 1
+#define FORCE_DISABLE 0
+
+#define CARD_UNPLUGED 1
+#define CARD_PLUGED 0
+
+#define ENABLE 1
+#define DISABLE 0
+
+#define HI_MCI_DETECT_TIMEOUT (HZ / 2)
+
+#define HI_MCI_REQUEST_TIMEOUT (30 * HZ)
+
+#define MAX_RETRY_COUNT 100
+
+#define MMC_CCLK_MIN  100000
+
+/* Base address of SD card register */
+#define HI_MCI_INTR (49 + 32)
+
+#define himci_trace(level, msg...) do { \
+	if ((level) >= trace_level) { \
+		printk(HIMCI_TRACE_FMT "%s:%d: ", __func__, __LINE__); \
+		printk(msg); \
+		printk("\n"); \
+	} \
+} while (0)
+
+#define himci_assert(cond) do { \
+	if (!(cond)) { \
+		printk(KERN_ERR "Assert:himci:%s:%d\n", \
+				__func__, \
+				__LINE__); \
+		BUG(); \
+	} \
+} while (0)
+
+#define himci_error(s...) do { \
+	printk(KERN_ERR "himci:%s:%d: ", __func__, __LINE__); \
+	printk(s); \
+	printk("\n"); \
+} while (0)
+
+#define himci_readl(addr) ({unsigned int reg = readl(IOMEM((uintptr_t)addr)); \
+	himci_trace(1, "readl(0x%04X) = 0x%08X", (unsigned int)(uintptr_t)addr, reg); \
+	reg; })
+
+#define himci_writel(v, addr) do { writel(v, IOMEM((uintptr_t)addr)); \
+	himci_trace(1, "writel(0x%04X) = 0x%08X", (unsigned int)(uintptr_t)addr, \
+			(unsigned int)(uintptr_t)(v)); \
+} while (0)
+
+struct himci_des {
+	unsigned long idmac_des_ctrl;
+	unsigned long idmac_des_buf_size;
+	unsigned long idmac_des_buf_addr;
+	unsigned long idmac_des_next_addr;
+};
+
+struct card_info {
+	unsigned int     card_type;
+	unsigned char    timing;
+	unsigned char    card_connect;
+#define CARD_CONNECT    1
+#define CARD_DISCONNECT 0
+	unsigned int     card_support_clock; /* clock rate */
+	unsigned int     card_state;      /* (our) card state */
+	unsigned int     sd_bus_speed;
+	unsigned int     ssr[16];
+};
+
+struct himci_host {
+	struct mmc_host *mmc;
+	struct platform_device *pdev;
+	spinlock_t lock;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	void __iomem *base;
+	struct scatterlist *dma_sg;
+	unsigned int dma_sg_num;
+	unsigned int dma_dir;
+	dma_addr_t dma_paddr;
+	unsigned int *dma_vaddr;
+	struct timer_list timer;
+	unsigned int irq;
+	unsigned int irq_status;
+	unsigned int is_tuning;
+	wait_queue_head_t intr_wait;
+#define HIMCI_PEND_DTO_B (0)
+#define HIMCI_PEND_DTO_M (1 << HIMCI_PEND_DTO_B)
+	unsigned long pending_events;
+	unsigned int power_status;
+	unsigned int card_rca;
+	unsigned int card_status;
+	unsigned int devid;
+	unsigned int hclk;
+	unsigned int cclk;
+	struct clk *clk;
+	struct reset_control *crg_rst;
+	unsigned int port;
+	unsigned int error_count;
+	unsigned int data_error_count;
+	struct card_info c_info;
+};
+
+union cmd_arg_u {
+	unsigned int cmd_arg;
+	struct cmd_bits_arg {
+		unsigned int cmd_index : 6;
+		unsigned int response_expect : 1;
+		unsigned int response_length : 1;
+		unsigned int check_response_crc : 1;
+		unsigned int data_transfer_expected : 1;
+		unsigned int read_write : 1;
+		unsigned int transfer_mode : 1;
+		unsigned int send_auto_stop : 1;
+		unsigned int wait_prvdata_complete : 1;
+		unsigned int stop_abort_cmd : 1;
+		unsigned int send_initialization : 1;
+		unsigned int card_number : 5;
+		unsigned int update_clk_reg_only : 1; /* bit 21 */
+		unsigned int read_ceata_device : 1;
+		unsigned int ccs_expected : 1;
+		unsigned int enable_boot : 1;
+		unsigned int expect_boot_ack : 1;
+		unsigned int disable_boot : 1;
+		unsigned int boot_mode : 1;
+		unsigned int volt_switch : 1;
+		unsigned int use_hold_reg : 1;
+		unsigned int reserved : 1;
+		unsigned int start_cmd : 1; /* HSB */
+	} bits;
+};
+
+struct mmc_host *get_mmchost(int hostid);
+#endif
diff --git a/drivers/mmc/host/himci/himci_hi3516dv300.c b/drivers/mmc/host/himci/himci_hi3516dv300.c
new file mode 100644
index 000000000..bb312d601
--- /dev/null
+++ b/drivers/mmc/host/himci/himci_hi3516dv300.c
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#define MMC_CRG_MIN 25000000
+
+#define TUNING_START_PHASE 0
+#define TUNING_END_PHASE 7
+#define HIMCI_PHASE_SCALE 8
+#define DRV_PHASE_DFLT (0x4<<23)
+#define SMPL_PHASE_DFLT (0x0<<16)
+
+/* eMMC pad ctrl reg */
+#define REG_CTRL_EMMC_START (0x10ff0000 + 0x0)
+/* sdio0 pad ctrl reg */
+#define REG_CTRL_SDIO0_START (0x10ff0000 + 0x24)
+/* sdio1 pad ctrl reg */
+#define REG_CTRL_SDIO1_START (0x112f0000 + 0x8)
+
+static unsigned int pad_ctrl_start[] = {REG_CTRL_EMMC_START, REG_CTRL_SDIO0_START, REG_CTRL_SDIO1_START};
+
+/*  clk   cmd   data0  data1  data2  data3 */
+static unsigned int emmc_hs200_drv[] = {0x2b0, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0};
+static unsigned int emmc_hs_drv[] = {0x6b0, 0x5e0, 0x5e0, 0x5e0, 0x5e0, 0x5e0};
+static unsigned int emmc_ds_drv[] = {0x6b0, 0x5f0, 0x5f0, 0x5f0, 0x5f0, 0x5f0};
+static unsigned int emmc_ds_400k_drv[] = {0x6c0, 0x5f0, 0x5f0, 0x5f0, 0x5f0, 0x5f0};
+
+static unsigned int sdio0_sdr104_drv[] = {0x290, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0};
+static unsigned int sdio0_sdr50_drv[] = {0x290, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0};
+static unsigned int sdio0_sdr25_drv[] = {0x6b0, 0x5d0, 0x5d0, 0x5d0, 0x5d0, 0x5d0};
+static unsigned int sdio0_sdr12_drv[] = {0x6b0, 0x5e0, 0x5e0, 0x5e0, 0x5e0, 0x5e0};
+static unsigned int sdio0_hs_drv[] = {0x6d0, 0x5f0, 0x5f0, 0x5f0, 0x5f0, 0x5f0};
+static unsigned int sdio0_ds_drv[] = {0x6b0, 0x5e0, 0x5e0, 0x5e0, 0x5e0, 0x5e0};
+
+static unsigned int sdio1_sdr104_drv[] = {0x290, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0};
+static unsigned int sdio1_sdr50_drv[] = {0x290, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x1c0};
+static unsigned int sdio1_sdr25_drv[] = {0x6b0, 0x5d0, 0x5d0, 0x5d0, 0x5d0, 0x5d0};
+static unsigned int sdio1_sdr12_drv[] = {0x6b0, 0x5e0, 0x5e0, 0x5e0, 0x5e0, 0x5e0};
+static unsigned int sdio1_hs_drv[] = {0x6d0, 0x5f0, 0x5f0, 0x5f0, 0x5f0, 0x5f0};
+static unsigned int sdio1_ds_drv[] = {0x6b0, 0x5e0, 0x5e0, 0x5e0, 0x5e0, 0x5e0};
+
+static void himci_set_drv_cap(struct himci_host *host, unsigned int vdd_180)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct mmc_ios *ios = &(mmc->ios);
+	unsigned int devid = host->devid;
+	unsigned char timing = ios->timing;
+	unsigned int i, j, start;
+	unsigned int *pin_drv_cap = NULL;
+
+	if (devid == 0) {
+		if (timing == MMC_TIMING_MMC_HS200)
+			pin_drv_cap = emmc_hs200_drv;
+		else if (timing == MMC_TIMING_MMC_HS)
+			pin_drv_cap = emmc_hs_drv;
+		else {
+			if (ios->clock == 400000) /* 400K */
+				pin_drv_cap = emmc_ds_400k_drv;
+			else
+				pin_drv_cap = emmc_ds_drv;
+		}
+	} else if (devid == 1) {
+		if (timing == MMC_TIMING_UHS_SDR104)
+			pin_drv_cap = sdio0_sdr104_drv;
+		else if (timing == MMC_TIMING_UHS_SDR50)
+			pin_drv_cap = sdio0_sdr50_drv;
+		else if (timing == MMC_TIMING_UHS_SDR25)
+			pin_drv_cap = sdio0_sdr25_drv;
+		else if (timing == MMC_TIMING_UHS_SDR12)
+			pin_drv_cap = sdio0_sdr12_drv;
+		else if (timing == MMC_TIMING_SD_HS)
+			pin_drv_cap = sdio0_hs_drv;
+		else
+			pin_drv_cap = sdio0_ds_drv;
+	} else {
+		if (timing == MMC_TIMING_UHS_SDR104)
+			pin_drv_cap = sdio1_sdr104_drv;
+		else if (timing == MMC_TIMING_UHS_SDR50)
+			pin_drv_cap = sdio1_sdr50_drv;
+		else if (timing == MMC_TIMING_UHS_SDR25)
+			pin_drv_cap = sdio1_sdr25_drv;
+		else if (timing == MMC_TIMING_UHS_SDR12)
+			pin_drv_cap = sdio1_sdr12_drv;
+		else if (timing == MMC_TIMING_SD_HS)
+			pin_drv_cap = sdio1_hs_drv;
+		else
+			pin_drv_cap = sdio1_ds_drv;
+	}
+
+	start = (unsigned int)(long)ioremap((resource_size_t)pad_ctrl_start[devid],
+					    (size_t)0x1000);
+	for (i = start, j = 0; j < 6; i = i + 4, j++) {
+		unsigned int reg = himci_readl(i);
+		/*
+		 * [10]:SR
+		 * [9]:internel pull down
+		 * [8]:internel pull up
+		 * [7:4]:
+		 * */
+		reg = reg & (~(0x7f0));
+		reg |= pin_drv_cap[j];
+		himci_writel(reg, i);
+	}
+	iounmap((void *)(long)start);
+}
+
+#define DRV_PHASE_180   (0x4<<23)
+#define DRV_PHASE_135   (0x3<<23)
+#define DRV_PHASE_90    (0x2<<23)
+
+#define SMP_PHASE_45    (0x1<<16)
+#define SMP_PHASE_0     (0x0<<16)
+
+static void himci_set_default_phase(struct himci_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct mmc_ios *ios = &(mmc->ios);
+	unsigned int devid = host->devid;
+	unsigned char timing = ios->timing;
+	unsigned int phase_cfg, reg_value;
+	if (devid == 0) {
+		if (timing == MMC_TIMING_MMC_HS200)
+			phase_cfg = DRV_PHASE_135 | SMP_PHASE_0;
+		else if (timing == MMC_TIMING_MMC_HS)
+			phase_cfg = DRV_PHASE_180 | SMP_PHASE_45;
+		else {
+			phase_cfg = DRV_PHASE_180 | SMP_PHASE_0;
+		}
+	} else {
+		if (timing == MMC_TIMING_UHS_SDR104)
+			phase_cfg = DRV_PHASE_135 | SMP_PHASE_0;
+		else if (timing == MMC_TIMING_UHS_SDR50)
+			phase_cfg = DRV_PHASE_90 | SMP_PHASE_0;
+		else if (timing == MMC_TIMING_UHS_SDR25)
+			phase_cfg = DRV_PHASE_180 | SMP_PHASE_45;
+		else if (timing == MMC_TIMING_SD_HS)
+			phase_cfg = DRV_PHASE_135 | SMP_PHASE_45;
+		else
+			phase_cfg = DRV_PHASE_180 | SMP_PHASE_0;
+	}
+
+	reg_value = himci_readl(host->base + MCI_UHS_REG_EXT);
+	reg_value &= ~CLK_SMPL_PHS_MASK;
+	reg_value &= ~CLK_DRV_PHS_MASK;
+	reg_value |= phase_cfg;
+	himci_writel(reg_value, host->base + MCI_UHS_REG_EXT);
+}
diff --git a/drivers/mmc/host/himci/himci_proc.c b/drivers/mmc/host/himci/himci_proc.c
new file mode 100644
index 000000000..ac339c4da
--- /dev/null
+++ b/drivers/mmc/host/himci/himci_proc.c
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+
+#include <linux/mmc/card.h>
+
+#include <linux/export.h>
+#include <linux/mmc/host.h>
+#include "himci.h"
+#include "himci_reg.h"
+#include "himci_proc.h"
+
+#define MCI_PARENT       "mci"
+#define MCI_STATS_PROC   "mci_info"
+#define MAX_CLOCK_SCALE	(4)
+#define UNSTUFF_BITS(resp, start, size)                   \
+	({                              \
+	 const int __size = size;                \
+	 const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1; \
+	 const int __off = 3 - ((start) / 32);           \
+	 const int __shft = (start) & 31;            \
+	 u32 __res;                      \
+	 \
+	 __res = resp[__off] >> __shft;              \
+	 if (__size + __shft > 32)               \
+	 __res |= resp[__off-1] << ((32 - __shft) % 32); \
+	 __res & __mask;                     \
+	 })
+
+extern unsigned int slot_index;
+static struct proc_dir_entry *proc_mci_dir;
+
+static char *card_type[MAX_CARD_TYPE + 1] = {
+	"MMC card",
+	"SD card",
+	"SDIO card",
+	"SD combo (IO+mem) card",
+	"unknown"
+};
+static char *clock_unit[MAX_CLOCK_SCALE] = {
+	"Hz",
+	"KHz",
+	"MHz",
+	"GHz"
+};
+
+static char *mci_get_card_type(unsigned int sd_type)
+{
+	if (MAX_CARD_TYPE <= sd_type)
+		return card_type[MAX_CARD_TYPE];
+	else
+		return card_type[sd_type];
+}
+
+static unsigned int analyze_clock_scale(unsigned int clock,
+					unsigned int *clock_val)
+{
+	unsigned int scale = 0;
+	unsigned int tmp = clock;
+
+	while (1) {
+		tmp = tmp / 1000;
+		if (0 < tmp) {
+			*clock_val = tmp;
+			scale++;
+		} else {
+			break;
+		}
+	}
+	return scale;
+}
+
+static inline int is_card_uhs(unsigned char timing)
+{
+	return timing >= MMC_TIMING_UHS_SDR12 &&
+	       timing <= MMC_TIMING_UHS_DDR50;
+};
+
+static inline int is_card_hs(unsigned char timing)
+{
+	return timing == MMC_TIMING_SD_HS || timing == MMC_TIMING_MMC_HS;
+};
+
+static void mci_stats_seq_printout(struct seq_file *s)
+{
+	unsigned int index_mci;
+	unsigned int clock;
+	unsigned int clock_scale;
+	unsigned int clock_value = 0;
+	const char *type = NULL;
+	unsigned int present;
+	struct himci_host *host = NULL;
+	struct card_info *c_info = NULL;
+	const char *uhs_bus_speed_mode = "";
+	u32 speed_class, grade_speed_uhs;
+	static const char *const uhs_speeds[] = {
+		[UHS_SDR12_BUS_SPEED] = "SDR12 ",
+		[UHS_SDR25_BUS_SPEED] = "SDR25 ",
+		[UHS_SDR50_BUS_SPEED] = "SDR50 ",
+		[UHS_SDR104_BUS_SPEED] = "SDR104 ",
+		[UHS_DDR50_BUS_SPEED] = "DDR50 ",
+	};
+
+	for (index_mci = 0; index_mci < HIMCI_SLOT_NUM; index_mci++) {
+		host = mci_host[index_mci];
+		if (!host || !host->mmc) {
+			seq_printf(s, "MCI%d: invalid\n", index_mci);
+			continue;
+		} else {
+			seq_printf(s, "MCI%d", index_mci);
+		}
+		c_info = &host->c_info;
+
+		present = host->mmc->ops->get_cd(host->mmc);
+		if (present) {
+			seq_puts(s, ": pluged");
+		} else {
+			seq_puts(s, ": unplugged");
+		}
+
+		if (CARD_CONNECT != c_info->card_connect) {
+			if (host->mmc->card_status == MMC_CARD_INIT_FAIL)
+				seq_puts(s, "_init_failed\n");
+			else
+				seq_puts(s, "_disconnected\n");
+		} else {
+			seq_puts(s, "_connected\n");
+			seq_printf(s,
+				   "\tType: %s",
+				   mci_get_card_type(c_info->card_type)
+				  );
+
+			if (c_info->card_state & MMC_STATE_BLOCKADDR) {
+				if (c_info->card_state & MMC_CARD_SDXC)
+					type = "SDXC";
+				else
+					type = "SDHC";
+				seq_printf(s, "(%s)\n", type);
+			}
+
+			if (is_card_uhs(c_info->timing) &&
+					c_info->sd_bus_speed < ARRAY_SIZE(uhs_speeds))
+				uhs_bus_speed_mode = uhs_speeds[c_info->sd_bus_speed];
+
+			seq_printf(s, "\tMode: %s%s%s%s\n",
+				   is_card_uhs(c_info->timing) ? "UHS " :
+				   (is_card_hs(c_info->timing) ? "HS " : ""),
+				   c_info->timing == MMC_TIMING_MMC_HS400 ? "HS400 " :
+				   (c_info->timing == MMC_TIMING_MMC_HS200 ? "HS200 " : ""),
+				   c_info->timing == MMC_TIMING_MMC_DDR52 ? "DDR " : "",
+				   uhs_bus_speed_mode);
+
+			speed_class = UNSTUFF_BITS(c_info->ssr, 440 - 384, 8);
+			grade_speed_uhs = UNSTUFF_BITS(c_info->ssr, 396 - 384, 4);
+			seq_printf(s, "\tSpeed Class: Class %s\n",
+				   (0x00 == speed_class) ? "0" :
+				   (0x01 == speed_class) ? "2" :
+				   (0x02 == speed_class) ? "4" :
+				   (0x03 == speed_class) ? "6" :
+				   (0x04 == speed_class) ? "10" :
+				   "Reserved");
+			seq_printf(s, "\tUhs Speed Grade: %s\n",
+				   (0x00 == grade_speed_uhs) ?
+				   "Less than 10MB/sec(0h)" :
+				   (0x01 == grade_speed_uhs) ?
+				   "10MB/sec and above(1h)" :
+				   "Reserved");
+
+			clock = host->hclk;
+			clock_scale = analyze_clock_scale(clock, &clock_value);
+			seq_printf(s, "\tHost work clock: %d%s\n",
+				   clock_value, clock_unit[clock_scale]);
+
+			clock = c_info->card_support_clock;
+			clock_scale = analyze_clock_scale(clock, &clock_value);
+			seq_printf(s, "\tCard support clock: %d%s\n",
+				   clock_value, clock_unit[clock_scale]);
+
+			clock = host->cclk;
+			clock_scale = analyze_clock_scale(clock, &clock_value);
+			seq_printf(s, "\tCard work clock: %d%s\n",
+				   clock_value, clock_unit[clock_scale]);
+			/* add card read/write error count */
+			seq_printf(s, "\tCard error count: %d\n",
+				   host->error_count);
+			seq_printf(s, "\tCard data error count: %d\n",
+				   host->data_error_count);
+		}
+	}
+}
+
+/* define parameters where showed in proc file */
+static int mci_stats_seq_show(struct seq_file *s, void *v)
+{
+	mci_stats_seq_printout(s);
+	return 0;
+}
+
+int mci_proc_init(void)
+{
+	struct proc_dir_entry *proc_stats_entry = NULL;
+	proc_mci_dir = proc_mkdir(MCI_PARENT, NULL);
+	if (!proc_mci_dir) {
+		pr_err("%s: failed to create proc file %s\n",
+				__func__, MCI_PARENT);
+		return 1;
+	}
+	proc_stats_entry = proc_create_single_data(MCI_STATS_PROC, 0,
+			proc_mci_dir, mci_stats_seq_show, NULL);
+	if (!proc_stats_entry) {
+		pr_err("%s: failed to create proc file %s\n",
+				__func__, MCI_STATS_PROC);
+		return 1;
+	}
+	return 0;
+}
+
+int mci_proc_shutdown(void)
+{
+	if (proc_mci_dir) {
+		remove_proc_entry(MCI_STATS_PROC, proc_mci_dir);
+		remove_proc_entry(MCI_PARENT, NULL);
+		proc_mci_dir = NULL;
+	}
+
+	return 0;
+}
diff --git a/drivers/mmc/host/himci/himci_proc.h b/drivers/mmc/host/himci/himci_proc.h
new file mode 100644
index 000000000..e6ea9a137
--- /dev/null
+++ b/drivers/mmc/host/himci/himci_proc.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ *  MCI connection table manager
+ */
+#ifndef __MCI_PROC_H__
+#define __MCI_PROC_H__
+
+#include <linux/proc_fs.h>
+
+#define MAX_CARD_TYPE 4
+#define MAX_SPEED_MODE 5
+#define MMC_STATE_BLOCKADDR (1<<2) /* card uses block-addressing copy from core/card.h */
+#define MMC_CARD_SDXC (1<<3) /* card is SDXC copy from core/card.h */
+#define HIMCI_SLOT_NUM 3
+
+extern struct himci_host *mci_host[HIMCI_SLOT_NUM];
+int mci_proc_init(void);
+int mci_proc_shutdown(void);
+
+#endif /*  __MCI_PROC_H__ */
diff --git a/drivers/mmc/host/himci/himci_reg.h b/drivers/mmc/host/himci/himci_reg.h
new file mode 100644
index 000000000..d1d8f9f9d
--- /dev/null
+++ b/drivers/mmc/host/himci/himci_reg.h
@@ -0,0 +1,241 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _HI_MCI_REG_H_
+#define _HI_MCI_REG_H_
+
+#define HI_MCI_IO_SIZE 0x1000
+
+#define MCI_CTRL 0x00
+#define MCI_PWREN 0x04
+#define MCI_CLKDIV 0x08
+#define MCI_CLKSRC 0x0C
+#define MCI_CLKENA 0x10
+#define MCI_TIMEOUT 0x14
+#define MCI_CTYPE 0x18
+#define MCI_BLKSIZ 0x1c
+#define MCI_BYTCNT 0x20
+#define MCI_INTMASK 0x24
+#define MCI_CMDARG 0x28
+#define MCI_CMD 0x2C
+#define MCI_RESP0 0x30
+#define MCI_RESP1 0x34
+#define MCI_RESP2 0x38
+#define MCI_RESP3 0x3C
+#define MCI_MINTSTS 0x40
+#define MCI_RINTSTS 0x44
+#define MCI_STATUS 0x48
+#define MCI_FIFOTH 0x4C
+#define MCI_CDETECT 0x50
+#define MCI_WRTPRT 0x54
+#define MCI_GPIO 0x58
+#define MCI_TCBCNT 0x5C
+#define MCI_TBBCNT 0x60
+#define MCI_DEBNCE 0x64
+#define MCI_USRID 0x68
+#define MCI_VERID 0x6C
+#define MCI_HCON 0x70
+#define MCI_UHS_REG 0x74
+#define MCI_RESET_N 0x78
+#define MCI_BMOD 0x80
+#define MCI_DBADDR 0x88
+#define MCI_IDSTS 0x8C
+#define MCI_IDINTEN 0x90
+#define MCI_DSCADDR 0x94
+#define MCI_BUFADDR 0x98
+#define MCI_CARDTHRCTL 0x100
+#define MCI_UHS_REG_EXT 0x108
+
+#define MCI_TUNING_CTRL 0x118
+
+/* MCI_IDSTS(0x8c) detals */
+#define CMD_LOCK_ERR (0x1 << 29)
+#define OWNBIT_ERR (0x1 << 28)
+#define QUEUE_OVERFLOW (0x1 << 27)
+#define RESP_CHECK_ERR (0x1 << 26)
+#define PACKET_INT (0x1 << 25)
+#define PACKET_TO_INT (0x1 << 24)
+#define AUTO_STOP_ERR (0x1 << 23)
+#define QUEUE_FULL (0x1 << 22)
+#define QUEUE_EMPTY (0x1 << 21)
+#define ADMA3_FSM_SHIFT (17)
+#define FSM_SHIFT (13)
+#define CES (0x1 << 5)
+#define DU (0x1 << 4)
+#define FBE (0x1 << 2)
+
+/* MCI_BMOD(0x80) details */
+#define BMOD_SWR (0x1 << 0)
+#define BURST_INCR (0x1 << 1)
+#define BMOD_DMA_EN (0x1 << 7)
+#define BURST_8 (0x2 << 8)
+#define BURST_16 (0x3 << 8)
+/* IDMAC DEST1 details */
+#define DMA_BUFFER (0x2000)
+#define MAX_DMA_DES (20480)
+
+/* IDMAC DEST0 details */
+#define DMA_DES_OWN (1 << 31)
+#define DMA_DES_NEXT_DES (1 << 4)
+#define DMA_DES_FIRST_DES (1 << 3)
+#define DMA_DES_LAST_DES (1 << 2)
+
+/* MCI_CTRL(0x00) details */
+#define CTRL_RESET (1 << 0)
+#define FIFO_RESET (1 << 1)
+#define DMA_RESET (1 << 2)
+#define INTR_EN (1 << 4)
+#define USE_INTERNAL_DMA (1 << 25)
+
+/* MCI_CLKENA(0x10) details */
+#define CCLK_ENABLE (0x1 << 0)
+#define CCLK_LOW_POWER (0x1 << 16)
+
+/* MCI_TIMEOUT(0x14) details: */
+/* bit 31-8: data read timeout param */
+#define DATA_TIMEOUT (0xffffff << 8)
+/* bit 7-0: response timeout param */
+#define RESPONSE_TIMEOUT 0xff
+
+/* MCI_CTYPE(0x18) details */
+#define CARD_WIDTH_0 (0x1 << 16)
+#define CARD_WIDTH_1 (0x1 << 0)
+
+/* MCI_INTMASK(0x24) details:
+   bit 16-1: mask MMC host controller each interrupt
+*/
+#define ALL_INT_MASK 0x1ffff
+#define DTO_INT_MASK (0x1 << 3)
+#define SDIO_INT_MASK (0x1 << 16)
+
+/* MCI_UHS_REG_EXT(0x108) details */
+/* bit[19:16] sampling phase */
+#define CLK_SMPL_PHS_SHIFT (16)
+#define CLK_SMPL_PHS_MASK (0x7 << 16)
+
+/* bit[26:23] drv phase */
+#define CLK_DRV_PHS_SHIFT (23)
+#define CLK_DRV_PHS_MASK (0x7 << 23)
+#define DEFAULT_PHASE 0x1050000
+
+/* MCI_CMD(0x2c) details:
+   bit 31: cmd execute or load start param of interface clk bit
+*/
+#define START_CMD (0x1<<31)
+
+/* MCI_INTSTS(0x44) details */
+
+/* bit 16: sdio interrupt status */
+#define SDIO_INT_STATUS (0x1 << 16)
+
+/* bit 15: end-bit error (read)/write no CRC interrupt status */
+#define EBE_INT_STATUS (0x1 << 15)
+
+/* bit 14: auto command done interrupt status */
+#define ACD_INT_STATUS (0x1 << 14)
+
+/* bit 13: start bit error interrupt status */
+#define SBE_INT_STATUS (0x1 << 13)
+
+/* bit 12: hardware locked write error interrupt status */
+#define HLE_INT_STATUS (0x1 << 12)
+
+/* bit 11: FIFO underrun/overrun error interrupt status */
+#define FRUN_INT_STATUS (0x1 << 11)
+
+/* bit 10: data starvation-by-host timeout interrupt status */
+#define HTO_INT_STATUS (0x1 << 10)
+
+/* bit 10: volt_switch to 1.8v for sdxc */
+#define VOLT_SWITCH_INT_STATUS (0x1 << 10)
+
+/* bit 9: data read timeout interrupt status */
+#define DRTO_INT_STATUS (0x1 << 9)
+
+/* bit 8: response timeout interrupt status */
+#define RTO_INT_STATUS (0x1 << 8)
+
+/* bit 7: data CRC error interrupt status */
+#define DCRC_INT_STATUS (0x1 << 7)
+
+/* bit 6: response CRC error interrupt status */
+#define RCRC_INT_STATUS    (0x1<<6)
+
+/* bit 5: receive FIFO data request interrupt status */
+#define RXDR_INT_STATUS    (0x1<<5)
+
+/* bit 4: transmit FIFO data request interrupt status */
+#define TXDR_INT_STATUS    (0x1<<4)
+
+/* bit 3: data transfer Over interrupt status */
+#define DTO_INT_STATUS    (0x1<<3)
+
+/* bit 2: command done interrupt status */
+#define CD_INT_STATUS    (0x1<<2)
+
+/* bit 1: response error interrupt status */
+#define RE_INT_STATUS    (0x1<<1)
+
+#define CMD_INT_MASK	(RTO_INT_STATUS | RCRC_INT_STATUS | RE_INT_STATUS)
+#define DATA_INT_MASK	(DTO_INT_STATUS | DCRC_INT_STATUS \
+		| SBE_INT_STATUS | EBE_INT_STATUS)
+
+
+/* MCI_RINTSTS(0x44) details:bit 16-1: clear
+   MMC host controller each interrupt but
+   hardware locked write error interrupt
+*/
+#define ALL_INT_CLR       0x1efff
+#define ALL_SD_INT_CLR    0xefff
+
+/* MCI_STATUS(0x48) details */
+#define DATA_BUSY		(0x1<<9)
+
+/* MCI_FIFOTH(0x4c) details */
+#define BURST_SIZE		(0x6<<28)
+#define RX_WMARK		(0x7f<<16)
+#define TX_WMARK          (0x80)
+
+/* MCI_CDETECT(0x50) details */
+#define HIMCI_CARD0		(0x1<<0)
+
+/* MCI_GPIO(0x58) details */
+#define DTO_FIX_BYPASS      (0x1<<23)
+#define CMD_OUT_EN_FIX_BYPASS   (0x1<<8)
+
+/* MCI_UHS_REG(0x74) details */
+#define HI_SDXC_CTRL_VDD_180	(0x1<<0)
+#define HI_SDXC_CTRL_DDR_REG	(0x1<<16)
+
+/* MCI_RESET_N(0x78) details */
+#define MMC_RST_N   (0x1<<0)
+
+/* MCI_CARDTHRCTL(0x100) details */
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)
+#define RW_THRESHOLD_SIZE	(0x2000005)
+#else
+#define RW_THRESHOLD_SIZE	(0x2000001)
+#endif
+
+/* MCI_TUNING_CTRL(0x118) details */
+#define HW_TUNING_EN	(0x1 << 0)
+#define EDGE_CTRL		(0x1 << 1)
+#define FOUND_EDGE		(0x1 << 5)
+
+#endif
diff --git a/drivers/mmc/host/mci_proc.c b/drivers/mmc/host/mci_proc.c
new file mode 100644
index 000000000..9465ad3fe
--- /dev/null
+++ b/drivers/mmc/host/mci_proc.c
@@ -0,0 +1,301 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2016-2020. All rights reserved.
+ * Description: mci driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include "../core/card.h"
+#include "sdhci.h"
+#include "mci_proc.h"
+
+#define MCI_PARENT       "mci"
+#define MCI_STATS_PROC   "mci_info"
+#define MAX_CLOCK_SCALE	 4
+
+unsigned int slot_index;
+struct mmc_host *mci_host[MCI_SLOT_NUM] = {NULL};
+static struct proc_dir_entry *proc_mci_dir;
+
+static char *card_type[MAX_CARD_TYPE + 1] = {
+	"MMC card",
+	"SD card",
+	"SDIO card",
+	"SD combo (IO+mem) card",
+	"unknown"
+};
+static char *clock_unit[MAX_CLOCK_SCALE] = {
+	"Hz",
+	"KHz",
+	"MHz",
+	"GHz"
+};
+
+#define BIT_WIDTH	32
+static unsigned int unstuff_bits(const u32 *resp, u32 start, u32 size)
+{
+	const u32 mask = ((size < BIT_WIDTH) ? 1 << size : 0) - 1;
+	const int off = 0x3 - ((start) / BIT_WIDTH);
+	const int shft = (start) & 31; /* max shift value 31 */
+	u32 res;
+
+	res = resp[off] >> shft;
+	if (size + shft > BIT_WIDTH)
+		res |= resp[off - 1] << ((BIT_WIDTH - shft) % BIT_WIDTH);
+	res = res & mask;
+
+	return res;
+}
+
+static char *mci_get_card_type(unsigned int sd_type)
+{
+	if (sd_type >= MAX_CARD_TYPE)
+		return card_type[MAX_CARD_TYPE];
+	else
+		return card_type[sd_type];
+}
+
+static unsigned int analyze_clock_scale(unsigned int clock,
+    unsigned int *clock_val)
+{
+	unsigned int scale = 0;
+	unsigned int tmp = clock;
+
+	while (1) {
+		tmp = tmp / 1000; /* Cal freq by dividing 1000 */
+		if (tmp > 0) {
+			*clock_val = tmp;
+			scale++;
+		} else {
+			break;
+		}
+	}
+	return scale;
+}
+
+static inline int is_card_uhs(unsigned char timing)
+{
+	return timing >= MMC_TIMING_UHS_SDR12 &&
+	       timing <= MMC_TIMING_UHS_DDR50;
+};
+
+static inline int is_card_hs(unsigned char timing)
+{
+	return timing == MMC_TIMING_SD_HS || timing == MMC_TIMING_MMC_HS;
+};
+
+static void mci_stats_seq_printout(struct seq_file *s)
+{
+	unsigned int index_mci;
+	unsigned int clock;
+	unsigned int clock_scale;
+	unsigned int clock_value = 0;
+	const char *type = NULL;
+	struct mmc_host *mmc = NULL;
+	const char *uhs_bus_speed_mode = "";
+	static const char * const uhs_speeds[] = {
+		[UHS_SDR12_BUS_SPEED] = "SDR12 ",
+		[UHS_SDR25_BUS_SPEED] = "SDR25 ",
+		[UHS_SDR50_BUS_SPEED] = "SDR50 ",
+		[UHS_SDR104_BUS_SPEED] = "SDR104 ",
+		[UHS_DDR50_BUS_SPEED] = "DDR50 ",
+	};
+	unsigned int speed_class, grade_speed_uhs;
+	unsigned int present;
+	struct card_info *info = NULL;
+	struct sdhci_host *host = NULL;
+
+	for (index_mci = 0; index_mci < MCI_SLOT_NUM; index_mci++) {
+		mmc = mci_host[index_mci];
+		if (mmc == NULL) {
+			seq_printf(s, "MCI%d: invalid\n", index_mci);
+			continue;
+		} else {
+			seq_printf(s, "MCI%d", index_mci);
+		}
+
+		host = mmc_priv(mmc);
+		info = &host->c_info;
+
+		present = host->mmc->ops->get_cd(host->mmc);
+		if (present)
+			seq_puts(s, ": pluged");
+		else
+			seq_puts(s, ": unplugged");
+
+		if (info->card_connect != CARD_CONNECT) {
+			if (mmc->card_status == MMC_CARD_INIT_FAIL)
+				seq_puts(s, "_init_failed\n");
+			else
+				seq_puts(s, "_disconnected\n");
+		} else {
+			seq_puts(s, "_connected\n");
+
+			seq_printf(s, "\tType: %s",
+				   mci_get_card_type(info->card_type));
+
+			if (info->card_state & MMC_STATE_BLOCKADDR) {
+				type = (info->card_state & MMC_CARD_SDXC) ?
+				       "SDXC" : "SDHC";
+				seq_printf(s, "(%s)\n", type);
+			}
+
+			if (is_card_uhs(info->timing) &&
+					info->sd_bus_speed < ARRAY_SIZE(uhs_speeds))
+				uhs_bus_speed_mode =
+					uhs_speeds[info->sd_bus_speed];
+
+			seq_printf(s, "\tMode: %s %s\n",
+				   is_card_uhs(info->timing) ? "UHS" :
+				   is_card_hs(info->timing) ? "HS" :
+				   (info->enhanced_strobe == true) ? "HS400ES" :
+				   (info->timing == MMC_TIMING_MMC_HS400) ? "HS400" :
+				   (info->timing == MMC_TIMING_MMC_HS200) ? "HS200" :
+				   (info->timing == MMC_TIMING_MMC_DDR52) ? "DDR" :
+				   "DS", uhs_bus_speed_mode);
+
+			speed_class = unstuff_bits(info->ssr, 56, 8); /* 56 = 440 - 384 */
+			grade_speed_uhs = unstuff_bits(info->ssr, 12, 4); /* 12 = 396 - 384 */
+			seq_printf(s, "\tSpeed Class: Class %s\n",
+				   (speed_class == 0x00) ? "0" :
+				   (speed_class == 0x01) ? "2" :
+				   (speed_class == 0x02) ? "4" :
+				   (speed_class == 0x03) ? "6" :
+				   (speed_class == 0x04) ? "10" :
+				   "Reserved");
+			seq_printf(s, "\tUhs Speed Grade: %s\n",
+				   (grade_speed_uhs == 0x00) ?
+				   "Less than 10MB/sec(0h)" :
+				   (grade_speed_uhs == 0x01) ?
+				   "10MB/sec and above(1h)" :
+				   "Reserved");
+
+			clock = info->card_support_clock;
+			clock_scale = analyze_clock_scale(clock, &clock_value);
+			seq_printf(s, "\tHost work clock: %d%s\n",
+				   clock_value, clock_unit[clock_scale]);
+
+			clock = info->card_support_clock;
+			clock_scale = analyze_clock_scale(clock, &clock_value);
+			seq_printf(s, "\tCard support clock: %d%s\n",
+				   clock_value, clock_unit[clock_scale]);
+
+			clock = mmc->actual_clock;
+			clock_scale = analyze_clock_scale(clock, &clock_value);
+			seq_printf(s, "\tCard work clock: %d%s\n",
+				   clock_value, clock_unit[clock_scale]);
+
+			/* add card read/write error count */
+			seq_printf(s, "\tCard error count: %d\n",
+				   host->error_count);
+		}
+	}
+}
+
+/* proc interface setup */
+static void *mci_seq_start(struct seq_file *s, loff_t *pos)
+{
+	/*  counter is used to tracking multi proc interfaces
+	 *  We have only one interface so return zero
+	 *  pointer to start the sequence.
+	 */
+	static unsigned long counter;
+
+	if (*pos == 0)
+		return &counter;
+
+	return NULL;
+}
+
+/* proc interface next */
+static void *mci_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	(*pos)++;
+
+	return mci_seq_start(s, pos);
+}
+
+/* define parameters where showed in proc file */
+static int mci_stats_seq_show(struct seq_file *s, void *v)
+{
+	mci_stats_seq_printout(s);
+	return 0;
+}
+
+/* proc interface stop */
+static void mci_seq_stop(struct seq_file *s, void *v)
+{
+}
+
+/* proc interface operation */
+static const struct seq_operations mci_stats_seq_ops = {
+	.start = mci_seq_start,
+	.next = mci_seq_next,
+	.stop = mci_seq_stop,
+	.show = mci_stats_seq_show
+};
+
+/* proc file open */
+static int mci_stats_proc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &mci_stats_seq_ops);
+};
+
+/* proc file operation */
+static const struct file_operations mci_stats_proc_ops = {
+	.owner = THIS_MODULE,
+	.open = mci_stats_proc_open,
+	.read = seq_read,
+	.release = seq_release
+};
+
+int mci_proc_init(void)
+{
+	struct proc_dir_entry *proc_stats_entry = NULL;
+
+	proc_mci_dir = proc_mkdir(MCI_PARENT, NULL);
+	if (proc_mci_dir == NULL) {
+		pr_err("%s: failed to create proc file %s\n",
+		       __func__, MCI_PARENT);
+		return 1;
+	}
+
+	proc_stats_entry = proc_create(MCI_STATS_PROC,
+				       0, proc_mci_dir, &mci_stats_proc_ops);
+	if (proc_stats_entry == NULL) {
+		pr_err("%s: failed to create proc file %s\n",
+		       __func__, MCI_STATS_PROC);
+		return 1;
+	}
+
+	return 0;
+}
+
+int mci_proc_shutdown(void)
+{
+	if (proc_mci_dir != NULL) {
+		remove_proc_entry(MCI_STATS_PROC, proc_mci_dir);
+		remove_proc_entry(MCI_PARENT, NULL);
+		proc_mci_dir = NULL;
+	}
+
+	return 0;
+}
diff --git a/drivers/mmc/host/mci_proc.h b/drivers/mmc/host/mci_proc.h
new file mode 100644
index 000000000..459c5d767
--- /dev/null
+++ b/drivers/mmc/host/mci_proc.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2016-2020. All rights reserved.
+ * Description: mci header
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ *  MCI connection table manager
+ */
+#ifndef __MCI_PROC_H__
+#define __MCI_PROC_H__
+
+#include <linux/proc_fs.h>
+
+#define MAX_CARD_TYPE	4
+#define MAX_SPEED_MODE	5
+
+#if defined(CONFIG_ARCH_HI3531DV200) || defined(CONFIG_ARCH_HI3535AV100) ||\
+	defined(CONFIG_ARCH_HI3521DV200) || defined(CONFIG_ARCH_HI3520DV500)
+#define MCI_SLOT_NUM 1
+#elif defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3569V100)
+#define MCI_SLOT_NUM 4
+#elif defined(CONFIG_ARCH_HI3556AV100) || defined(CONFIG_ARCH_HI3519AV100) ||\
+    defined(CONFIG_ARCH_HI3516EV200) || defined(CONFIG_ARCH_HI3516EV300) ||\
+	defined(CONFIG_ARCH_HI3518EV300) || defined(CONFIG_ARCH_HI3516DV200) ||\
+	defined(CONFIG_ARCH_HI3568V100)
+#define MCI_SLOT_NUM 3
+#else
+#error MCI_SLOT_NUM should not be zero!
+#endif
+
+extern unsigned int slot_index;
+extern struct mmc_host *mci_host[MCI_SLOT_NUM];
+
+int mci_proc_init(void);
+int mci_proc_shutdown(void);
+
+#endif /*  __MCI_PROC_H__ */
diff --git a/drivers/mmc/host/sdhci-hisi.c b/drivers/mmc/host/sdhci-hisi.c
new file mode 100644
index 000000000..be2a903ac
--- /dev/null
+++ b/drivers/mmc/host/sdhci-hisi.c
@@ -0,0 +1,783 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2017-2020. All rights reserved.
+ * Description: hisi sdhci driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "sdhci-hisi.h"
+#include "cqhci.h"
+#include "mci_proc.h"
+
+int sdhci_hisi_parse_dt(struct sdhci_host *host)
+{
+	struct sdhci_hisi_priv *priv = sdhci_get_pltfm_priv(host);
+	struct device_node *np = host->mmc->parent->of_node;
+	u32 bus_width;
+	int ret;
+
+	ret = mmc_of_parse(host->mmc);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_MMC_CQHCI
+	if (of_get_property(np, "mmc-cmd-queue", NULL))
+		host->mmc->caps2 |= MMC_CAP2_CQE | MMC_CAP2_CQE_DCMD;
+#endif
+	if (of_get_property(np, "mmc-broken-cmd23", NULL))
+		host->quirks2 |= SDHCI_QUIRK2_HOST_NO_CMD23;
+
+	if (of_property_read_u32(np, "bus-width", &bus_width) == 0) {
+		priv->bus_width = bus_width;
+	} else {
+		pr_err("%s: \"bus-width\" property is missing, assuming 1 bit.\n",
+		       mmc_hostname(host->mmc));
+		priv->bus_width = 1;
+	}
+
+	if (of_get_property(np, "sdhci,1-bit-only", NULL) ||
+			(priv->bus_width == 1)) {
+		priv->bus_width = 1;
+		host->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;
+	}
+
+	return 0;
+}
+
+void hisi_enable_sample(struct sdhci_host *host)
+{
+	unsigned int reg;
+
+	reg = sdhci_readl(host, SDHCI_AT_CTRL);
+	reg |= SDHCI_SAMPLE_EN;
+	sdhci_writel(host, reg, SDHCI_AT_CTRL);
+}
+
+void hisi_set_sample_phase(struct sdhci_host *host, u32 phase)
+{
+	unsigned int reg;
+
+	reg = sdhci_readl(host, SDHCI_AT_STAT);
+	reg &= ~SDHCI_PHASE_SEL_MASK;
+	reg |= phase;
+	sdhci_writel(host, reg, SDHCI_AT_STAT);
+}
+
+void hisi_disable_card_clk(struct sdhci_host *host)
+{
+	u16 clk;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk &= ~SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+}
+
+void hisi_enable_card_clk(struct sdhci_host *host)
+{
+	u16 clk;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk |= SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+}
+
+void hisi_disable_internal_clk(struct sdhci_host *host)
+{
+	u16 clk;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk &= ~SDHCI_CLOCK_INT_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+}
+
+void hisi_enable_internal_clk(struct sdhci_host *host)
+{
+	unsigned int timeout = 20;
+	u16 clk;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk |= SDHCI_CLOCK_INT_EN | SDHCI_CLOCK_PLL_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	while (!(clk & SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			pr_err("%s: Internal clock never stabilised.\n",
+			       __func__);
+			return;
+		}
+		timeout--;
+		udelay(1000); /* delay 1000us */
+		clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	}
+}
+
+static void hisi_select_sample_phase(struct sdhci_host *host,
+    unsigned int phase)
+{
+	hisi_disable_card_clk(host);
+	hisi_set_sample_phase(host, phase);
+	hisi_wait_sample_dll_ready(host);
+	hisi_enable_card_clk(host);
+	udelay(1);
+}
+
+static int hisi_send_tuning(struct sdhci_host *host, u32 opcode)
+{
+	int count, err;
+
+	count = 0;
+	do {
+		err = mmc_send_tuning(host->mmc, opcode, NULL);
+		if (err) {
+			mmc_abort_tuning(host->mmc, opcode);
+			break;
+		}
+		count++;
+	} while (count < MAX_TUNING_NUM);
+
+	return err;
+}
+
+static void hisi_pre_tuning(struct sdhci_host *host)
+{
+	sdhci_writel(host, host->ier | SDHCI_INT_DATA_AVAIL, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier | SDHCI_INT_DATA_AVAIL, SDHCI_SIGNAL_ENABLE);
+
+	hisi_enable_sample(host);
+	host->is_tuning = 1;
+}
+
+static void hisi_post_tuning(struct sdhci_host *host)
+{
+	unsigned short ctrl;
+
+	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl |= SDHCI_CTRL_TUNED_CLK;
+	sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+	host->is_tuning = 0;
+}
+
+#ifndef SDHCI_HISI_EDGE_TUNING
+static int hisi_get_best_sample(u32 candidates)
+{
+	int rise = NOT_FOUND;
+	int fall, i, win;
+	int win_max_r = NOT_FOUND;
+	int win_max_f = NOT_FOUND;
+	int end_fall = NOT_FOUND;
+	int found = NOT_FOUND;
+	int win_max = 0;
+
+	for (i = 0; i < PHASE_SCALE; i++) {
+		if ((candidates & 0x3) == 0x2)
+			rise = (i + 1) % PHASE_SCALE;
+
+		if ((candidates & 0x3) == 0x1) {
+			fall = i;
+			if (rise != NOT_FOUND) {
+				win = fall - rise + 1;
+				if (win > win_max) {
+					win_max = win;
+					found = (fall + rise) / 2; /* Get window center by devide 2 */
+					win_max_r = rise;
+					win_max_f = fall;
+					rise = NOT_FOUND;
+					fall = NOT_FOUND;
+				}
+			} else {
+				end_fall = fall;
+			}
+		}
+		candidates = ror32(candidates, 1);
+	}
+
+	if (end_fall != NOT_FOUND && rise != NOT_FOUND) {
+		fall = end_fall;
+		if (end_fall < rise)
+			end_fall += PHASE_SCALE;
+
+		win = end_fall - rise + 1;
+		if (win > win_max) {
+			found = (rise + (win / 2)) % PHASE_SCALE; /* Get window center by devide 2 */
+			win_max_r = rise;
+			win_max_f = fall;
+		}
+	}
+
+	if (found != NOT_FOUND)
+		pr_err("valid phase shift [%d, %d] Final Phase:%d\n",
+		       win_max_r, win_max_f, found);
+
+	return found;
+}
+
+static int sdhci_hisi_exec_tuning(struct sdhci_host *host, u32 opcode)
+{
+	struct sdhci_hisi_priv *priv = sdhci_get_pltfm_priv(host);
+	unsigned int sample;
+	unsigned int candidates = 0;
+	int phase, err;
+
+	hisi_pre_tuning(host);
+
+	for (sample = 0; sample < PHASE_SCALE; sample++) {
+		hisi_select_sample_phase(host, sample);
+
+		err = hisi_send_tuning(host, opcode);
+		if (err)
+			pr_debug("send tuning CMD%u fail! phase:%d err:%d\n",
+				 opcode, sample, err);
+		else
+			candidates |= (0x1 << sample);
+	}
+
+	pr_info("%s: tuning done! candidates 0x%X: ",
+		mmc_hostname(host->mmc), candidates);
+
+	phase = hisi_get_best_sample(candidates);
+	if (phase == NOT_FOUND) {
+		phase = priv->sample_phase;
+		pr_err("no valid phase shift! use default %d\n", phase);
+	}
+
+	priv->tuning_phase = phase;
+	hisi_select_sample_phase(host, phase);
+	hisi_post_tuning(host);
+
+	return 0;
+}
+#else
+static void hisi_enable_edge_tuning(struct sdhci_host *host)
+{
+	unsigned int reg;
+
+	reg = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	reg |= SDHCI_EDGE_DETECT_EN;
+	sdhci_writel(host, reg, SDHCI_MULTI_CYCLE);
+}
+
+static void hisi_disable_edge_tuning(struct sdhci_host *host)
+{
+	unsigned int reg;
+
+	reg = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	reg &= ~SDHCI_EDGE_DETECT_EN;
+	sdhci_writel(host, reg, SDHCI_MULTI_CYCLE);
+}
+
+static int sdhci_hisi_exec_edge_tuning(struct sdhci_host *host, u32 opcode)
+{
+	struct sdhci_hisi_priv *priv = sdhci_get_pltfm_priv(host);
+	unsigned int index, val;
+	unsigned int found;
+	unsigned int prev_found = 0;
+	unsigned int edge_p2f, edge_f2p, start, end;
+	unsigned int phase, fall, rise;
+	unsigned int fall_updat_flag = 0;
+	int err;
+	int prev_err = 0;
+
+	hisi_pre_tuning(host);
+	hisi_enable_edge_tuning(host);
+
+	start = 0;
+	end = PHASE_SCALE / EDGE_TUNING_PHASE_STEP;
+
+	edge_p2f = start;
+	edge_f2p = end;
+	for (index = 0; index <= end; index++) {
+		hisi_select_sample_phase(host, index * EDGE_TUNING_PHASE_STEP);
+		err = hisi_send_tuning(host, opcode);
+		if (!err) {
+			val = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+			found = val & SDHCI_FOUND_EDGE;
+		} else {
+			found = 1;
+		}
+
+		if (prev_found && !found)
+			edge_f2p = index;
+		else if (!prev_found && found)
+			edge_p2f = index;
+
+		if ((edge_p2f != start) && (edge_f2p != end))
+			break;
+
+		prev_found = found;
+	}
+
+	if ((edge_p2f == start) && (edge_f2p == end)) {
+		pr_err("%s: tuning failed! can not found edge!\n",
+		       mmc_hostname(host->mmc));
+		return -1;
+	}
+
+	hisi_disable_edge_tuning(host);
+
+	start = edge_p2f * EDGE_TUNING_PHASE_STEP;
+	end = edge_f2p * EDGE_TUNING_PHASE_STEP;
+	if (end <= start)
+		end += PHASE_SCALE;
+
+	fall = start;
+	rise = end;
+	for (index = start; index <= end; index++) {
+		hisi_select_sample_phase(host, index % PHASE_SCALE);
+		err = hisi_send_tuning(host, opcode);
+		if (err)
+			pr_debug("send tuning CMD%u fail! phase:%d err:%d\n",
+				 opcode, index, err);
+
+		if (err && index == start) {
+			if (!fall_updat_flag) {
+				fall_updat_flag = 1;
+				fall = start;
+			}
+		} else if (!prev_err && err) {
+			if (!fall_updat_flag) {
+				fall_updat_flag = 1;
+				fall = index;
+			}
+		}
+
+		if (prev_err && !err)
+			rise = index;
+
+		if (err && index == end)
+			rise = end;
+
+		prev_err = err;
+	}
+
+	phase = ((fall + rise) / 2 + PHASE_SCALE / 2) % /* 2 for cal average */
+		PHASE_SCALE;
+
+	pr_info("%s: tuning done! valid phase shift [%d, %d] Final Phase:%d\n",
+		mmc_hostname(host->mmc), rise % PHASE_SCALE,
+		fall % PHASE_SCALE, phase);
+
+	priv->tuning_phase = phase;
+	hisi_select_sample_phase(host, phase);
+	hisi_post_tuning(host);
+
+	return 0;
+}
+#endif
+
+static int sdhci_hisi_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+#ifdef SDHCI_HISI_EDGE_TUNING
+	return sdhci_hisi_exec_edge_tuning(host, opcode);
+#else
+	return sdhci_hisi_exec_tuning(host, opcode);
+#endif
+}
+
+static void hisi_set_emmc_card(struct sdhci_host *host)
+{
+	unsigned int reg;
+
+	if (host->timing == MMC_TIMING_MMC_HS ||
+			host->timing == MMC_TIMING_MMC_DDR52 ||
+			host->timing == MMC_TIMING_MMC_HS200 ||
+			host->timing == MMC_TIMING_MMC_HS400) {
+		reg = sdhci_readl(host, SDHCI_EMMC_CTRL);
+		reg |= SDHCI_CARD_IS_EMMC;
+		sdhci_writel(host, reg, SDHCI_EMMC_CTRL);
+	}
+}
+
+static void sdhci_hisi_set_uhs_signaling(struct sdhci_host *host,
+    unsigned int timing)
+{
+	sdhci_set_uhs_signaling(host, timing);
+	host->timing = timing;
+	hisi_set_emmc_card(host);
+	hisi_set_drv_cap(host);
+}
+
+static void sdhci_hisi_hw_reset(struct sdhci_host *host)
+{
+	sdhci_writel(host, 0x0, SDHCI_EMMC_HW_RESET);
+	udelay(10);  /* delay 10us */
+	sdhci_writel(host, 0x1, SDHCI_EMMC_HW_RESET);
+	udelay(200); /* delay 200us */
+}
+
+/*
+ * This api is for wifi driver rescan the sdio device
+ */
+int hisi_sdio_rescan(int slot)
+{
+	struct mmc_host *mmc = NULL;
+
+	if ((slot >= MCI_SLOT_NUM) || (slot <= 0)) {
+		pr_err("invalid mmc slot, please check the argument\n");
+		return -EINVAL;
+	}
+
+	mmc = mci_host[slot];
+	if (mmc == NULL) {
+		pr_err("invalid mmc, please check the argument\n");
+		return -EINVAL;
+	}
+
+	mmc_detect_change(mmc, 0);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(hisi_sdio_rescan);
+
+static const struct of_device_id sdhci_hisi_match[] = {
+	{ .compatible = "hisilicon,sdhci" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, sdhci_hisi_match);
+
+static struct sdhci_ops sdhci_hisi_ops = {
+	.platform_execute_tuning = sdhci_hisi_execute_tuning,
+	.reset = sdhci_reset,
+	.set_clock = sdhci_hisi_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.set_uhs_signaling = sdhci_hisi_set_uhs_signaling,
+	.hw_reset = sdhci_hisi_hw_reset,
+#if defined(CONFIG_ARCH_HI3556AV100) || defined(CONFIG_ARCH_HI3559AV100) || \
+	defined(CONFIG_ARCH_HI3519AV100) || defined(CONFIG_ARCH_HI3569V100) || \
+	defined(CONFIG_ARCH_HI3568V100)
+	.start_signal_voltage_switch = sdhci_hisi_start_signal_voltage_switch,
+#endif
+	.init = sdhci_hisi_extra_init,
+};
+
+static const struct sdhci_pltfm_data sdhci_hisi_pdata = {
+	.ops = &sdhci_hisi_ops,
+	.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+#ifdef CONFIG_MMC_CQHCI
+static u32 sdhci_hisi_cqhci_irq(struct sdhci_host *host, u32 intmask)
+{
+	int cmd_error = 0;
+	int data_error = 0;
+
+	if (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))
+		return intmask;
+
+	cqhci_irq(host->mmc, intmask, cmd_error, data_error);
+
+	return 0;
+}
+
+static void sdhci_hisi_controller_v4_enable(struct sdhci_host *host, int enable)
+{
+	u16 ctrl;
+
+	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	if (enable)
+		ctrl |= SDHCI_CTRL_HOST_VER4_ENABLE;
+	else
+		ctrl &= ~SDHCI_CTRL_HOST_VER4_ENABLE;
+
+	if (host->flags & SDHCI_USE_64_BIT_DMA)
+		ctrl |= SDHCI_CTRL_64BIT_ADDR;
+
+	sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+}
+
+static void sdhci_hisi_cqe_enable(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	unsigned int timeout = 10000;
+	u16 reg, clk;
+	u8 ctrl;
+
+	/* SW_RST_DAT */
+	sdhci_reset(host, SDHCI_RESET_DATA);
+
+	sdhci_hisi_controller_v4_enable(host, 1);
+
+	/* Set the DMA boundary value and block size */
+	sdhci_writew(host, SDHCI_MAKE_BLKSZ(host->sdma_boundary,
+					    MMC_BLOCK_SIZE), SDHCI_BLOCK_SIZE);
+
+	/* need to set multitransfer for cmdq */
+	reg = sdhci_readw(host, SDHCI_TRANSFER_MODE);
+	reg |= SDHCI_TRNS_MULTI;
+	reg |= SDHCI_TRNS_BLK_CNT_EN;
+	sdhci_writew(host, reg, SDHCI_TRANSFER_MODE);
+
+	/* ADMA2 only */
+	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+	ctrl &= ~SDHCI_CTRL_DMA_MASK;
+	ctrl |= SDHCI_CTRL_ADMA32;
+	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk |= SDHCI_CLOCK_PLL_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	while (mmc->ops->card_busy(mmc)) {
+		timeout--;
+		if (!timeout) {
+			pr_err("%s: wait busy timeout\n", __func__);
+			break;
+		}
+		udelay(1);
+	}
+
+	sdhci_cqe_enable(mmc);
+}
+
+static void sdhci_hisi_cqe_disable(struct mmc_host *mmc, bool recovery)
+{
+	int timeout = 10000;
+
+	while (mmc->ops->card_busy(mmc)) {
+		timeout--;
+		if (!timeout) {
+			pr_err("%s: wait busy timeout\n", __func__);
+			break;
+		}
+		udelay(1);
+	}
+
+	sdhci_hisi_controller_v4_enable(mmc_priv(mmc), 0);
+
+	sdhci_cqe_disable(mmc, recovery);
+}
+
+static void sdhci_hisi_dumpregs(struct mmc_host *mmc)
+{
+	sdhci_dumpregs(mmc_priv(mmc));
+}
+
+static const struct cqhci_host_ops sdhci_hisi_cqhci_ops = {
+	.enable = sdhci_hisi_cqe_enable,
+	.disable = sdhci_hisi_cqe_disable,
+	.dumpregs = sdhci_hisi_dumpregs,
+};
+
+static const struct sdhci_ops sdhci_hisi_cqe_ops = {
+	.platform_execute_tuning = sdhci_hisi_execute_tuning,
+	.reset = sdhci_reset,
+	.set_clock = sdhci_hisi_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.set_uhs_signaling = sdhci_hisi_set_uhs_signaling,
+	.hw_reset = sdhci_hisi_hw_reset,
+	.irq = sdhci_hisi_cqhci_irq,
+	.init = sdhci_hisi_extra_init,
+};
+
+static const struct sdhci_pltfm_data sdhci_hisi_cqe_pdata = {
+	.ops = &sdhci_hisi_cqe_ops,
+	.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static int sdhci_hisi_add_host(struct sdhci_host *host)
+{
+	struct cqhci_host *cq_host = NULL;
+	bool dma64 = false;
+	int ret;
+
+	if (!(host->mmc->caps2 & MMC_CAP2_CQE))
+		return sdhci_add_host(host);
+
+	ret = sdhci_setup_host(host);
+	if (ret)
+		return ret;
+
+	cq_host = devm_kzalloc(host->mmc->parent, sizeof(*cq_host), GFP_KERNEL);
+	if (cq_host == NULL) {
+		pr_err("%s: allocate memory for CQE fail\n", __func__);
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	cq_host->mmio = host->ioaddr + 0x180;
+	cq_host->ops = &sdhci_hisi_cqhci_ops;
+
+	/*
+	 * synopsys controller has dma 128M algin limit,
+	 * may split the trans descriptors
+	 */
+	cq_host->quirks |= CQHCI_QUIRK_TXFR_DESC_SZ_SPLIT;
+
+	dma64 = host->flags & SDHCI_USE_64_BIT_DMA;
+	if (dma64)
+		cq_host->caps |= CQHCI_TASK_DESC_SZ_128;
+
+	ret = cqhci_init(cq_host, host->mmc, dma64);
+	if (ret) {
+		pr_err("%s: CQE init fail\n", __func__);
+		return ret;
+	}
+
+	ret = __sdhci_add_host(host);
+	if (ret)
+		return ret;
+
+	return 0;
+
+cleanup:
+	sdhci_cleanup_host(host);
+	return ret;
+}
+#else
+static int sdhci_hisi_add_host(struct sdhci_host *host)
+{
+	return sdhci_add_host(host);
+}
+#endif
+
+static int sdhci_hisi_probe(struct platform_device *pdev)
+{
+	struct sdhci_host *host = NULL;
+	const struct sdhci_pltfm_data *pdata = NULL;
+	int ret;
+
+#ifdef CONFIG_MMC_CQHCI
+	if (of_get_property(pdev->dev.of_node, "mmc-cmd-queue", NULL))
+		pdata = &sdhci_hisi_cqe_pdata;
+	else
+		pdata = &sdhci_hisi_pdata;
+#else
+	pdata = &sdhci_hisi_pdata;
+#endif
+	host = sdhci_pltfm_init(pdev, pdata, sizeof(struct sdhci_hisi_priv));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	ret = sdhci_hisi_pltfm_init(pdev, host);
+	if (ret)
+		goto pltfm_free;
+
+	if (hisi_support_runtime_pm(host)) {
+		pm_runtime_get_noresume(&pdev->dev);
+		pm_runtime_set_autosuspend_delay(&pdev->dev, HISI_MMC_AUTOSUSPEND_DELAY_MS);
+		pm_runtime_use_autosuspend(&pdev->dev);
+		pm_runtime_set_active(&pdev->dev);
+		pm_runtime_enable(&pdev->dev);
+	}
+
+	ret = sdhci_hisi_add_host(host);
+	if (ret)
+		goto pm_runtime_disable;
+
+	if (hisi_support_runtime_pm(host)) {
+		pm_runtime_mark_last_busy(&pdev->dev);
+		pm_runtime_put_autosuspend(&pdev->dev);
+	}
+
+	return 0;
+
+pm_runtime_disable:
+	if (hisi_support_runtime_pm(host)) {
+		pm_runtime_disable(&pdev->dev);
+		pm_runtime_set_suspended(&pdev->dev);
+		pm_runtime_put_noidle(&pdev->dev);
+	}
+
+pltfm_free:
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int sdhci_hisi_remove(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	int dead = (readl_relaxed(host->ioaddr + SDHCI_INT_STATUS) ==
+		    0xffffffff);
+
+	if (hisi_support_runtime_pm(host)) {
+		pm_runtime_get_sync(&pdev->dev);
+		pm_runtime_disable(&pdev->dev);
+		pm_runtime_put_noidle(&pdev->dev);
+	}
+
+	sdhci_remove_host(host, dead);
+	sdhci_pltfm_free(pdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sdhci_hisi_runtime_suspend(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+
+	hisi_disable_card_clk(host);
+	return 0;
+}
+
+static int sdhci_hisi_runtime_resume(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+
+	hisi_enable_card_clk(host);
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops sdhci_hisi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdhci_pltfm_suspend,
+				sdhci_pltfm_resume)
+
+	SET_RUNTIME_PM_OPS(sdhci_hisi_runtime_suspend,
+			   sdhci_hisi_runtime_resume,
+			   NULL)
+};
+
+static struct platform_driver sdhci_hisi_driver = {
+	.probe = sdhci_hisi_probe,
+	.remove = sdhci_hisi_remove,
+	.driver = {
+		.name = "sdhci_hisi",
+		.of_match_table = sdhci_hisi_match,
+		.pm = &sdhci_hisi_pm_ops,
+	},
+};
+
+static int __init sdhci_hisi_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sdhci_hisi_driver);
+	if (ret)
+		return ret;
+
+	ret = mci_proc_init();
+	if (ret)
+		platform_driver_unregister(&sdhci_hisi_driver);
+
+	return ret;
+}
+
+static void __exit sdhci_hisi_exit(void)
+{
+	mci_proc_shutdown();
+
+	platform_driver_unregister(&sdhci_hisi_driver);
+}
+
+module_init(sdhci_hisi_init);
+module_exit(sdhci_hisi_exit);
+MODULE_DESCRIPTION("SDHCI driver for Hisilicon");
+MODULE_AUTHOR("HiSilicon Technologies Co., Ltd..");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/sdhci-hisi.h b/drivers/mmc/host/sdhci-hisi.h
new file mode 100644
index 000000000..19cea6dc5
--- /dev/null
+++ b/drivers/mmc/host/sdhci-hisi.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2017-2020. All rights reserved.
+ * Description: hisi sdhci header
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _DRIVERS_MMC_SDHCI_HISI_H
+#define _DRIVERS_MMC_SDHCI_HISI_H
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/reset.h>
+#include <linux/mmc/host.h>
+#include <linux/pm_runtime.h>
+#include "sdhci-pltfm.h"
+
+#define SDHCI_HISI_EDGE_TUNING /* enable edge tuning */
+
+#define PHASE_SCALE	32
+#define NOT_FOUND	(-1)
+#define MAX_TUNING_NUM	1
+#define MAX_FREQ	200000000
+#define EDGE_TUNING_PHASE_STEP	4
+#define MMC_BLOCK_SIZE	512
+
+/* Software auto suspend delay */
+#define HISI_MMC_AUTOSUSPEND_DELAY_MS 50
+
+static inline void *sdhci_get_pltfm_priv(struct sdhci_host *host)
+{
+	return sdhci_pltfm_priv(sdhci_priv(host));
+}
+
+struct sdhci_hisi_priv {
+	struct reset_control *crg_rst;
+	struct reset_control *dll_rst;
+	struct reset_control *sampl_rst;
+	struct regmap *crg_regmap;
+	struct regmap *misc_regmap;
+	struct regmap *iocfg_regmap;
+	void __iomem *phy_addr;
+	unsigned int devid;
+	unsigned int drv_phase;
+	unsigned int sample_phase;
+	unsigned int tuning_phase;
+	unsigned int bus_width;
+};
+
+/* Hisilicon extended host controller registers. */
+#define  SDHCI_CTRL_HOST_VER4_ENABLE	0x1000
+#define  SDHCI_CLOCK_PLL_EN	0x0008
+#define  SDHCI_CTRL_64BIT_ADDR	0x2000
+#define  SDHCI_CAN_DO_ADMA3	0x08000000
+
+/* Hisilicon extended registers */
+#define SDHCI_MSHC_CTRL		0x508
+#define SDHCI_CMD_CONFLIT_CHECK	0x01
+
+#define SDHCI_AXI_MBIIU_CTRL	0x510
+#define SDHCI_GM_WR_OSRC_LMT_MASK	(0x7 << 24)
+#define SDHCI_GM_WR_OSRC_LMT_SEL(x)	((x) << 24)
+#define SDHCI_GM_RD_OSRC_LMT_MASK	(0x7 << 16)
+#define SDHCI_GM_RD_OSRC_LMT_SEL(x)	((x) << 16)
+#define SDHCI_UNDEFL_INCR_EN		0x1
+
+#define SDHCI_EMMC_CTRL		0x52C
+#define  SDHCI_CARD_IS_EMMC	0x0001
+#define  SDHCI_ENH_STROBE_EN	0x0100
+
+#define SDHCI_EMMC_HW_RESET	0x534
+
+#define SDHCI_AT_CTRL		0x540
+#define  SDHCI_SAMPLE_EN	0x00000010
+
+#define SDHCI_AT_STAT		0x544
+#define  SDHCI_PHASE_SEL_MASK	0x000000FF
+
+#define SDHCI_MULTI_CYCLE	0x54C
+#define  SDHCI_FOUND_EDGE	(0x1 << 11)
+#define  SDHCI_EDGE_DETECT_EN	(0x1 << 8)
+#define  SDHCI_DOUT_EN_F_EDGE	(0x1 << 6)
+#define  SDHCI_DATA_DLY_EN	(0x1 << 3)
+#define  SDHCI_CMD_DLY_EN	(0x1 << 2)
+
+void hisi_set_drv_cap(struct sdhci_host *host);
+void hisi_get_phase(struct sdhci_host *host);
+void hisi_set_drv_phase(struct sdhci_host *host, unsigned int phase);
+void hisi_enable_sample(struct sdhci_host *host);
+void hisi_set_sample_phase(struct sdhci_host *host, u32 phase);
+void hisi_disable_card_clk(struct sdhci_host *host);
+void hisi_enable_card_clk(struct sdhci_host *host);
+void hisi_disable_internal_clk(struct sdhci_host *host);
+void hisi_enable_internal_clk(struct sdhci_host *host);
+void hisi_enable_sample_dll_slave(struct sdhci_host *host);
+void hisi_wait_sample_dll_ready(struct sdhci_host *host);
+void hisi_wait_p4_dll_lock(struct sdhci_host *host);
+void hisi_wait_ds_dll_ready(struct sdhci_host *host);
+void hisi_wait_ds_180_dll_ready(struct sdhci_host *host);
+void hisi_wait_ds_dll_lock(struct sdhci_host *host);
+void hisi_set_ds_dll_delay(struct sdhci_host *host);
+void sdhci_hisi_set_clock(struct sdhci_host *host, unsigned int clk);
+int hisi_support_runtime_pm(struct sdhci_host *host);
+int sdhci_hisi_pltfm_init(struct platform_device *pdev,
+    struct sdhci_host *host);
+void sdhci_hisi_extra_init(struct sdhci_host *host);
+int sdhci_hisi_parse_dt(struct sdhci_host *host);
+int sdhci_hisi_start_signal_voltage_switch(struct sdhci_host *host,
+    struct mmc_ios *ios);
+
+#endif /* _DRIVERS_MMC_SDHCI_HISI_H */
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 07d131fac..49ee7d99b 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -261,7 +261,7 @@ static void sdhci_set_default_irqs(struct sdhci_host *host)
 		    SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT |
 		    SDHCI_INT_INDEX | SDHCI_INT_END_BIT | SDHCI_INT_CRC |
 		    SDHCI_INT_TIMEOUT | SDHCI_INT_DATA_END |
-		    SDHCI_INT_RESPONSE;
+		    SDHCI_INT_RESPONSE | SDHCI_INT_AUTO_CMD_ERR;
 
 	if (host->tuning_mode == SDHCI_TUNING_MODE_2 ||
 	    host->tuning_mode == SDHCI_TUNING_MODE_3)
@@ -291,8 +291,12 @@ static void sdhci_config_dma(struct sdhci_host *host)
 		goto out;
 
 	/* Note if DMA Select is zero then SDMA is selected */
-	if (host->flags & SDHCI_USE_ADMA)
+	if (host->flags & SDHCI_USE_ADMA) {
 		ctrl |= SDHCI_CTRL_ADMA32;
+		if (host->flags & SDHCI_USE_ADMA3) {
+			ctrl |= SDHCI_CTRL_ADMA3;
+		}
+	}
 
 	if (host->flags & SDHCI_USE_64_BIT_DMA) {
 		/*
@@ -341,6 +345,9 @@ static void sdhci_init(struct sdhci_host *host, int soft)
 		host->clock = 0;
 		mmc->ops->set_ios(mmc, &mmc->ios);
 	}
+
+	if (host->ops->init)
+		host->ops->init(host);
 }
 
 static void sdhci_reinit(struct sdhci_host *host)
@@ -478,6 +485,28 @@ static void sdhci_del_timer(struct sdhci_host *host, struct mmc_request *mrq)
 		del_timer(&host->timer);
 }
 
+static void __sdhci_noadma3_set_cmd_arg(struct sdhci_host *host, struct mmc_command *cmd)
+{
+	if (!(host->flags & SDHCI_USE_ADMA3) || !cmd->data)
+		sdhci_writel(host, cmd->arg, SDHCI_ARGUMENT);
+}
+
+static void __sdhci_prep_adma3(struct sdhci_host *host,
+		struct mmc_command *cmd, int *flags)
+{
+	if ((host->flags & SDHCI_USE_ADMA3) && cmd->data) {
+		sdhci_prep_adma3_desc(host, cmd, *flags);
+
+		sdhci_writel(host, (u32)host->adma3_addr,
+				SDHCI_ADMA3_ID_ADDR_LOW);
+		if (host->flags & SDHCI_USE_64_BIT_DMA)
+			sdhci_writel(host, (u32)((u64)host->adma3_addr >> 32),  // right shift 32
+					SDHCI_ADMA3_ID_ADDR_HI);
+	} else {
+		sdhci_writew(host, SDHCI_MAKE_CMD(cmd->opcode, *flags), SDHCI_COMMAND);
+	}
+}
+
 static inline bool sdhci_has_requests(struct sdhci_host *host)
 {
 	return host->cmd || host->data_cmd;
@@ -700,6 +729,60 @@ void sdhci_adma_write_desc(struct sdhci_host *host, void **desc,
 }
 EXPORT_SYMBOL_GPL(sdhci_adma_write_desc);
 
+static void sdhci_write_cmd_table(u8 *desc, u32 reg, u32 attr)
+{
+	__le32 *reg_addr = (__le32 __force *)(desc + 4);  // offset 4
+	__le32 *attr_addr = (__le32 __force *)desc;
+
+	attr_addr[0] = cpu_to_le32(attr);
+	reg_addr[0] = cpu_to_le32(reg);
+}
+
+static void sdhci_write_adma3_desc(struct sdhci_host *host, u8 *desc,
+		dma_addr_t addr, unsigned int attr)
+{
+	__le32 *attr_addr = (__le32 __force *)desc;
+
+	attr_addr[0] = cpu_to_le32(attr);
+
+	if (host->flags & SDHCI_USE_64_BIT_DMA) {
+		__le64 *cmd_ddr = (__le64 __force *)(desc + 4);  // offset 4
+		cmd_ddr[0] = cpu_to_le64(addr);
+	} else {
+		__le32 *cmd_ddr = (__le32 __force *)(desc + 4);  // offset 4
+		cmd_ddr[0] = cpu_to_le32(addr);
+	}
+}
+
+static void sdhci_prep_adma3_desc(struct sdhci_host *host,
+		struct mmc_command *cmd, int flags)
+{
+	struct mmc_data *data = cmd->data;
+	unsigned int ctrl_2, cmd_xfer, blksz;
+	u16 mode;
+
+	blksz = SDHCI_MAKE_BLKSZ(0, data->blksz);
+	mode = sdhci_readw(host, SDHCI_TRANSFER_MODE);
+	cmd_xfer = (SDHCI_MAKE_CMD(cmd->opcode, flags) << 16) | mode;  // left shift 16
+
+	sdhci_write_cmd_table(host->cmd_table, data->blocks, ADMA3_CMD_VALID);
+	sdhci_write_cmd_table(host->cmd_table + 0x8, blksz, ADMA3_CMD_VALID);  // add 0x8
+	sdhci_write_cmd_table(host->cmd_table + 0x10,    // add 0x10
+			cmd->arg, ADMA3_CMD_VALID);
+	sdhci_write_cmd_table(host->cmd_table + 0x18,  // add 0x18
+			cmd_xfer, ADMA3_CMD_VALID);
+	sdhci_adma_write_desc(host, host->cmd_table + 0x20,  // add 0x20
+			host->adma_addr, 0x0, ADMA2_LINK_VALID);
+	sdhci_write_adma3_desc(host, host->adma3_table,
+			host->cmd_addr, ADMA3_END);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 |= SDHCI_CTRL_HOST_VER4_ENABLE;
+	if (host->flags & SDHCI_USE_64_BIT_DMA)
+		ctrl_2 |= SDHCI_CTRL_ADDRESSING_64BIT;
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
 static inline void __sdhci_adma_write_desc(struct sdhci_host *host,
 					   void **desc, dma_addr_t addr,
 					   int len, unsigned int cmd)
@@ -774,10 +857,22 @@ static void sdhci_adma_table_pre(struct sdhci_host *host,
 
 		BUG_ON(len > 65536);
 
-		/* tran, valid */
-		if (len)
-			__sdhci_adma_write_desc(host, &desc, addr, len,
+ 		if (len) {
+			/* work around for buffer across 128M boundary, split the buffer */
+			if (((addr & (SDHCI_DMA_BOUNDARY_SIZE - 1)) + len) >
+					SDHCI_DMA_BOUNDARY_SIZE) {
+				offset = SDHCI_DMA_BOUNDARY_SIZE -
+					(addr & (SDHCI_DMA_BOUNDARY_SIZE - 1));
+				sdhci_adma_write_desc(host, desc, addr, offset,
 						ADMA2_TRAN_VALID);
+				desc += host->desc_sz;
+				addr += offset;
+				len -= offset;
+			}
+ 			/* tran, valid */
+ 			sdhci_adma_write_desc(host, desc, addr, len,
+ 					      ADMA2_TRAN_VALID);
+		}
 
 		/*
 		 * If this triggers then we have a calculation bug
@@ -1040,6 +1135,18 @@ static void sdhci_set_timeout(struct sdhci_host *host, struct mmc_command *cmd)
 		__sdhci_set_timeout(host, cmd);
 }
 
+static void __sdhci_select_adma3_mode(struct sdhci_host *host, u8 *ctrl)
+{
+	if (host->flags & SDHCI_USE_ADMA3) {
+		*ctrl |= SDHCI_CTRL_ADMA3;
+	} else {
+		if (host->flags & SDHCI_USE_64_BIT_DMA)
+			*ctrl |= SDHCI_CTRL_ADMA64;
+		else
+			*ctrl |= SDHCI_CTRL_ADMA32;
+	}
+}
+
 static void sdhci_initialize_data(struct sdhci_host *host,
 				  struct mmc_data *data)
 {
@@ -1134,7 +1241,6 @@ static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
 
 	if (host->flags & SDHCI_REQ_USE_DMA) {
 		int sg_cnt = sdhci_pre_dma_transfer(host, data, COOKIE_MAPPED);
-
 		if (sg_cnt <= 0) {
 			/*
 			 * This only happens when someone fed
@@ -1633,7 +1739,7 @@ static bool sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 			sdhci_prepare_data(host, cmd);
 	}
 
-	sdhci_writel(host, cmd->arg, SDHCI_ARGUMENT);
+	__sdhci_noadma3_set_cmd_arg(host, cmd);
 
 	sdhci_set_transfer_mode(host, cmd);
 
@@ -1678,7 +1784,7 @@ static bool sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 	if (host->use_external_dma)
 		sdhci_external_dma_pre_transfer(host, cmd);
 
-	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->opcode, flags), SDHCI_COMMAND);
+	__sdhci_prep_adma3(host, cmd, &flags);
 
 	return true;
 }
@@ -1755,6 +1861,14 @@ static void sdhci_read_rsp_136(struct sdhci_host *host, struct mmc_command *cmd)
 	}
 }
 
+#define CMD_ERRORS                          \
+	(R1_OUT_OF_RANGE |  /* Command argument out of range */ \
+	 R1_ADDRESS_ERROR | /* Misaligned address */        \
+	 R1_BLOCK_LEN_ERROR |   /* Transferred block length incorrect */\
+	 R1_WP_VIOLATION |  /* Tried to write to protected block */ \
+	 R1_CC_ERROR |      /* Card controller error */     \
+	 R1_ERROR)      /* General/unknown error */
+
 static void sdhci_finish_command(struct sdhci_host *host)
 {
 	struct mmc_command *cmd = host->cmd;
@@ -1767,6 +1881,12 @@ static void sdhci_finish_command(struct sdhci_host *host)
 		} else {
 			cmd->resp[0] = sdhci_readl(host, SDHCI_RESPONSE);
 		}
+
+		if (((cmd->flags & MMC_RSP_R1) == MMC_RSP_R1) &&
+			((cmd->flags & MMC_CMD_MASK) != MMC_CMD_BCR)) {
+			if ((cmd->resp[0] & CMD_ERRORS) && !host->is_tuning)
+				host->error_count++;
+		}
 	}
 
 	if (cmd->mrq->cap_cmd_during_tfr && cmd == cmd->mrq->cmd)
@@ -2067,6 +2187,12 @@ void sdhci_set_power_noreg(struct sdhci_host *host, unsigned char mode,
 		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
 		if (host->quirks2 & SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)
 			sdhci_runtime_pm_bus_off(host);
+		/*
+		 * Controllers need an extra 100ms delay to ensure power off
+		 * completely
+		 */
+		msleep(100);
+
 	} else {
 		/*
 		 * Spec says that we should clear the power reg before setting
@@ -2388,7 +2514,9 @@ void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		}
 
 		/* Re-enable SD Clock */
-		host->ops->set_clock(host, host->clock);
+		clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+		clk |= SDHCI_CLOCK_CARD_EN;
+		sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
 	} else
 		sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
 
@@ -2529,6 +2657,9 @@ int sdhci_start_signal_voltage_switch(struct mmc_host *mmc,
 	u16 ctrl;
 	int ret;
 
+	if (host->ops->start_signal_voltage_switch)
+		return host->ops->start_signal_voltage_switch(host, ios);
+
 	/*
 	 * Signal Voltage Switching is only applicable for Host Controllers
 	 * v3.00 and above.
@@ -2966,6 +3097,34 @@ static void sdhci_card_event(struct mmc_host *mmc)
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
+static int sdhci_card_info_save(struct mmc_host *mmc)
+{
+	struct mmc_card *card = mmc->card;
+	struct sdhci_host *host= mmc_priv(mmc);
+	struct card_info *c_info = &host->c_info;
+
+	if (!card) {
+		memset(c_info,0,sizeof(struct card_info));
+		c_info->card_connect = CARD_DISCONNECT;
+		goto out;
+	}
+
+	c_info->card_type = card->type;
+	c_info->card_state = card->state;
+
+	c_info->timing = mmc->ios.timing;
+	c_info->enhanced_strobe = mmc->ios.enhanced_strobe;
+	c_info->card_support_clock = mmc->ios.clock;
+
+	c_info->sd_bus_speed = card->sd_bus_speed;
+
+	memcpy(c_info->ssr, card->raw_ssr, ARRAY_SIZE(c_info->ssr));
+
+	c_info->card_connect = CARD_CONNECT;
+out:
+	return 0;
+}
+
 static const struct mmc_host_ops sdhci_ops = {
 	.request	= sdhci_request,
 	.post_req	= sdhci_post_req,
@@ -2981,6 +3140,7 @@ static const struct mmc_host_ops sdhci_ops = {
 	.execute_tuning			= sdhci_execute_tuning,
 	.card_event			= sdhci_card_event,
 	.card_busy	= sdhci_card_busy,
+	.card_info_save = sdhci_card_info_save,
 };
 
 /*****************************************************************************\
@@ -3039,6 +3199,9 @@ static bool sdhci_request_done(struct sdhci_host *host)
 		host->pending_reset = false;
 	}
 
+	if (mrq->data && mrq->data->error && !host->is_tuning)
+		host->error_count++;
+
 	/*
 	 * Always unmap the data buffers if they were mapped by
 	 * sdhci_prepare_data() whenever we finish with a request.
@@ -3181,6 +3344,24 @@ static void sdhci_timeout_data_timer(struct timer_list *t)
  *                                                                           *
 \*****************************************************************************/
 
+static void __sdhci_handle_auto_cmd_err(struct sdhci_host *host, u32 *intmask)
+{
+	if (*intmask & SDHCI_INT_AUTO_CMD_ERR) {
+		u16 acmd_stat = sdhci_readw(host, SDHCI_AUTO_CMD_STATUS);
+		if (acmd_stat & (SDHCI_AUTO_CMD12_NOT_EXEC |
+					SDHCI_AUTO_CMD_INDEX |
+					SDHCI_AUTO_CMD12_NOT_ISSUED))
+			host->cmd->error = -EIO;
+		else if (acmd_stat & SDHCI_AUTO_CMD_TIMEOUT)
+			host->cmd->error = -ETIMEDOUT;
+		else
+			host->cmd->error = -EILSEQ;
+
+	} else {
+		host->cmd->error = -EILSEQ;
+	}
+}
+
 static void sdhci_cmd_irq(struct sdhci_host *host, u32 intmask, u32 *intmask_p)
 {
 	/* Handle auto-CMD12 error */
@@ -3206,18 +3387,21 @@ static void sdhci_cmd_irq(struct sdhci_host *host, u32 intmask, u32 *intmask_p)
 		 */
 		if (host->pending_reset)
 			return;
-		pr_err("%s: Got command interrupt 0x%08x even though no command operation was in progress.\n",
+
+		/*pr_err("%s: Got command interrupt 0x%08x even though no command operation was in progress.\n",
 		       mmc_hostname(host->mmc), (unsigned)intmask);
-		sdhci_dumpregs(host);
+		sdhci_dumpregs(host);*/
+
 		return;
 	}
 
 	if (intmask & (SDHCI_INT_TIMEOUT | SDHCI_INT_CRC |
-		       SDHCI_INT_END_BIT | SDHCI_INT_INDEX)) {
+		       SDHCI_INT_END_BIT | SDHCI_INT_INDEX |
+		       SDHCI_INT_AUTO_CMD_ERR)) {
 		if (intmask & SDHCI_INT_TIMEOUT)
 			host->cmd->error = -ETIMEDOUT;
 		else
-			host->cmd->error = -EILSEQ;
+			__sdhci_handle_auto_cmd_err(host, &intmask);
 
 		/* Treat data command CRC error the same as data CRC error */
 		if (host->cmd->data &&
@@ -3442,6 +3626,9 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 	do {
 		DBG("IRQ status 0x%08x\n", intmask);
 
+		if ((intmask & SDHCI_INT_ERROR) && !host->is_tuning)
+			host->error_count++;
+
 		if (host->ops->irq) {
 			intmask = host->ops->irq(host, intmask);
 			if (!intmask)
@@ -3801,10 +3988,11 @@ void sdhci_cqe_enable(struct mmc_host *mmc)
 {
 	struct sdhci_host *host = mmc_priv(mmc);
 	unsigned long flags;
+#ifndef CONFIG_MMC_SDHCI_HISI
 	u8 ctrl;
-
+#endif
 	spin_lock_irqsave(&host->lock, flags);
-
+#ifndef CONFIG_MMC_SDHCI_HISI
 	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
 	ctrl &= ~SDHCI_CTRL_DMA_MASK;
 	/*
@@ -3822,7 +4010,7 @@ void sdhci_cqe_enable(struct mmc_host *mmc)
 
 	sdhci_writew(host, SDHCI_MAKE_BLKSZ(host->sdma_boundary, 512),
 		     SDHCI_BLOCK_SIZE);
-
+#endif
 	/* Set maximum timeout */
 	sdhci_set_timeout(host, NULL);
 
@@ -4099,6 +4287,72 @@ static void sdhci_allocate_bounce_buffer(struct sdhci_host *host)
 		mmc_hostname(mmc), max_blocks, bounce_size);
 }
 
+static void __sdhci_support_adma3(struct sdhci_host *host)
+{
+	if ((host->version >= SDHCI_SPEC_400) &&
+		(host->caps1 & SDHCI_CAN_DO_ADMA3))
+		host->flags |= SDHCI_USE_ADMA3 | SDHCI_HOST_VER4_ENABLE;
+
+	if ((host->quirks2 & SDHCI_QUIRK2_BROKEN_ADMA3) &&
+			(host->flags & SDHCI_USE_ADMA3)) {
+		DBG("Disabling ADMA3 as it is marked broken\n");
+		host->flags &= ~(SDHCI_USE_ADMA3 | SDHCI_HOST_VER4_ENABLE);
+	}
+}
+
+static void __sdhci_set_dma_descriptor_size(struct sdhci_host *host)
+{
+	if (host->flags & SDHCI_HOST_VER4_ENABLE)
+		host->desc_sz = 16;  //descriptor size 16
+	else
+		host->desc_sz = SDHCI_ADMA2_64_DESC_SZ;
+}
+
+static void __sdhci_set_adma_cmd_table(struct sdhci_host *host,
+		void *buf, dma_addr_t *dma, struct mmc_host *mmc)
+{
+	if (!(host->flags & SDHCI_USE_ADMA))
+		host->flags &= ~SDHCI_USE_ADMA3;
+
+	if (host->flags & SDHCI_USE_ADMA3) {
+#define MAX_CMD_NUM	32
+#define SDHCI_CMD_DESC_SZ	16
+		if (host->flags & SDHCI_USE_64_BIT_DMA)
+			host->adma3_desc_sz = SDHCI_ADMA3_64_DESC_SZ;
+		else
+			host->adma3_desc_sz = SDHCI_ADMA3_32_DESC_SZ;
+
+		host->adma3_table_sz = MAX_CMD_NUM * host->adma3_desc_sz;
+		host->cmd_table_sz = MAX_CMD_NUM *
+					(SDHCI_CMD_DESC_SZ + 16);  // offset 16
+		buf = dma_alloc_coherent(mmc_dev(mmc), host->adma3_table_sz +
+				host->cmd_table_sz, dma, GFP_KERNEL);
+		if (!buf) {
+			pr_warn("%s: Unable to allocate ADMA3 buffers - falling back \
+					to standard DMA\n", mmc_hostname(mmc));
+			host->flags &= ~SDHCI_USE_ADMA3;
+		} else {
+			host->adma3_table = buf;
+			host->adma3_addr = *dma;
+
+			host->cmd_table = buf + host->adma3_desc_sz;
+			host->cmd_addr = *dma + host->adma3_desc_sz;
+		}
+	}
+}
+
+static void __sdhci_release_adma3_cmd_table(struct sdhci_host *host,
+		struct mmc_host *mmc)
+{
+	if (host->adma3_table)
+		dma_free_coherent(mmc_dev(mmc), host->adma3_table_sz +
+				  host->cmd_table_sz, host->adma3_table,
+				  host->adma3_addr);
+
+	host->adma3_table = NULL;
+	host->cmd_table = NULL;
+}
+
 static inline bool sdhci_can_64bit_dma(struct sdhci_host *host)
 {
 	/*
@@ -4180,6 +4434,8 @@ int sdhci_setup_host(struct sdhci_host *host)
 		host->flags &= ~SDHCI_USE_ADMA;
 	}
 
+	__sdhci_support_adma3(host);
+
 	if (sdhci_can_64bit_dma(host))
 		host->flags |= SDHCI_USE_64_BIT_DMA;
 
@@ -4258,6 +4514,7 @@ int sdhci_setup_host(struct sdhci_host *host)
 			host->adma_table = buf + host->align_buffer_sz;
 			host->adma_addr = dma + host->align_buffer_sz;
 		}
+		__sdhci_set_adma_cmd_table(host, buf, &dma, mmc);
 	}
 
 	/*
@@ -4506,7 +4763,6 @@ int sdhci_setup_host(struct sdhci_host *host)
 	if (!max_current_caps && !IS_ERR(mmc->supply.vmmc)) {
 		int curr = regulator_get_current_limit(mmc->supply.vmmc);
 		if (curr > 0) {
-
 			/* convert to SDHCI_MAX_CURRENT format */
 			curr = curr/1000;  /* convert to mA */
 			curr = curr/SDHCI_MAX_CURRENT_MULTIPLIER;
@@ -4659,6 +4915,8 @@ int sdhci_setup_host(struct sdhci_host *host)
 	host->adma_table = NULL;
 	host->align_buffer = NULL;
 
+	__sdhci_release_adma3_cmd_table(host, mmc);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(sdhci_setup_host);
@@ -4680,6 +4938,8 @@ void sdhci_cleanup_host(struct sdhci_host *host)
 
 	host->adma_table = NULL;
 	host->align_buffer = NULL;
+
+	__sdhci_release_adma3_cmd_table(host, mmc);
 }
 EXPORT_SYMBOL_GPL(sdhci_cleanup_host);
 
@@ -4729,6 +4989,7 @@ int __sdhci_add_host(struct sdhci_host *host)
 
 	pr_info("%s: SDHCI controller on %s [%s] using %s\n",
 		mmc_hostname(mmc), host->hw_name, dev_name(mmc_dev(mmc)),
+		(host->flags & SDHCI_USE_ADMA3) ? "ADMA3" :
 		host->use_external_dma ? "External DMA" :
 		(host->flags & SDHCI_USE_ADMA) ?
 		(host->flags & SDHCI_USE_64_BIT_DMA) ? "ADMA 64-bit" : "ADMA" :
@@ -4794,6 +5055,8 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 
 	sdhci_disable_card_detection(host);
 
+	free_irq(host->irq, host);
+
 	mmc_remove_host(mmc);
 
 	sdhci_led_unregister(host);
@@ -4803,7 +5066,6 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 
 	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
 	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
-	free_irq(host->irq, host);
 
 	del_timer_sync(&host->timer);
 	del_timer_sync(&host->data_timer);
@@ -4823,6 +5085,8 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 
 	host->adma_table = NULL;
 	host->align_buffer = NULL;
+
+	__sdhci_release_adma3_cmd_table(host, mmc);
 }
 
 EXPORT_SYMBOL_GPL(sdhci_remove_host);
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 960fed785..4688a612b 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -140,6 +140,7 @@
 #define  SDHCI_INT_CARD_INT	0x00000100
 #define  SDHCI_INT_RETUNE	0x00001000
 #define  SDHCI_INT_CQE		0x00004000
+#define  SDHCI_INT_CQE		0x00004000
 #define  SDHCI_INT_ERROR	0x00008000
 #define  SDHCI_INT_TIMEOUT	0x00010000
 #define  SDHCI_INT_CRC		0x00020000
@@ -173,10 +174,12 @@
 #define SDHCI_CQE_INT_MASK (SDHCI_CQE_INT_ERR_MASK | SDHCI_INT_CQE)
 
 #define SDHCI_AUTO_CMD_STATUS	0x3C
+#define SDHCI_AUTO_CMD12_NOT_EXEC	0x0001
 #define  SDHCI_AUTO_CMD_TIMEOUT	0x00000002
 #define  SDHCI_AUTO_CMD_CRC	0x00000004
 #define  SDHCI_AUTO_CMD_END_BIT	0x00000008
 #define  SDHCI_AUTO_CMD_INDEX	0x00000010
+#define SDHCI_AUTO_CMD12_NOT_ISSUED	0x0080
 
 #define SDHCI_HOST_CONTROL2		0x3E
 #define  SDHCI_CTRL_UHS_MASK		0x0007
@@ -185,7 +188,7 @@
 #define   SDHCI_CTRL_UHS_SDR50		0x0002
 #define   SDHCI_CTRL_UHS_SDR104		0x0003
 #define   SDHCI_CTRL_UHS_DDR50		0x0004
-#define   SDHCI_CTRL_HS400		0x0005 /* Non-standard */
+#define   SDHCI_CTRL_HS400		0x0007 /* Non-standard */
 #define  SDHCI_CTRL_VDD_180		0x0008
 #define  SDHCI_CTRL_DRV_TYPE_MASK	0x0030
 #define   SDHCI_CTRL_DRV_TYPE_B		0x0000
@@ -194,6 +197,9 @@
 #define   SDHCI_CTRL_DRV_TYPE_D		0x0030
 #define  SDHCI_CTRL_EXEC_TUNING		0x0040
 #define  SDHCI_CTRL_TUNED_CLK		0x0080
+#define  SDHCI_CTRL_HOST_VER4_ENABLE	0x1000
+#define  SDHCI_CTRL_ADDRESSING_64BIT	0x2000
+#define  SDHCI_CTRL_ASYNC_INT_ENABLE	0x4000
 #define  SDHCI_CMD23_ENABLE		0x0800
 #define  SDHCI_CTRL_V4_MODE		0x1000
 #define  SDHCI_CTRL_64BIT_ADDR		0x2000
@@ -217,6 +223,7 @@
 #define  SDHCI_CAN_VDD_180	0x04000000
 #define  SDHCI_CAN_64BIT_V4	0x08000000
 #define  SDHCI_CAN_64BIT	0x10000000
+#define  SDHCI_CAN_ASYNC_INT	0x20000000
 
 #define SDHCI_CAPABILITIES_1	0x44
 #define  SDHCI_SUPPORT_SDR50	0x00000001
@@ -264,6 +271,9 @@
 #define SDHCI_PRESET_CLKGEN_SEL		BIT(10)
 #define SDHCI_PRESET_SDCLK_FREQ_MASK	GENMASK(9, 0)
 
+#define SDHCI_ADMA3_ID_ADDR_LOW	0x78
+#define SDHCI_ADMA3_ID_ADDR_HI	0x7C
+
 #define SDHCI_SLOT_INT_STATUS	0xFC
 
 #define SDHCI_HOST_VERSION	0xFE
@@ -290,6 +300,7 @@
  */
 #define SDHCI_DEFAULT_BOUNDARY_SIZE  (512 * 1024)
 #define SDHCI_DEFAULT_BOUNDARY_ARG   (ilog2(SDHCI_DEFAULT_BOUNDARY_SIZE) - 12)
+#define SDHCI_DMA_BOUNDARY_SIZE	     (0x1 << 27)
 
 /* ADMA2 32-bit DMA descriptor size */
 #define SDHCI_ADMA2_32_DESC_SZ	8
@@ -321,6 +332,12 @@ struct sdhci_adma2_32_desc {
  */
 #define SDHCI_ADMA2_64_DESC_SZ(host)	((host)->v4_mode ? 16 : 12)
 
+/* ADMA3 32-bit DMA descriptor size */
+#define SDHCI_ADMA3_32_DESC_SZ	8
+
+/* ADMA3 64-bit DMA descriptor size */
+#define SDHCI_ADMA3_64_DESC_SZ	16
+
 /*
  * ADMA2 64-bit descriptor. Note 12-byte descriptor can't always be 8-byte
  * aligned.
@@ -335,6 +352,9 @@ struct sdhci_adma2_64_desc {
 #define ADMA2_TRAN_VALID	0x21
 #define ADMA2_NOP_END_VALID	0x3
 #define ADMA2_END		0x2
+#define ADMA2_LINK_VALID	0x31
+#define ADMA3_CMD_VALID		0x9
+#define ADMA3_END		0x3b
 
 /*
  * Maximum segments assuming a 512KiB maximum requisition size and a minimum
@@ -359,6 +379,19 @@ enum sdhci_cookie {
 	COOKIE_MAPPED,		/* mapped by sdhci_prepare_data() */
 };
 
+struct card_info {
+	unsigned int     card_type;
+	unsigned char    timing;
+	bool enhanced_strobe;
+	unsigned char    card_connect;
+#define CARD_CONNECT    1
+#define CARD_DISCONNECT 0
+	unsigned int     card_support_clock; /* clock rate */
+	unsigned int     card_state;      /* (our) card state */
+	unsigned int     sd_bus_speed;
+	unsigned int     ssr[16];
+};
+
 struct sdhci_host {
 	/* Data set by hardware interface driver */
 	const char *hw_name;	/* Hardware bus name */
@@ -460,6 +493,7 @@ struct sdhci_host {
 #define SDHCI_QUIRK2_ACMD23_BROKEN			(1<<14)
 /* Broken Clock divider zero in controller */
 #define SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN		(1<<15)
+#define SDHCI_QUIRK2_BROKEN_ADMA3			(1<<16)
 /* Controller has CRC in 136 bit Command Response */
 #define SDHCI_QUIRK2_RSP_136_HAS_CRC			(1<<16)
 /*
@@ -510,6 +544,8 @@ struct sdhci_host {
 #define SDHCI_SIGNALING_330	(1<<14)	/* Host is capable of 3.3V signaling */
 #define SDHCI_SIGNALING_180	(1<<15)	/* Host is capable of 1.8V signaling */
 #define SDHCI_SIGNALING_120	(1<<16)	/* Host is capable of 1.2V signaling */
+#define SDHCI_USE_ADMA3		(1<<17)	/* Host is ADMA3 capable */
+#define SDHCI_HOST_VER4_ENABLE	(1<<18) /* Host version 4 enable */
 
 	unsigned int version;	/* SDHCI spec. version */
 
@@ -543,14 +579,21 @@ struct sdhci_host {
 
 	void *adma_table;	/* ADMA descriptor table */
 	void *align_buffer;	/* Bounce buffer */
+	void *adma3_table;	/* ADMA3 integrated descriptor table */
+	void *cmd_table;	/* ADMA3 command descriptor table */
 
 	size_t adma_table_sz;	/* ADMA descriptor table size */
 	size_t align_buffer_sz;	/* Bounce buffer size */
+	size_t adma3_table_sz;	/* ADMA3 integrated descriptor table size */
+	size_t cmd_table_sz;	/* ADMA3 command descriptor table size */
 
 	dma_addr_t adma_addr;	/* Mapped ADMA descr. table */
 	dma_addr_t align_addr;	/* Mapped bounce buffer */
+	dma_addr_t adma3_addr;	/* Mapped ADMA3 integrated descr. table */
+	dma_addr_t cmd_addr;	/* Mapped ADMA3 command descr. table */
 
 	unsigned int desc_sz;	/* ADMA current descriptor size */
+	unsigned int adma3_desc_sz;	/* ADMA3 integrated descriptor size */
 	unsigned int alloc_desc_sz;	/* ADMA descr. max size host supports */
 
 	struct workqueue_struct *complete_wq;	/* Request completion wq */
@@ -606,6 +649,10 @@ struct sdhci_host {
 
 	u64			data_timeout;
 
+	u32			is_tuning;
+	unsigned int		error_count;
+	struct card_info 	c_info;
+
 	unsigned long private[] ____cacheline_aligned;
 };
 
@@ -645,6 +692,9 @@ struct sdhci_ops {
 	void    (*adma_workaround)(struct sdhci_host *host, u32 intmask);
 	void    (*card_event)(struct sdhci_host *host);
 	void	(*voltage_switch)(struct sdhci_host *host);
+	void	(*init)(struct sdhci_host *host);
+	int	(*start_signal_voltage_switch)(struct sdhci_host *host,
+					       struct mmc_ios *ios);
 	void	(*adma_write_desc)(struct sdhci_host *host, void **desc,
 				   dma_addr_t addr, int len, unsigned int cmd);
 	void	(*copy_to_bounce_buffer)(struct sdhci_host *host,
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index 593d0593a..cdf3ff323 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -26,8 +26,9 @@ obj-$(CONFIG_MTD_SWAP)		+= mtdswap.o
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
 
-obj-y		+= chips/ lpddr/ maps/ devices/ nand/ tests/
 
 obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor/
+obj-y		+= chips/ lpddr/ maps/ devices/ nand/ tests/
+
 obj-$(CONFIG_MTD_UBI)		+= ubi/
 obj-$(CONFIG_MTD_HYPERBUS)	+= hyperbus/
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 4a9aed4f0..5c3e95668 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -6,7 +6,32 @@ config MTD_NAND_CORE
 	tristate
 
 source "drivers/mtd/nand/onenand/Kconfig"
+
+config MTD_SPI_NAND_HISI_BVT
+    tristate "Support for SPI NAND controller on Hisilicon SoCs"
+    depends on MTD_NAND
+    help
+      Enables support for the SPI NAND device drivers.
+
+config HISI_NAND_ECC_STATUS_REPORT
+	tristate "Report the ecc status to MTD for HiSilicon Nand Driver"
+	depends on MTD_NAND && ARCH_HISI_BVT
+	default n
+	help
+	  Flash Memory Controller reports the ecc status include ECC error
+	  and ECC corrected to MTD to monitor the aging of devices.
+
+config HISI_NAND_FS_MAY_NO_YAFFS2
+    bool "Remove the restraintion of 16bit ecc type on yaffs2 to HiSilicon"
+	depends on MFD_HISI_FMC
+    default n
+    help
+      The ecc type: 16bit is limited by the HiSilicon flash memory controller,
+      as the yaffs2 tag of hisi rootfs limits the min size of CTRL len is 28.
+
 source "drivers/mtd/nand/raw/Kconfig"
+source "drivers/mtd/nand/hifmc100/Kconfig"
+source "drivers/mtd/nand/hifmc100_nand/Kconfig"
 source "drivers/mtd/nand/spi/Kconfig"
 
 menu "ECC engine support"
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 981372953..4fb87a5c3 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -1,6 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0
 
 nandcore-objs := core.o bbt.o
+obj-$(CONFIG_MTD_NAND_HIFMC100)		+= hifmc100_nand/
+obj-$(CONFIG_MTD_SPI_NAND_HIFMC100)	+= hifmc100/
 obj-$(CONFIG_MTD_NAND_CORE) += nandcore.o
 
 obj-y	+= onenand/
diff --git a/drivers/mtd/nand/hifmc100/Kconfig b/drivers/mtd/nand/hifmc100/Kconfig
new file mode 100644
index 000000000..5b15bc8b9
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100/Kconfig
@@ -0,0 +1,17 @@
+#
+# hisilicon flash memory controller SPI nand device driver version 100
+# drivers/mtd/nand/hifmc100/Kconfig
+# add by hisilicon 2017.8.7
+#
+
+config MTD_SPI_NAND_HIFMC100
+	bool "Hisilicon Flash Memory Controller v100 SPI Nand devices support"
+	depends on MFD_HISI_FMC && MTD_SPI_NAND_HISI_BVT
+	select MISC_FILESYSTEMS
+	select MTD_BLOCK
+	select YAFFS_FS
+	select YAFFS_YAFFS2
+	help
+	  Hisilicon Flash Memory Controller version 100 is called hifmc100 for
+	  short. The controller driver support registers and DMA transfers
+	  while reading or writing the SPI nand flash.
diff --git a/drivers/mtd/nand/hifmc100/Makefile b/drivers/mtd/nand/hifmc100/Makefile
new file mode 100644
index 000000000..b1fda5de8
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100/Makefile
@@ -0,0 +1,26 @@
+#
+# The Flash Memory Controller v100 Device Driver for hisilicon
+#
+# Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+#
+# This program is free software; you can redistribute  it and/or modify it
+# under  the terms of  the GNU General  Public License as published by the
+# Free Software Foundation;  either version 2 of the  License, or (at your
+# option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+#
+
+#
+# drivers/mtd/nand/hifmc100/Makefile
+#
+
+obj-y	+= hifmc_spi_nand_ids.o
+obj-y	+= hifmc100.o hifmc100_os.o
diff --git a/drivers/mtd/nand/hifmc100/hifmc100.c b/drivers/mtd/nand/hifmc100/hifmc100.c
new file mode 100644
index 000000000..6cb12d3b6
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100/hifmc100.c
@@ -0,0 +1,1218 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/mtd/rawnand.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <asm/setup.h>
+
+#include "../raw/hinfc_gen.h"
+#include "hifmc100.h"
+#include <linux/mfd/hisi_fmc.h>
+
+static void hifmc100_switch_to_spi_nand(struct hifmc_host *host)
+{
+	u32 reg;
+
+	reg = hifmc_readl(host, FMC_CFG);
+	reg &= ~FLASH_TYPE_SEL_MASK;
+	reg |= FMC_CFG_FLASH_SEL(FLASH_TYPE_SPI_NAND);
+	hifmc_writel(host, FMC_CFG, reg);
+}
+
+static void hifmc100_set_str_mode(const struct hifmc_host *host)
+{
+	u32 reg;
+
+	reg = hifmc_readl(host, FMC_GLOBAL_CFG);
+	reg &= (~FMC_GLOBAL_CFG_DTR_MODE);
+	hifmc_writel(host, FMC_GLOBAL_CFG, reg);
+}
+
+static void hifmc100_operation_config(struct hifmc_host *host, int op)
+{
+	int ret;
+	unsigned long clkrate = 0;
+	struct hifmc_spi *spi = host->spi;
+
+	hifmc100_switch_to_spi_nand(host);
+	clk_prepare_enable(host->clk);
+	switch (op) {
+	case OP_STYPE_WRITE:
+		clkrate = min((u_long)host->clkrate,
+			      (u_long)CLK_FMC_TO_CRG_MHZ(spi->write->clock));
+		break;
+	case OP_STYPE_READ:
+		clkrate = min((u_long)host->clkrate,
+			      (u_long)CLK_FMC_TO_CRG_MHZ(spi->read->clock));
+		break;
+	case OP_STYPE_ERASE:
+		clkrate = min((u_long)host->clkrate,
+			      (u_long)CLK_FMC_TO_CRG_MHZ(spi->erase->clock));
+		break;
+	default:
+		break;
+	}
+
+	ret = clk_set_rate(host->clk, clkrate);
+	if (WARN_ON(ret)) {
+		pr_err("clk_set_rate failed: %d\n", ret);
+	}
+}
+
+static void hifmc100_send_cmd_write(struct hifmc_host *host)
+{
+	unsigned char pages_per_block_shift;
+	unsigned int reg, block_num, block_num_h, page_num;
+	int ret;
+	struct hifmc_spi *spi = host->spi;
+	struct nand_chip *chip = host->chip;
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+	const char *op = "Reg";
+#else
+	const char *op = "Dma";
+#endif
+
+	if (WR_DBG) {
+		pr_info("\n");
+	}
+	FMC_PR(WR_DBG, "*-Start send %s page write command\n", op);
+
+	mutex_lock(host->lock);
+	hifmc100_operation_config(host, OP_STYPE_WRITE);
+
+	ret = spi->driver->wait_ready(spi);
+	if (ret) {
+		DB_MSG("Error: %s program wait ready failed! status: %#x\n",
+		       op, ret);
+		goto end;
+	}
+
+	ret = spi->driver->write_enable(spi);
+	if (ret) {
+		DB_MSG("Error: %s program write enable failed! ret: %#x\n",
+		       op, ret);
+		goto end;
+	}
+
+	reg = FMC_INT_CLR_ALL;
+	hifmc_writel(host, FMC_INT_CLR, reg);
+	FMC_PR(WR_DBG, "|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+	      | OP_CFG_MEM_IF_TYPE(spi->write->iftype)
+	      | OP_CFG_OEN_EN;
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(WR_DBG, "|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	pages_per_block_shift = chip->phys_erase_shift - chip->page_shift;
+	block_num = host->addr_value[1] >> pages_per_block_shift;
+	block_num_h = block_num >> REG_CNT_HIGH_BLOCK_NUM_SHIFT;
+	reg = FMC_ADDRH_SET(block_num_h);
+	hifmc_writel(host, FMC_ADDRH, reg);
+	FMC_PR(WR_DBG, "|-Set ADDRH[%#x]%#x\n", FMC_ADDRH, reg);
+
+	page_num = host->addr_value[1] - (block_num << pages_per_block_shift);
+	reg = ((block_num & REG_CNT_BLOCK_NUM_MASK) << REG_CNT_BLOCK_NUM_SHIFT)
+	      | ((page_num & REG_CNT_PAGE_NUM_MASK) << REG_CNT_PAGE_NUM_SHIFT);
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(WR_DBG, "|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	*host->epm = 0x0000;
+
+#ifndef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+	reg = host->dma_buffer;
+	hifmc_writel(host, FMC_DMA_SADDR_D0, reg);
+	FMC_PR(WR_DBG, "|-Set DMA_SADDR_D[0x40]%#x\n", reg);
+
+#ifdef CONFIG_64BIT
+	reg = (host->dma_buffer & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_D0, reg);
+	FMC_PR(WR_DBG, "\t|-Set DMA_SADDRH_D0[%#x]%#x\n", FMC_DMA_SADDRH_D0, reg);
+#endif
+
+	reg = host->dma_oob;
+	hifmc_writel(host, FMC_DMA_SADDR_OOB, reg);
+	FMC_PR(WR_DBG, "|-Set DMA_SADDR_OOB[%#x]%#x\n", FMC_DMA_SADDR_OOB, reg);
+#ifdef CONFIG_64BIT
+	reg = (host->dma_oob & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_OOB, reg);
+	FMC_PR(WR_DBG, "\t|-Set DMA_SADDRH_OOB[%#x]%#x\n", FMC_DMA_SADDRH_OOB,
+	       reg);
+#endif
+#endif
+
+	reg = OP_CTRL_WR_OPCODE(spi->write->cmd)
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+	      | OP_CTRL_DMA_OP(OP_TYPE_REG)
+#else
+	      | OP_CTRL_DMA_OP(OP_TYPE_DMA)
+#endif
+	      | OP_CTRL_RW_OP(RW_OP_WRITE)
+	      | OP_CTRL_DMA_OP_READY;
+	hifmc_writel(host, FMC_OP_CTRL, reg);
+	FMC_PR(WR_DBG, "|-Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, reg);
+
+	FMC_DMA_WAIT_INT_FINISH(host);
+
+end:
+	mutex_unlock(host->lock);
+	FMC_PR(WR_DBG, "*-End %s page program!\n", op);
+}
+
+static void hifmc100_send_cmd_status(struct hifmc_host *host)
+{
+	u_char status;
+	int ret;
+	unsigned char addr = STATUS_ADDR;
+	struct hifmc_spi *spi = NULL;
+
+	if(host == NULL || host->spi == NULL) {
+		DB_MSG("Error: host or host->spi is NULL!\n");
+		return;
+	}
+	spi = host->spi;
+	if (host->cmd_op.l_cmd == NAND_CMD_GET_FEATURES) {
+		addr = PROTECT_ADDR;
+	}
+
+	ret = spi_nand_feature_op(spi, GET_OP, addr, &status);
+	if (ret)
+		return;
+	FMC_PR((ER_DBG || WR_DBG), "\t*-Get status[%#x]: %#x\n", addr, status);
+}
+
+static void hifmc100_send_cmd_read(struct hifmc_host *host)
+{
+	unsigned char pages_per_block_shift;
+	unsigned int reg, block_num, block_num_h, page_num;
+	struct hifmc_spi *spi = host->spi;
+	struct nand_chip *chip = host->chip;
+	int ret;
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+	char *op = "Reg";
+#else
+	char *op = "Dma";
+#endif
+
+	if (RD_DBG) {
+		pr_info("\n");
+	}
+	FMC_PR(RD_DBG, "\t*-Start %s page read\n", op);
+
+	if ((host->addr_value[0] == host->cache_addr_value[0])
+			&& (host->addr_value[1] == host->cache_addr_value[1])) {
+		FMC_PR(RD_DBG, "\t*-%s read cache hit, addr[%#x %#x]\n",
+		       op, host->addr_value[1], host->addr_value[0]);
+		return;
+	}
+
+	mutex_lock(host->lock);
+	hifmc100_operation_config(host, OP_STYPE_READ);
+
+	FMC_PR(RD_DBG, "\t|-Wait ready before %s page read\n", op);
+	ret = spi->driver->wait_ready(spi);
+	if (ret) {
+		DB_MSG("Error: %s read wait ready fail! ret: %#x\n", op, ret);
+		goto end;
+	}
+
+	reg = FMC_INT_CLR_ALL;
+	hifmc_writel(host, FMC_INT_CLR, reg);
+	FMC_PR(RD_DBG, "\t|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READOOB)
+		host->cmd_op.op_cfg = OP_CTRL_RD_OP_SEL(RD_OP_READ_OOB);
+	else
+		host->cmd_op.op_cfg = OP_CTRL_RD_OP_SEL(RD_OP_READ_ALL_PAGE);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+	      | OP_CFG_MEM_IF_TYPE(spi->read->iftype)
+	      | OP_CFG_DUMMY_NUM(spi->read->dummy)
+	      | OP_CFG_OEN_EN;
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(RD_DBG, "\t|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	pages_per_block_shift = chip->phys_erase_shift - chip->page_shift;
+	block_num = host->addr_value[1] >> pages_per_block_shift;
+	block_num_h = block_num >> REG_CNT_HIGH_BLOCK_NUM_SHIFT;
+
+	reg = FMC_ADDRH_SET(block_num_h);
+	hifmc_writel(host, FMC_ADDRH, reg);
+	FMC_PR(RD_DBG, "\t|-Set ADDRH[%#x]%#x\n", FMC_ADDRH, reg);
+
+	page_num = host->addr_value[1] - (block_num << pages_per_block_shift);
+	reg = ((block_num & REG_CNT_BLOCK_NUM_MASK) << REG_CNT_BLOCK_NUM_SHIFT)
+	      | ((page_num & REG_CNT_PAGE_NUM_MASK) << REG_CNT_PAGE_NUM_SHIFT);
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(RD_DBG, "\t|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+#ifndef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+	reg = host->dma_buffer;
+	hifmc_writel(host, FMC_DMA_SADDR_D0, reg);
+	FMC_PR(RD_DBG, "\t|-Set DMA_SADDR_D0[%#x]%#x\n", FMC_DMA_SADDR_D0, reg);
+
+#ifdef CONFIG_64BIT
+	reg = (host->dma_buffer & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_D0, reg);
+	FMC_PR(RD_DBG, "\t|-Set DMA_SADDRH_D0[%#x]%#x\n", FMC_DMA_SADDRH_D0, reg);
+#endif
+
+	reg = host->dma_oob;
+	hifmc_writel(host, FMC_DMA_SADDR_OOB, reg);
+	FMC_PR(RD_DBG, "\t|-Set DMA_SADDR_OOB[%#x]%#x\n", FMC_DMA_SADDR_OOB,
+	       reg);
+
+#ifdef CONFIG_64BIT
+	reg = (host->dma_oob & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_OOB, reg);
+	FMC_PR(RD_DBG, "\t|-Set DMA_SADDRH_OOB[%#x]%#x\n", FMC_DMA_SADDRH_OOB,
+	       reg);
+#endif
+#endif
+
+	reg = OP_CTRL_RD_OPCODE(spi->read->cmd) | host->cmd_op.op_cfg
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+	      | OP_CTRL_DMA_OP(OP_TYPE_REG)
+#else
+	      | OP_CTRL_DMA_OP(OP_TYPE_DMA)
+#endif
+	      | OP_CTRL_RW_OP(RW_OP_READ) | OP_CTRL_DMA_OP_READY;
+	hifmc_writel(host, FMC_OP_CTRL, reg);
+	FMC_PR(RD_DBG, "\t|-Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, reg);
+
+	FMC_DMA_WAIT_INT_FINISH(host);
+
+	host->cache_addr_value[0] = host->addr_value[0];
+	host->cache_addr_value[1] = host->addr_value[1];
+
+end:
+	mutex_unlock(host->lock);
+	FMC_PR(RD_DBG, "\t*-End %s page read\n", op);
+}
+
+static void hifmc100_send_cmd_erase(struct hifmc_host *host)
+{
+	unsigned int reg;
+	struct hifmc_spi *spi = host->spi;
+	int ret;
+
+	if (ER_DBG) {
+		pr_info("\n");
+	}
+	FMC_PR(ER_DBG, "\t*-Start send cmd erase!\n");
+
+	mutex_lock(host->lock);
+	hifmc100_operation_config(host, OP_STYPE_ERASE);
+
+	ret = spi->driver->wait_ready(spi);
+	FMC_PR(ER_DBG, "\t|-Erase wait ready, ret: %#x\n", ret);
+	if (ret) {
+		DB_MSG("Error: Erase wait ready fail! status: %#x\n", ret);
+		goto end;
+	}
+
+	ret = spi->driver->write_enable(spi);
+	if (ret) {
+		DB_MSG("Error: Erase write enable failed! ret: %#x\n", ret);
+		goto end;
+	}
+
+	reg = FMC_INT_CLR_ALL;
+	hifmc_writel(host, FMC_INT_CLR, reg);
+	FMC_PR(ER_DBG, "\t|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	reg = spi->erase->cmd;
+	hifmc_writel(host, FMC_CMD, FMC_CMD_CMD1(reg));
+	FMC_PR(ER_DBG, "\t|-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = FMC_ADDRL_BLOCK_H_MASK(host->addr_value[1])
+	      | FMC_ADDRL_BLOCK_L_MASK(host->addr_value[0]);
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(ER_DBG, "\t|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+	      | OP_CFG_MEM_IF_TYPE(spi->erase->iftype)
+	      | OP_CFG_ADDR_NUM(STD_OP_ADDR_NUM)
+	      | OP_CFG_DUMMY_NUM(spi->erase->dummy)
+	      | OP_CFG_OEN_EN;
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(ER_DBG, "\t|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_OP_CMD1_EN
+	      | FMC_OP_ADDR_EN
+	      | FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(ER_DBG, "\t|-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+end:
+	mutex_unlock(host->lock);
+	FMC_PR(ER_DBG, "\t*-End send cmd erase!\n");
+}
+
+void hifmc100_ecc0_switch(struct hifmc_host *host, unsigned char op)
+{
+	unsigned int config;
+#if EC_DBG
+	unsigned int cmp_cfg;
+
+	if(host == NULL) {
+		DB_MSG("Error: host is NULL!\n");
+		return;
+	}
+	config = hifmc_readl(host, FMC_CFG);
+	FMC_PR(EC_DBG, "\t *-Get CFG[%#x]%#x\n", FMC_CFG, config);
+
+	if (op) {
+		cmp_cfg = host->fmc_cfg;
+	} else {
+		cmp_cfg = host->fmc_cfg_ecc0;
+	}
+
+	if (cmp_cfg != config)
+		DB_MSG("Warning: FMC config[%#x] is different.\n",
+		       cmp_cfg);
+#endif
+	if(host == NULL) {
+		DB_MSG("Error: host is NULL!\n");
+		return;
+	}
+	if (op == ENABLE) {
+		config = host->fmc_cfg_ecc0;
+	} else if (op == DISABLE) {
+		config = host->fmc_cfg;
+	} else {
+		DB_MSG("Error: Invalid opcode: %d\n", op);
+		return;
+	}
+
+	hifmc_writel(host, FMC_CFG, config);
+	FMC_PR(EC_DBG, "\t *-Set CFG[%#x]%#x\n", FMC_CFG, config);
+}
+
+static void hifmc100_send_cmd_readid(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(BT_DBG, "\t|*-Start send cmd read ID\n");
+
+	hifmc100_ecc0_switch(host, ENABLE);
+
+	reg = FMC_CMD_CMD1(SPI_CMD_RDID);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(BT_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = READ_ID_ADDR;
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(BT_DBG, "\t||-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+	      | OP_CFG_ADDR_NUM(READ_ID_ADDR_NUM)
+	      | OP_CFG_OEN_EN;
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(BT_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_DATA_NUM_CNT(MAX_SPI_NAND_ID_LEN);
+	hifmc_writel(host, FMC_DATA_NUM, reg);
+	FMC_PR(BT_DBG, "\t||-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = FMC_OP_CMD1_EN
+	      | FMC_OP_ADDR_EN
+	      | FMC_OP_READ_DATA_EN
+	      | FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(BT_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	host->addr_cycle = 0x0;
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	hifmc100_ecc0_switch(host, DISABLE);
+
+	FMC_PR(BT_DBG, "\t|*-End read flash ID\n");
+}
+
+static void hifmc100_send_cmd_reset(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(BT_DBG, "\t|*-Start send cmd reset\n");
+
+	reg = FMC_CMD_CMD1(SPI_CMD_RESET);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(BT_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs) | OP_CFG_OEN_EN;
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(BT_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_OP_CMD1_EN | FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(BT_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	FMC_PR(BT_DBG, "\t|*-End send cmd reset\n");
+}
+
+static void hifmc100_host_init(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(BT_DBG, "\t||*-Start SPI Nand host init\n");
+
+	reg = hifmc_readl(host, FMC_CFG);
+	if ((reg & FMC_CFG_OP_MODE_MASK) == FMC_CFG_OP_MODE_BOOT) {
+		reg |= FMC_CFG_OP_MODE(FMC_CFG_OP_MODE_NORMAL);
+		hifmc_writel(host, FMC_CFG, reg);
+		FMC_PR(BT_DBG, "\t|||-Set CFG[%#x]%#x\n", FMC_CFG, reg);
+	}
+
+	host->fmc_cfg = reg;
+	host->fmc_cfg_ecc0 = (reg & ~ECC_TYPE_MASK) | ECC_TYPE_0BIT;
+
+	reg = hifmc_readl(host, FMC_GLOBAL_CFG);
+	if (reg & FMC_GLOBAL_CFG_WP_ENABLE) {
+		reg &= ~FMC_GLOBAL_CFG_WP_ENABLE;
+		hifmc_writel(host, FMC_GLOBAL_CFG, reg);
+	}
+
+	host->addr_cycle = 0;
+	host->addr_value[0] = 0;
+	host->addr_value[1] = 0;
+	host->cache_addr_value[0] = ~0;
+	host->cache_addr_value[1] = ~0;
+
+	host->send_cmd_write = hifmc100_send_cmd_write;
+	host->send_cmd_status = hifmc100_send_cmd_status;
+	host->send_cmd_read = hifmc100_send_cmd_read;
+	host->send_cmd_erase = hifmc100_send_cmd_erase;
+	host->send_cmd_readid = hifmc100_send_cmd_readid;
+	host->send_cmd_reset = hifmc100_send_cmd_reset;
+#ifdef CONFIG_PM
+	host->suspend = hifmc100_suspend;
+	host->resume  = hifmc100_resume;
+#endif
+
+	reg = TIMING_CFG_TCSH(CS_HOLD_TIME)
+	      | TIMING_CFG_TCSS(CS_SETUP_TIME)
+	      | TIMING_CFG_TSHSL(CS_DESELECT_TIME);
+	hifmc_writel(host, FMC_SPI_TIMING_CFG, reg);
+
+	reg = ALL_BURST_ENABLE;
+	hifmc_writel(host, FMC_DMA_AHB_CTRL, reg);
+
+	FMC_PR(BT_DBG, "\t||*-End SPI Nand host init\n");
+}
+
+static unsigned char hifmc100_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	unsigned char value;
+	unsigned char ret_val = 0;
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READID) {
+		value = hifmc_readb(host->iobase + host->offset);
+		host->offset++;
+		if (host->cmd_op.data_no == host->offset) {
+			host->cmd_op.l_cmd = 0;
+		}
+		return value;
+	}
+
+	if (host->cmd_op.cmd == NAND_CMD_STATUS) {
+		value = hifmc_readl(host, FMC_STATUS);
+		if (host->cmd_op.l_cmd == NAND_CMD_GET_FEATURES) {
+			FMC_PR((ER_DBG || WR_DBG), "\t\tRead BP status:%#x\n",
+			       value);
+			if (ANY_BP_ENABLE(value)) {
+				ret_val |= NAND_STATUS_WP;
+			}
+
+			host->cmd_op.l_cmd = NAND_CMD_STATUS;
+		}
+
+		if (!(value & STATUS_OIP_MASK)) {
+			ret_val |= NAND_STATUS_READY;
+		}
+
+		if (value & STATUS_E_FAIL_MASK) {
+			FMC_PR(ER_DBG, "\t\tGet erase status: %#x\n", value);
+			ret_val |= NAND_STATUS_FAIL;
+		}
+
+		if (value & STATUS_P_FAIL_MASK) {
+			FMC_PR(WR_DBG, "\t\tGet write status: %#x\n", value);
+			ret_val |= NAND_STATUS_FAIL;
+		}
+
+		return ret_val;
+	}
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READOOB) {
+		value  = hifmc_readb(host->buffer + host->pagesize + host->offset);
+		host->offset++;
+		return value;
+	}
+
+	host->offset++;
+
+	return hifmc_readb(host->buffer + host->column + host->offset - 1);
+}
+
+static unsigned short hifmc100_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	host->offset += 2;
+	return hifmc_readw(host->buffer + host->column + host->offset - 2);
+}
+
+static void hifmc100_write_buf(struct mtd_info *mtd,
+			       const u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+	if (buf == chip->oob_poi) {
+		memcpy((char *)host->iobase + host->pagesize, buf, len);
+	} else {
+		memcpy((char *)host->iobase, buf, len);
+	}
+#else
+	if (buf == chip->oob_poi) {
+		memcpy((char *)(host->buffer + host->pagesize), buf, len);
+	} else {
+		memcpy((char *)host->buffer, buf, len);
+	}
+#endif
+	return;
+}
+
+static void hifmc100_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+	if (buf == chip->oob_poi) {
+		memcpy(buf, (char *)host->iobase + host->pagesize, len);
+	} else {
+		memcpy(buf, (char *)host->iobase, len);
+	}
+#else
+	if (buf == chip->oob_poi) {
+		memcpy(buf, (char *)host->buffer + host->pagesize, len);
+	} else {
+		memcpy(buf, (char *)host->buffer, len);
+	}
+#endif
+
+#ifdef CONFIG_HISI_NAND_ECC_STATUS_REPORT
+	if (buf != chip->oob_poi) {
+		u_int reg;
+		u_int ecc_step = host->pagesize >> 10;
+
+		reg = hifmc_readl(host, HIFMC100_ECC_ERR_NUM0_BUF0);
+		while (ecc_step) {
+			u_char err_num;
+
+			err_num = GET_ECC_ERR_NUM(--ecc_step, reg);
+			if (err_num == 0xff) {
+				mtd->ecc_stats.failed++;
+			} else {
+				mtd->ecc_stats.corrected += err_num;
+			}
+		}
+	}
+#endif
+
+	return;
+}
+
+static void hifmc100_select_chip(struct mtd_info *mtd, int chipselect)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	if (chipselect < 0) {
+		mutex_unlock(&fmc_switch_mutex);
+		return;
+	}
+
+	mutex_lock(&fmc_switch_mutex);
+
+	if (chipselect > CONFIG_SPI_NAND_MAX_CHIP_NUM) {
+		DB_BUG("Error: Invalid chipselect: %d\n", chipselect);
+	}
+
+	if (host->mtd != mtd) {
+		host->mtd = mtd;
+		host->cmd_op.cs = chipselect;
+	}
+
+	if (!(chip->options & NAND_BROKEN_XD)) {
+		if ((chip->state == FL_ERASING) || (chip->state == FL_WRITING)) {
+			host->cmd_op.l_cmd = NAND_CMD_GET_FEATURES;
+		}
+	}
+}
+
+static void hifmc100_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned ctrl)
+{
+	unsigned char cmd;
+	int is_cache_invalid = 1;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	unsigned int udat = (unsigned int)dat;
+
+	if (ctrl & NAND_ALE) {
+		unsigned int addr_value = 0;
+		unsigned int addr_offset = 0;
+
+		if (ctrl & NAND_CTRL_CHANGE) {
+			host->addr_cycle = 0x0;
+			host->addr_value[0] = 0x0;
+			host->addr_value[1] = 0x0;
+		}
+		addr_offset = host->addr_cycle << 3;
+
+		if (host->addr_cycle >= HIFMC100_ADDR_CYCLE_MASK) {
+			addr_offset = (host->addr_cycle -
+				       HIFMC100_ADDR_CYCLE_MASK) << 3;
+			addr_value = 1;
+		}
+		host->addr_value[addr_value] |=
+			((udat & 0xff) << addr_offset);
+
+		host->addr_cycle++;
+	}
+
+	if ((ctrl & NAND_CLE) && (ctrl & NAND_CTRL_CHANGE)) {
+		cmd = udat & 0xff;
+		host->cmd_op.cmd = cmd;
+		switch (cmd) {
+		case NAND_CMD_PAGEPROG:
+			host->offset = 0;
+			host->send_cmd_write(host);
+			break;
+
+		case NAND_CMD_READSTART:
+			is_cache_invalid = 0;
+			if (host->addr_value[0] == host->pagesize) {
+				host->cmd_op.l_cmd = NAND_CMD_READOOB;
+			}
+			host->send_cmd_read(host);
+			break;
+
+		case NAND_CMD_ERASE2:
+			host->send_cmd_erase(host);
+			break;
+
+		case NAND_CMD_READID:
+			memset((u_char *)(host->iobase), 0,
+			       MAX_SPI_NAND_ID_LEN);
+			host->cmd_op.l_cmd = cmd;
+			host->cmd_op.data_no = MAX_SPI_NAND_ID_LEN;
+			host->send_cmd_readid(host);
+			break;
+
+		case NAND_CMD_STATUS:
+			host->send_cmd_status(host);
+			break;
+
+		case NAND_CMD_READ0:
+			host->cmd_op.l_cmd = cmd;
+			break;
+
+		case NAND_CMD_RESET:
+			host->send_cmd_reset(host);
+			break;
+
+		case NAND_CMD_SEQIN:
+		case NAND_CMD_ERASE1:
+		default:
+			break;
+		}
+	}
+
+	if ((dat == NAND_CMD_NONE) && host->addr_cycle) {
+		if (host->cmd_op.cmd == NAND_CMD_SEQIN
+				|| host->cmd_op.cmd == NAND_CMD_READ0
+				|| host->cmd_op.cmd == NAND_CMD_READID) {
+			host->offset = 0x0;
+			host->column = (host->addr_value[0] & 0xffff);
+		}
+	}
+
+	if (is_cache_invalid) {
+		host->cache_addr_value[0] = ~0;
+		host->cache_addr_value[1] = ~0;
+	}
+}
+
+static int hifmc100_dev_ready(struct mtd_info *mtd)
+{
+	unsigned int reg;
+	unsigned long deadline = jiffies + FMC_MAX_READY_WAIT_JIFFIES;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	do {
+		reg = OP_CFG_FM_CS(host->cmd_op.cs) | OP_CFG_OEN_EN;
+		hifmc_writel(host, FMC_OP_CFG, reg);
+
+		reg = FMC_OP_READ_STATUS_EN | FMC_OP_REG_OP_START;
+		hifmc_writel(host, FMC_OP, reg);
+
+		FMC_CMD_WAIT_CPU_FINISH(host);
+
+		reg = hifmc_readl(host, FMC_STATUS);
+
+		if (!(reg & STATUS_OIP_MASK)) {
+			return NAND_STATUS_READY;
+		}
+
+		cond_resched();
+	} while (!time_after_eq(jiffies, deadline));
+
+	if (!(chip->options & NAND_SCAN_SILENT_NODEV)) {
+		pr_warn("Wait SPI nand ready timeout, status: %#x\n", reg);
+	}
+
+	return 0;
+}
+
+/*
+ * 'host->epm' only use the first oobfree[0] field, it looks very simple, But...
+ */
+/* Default OOB area layout */
+static int hifmc_ooblayout_ecc_default(struct mtd_info *mtd, int section,
+				       struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 32;
+	oobregion->offset = 32;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_default(struct mtd_info *mtd, int section,
+					struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 30;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static struct mtd_ooblayout_ops hifmc_ooblayout_default_ops = {
+	.ecc = hifmc_ooblayout_ecc_default,
+	.free = hifmc_ooblayout_free_default,
+};
+
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+static int hifmc_ooblayout_ecc_4k16bit(struct mtd_info *mtd, int section,
+				       struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 14;
+	oobregion->offset = 14;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_4k16bit(struct mtd_info *mtd, int section,
+					struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 14;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static struct mtd_ooblayout_ops hifmc_ooblayout_4k16bit_ops = {
+	.ecc = hifmc_ooblayout_ecc_4k16bit,
+	.free = hifmc_ooblayout_free_4k16bit,
+};
+
+static int hifmc_ooblayout_ecc_2k16bit(struct mtd_info *mtd, int section,
+				       struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 6;
+	oobregion->offset = 6;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_2k16bit(struct mtd_info *mtd, int section,
+					struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 6;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static struct mtd_ooblayout_ops hifmc_ooblayout_2k16bit_ops = {
+	.ecc = hifmc_ooblayout_ecc_2k16bit,
+	.free = hifmc_ooblayout_free_2k16bit,
+};
+#endif
+
+static struct nand_config_info hifmc_spi_nand_config_table[] = {
+	{NAND_PAGE_4K,  NAND_ECC_24BIT, 24, 200,    &hifmc_ooblayout_default_ops},
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	{NAND_PAGE_4K,  NAND_ECC_16BIT, 16, 128,    &hifmc_ooblayout_4k16bit_ops},
+#endif
+	{NAND_PAGE_4K,  NAND_ECC_8BIT,  8, 128,     &hifmc_ooblayout_default_ops},
+	{NAND_PAGE_4K,  NAND_ECC_0BIT,  0, 32,      &hifmc_ooblayout_default_ops},
+	{NAND_PAGE_2K,  NAND_ECC_24BIT, 24, 128,    &hifmc_ooblayout_default_ops},
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	{NAND_PAGE_2K,  NAND_ECC_16BIT, 16, 64,     &hifmc_ooblayout_2k16bit_ops},
+#endif
+	{NAND_PAGE_2K,  NAND_ECC_8BIT,  8, 64,      &hifmc_ooblayout_default_ops},
+	{NAND_PAGE_2K,  NAND_ECC_0BIT,  0, 32,      &hifmc_ooblayout_default_ops},
+	{0, 0, 0, 0, NULL},
+};
+
+/*
+ * Auto-sensed the page size and ecc type value. driver will try each of page
+ * size and ecc type one by one till flash can be read and wrote accurately.
+ * so the page size and ecc type is match adaptively without switch on the board
+ */
+static struct nand_config_info *hifmc100_get_config_type_info(
+	struct mtd_info *mtd, struct nand_dev_t *nand_dev)
+{
+	struct nand_config_info *best = NULL;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_config_info *info = hifmc_spi_nand_config_table;
+
+	nand_dev->start_type = "Auto";
+
+	for (; info->ooblayout_ops; info++) {
+		if (match_page_type_to_size(info->pagetype) != mtd->writesize) {
+			continue;
+		}
+
+		if (mtd->oobsize < info->oobsize) {
+			continue;
+		}
+
+		if (!best || (best->ecctype < info->ecctype)) {
+			best = info;
+		}
+	}
+
+	/* All SPI NAND are small-page, SLC */
+	chip->bits_per_cell = 1;
+
+	return best;
+}
+
+static void hifmc100_chip_init(struct nand_chip *chip)
+{
+	chip->read_byte = hifmc100_read_byte;
+	chip->read_word = hifmc100_read_word;
+	chip->write_buf = hifmc100_write_buf;
+	chip->read_buf = hifmc100_read_buf;
+
+	chip->select_chip = hifmc100_select_chip;
+
+	chip->cmd_ctrl = hifmc100_cmd_ctrl;
+	chip->dev_ready = hifmc100_dev_ready;
+
+	chip->chip_delay = FMC_CHIP_DELAY;
+
+	chip->options = NAND_SKIP_BBTSCAN | NAND_BROKEN_XD
+			| NAND_SCAN_SILENT_NODEV;
+
+	chip->ecc.mode = NAND_ECC_NONE;
+}
+
+static void hifmc100_set_oob_info(struct mtd_info *mtd,
+				  struct nand_config_info *info, struct nand_dev_t *nand_dev)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	struct mtd_oob_region hifmc_oobregion = {0, 0};
+	if (info == NULL || mtd == NULL || nand_dev == NULL) {
+		DB_MSG("set oob info err!!!\n");
+		return;
+	}
+
+	if (info->ecctype != NAND_ECC_0BIT) {
+		mtd->oobsize = info->oobsize;
+	}
+
+	host->oobsize = mtd->oobsize;
+	nand_dev->oobsize = host->oobsize;
+
+	host->dma_oob = host->dma_buffer + host->pagesize;
+	host->bbm = (u_char *)(host->buffer + host->pagesize
+			       + HIFMC_BAD_BLOCK_POS);
+	if(info->ooblayout_ops == NULL) {
+		DB_MSG("Error: info->ooblayout_ops or is NULL!\n");
+		return;
+	}
+	info->ooblayout_ops->free(mtd, 0, &hifmc_oobregion);
+
+	mtd_set_ooblayout(mtd, info->ooblayout_ops);
+
+	/* EB bits locate in the bottom two of CTRL(30) */
+	host->epm = (u_short *)(host->buffer + host->pagesize
+				+ hifmc_oobregion.offset + 28);
+
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	if (best->ecctype == NAND_ECC_16BIT) {
+		if (host->pagesize == _2K) {
+			/* EB bits locate in the bottom two of CTRL(4) */
+			host->epm = (u_short *)(host->buffer + host->pagesize
+						+ hifmc_oobregion.offset + 4);
+		} else if (host->pagesize == _4K) {
+			/* EB bit locate in the bottom two of CTRL(14) */
+			host->epm = (u_short *)(host->buffer + host->pagesize
+						+ hifmc_oobregion.offset + 12);
+		}
+	}
+#endif
+}
+
+static unsigned int hifmc100_get_ecc_reg(struct hifmc_host *host,
+		const struct nand_config_info *info, struct nand_dev_t *nand_dev)
+{
+	if (info == NULL || host == NULL || nand_dev == NULL) {
+		DB_MSG("get ecc reg err!!!\n");
+		return 0;
+	}
+	host->ecctype = info->ecctype;
+	nand_dev->ecctype = host->ecctype;
+
+	return FMC_CFG_ECC_TYPE(match_ecc_type_to_reg(info->ecctype));
+}
+
+static unsigned int hifmc100_get_page_reg(struct hifmc_host *host,
+		const struct nand_config_info *info)
+{
+	if (info == NULL || host == NULL) {
+		DB_MSG("get page reg err!!!\n");
+		return 0;
+	}
+	host->pagesize = match_page_type_to_size(info->pagetype);
+
+	return FMC_CFG_PAGE_SIZE(match_page_type_to_reg(info->pagetype));
+}
+
+static unsigned int hifmc100_get_block_reg(struct hifmc_host *host,
+		const struct nand_config_info *info)
+{
+	unsigned int block_reg = 0;
+	unsigned int page_per_block = 0;
+	struct mtd_info *mtd = NULL;
+
+	if (info == NULL || host == NULL) {
+		DB_MSG("get block reg err!!!\n");
+		return 0;
+	}
+
+	mtd = host->mtd;
+	if(mtd == NULL) {
+		DB_MSG("err:mtd is NULL!!!\n");
+		return 0;
+	}
+	host->block_page_mask = ((mtd->erasesize / mtd->writesize) - 1);
+	page_per_block = mtd->erasesize / match_page_type_to_size(info->pagetype);
+	switch (page_per_block) {
+	case 64:
+		block_reg = BLOCK_SIZE_64_PAGE;
+		break;
+	case 128:
+		block_reg = BLOCK_SIZE_128_PAGE;
+		break;
+	case 256:
+		block_reg = BLOCK_SIZE_256_PAGE;
+		break;
+	case 512:
+		block_reg = BLOCK_SIZE_512_PAGE;
+		break;
+	default:
+		DB_MSG("Can't support block %#x and page %#x size\n",
+		       mtd->erasesize, mtd->writesize);
+	}
+
+	return FMC_CFG_BLOCK_SIZE(block_reg);
+}
+
+static void hifmc100_set_fmc_cfg_reg(struct hifmc_host *host,
+	const struct nand_config_info *type_info, struct nand_dev_t *nand_dev)
+{
+	unsigned int page_reg, ecc_reg, block_reg, reg_fmc_cfg;
+
+	ecc_reg = hifmc100_get_ecc_reg(host, type_info, nand_dev);
+	page_reg = hifmc100_get_page_reg(host, type_info);
+	block_reg = hifmc100_get_block_reg(host, type_info);
+
+	reg_fmc_cfg = hifmc_readl(host, FMC_CFG);
+	reg_fmc_cfg &= ~(PAGE_SIZE_MASK | ECC_TYPE_MASK | BLOCK_SIZE_MASK);
+	reg_fmc_cfg |= ecc_reg | page_reg | block_reg;
+	hifmc_writel(host, FMC_CFG, reg_fmc_cfg);
+
+	/* Save value of FMC_CFG and FMC_CFG_ECC0 to turn on/off ECC */
+	host->fmc_cfg = reg_fmc_cfg;
+	host->fmc_cfg_ecc0 = (host->fmc_cfg & ~ECC_TYPE_MASK) | ECC_TYPE_0BIT;
+	FMC_PR(BT_DBG, "\t|-Save FMC_CFG[%#x]: %#x and FMC_CFG_ECC0: %#x\n",
+	       FMC_CFG, host->fmc_cfg, host->fmc_cfg_ecc0);
+}
+
+static int hifmc100_set_config_info(struct mtd_info *mtd,
+				    struct nand_chip *chip, struct nand_dev_t *nand_dev)
+{
+	struct hifmc_host *host = chip->priv;
+	struct nand_config_info *type_info = NULL;
+
+	FMC_PR(BT_DBG, "\t*-Start config Block Page OOB and Ecc\n");
+
+	type_info = hifmc100_get_config_type_info(mtd, nand_dev);
+	WARN_ON(!type_info);
+	if (type_info == NULL) {
+		DB_MSG("set config info err!!!\n");
+		return 0;
+	}
+
+	FMC_PR(BT_DBG, "\t|-%s Config, PageSize %s EccType %s OOBSize %d\n",
+	       nand_dev->start_type, nand_page_name(type_info->pagetype),
+	       nand_ecc_name(type_info->ecctype), type_info->oobsize);
+
+	/* Set the page_size, ecc_type, block_size of FMC_CFG[0x0] register */
+	hifmc100_set_fmc_cfg_reg(host, type_info, nand_dev);
+
+	hifmc100_set_oob_info(mtd, type_info, nand_dev);
+
+	FMC_PR(BT_DBG, "\t*-End config Block Page Oob and Ecc\n");
+
+	return 0;
+}
+
+void hifmc100_spi_nand_init(struct nand_chip *chip)
+{
+	struct hifmc_host *host = NULL;
+
+	if((chip == NULL) || (chip->priv == NULL)) {
+		DB_MSG("Error: chip or chip->priv is NULL!\n");
+		return;
+	}
+	host = chip->priv;
+	FMC_PR(BT_DBG, "\t|*-Start hifmc100 SPI Nand init\n");
+
+	/* Switch SPI type to SPI nand */
+	hifmc100_switch_to_spi_nand(host);
+
+	/* hold on STR mode */
+	hifmc100_set_str_mode(host);
+
+	/* Hifmc host init */
+	hifmc100_host_init(host);
+	host->chip = chip;
+
+	/* Hifmc nand_chip struct init */
+	hifmc100_chip_init(chip);
+
+	hifmc_spi_nand_ids_register();
+	hinfc_param_adjust = hifmc100_set_config_info;
+
+	FMC_PR(BT_DBG, "\t|*-End hifmc100 SPI Nand init\n");
+}
+#ifdef CONFIG_PM
+int hifmc100_suspend(struct platform_device *pltdev, pm_message_t state)
+{
+	int ret;
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+	struct hifmc_spi *spi = host->spi;
+
+	mutex_lock(host->lock);
+	hifmc100_switch_to_spi_nand(host);
+
+	ret = spi->driver->wait_ready(spi);
+	if (ret) {
+		DB_MSG("Error: wait ready failed!");
+		clk_disable_unprepare(host->clk);
+		mutex_unlock(host->lock);
+		return 0;
+	}
+
+	clk_disable_unprepare(host->clk);
+	mutex_unlock(host->lock);
+
+	return 0;
+}
+
+int hifmc100_resume(struct platform_device *pltdev)
+{
+	int cs;
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+	struct nand_chip *chip = host->chip;
+
+	mutex_lock(host->lock);
+	hifmc100_switch_to_spi_nand(host);
+	clk_prepare_enable(host->clk);
+
+	for (cs = 0; cs < chip->numchips; cs++) {
+		host->send_cmd_reset(host);
+	}
+
+	hifmc100_spi_nand_config(host);
+
+	mutex_unlock(host->lock);
+	return 0;
+}
+#endif
diff --git a/drivers/mtd/nand/hifmc100/hifmc100.h b/drivers/mtd/nand/hifmc100/hifmc100.h
new file mode 100644
index 000000000..9f169f3d5
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100/hifmc100.h
@@ -0,0 +1,354 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __HIFMC100_H__
+#define __HIFMC100_H__
+
+#include <linux/platform_device.h>
+#include <linux/mfd/hisi_fmc.h>
+
+#define INFINITE            (0xFFFFFFFF)
+
+#define SPI_IF_READ_STD         (0x01)
+#define SPI_IF_READ_FAST        (0x02)
+#define SPI_IF_READ_DUAL        (0x04)
+#define SPI_IF_READ_DUAL_ADDR       (0x08)
+#define SPI_IF_READ_QUAD        (0x10)
+#define SPI_IF_READ_QUAD_ADDR       (0x20)
+
+#define SPI_IF_WRITE_STD        (0x01)
+#define SPI_IF_WRITE_DUAL       (0x02)
+#define SPI_IF_WRITE_DUAL_ADDR      (0x04)
+#define SPI_IF_WRITE_QUAD       (0x08)
+#define SPI_IF_WRITE_QUAD_ADDR      (0x10)
+
+#define SPI_IF_ERASE_SECTOR_4K      (0x01)
+#define SPI_IF_ERASE_SECTOR_32K     (0x02)
+#define SPI_IF_ERASE_SECTOR_64K     (0x04)
+#define SPI_IF_ERASE_SECTOR_128K    (0x08)
+#define SPI_IF_ERASE_SECTOR_256K    (0x10)
+
+#define HIFMC_SPI_NAND_SUPPORT_READ (SPI_IF_READ_STD \
+                    | SPI_IF_READ_FAST \
+                    | SPI_IF_READ_DUAL \
+                    | SPI_IF_READ_DUAL_ADDR \
+                    | SPI_IF_READ_QUAD \
+                    | SPI_IF_READ_QUAD_ADDR)
+
+#define HIFMC_SPI_NAND_SUPPORT_WRITE    (SPI_IF_WRITE_STD | SPI_IF_WRITE_QUAD)
+
+#define HIFMC_SPI_NAND_SUPPORT_MAX_DUMMY    8
+
+#define SPI_CMD_READ_STD        0x03    /* Standard read cache */
+#define SPI_CMD_READ_FAST       0x0B    /* Higher speed read cache */
+#define SPI_CMD_READ_DUAL       0x3B    /* 2 IO read cache only date */
+#define SPI_CMD_READ_DUAL_ADDR      0xBB    /* 2 IO read cache date&addr */
+#define SPI_CMD_READ_QUAD       0x6B    /* 4 IO read cache only date */
+#define SPI_CMD_READ_QUAD_ADDR      0xEB    /* 4 IO read cache date&addr */
+
+#define SPI_CMD_WRITE_STD       0x02    /* Standard page program */
+#define SPI_CMD_WRITE_DUAL      0xA2    /* 2 IO program only date */
+#define SPI_CMD_WRITE_DUAL_ADDR     0xD2    /* 2 IO program date&addr */
+#define SPI_CMD_WRITE_QUAD      0x32    /* 4 IO program only date */
+#define SPI_CMD_WRITE_QUAD_ADDR     0x12    /* 4 IO program date&addr */
+
+#define SPI_CMD_SE_4K           0x20    /* 4KB sector Erase */
+#define SPI_CMD_SE_32K          0x52    /* 32KB sector Erase */
+#define SPI_CMD_SE_64K          0xD8    /* 64KB sector Erase */
+#define SPI_CMD_SE_128K         0xD8    /* 128KB sector Erase */
+#define SPI_CMD_SE_256K         0xD8    /* 256KB sector Erase */
+
+#define SET_READ_STD(_dummy_, _size_, _clk_) \
+    static struct spi_op read_std_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_STD, SPI_CMD_READ_STD, _dummy_, _size_, _clk_ }
+
+#define SET_READ_FAST(_dummy_, _size_, _clk_) \
+    static struct spi_op read_fast_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_FAST, SPI_CMD_READ_FAST, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL, SPI_CMD_READ_DUAL, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual_addr_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL_ADDR, SPI_CMD_READ_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD, SPI_CMD_READ_QUAD, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_addr_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_ADDR, SPI_CMD_READ_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_STD(_dummy_, _size_, _clk_) \
+    static struct spi_op write_std_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_STD, SPI_CMD_WRITE_STD, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_DUAL, SPI_CMD_WRITE_DUAL, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_DUAL_ADDR, SPI_CMD_WRITE_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_QUAD, SPI_CMD_WRITE_QUAD, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_QUAD_ADDR, SPI_CMD_WRITE_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_4K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_4k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_4K, SPI_CMD_SE_4K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_32K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_32k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_32K, SPI_CMD_SE_32K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_64K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_64k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_64K, SPI_CMD_SE_64K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_128K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_128k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_128K, SPI_CMD_SE_128K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_256K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_256k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_256K, SPI_CMD_SE_256K, _dummy_, _size_, _clk_ }
+
+#define READ_STD(_dummy_, _size_, _clk_) read_std_##_dummy_##_size_##_clk_
+#define READ_FAST(_dummy_, _size_, _clk_) read_fast_##_dummy_##_size_##_clk_
+#define READ_DUAL(_dummy_, _size_, _clk_) read_dual_##_dummy_##_size_##_clk_
+#define READ_DUAL_ADDR(_dummy_, _size_, _clk_) \
+        read_dual_addr_##_dummy_##_size_##_clk_
+#define READ_QUAD(_dummy_, _size_, _clk_) read_quad_##_dummy_##_size_##_clk_
+#define READ_QUAD_ADDR(_dummy_, _size_, _clk_) \
+        read_quad_addr_##_dummy_##_size_##_clk_
+
+#define WRITE_STD(_dummy_, _size_, _clk_) write_std_##_dummy_##_size_##_clk_
+#define WRITE_DUAL(_dummy_, _size_, _clk_) write_dual_##_dummy_##_size_##_clk_
+#define WRITE_DUAL_ADDR(_dummy_, _size_, _clk_) \
+        write_dual_addr_##_dummy_##_size_##_clk_
+#define WRITE_QUAD(_dummy_, _size_, _clk_) write_quad_##_dummy_##_size_##_clk_
+#define WRITE_QUAD_ADDR(_dummy_, _size_, _clk_) \
+        write_quad_addr_##_dummy_##_size_##_clk_
+
+#define ERASE_SECTOR_4K(_dummy_, _size_, _clk_) \
+        erase_sector_4k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_32K(_dummy_, _size_, _clk_) \
+        erase_sector_32k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_64K(_dummy_, _size_, _clk_) \
+        erase_sector_64k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_128K(_dummy_, _size_, _clk_) \
+        erase_sector_128k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_256K(_dummy_, _size_, _clk_) \
+        erase_sector_256k_##_dummy_##_size_##_clk_
+
+#define SPI_CMD_WREN            0x06    /* Write Enable */
+#define SPI_CMD_WRDI            0x04    /* Write Disable */
+
+#define SPI_CMD_RDID            0x9F    /* Read Identification */
+
+#define SPI_CMD_GET_FEATURES        0x0F    /* Get Features */
+#define SPI_CMD_SET_FEATURE     0x1F    /* Set Feature */
+
+#define SPI_CMD_PAGE_READ       0x13    /* Page Read to Cache */
+
+#define SPI_CMD_RESET           0xff    /* Reset the device */
+
+/* These macroes are for debug only, reg option is slower then dma option */
+#undef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+/* #define HIFMC100_SPI_NAND_SUPPORT_REG_READ */
+
+#undef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+/* #define HIFMC100_SPI_NAND_SUPPORT_REG_WRITE */
+
+#ifdef CONFIG_HISI_NAND_ECC_STATUS_REPORT
+#define HIFMC100_ECC_ERR_NUM0_BUF0      0xc0
+
+#define GET_ECC_ERR_NUM(_i, _reg)       (((_reg) >> ((_i) * 8)) & 0xff)
+#endif
+#define REG_CNT_HIGH_BLOCK_NUM_SHIFT        10
+
+#define REG_CNT_BLOCK_NUM_MASK          0x3ff
+#define REG_CNT_BLOCK_NUM_SHIFT         22
+
+#define REG_CNT_PAGE_NUM_MASK           0x3f
+#define REG_CNT_PAGE_NUM_SHIFT          16
+
+#define ERR_STR_DRIVER "Driver does not support this configure "
+#define ERR_STR_CHECK "Please make sure the hardware configuration is correct"
+#define HIFMC100_ADDR_CYCLE_MASK        0x2
+#define OP_STYPE_NONE           0x0
+#define OP_STYPE_READ           0x01
+#define OP_STYPE_WRITE          0x02
+#define OP_STYPE_ERASE          0x04
+#define CLK_FMC_TO_CRG_MHZ(_clk)    ((_clk) * 2000000)
+#define MAX_SPI_OP          8
+/* SPI general operation parameter */
+struct spi_op {
+	unsigned char iftype;
+	unsigned char cmd;
+	unsigned char dummy;
+	unsigned int size;
+	unsigned int clock;
+};
+
+struct spi_drv;
+
+/* SPI interface all operation */
+struct hifmc_spi {
+	char *name;
+	int chipselect;
+	unsigned long long chipsize;
+	unsigned int erasesize;
+#define SPI_NOR_3BYTE_ADDR_LEN  3   /* address len 3Bytes */
+#define SPI_NOR_4BYTE_ADDR_LEN  4   /* address len 4Bytes for 32MB */
+	unsigned int addrcycle;
+
+	struct spi_op read[1];
+	struct spi_op write[1];
+	struct spi_op erase[MAX_SPI_OP];
+
+	void *host;
+
+	struct spi_drv *driver;
+};
+
+/* SPI interface special operation function hook */
+struct spi_drv {
+	int (*wait_ready)(struct hifmc_spi *spi);
+	int (*write_enable)(struct hifmc_spi *spi);
+	int (*qe_enable)(struct hifmc_spi *spi);
+	int (*bus_prepare)(struct hifmc_spi *spi, int op);
+	int (*entry_4addr)(struct hifmc_spi *spi, int en);
+};
+
+struct spi_nand_info {
+	char *name;
+	unsigned char id[MAX_SPI_NAND_ID_LEN];
+	unsigned char id_len;
+	unsigned long long chipsize;
+	unsigned int erasesize;
+	unsigned int pagesize;
+	unsigned int oobsize;
+#define BBP_LAST_PAGE       0x01
+#define BBP_FIRST_PAGE      0x02
+	unsigned int badblock_pos;
+	struct spi_op *read[MAX_SPI_OP];
+	struct spi_op *write[MAX_SPI_OP];
+	struct spi_op *erase[MAX_SPI_OP];
+	struct spi_drv *driver;
+};
+
+extern char spi_nand_feature_op(struct hifmc_spi *spi, u_char op, u_char addr,
+				  u_char *val);
+
+struct hifmc_host {
+	struct mtd_info *mtd;
+	struct nand_chip *chip;
+	struct hifmc_spi spi[CONFIG_SPI_NAND_MAX_CHIP_NUM];
+	struct hifmc_cmd_op cmd_op;
+
+	void __iomem *iobase;
+	void __iomem *regbase;
+	struct clk *clk;
+	u32 clkrate;
+
+	unsigned int fmc_cfg;
+	unsigned int fmc_cfg_ecc0;
+
+	unsigned int offset;
+
+	struct device *dev;
+	struct mutex *lock;
+
+	/* This is maybe an un-aligment address, only for malloc or free */
+	char *buforg;
+	char *buffer;
+
+#ifdef CONFIG_64BIT
+	unsigned long long dma_buffer;
+	unsigned long long dma_oob;
+#else
+	unsigned int dma_buffer;
+	unsigned int dma_oob;
+#endif
+
+	unsigned int addr_cycle;
+	unsigned int addr_value[2];
+	unsigned int cache_addr_value[2];
+
+	unsigned int column;
+	unsigned int block_page_mask;
+
+	unsigned int ecctype;
+	unsigned int pagesize;
+	unsigned int oobsize;
+
+	int add_partition;
+
+	int  need_rr_data;
+#define HIFMC100_READ_RETRY_DATA_LEN         128
+	char rr_data[HIFMC100_READ_RETRY_DATA_LEN];
+	struct read_retry_t *read_retry;
+
+	int version;
+
+	/* BOOTROM read two bytes to detect the bad block flag */
+#define HIFMC_BAD_BLOCK_POS     0
+	unsigned char *bbm; /* nand bad block mark */
+	unsigned short *epm;    /* nand empty page mark */
+
+	unsigned int uc_er;
+
+	void (*send_cmd_write)(struct hifmc_host *host);
+	void (*send_cmd_status)(struct hifmc_host *host);
+	void (*send_cmd_read)(struct hifmc_host *host);
+	void (*send_cmd_erase)(struct hifmc_host *host);
+	void (*send_cmd_readid)(struct hifmc_host *host);
+	void (*send_cmd_reset)(struct hifmc_host *host);
+#ifdef CONFIG_PM
+	int (*suspend)(struct platform_device *pltdev, pm_message_t state);
+	int (*resume)(struct platform_device *pltdev);
+#endif
+};
+
+void hifmc100_ecc0_switch(struct hifmc_host *host, unsigned char op);
+
+void hifmc100_spi_nand_init(struct nand_chip *chip);
+
+extern void hifmc_spi_nand_ids_register(void);
+
+extern void hifmc_set_nand_system_clock(struct spi_op *op, int clk_en);
+
+#ifdef CONFIG_PM
+int hifmc100_suspend(struct platform_device *pltdev, pm_message_t state);
+int hifmc100_resume(struct platform_device *pltdev);
+void hifmc100_spi_nand_config(struct hifmc_host *host);
+#endif
+
+#endif /* End of __HIFMC100_H__ */
diff --git a/drivers/mtd/nand/hifmc100/hifmc100_os.c b/drivers/mtd/nand/hifmc100/hifmc100_os.c
new file mode 100644
index 000000000..980bfb8f6
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100/hifmc100_os.c
@@ -0,0 +1,247 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/rawnand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/of_platform.h>
+#include <linux/mfd/hisi_fmc.h>
+
+#include <asm/setup.h>
+
+#include "../../mtdcore.h"
+#include "hifmc100.h"
+
+static int hifmc100_spi_nand_pre_probe(struct nand_chip *chip)
+{
+	uint8_t nand_maf_id;
+	struct hifmc_host *host = chip->priv;
+
+	/* Reset the chip first */
+	host->send_cmd_reset(host);
+	udelay(1000);
+
+	/* Check the ID */
+	host->offset = 0;
+	memset((unsigned char *)(chip->IO_ADDR_R), 0, 0x10);
+	host->send_cmd_readid(host);
+	nand_maf_id = hifmc_readb(chip->IO_ADDR_R);
+
+	if (nand_maf_id == 0x00 || nand_maf_id == 0xff) {
+		printk("Cannot found a valid SPI Nand Device\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int hifmc_nand_scan(struct mtd_info *mtd)
+{
+	int result = 0;
+	unsigned char cs;
+	unsigned char chip_num = CONFIG_SPI_NAND_MAX_CHIP_NUM;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	for (cs = 0; chip_num && (cs < HIFMC_MAX_CHIP_NUM); cs++) {
+		if (hifmc_cs_user[cs]) {
+			FMC_PR(BT_DBG, "\t\t*-Current CS(%d) is occupied.\n",
+			       cs);
+			continue;
+		}
+
+		host->cmd_op.cs = cs;
+
+		if (hifmc100_spi_nand_pre_probe(chip)) {
+			return -ENODEV;
+		}
+
+		FMC_PR(BT_DBG, "\t\t*-Scan SPI nand flash on CS: %d\n", cs);
+		if (nand_scan_with_ids(mtd, chip_num, NULL)) {
+			continue;
+		}
+		chip_num--;
+	}
+
+	if (chip_num == CONFIG_SPI_NAND_MAX_CHIP_NUM) {
+		result = -ENXIO;
+	} else {
+		result = 0;
+	}
+
+	return result;
+}
+
+static int hisi_spi_nand_probe(struct platform_device *pltdev)
+{
+	int len;
+	int result = 0;
+	struct hifmc_host *host = NULL;
+	struct nand_chip *chip = NULL;
+	struct mtd_info *mtd = NULL;
+	struct device *dev = &pltdev->dev;
+	struct device_node *np = NULL;
+	struct hisi_fmc *fmc = dev_get_drvdata(dev->parent);
+
+	FMC_PR(BT_DBG, "\t*-Start SPI Nand flash driver probe\n");
+
+	if (!fmc) {
+		dev_err(dev, "get mfd fmc devices failed\n");
+		return -ENXIO;
+	}
+
+	len = sizeof(struct hifmc_host) + sizeof(struct nand_chip) +
+	      sizeof(struct mtd_info);
+	host = devm_kzalloc(dev, len, GFP_KERNEL);
+	if (!host) {
+		return -ENOMEM;
+	}
+	memset((char *)host, 0, len);
+
+	platform_set_drvdata(pltdev, host);
+	host->dev = &pltdev->dev;
+
+	host->chip = chip = (struct nand_chip *)&host[1];
+	host->mtd  = mtd  = nand_to_mtd(chip);
+
+	host->regbase = fmc->regbase;
+	host->iobase = fmc->iobase;
+	host->clk = fmc->clk;
+	host->lock = &fmc->lock;
+	host->buffer = fmc->buffer;
+	host->dma_buffer = fmc->dma_buffer;
+
+	memset((char *)host->iobase, 0xff, fmc->dma_len);
+	chip->IO_ADDR_R = chip->IO_ADDR_W = host->iobase;
+
+	chip->priv = host;
+
+	/* Set system clock */
+	result = clk_prepare_enable(host->clk);
+	if (result) {
+		printk("\nclk prepare enable failed!");
+		goto fail;
+	}
+
+	hifmc100_spi_nand_init(chip);
+
+	np = of_get_next_available_child(dev->of_node, NULL);
+	if (np == NULL) {
+		printk("\nof_get_next_available_child failed!");
+		goto fail;
+	}
+	mtd->name = np->name;
+	mtd->type = MTD_NANDFLASH;
+	mtd->priv = chip;
+	mtd->owner = THIS_MODULE;
+
+	result = of_property_read_u32(np, "spi-max-frequency", &host->clkrate);
+	if (result) {
+		printk("\nget fmc clkrate failed");
+		goto fail;
+	}
+
+	result = hifmc_nand_scan(mtd);
+	if (result) {
+		FMC_PR(BT_DBG, "\t|-Scan SPI Nand failed.\n");
+		goto fail;
+	}
+
+	result = mtd_device_register(mtd, NULL, 0);
+	if (!result) {
+		FMC_PR(BT_DBG, "\t*-End driver probe !!\n");
+		return 0;
+	}
+
+	result = -ENODEV;
+	nand_release(mtd);
+fail:
+	clk_disable_unprepare(host->clk);
+	DB_MSG("Error: driver probe, result: %d\n", result);
+	return result;
+}
+
+static int hisi_spi_nand_remove(struct platform_device *pltdev)
+{
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+
+	if (host) {
+		if (host->clk)
+			clk_disable_unprepare(host->clk);
+		if (host->mtd)
+			nand_release(host->mtd);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int hifmc100_os_suspend(struct platform_device *pltdev,
+			       pm_message_t state)
+{
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+
+	if (host && host->suspend) {
+		return (host->suspend)(pltdev, state);
+	}
+
+	return 0;
+}
+
+static int hifmc100_os_resume(struct platform_device *pltdev)
+{
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+
+	if (host && host->resume) {
+		return (host->resume)(pltdev);
+	}
+
+	return 0;
+}
+#endif /* End of CONFIG_PM */
+
+static const struct of_device_id hisi_spi_nand_dt_ids[] = {
+	{ .compatible = "hisilicon,hisi-spi-nand" },
+	{ } /* sentinel */
+};
+MODULE_DEVICE_TABLE(of, hisi_spi_nand_dt_ids);
+
+static struct platform_driver hisi_spi_nand_driver = {
+	.driver = {
+		.name   = "hisi_spi_nand",
+		.of_match_table = hisi_spi_nand_dt_ids,
+	},
+	.probe  = hisi_spi_nand_probe,
+	.remove = hisi_spi_nand_remove,
+#ifdef CONFIG_PM
+	.suspend    = hifmc100_os_suspend,
+	.resume     = hifmc100_os_resume,
+#endif
+};
+module_platform_driver(hisi_spi_nand_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("BVT_BSP");
+MODULE_DESCRIPTION("Hisilicon Flash Memory Controller V100 SPI Nand Driver");
diff --git a/drivers/mtd/nand/hifmc100/hifmc100_spi_general.c b/drivers/mtd/nand/hifmc100/hifmc100_spi_general.c
new file mode 100644
index 000000000..3b46205f3
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100/hifmc100_spi_general.c
@@ -0,0 +1,313 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/*
+    Send set/get features command to SPI Nand flash
+*/
+char spi_nand_feature_op(struct hifmc_spi *spi, u_char op, u_char addr,
+			   u_char *val)
+{
+	unsigned int reg;
+	const char *str[] = {"Get", "Set"};
+	struct hifmc_host *host = NULL;
+
+	if (!spi) {
+		DB_MSG("Error: spi is NULL !\n");
+		return -1;
+	}
+	host = (struct hifmc_host *)spi->host;
+	if (!host) {
+		DB_MSG("Error: host is NULL !\n");
+		return -1;
+	}
+
+	if ((op == GET_OP) && (STATUS_ADDR == addr)) {
+		if (!val) {
+			DB_MSG("Error: val is NULL !\n");
+			return -1;
+		}
+		if (SR_DBG) {
+			pr_info("\n");
+		}
+		FMC_PR(SR_DBG, "\t\t|*-Start Get Status\n");
+
+		reg = OP_CFG_FM_CS(host->cmd_op.cs) | OP_CFG_OEN_EN;
+		hifmc_writel(host, FMC_OP_CFG, reg);
+		FMC_PR(SR_DBG, "\t\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+		reg = FMC_OP_READ_STATUS_EN | FMC_OP_REG_OP_START;
+		hifmc_writel(host, FMC_OP, reg);
+		FMC_PR(SR_DBG, "\t\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+		FMC_CMD_WAIT_CPU_FINISH(host);
+
+		*val = hifmc_readl(host, FMC_STATUS);
+		FMC_PR(SR_DBG, "\t\t|*-End Get Status, result: %#x\n", *val);
+
+		return 0;
+	}
+
+	FMC_PR(FT_DBG, "\t|||*-Start %s feature, addr[%#x]\n", str[op], addr);
+
+	hifmc100_ecc0_switch(host, ENABLE);
+
+	reg = FMC_CMD_CMD1(op ? SPI_CMD_SET_FEATURE : SPI_CMD_GET_FEATURES);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(FT_DBG, "\t||||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	hifmc_writel(host, FMC_ADDRL, addr);
+	FMC_PR(FT_DBG, "\t||||-Set ADDRL[%#x]%#x\n", FMC_ADDRL, addr);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+	      | OP_CFG_ADDR_NUM(FEATURES_OP_ADDR_NUM)
+	      | OP_CFG_OEN_EN;
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(FT_DBG, "\t||||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_DATA_NUM_CNT(FEATURES_DATA_LEN);
+	hifmc_writel(host, FMC_DATA_NUM, reg);
+	FMC_PR(FT_DBG, "\t||||-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = FMC_OP_CMD1_EN
+	      | FMC_OP_ADDR_EN
+	      | FMC_OP_REG_OP_START;
+
+	if (op == SET_OP) {
+		if (!val || !host->iobase) {
+			DB_MSG("Error: host->iobase is NULL !\n");
+			return -1;
+		}
+		reg |= FMC_OP_WRITE_DATA_EN;
+		hifmc_writeb(*val, host->iobase);
+		FMC_PR(FT_DBG, "\t||||-Write IO[%#lx]%#x\n", (long)host->iobase,
+		       *(u_char *)host->iobase);
+	} else {
+		reg |= FMC_OP_READ_DATA_EN;
+	}
+
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(FT_DBG, "\t||||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	if (op == GET_OP) {
+		if (!val || !host->iobase) {
+			DB_MSG("Error: val or host->iobase is NULL !\n");
+			return -1;
+		}
+		*val = hifmc_readb(host->iobase);
+		FMC_PR(FT_DBG, "\t||||-Read IO[%#lx]%#x\n", (long)host->iobase,
+		       *(u_char *)host->iobase);
+	}
+
+	hifmc100_ecc0_switch(host, DISABLE);
+
+	FMC_PR(FT_DBG, "\t|||*-End %s Feature[%#x]:%#x\n", str[op], addr, *val);
+
+	return 0;
+}
+
+/*
+    Read status[C0H]:[0]bit OIP, judge whether the device is busy or not
+*/
+static int spi_general_wait_ready(struct hifmc_spi *spi)
+{
+	unsigned char status;
+	int ret;
+	unsigned long deadline = jiffies + FMC_MAX_READY_WAIT_JIFFIES;
+	struct hifmc_host *host = NULL;
+
+	if(spi == NULL || spi->host == NULL) {
+		DB_MSG("Error: host or host->spi is NULL!\n");
+		return -1;
+	}
+	host = (struct hifmc_host *)spi->host;
+
+	do {
+		ret = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, &status);
+		if (ret)
+		    return -1;
+		if (!(status & STATUS_OIP_MASK)) {
+			if ((host->cmd_op.l_cmd == NAND_CMD_ERASE2)
+					&& (status & STATUS_E_FAIL_MASK)) {
+				return status;
+			}
+			if ((host->cmd_op.l_cmd == NAND_CMD_PAGEPROG)
+					&& (status & STATUS_P_FAIL_MASK)) {
+				return status;
+			}
+			return 0;
+		}
+
+		cond_resched();
+	} while (!time_after_eq(jiffies, deadline));
+
+	DB_MSG("Error: SPI Nand wait ready timeout, status: %#x\n", status);
+
+	return 1;
+}
+
+/*
+    Send write enable cmd to SPI Nand, status[C0H]:[2]bit WEL must be set 1
+*/
+static int spi_general_write_enable(struct hifmc_spi *spi)
+{
+	u_char reg;
+	int ret;
+	unsigned int regl;
+	struct hifmc_host *host = NULL;
+	if(spi == NULL || spi->host == NULL) {
+		DB_MSG("Error: host or host->spi is NULL!\n");
+		return -1;
+	}
+	host = spi->host;
+	if (WE_DBG) {
+		pr_info("\n");
+	}
+	FMC_PR(WE_DBG, "\t|*-Start Write Enable\n");
+
+	ret = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, &reg);
+	if (ret)
+		return -1;
+	if (reg & STATUS_WEL_MASK) {
+		FMC_PR(WE_DBG, "\t||-Write Enable was opened! reg: %#x\n",
+		       reg);
+		return 0;
+	}
+
+	regl = hifmc_readl(host, FMC_GLOBAL_CFG);
+	FMC_PR(WE_DBG, "\t||-Get GLOBAL_CFG[%#x]%#x\n", FMC_GLOBAL_CFG, regl);
+	if (regl & FMC_GLOBAL_CFG_WP_ENABLE) {
+		regl &= ~FMC_GLOBAL_CFG_WP_ENABLE;
+		hifmc_writel(host, FMC_GLOBAL_CFG, regl);
+		FMC_PR(WE_DBG, "\t||-Set GLOBAL_CFG[%#x]%#x\n",
+		       FMC_GLOBAL_CFG, regl);
+	}
+
+	regl = FMC_CMD_CMD1(SPI_CMD_WREN);
+	hifmc_writel(host, FMC_CMD, regl);
+	FMC_PR(WE_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, regl);
+
+	regl = OP_CFG_FM_CS(host->cmd_op.cs) | OP_CFG_OEN_EN;
+	hifmc_writel(host, FMC_OP_CFG, regl);
+	FMC_PR(WE_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regl);
+
+	regl = FMC_OP_CMD1_EN | FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, regl);
+	FMC_PR(WE_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, regl);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+#if WE_DBG
+	if(!spi->driver) {
+		DB_MSG("Error: spi->driver is NULL!\n");
+		return -1;
+	}
+	spi->driver->wait_ready(spi);
+
+	ret = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, &reg);
+	if (ret)
+		return -1;
+	if (reg & STATUS_WEL_MASK) {
+		FMC_PR(WE_DBG, "\t||-Write Enable success. reg: %#x\n", reg);
+	} else {
+		DB_MSG("Error: Write Enable failed! reg: %#x\n", reg);
+		return reg;
+	}
+#endif
+
+	FMC_PR(WE_DBG, "\t|*-End Write Enable\n");
+	return 0;
+}
+
+/*
+    judge whether SPI Nand support QUAD read/write or not
+*/
+static int spi_is_quad(struct hifmc_spi *spi)
+{
+	const char *if_str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+	FMC_PR(QE_DBG, "\t\t|||*-SPI read iftype: %s write iftype: %s\n",
+	       if_str[spi->read->iftype], if_str[spi->write->iftype]);
+
+	if ((spi->read->iftype == IF_TYPE_QUAD)
+			|| (spi->read->iftype == IF_TYPE_QIO)
+			|| (spi->write->iftype == IF_TYPE_QUAD)
+			|| (spi->write->iftype == IF_TYPE_QIO)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/*
+    Send set features cmd to SPI Nand, feature[B0H]:[0]bit QE would be set
+*/
+static int spi_general_qe_enable(struct hifmc_spi *spi)
+{
+	int op;
+	u_char reg;
+	int ret;
+	const char *str[] = {"Disable", "Enable"};
+
+	if(!spi || !spi->host || !spi->driver) {
+		DB_MSG("Error: host or spi->host or spi->driver is NULL!\n");
+		return -1;
+	}
+	FMC_PR(QE_DBG, "\t||*-Start SPI Nand flash QE\n");
+
+	op = spi_is_quad(spi);
+
+	FMC_PR(QE_DBG, "\t|||*-End Quad check, SPI Nand %s Quad.\n", str[op]);
+
+	ret = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, &reg);
+	if (ret)
+		return -1;
+	FMC_PR(QE_DBG, "\t|||-Get [%#x]feature: %#x\n", FEATURE_ADDR, reg);
+	if ((reg & FEATURE_QE_ENABLE) == op) {
+		FMC_PR(QE_DBG, "\t||*-SPI Nand quad was %sd!\n", str[op]);
+		return op;
+	}
+
+	if (op == ENABLE) {
+		reg |= FEATURE_QE_ENABLE;
+	} else {
+		reg &= ~FEATURE_QE_ENABLE;
+	}
+
+	ret = spi_nand_feature_op(spi, SET_OP, FEATURE_ADDR, &reg);
+	if (ret)
+		return -1;
+	FMC_PR(QE_DBG, "\t|||-SPI Nand %s Quad\n", str[op]);
+
+	spi->driver->wait_ready(spi);
+
+	ret = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, &reg);
+	if (ret)
+		return -1;
+	if ((reg & FEATURE_QE_ENABLE) == op) {
+		FMC_PR(QE_DBG, "\t|||-SPI Nand %s Quad succeed!\n", str[op]);
+	} else {
+		DB_MSG("Error: %s Quad failed! reg: %#x\n", str[op], reg);
+	}
+
+	FMC_PR(QE_DBG, "\t||*-End SPI Nand %s Quad.\n", str[op]);
+
+	return op;
+}
diff --git a/drivers/mtd/nand/hifmc100/hifmc_spi_nand_ids.c b/drivers/mtd/nand/hifmc100/hifmc_spi_nand_ids.c
new file mode 100644
index 000000000..bf963d146
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100/hifmc_spi_nand_ids.c
@@ -0,0 +1,2457 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <asm/setup.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/sched.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/rawnand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mfd/hisi_fmc.h>
+#include <linux/uaccess.h>
+
+#include "../raw/hinfc_gen.h"
+#include "hifmc100.h"
+
+SET_READ_STD(1, INFINITE, 24);
+
+SET_READ_FAST(1, INFINITE, 80);
+SET_READ_FAST(1, INFINITE, 100);
+SET_READ_FAST(1, INFINITE, 104);
+SET_READ_FAST(1, INFINITE, 108);
+SET_READ_FAST(1, INFINITE, 120);
+SET_READ_FAST(1, INFINITE, 133);
+
+SET_READ_DUAL(1, INFINITE, 80);
+SET_READ_DUAL(1, INFINITE, 100);
+SET_READ_DUAL(1, INFINITE, 104);
+SET_READ_DUAL(1, INFINITE, 108);
+SET_READ_DUAL(1, INFINITE, 120);
+SET_READ_DUAL(1, INFINITE, 133);
+
+SET_READ_DUAL_ADDR(1, INFINITE, 40);
+SET_READ_DUAL_ADDR(1, INFINITE, 80);
+SET_READ_DUAL_ADDR(2, INFINITE, 80);
+SET_READ_DUAL_ADDR(1, INFINITE, 100);
+SET_READ_DUAL_ADDR(1, INFINITE, 104);
+SET_READ_DUAL_ADDR(1, INFINITE, 108);
+SET_READ_DUAL_ADDR(1, INFINITE, 120);
+SET_READ_DUAL_ADDR(2, INFINITE, 104);
+
+SET_READ_QUAD(1, INFINITE, 80);
+SET_READ_QUAD(1, INFINITE, 100);
+SET_READ_QUAD(1, INFINITE, 104);
+SET_READ_QUAD(1, INFINITE, 108);
+SET_READ_QUAD(1, INFINITE, 120);
+SET_READ_QUAD(1, INFINITE, 133);
+
+SET_READ_QUAD_ADDR(2, INFINITE, 40);
+SET_READ_QUAD_ADDR(1, INFINITE, 80);
+SET_READ_QUAD_ADDR(2, INFINITE, 80);
+SET_READ_QUAD_ADDR(4, INFINITE, 80);
+SET_READ_QUAD_ADDR(1, INFINITE, 100);
+SET_READ_QUAD_ADDR(1, INFINITE, 104);
+SET_READ_QUAD_ADDR(2, INFINITE, 104);
+SET_READ_QUAD_ADDR(1, INFINITE, 108);
+SET_READ_QUAD_ADDR(1, INFINITE, 120);
+SET_READ_QUAD_ADDR(4, INFINITE, 104);
+
+SET_WRITE_STD(0, 256, 24);
+SET_WRITE_STD(0, 256, 75);
+SET_WRITE_STD(0, 256, 80);
+SET_WRITE_STD(0, 256, 100);
+SET_WRITE_STD(0, 256, 104);
+SET_WRITE_STD(0, 256, 133);
+
+SET_WRITE_QUAD(0, 256, 80);
+SET_WRITE_QUAD(0, 256, 100);
+SET_WRITE_QUAD(0, 256, 104);
+SET_WRITE_QUAD(0, 256, 108);
+SET_WRITE_QUAD(0, 256, 120);
+SET_WRITE_QUAD(0, 256, 133);
+
+SET_ERASE_SECTOR_128K(0, _128K, 24);
+SET_ERASE_SECTOR_128K(0, _128K, 75);
+SET_ERASE_SECTOR_128K(0, _128K, 80);
+SET_ERASE_SECTOR_128K(0, _128K, 104);
+SET_ERASE_SECTOR_128K(0, _128K, 133);
+
+SET_ERASE_SECTOR_256K(0, _256K, 24);
+SET_ERASE_SECTOR_256K(0, _256K, 75);
+SET_ERASE_SECTOR_256K(0, _256K, 80);
+SET_ERASE_SECTOR_256K(0, _256K, 100);
+SET_ERASE_SECTOR_256K(0, _256K, 104);
+SET_ERASE_SECTOR_256K(0, _256K, 133);
+
+#include "hifmc100_spi_general.c"
+static struct spi_drv spi_driver_general = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_general_qe_enable,
+};
+
+/* some spi nand flash default QUAD enable, needn't to set qe enable */
+static struct spi_drv spi_driver_no_qe = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+};
+
+#define SPI_NAND_ID_TAB_VER     "2.7"
+
+/******* SPI Nand ID Table ***************************************************
+ * Version  Manufacturer    Chip Name   Size        Operation
+ * 1.0  ESMT        F50L512M41A     64MB        Add 5 chip
+ *      GD          5F1GQ4UAYIG     128MB
+ *      GD          5F2GQ4UAYIG     256MB
+ *	GD	    GD5F2GQ5UEYIG   256MB
+ *      GD          5F4GQ4UAYIG     512MB
+ *      GD          5F4GQ4UBYIG     512MB
+ *      GD          5F1GQ4RB9IG     128MB
+ *      GD          5F1GQ4UEYIHY    128MB
+ * 1.1  ESMT        F50L1G41A       128MB       Add 2 chip
+ *      Winbond     W25N01GV        128MB
+ *      Winbond     W25N02JWZEIF    256MB
+ * 1.2  GD          5F1GQ4UBYIG     128MB       Add 2 chip
+ *      GD      5F2GQ4U9IGR/BYIG    256MB
+ *      GD   1.8V   5F4GQ6RE9IG     512MB
+ * 1.3  ATO         ATO25D1GA       128MB       Add 1 chip
+ * 1.4  MXIC        MX35LF1GE4AB    128MB       Add 2 chip
+ *      MXIC        MX35LF2GE4AB    256MB       (SOP-16Pin)
+ * 1.5  Paragon     PN26G01A        128MB       Add 1 chip
+ * 1.6  All-flash   AFS1GQ4UAC      128MB       Add 1 chip
+ * 1.7  TOSHIBA     TC58CVG0S3H     128MB       Add 2 chip
+ *      TOSHIBA     TC58CVG2S0H     512MB
+ * 1.8  ALL-flash   AFS2GQ4UAD      256MB       Add 2 chip
+ *      Paragon     PN26G02A        256MB
+ * 1.9  TOSHIBA     TC58CVG1S3H     256MB       Add 1 chip
+ * 2.0  HeYangTek   HYF1GQ4UAACAE   128MB       Add 3 chip
+ *      HeYangTek   HYF2GQ4UAACAE   256MB
+ *      HeYangTek   HYF4GQ4UAACBE   512MB
+ * 2.1  Micron      MT29F1G01ABA    128MB       Add 5 chip
+ *	TOSHIBA 1.8V TC58CYG0S3H   128MB
+ *	TOSHIBA 1.8V TC58CYG1S3H   256MB
+ *	TOSHIBA 1.8V TC58CYG2S0H   512MB
+ *	Winbond 1.8V W25N01GWZEIG  128MB
+ * 2.2  Micron      MT29F2G01ABA    256MB       Add 1 chip
+ * 2.3  MXIC        MX35LF2G14AC    256MB       Add 1 chip
+ * 2.4  GD 1.8V     5F4GQ4RAYIG     512MB       Add 1 chip
+ * 2.5  GD 1.8V     5F2GQ4RB9IGR    256MB       Add 1 chip
+ * 2.6  MXIC 1.8V   MX35UF1G14AC    128MB       Add 4 chip
+ *      MXIC 1.8V   MX35UF2G14AC    256MB
+ *      Micron 1.8V MT29F1G01ABB    128MB
+ *      Micron 1.8V MT29F2G01ABB    256MB
+ * 2.7  Dosilicon   DS35Q1GA-IB     128MB       Add 2 chip
+ *      Dosilicon   DS35Q2GA-IB     256MB
+ *      GD          5F1GQ4RB9IGR    128MB
+ *      Micron      MT29F4G01ADAG   512MB   3.3V    Add 1 chip
+ *      GD 1.8V     5F4GQ4RBYIG     512MB       Add 1 chip
+ *      Etron 1.8V  EM78D044VCF-H   256MB
+ *      Etron 3.3V  EM73C044VCC-H   128MB
+ *      XTX 3.3V    XT26G01B 1Gbit  128MB
+ *      Micron      MT29F4G01ABBFDW 512MB 	1.8V
+ *	FM	    FM25S01-DND-A-G 128MB  	3.3V
+ *	FM	    FM25S01A	    128MB	3.3V
+ ******************************************************************************/
+struct spi_nand_info hifmc_spi_nand_flash_table[] = {
+	/* Micron MT29F1G01ABA 1GBit */
+	{
+		.name      = "MT29F1G01ABA",
+		.id        = {0x2C, 0x14},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(2, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F1G01ABB 1GBit 1.8V */
+	{
+		.name      = "MT29F1G01ABB",
+		.id        = {0x2C, 0x15},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(2, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F2G01ABA 2GBit */
+	{
+		.name      = "MT29F2G01ABA",
+		.id        = {0x2C, 0x24},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 108),
+			&READ_DUAL(1, INFINITE, 108),
+			&READ_DUAL_ADDR(1, INFINITE, 108),
+			&READ_QUAD(1, INFINITE, 108),
+			&READ_QUAD_ADDR(2, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 108),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F2G01ABB 2GBit 1.8V */
+	{
+		.name      = "MT29F2G01ABB",
+		.id        = {0x2C, 0x25},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(2, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F4G01ADAG 4GBit 3.3V */
+	{
+		.name      = "MT29F4G01ADAG",
+		.id        = {0x2C, 0x36},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 108),
+			&READ_DUAL(1, INFINITE, 108),
+			&READ_DUAL_ADDR(1, INFINITE, 108),
+			&READ_QUAD(1, INFINITE, 108),
+			&READ_QUAD_ADDR(2, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 108),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ESMT F50L512M41A 512Mbit */
+	{
+		.name      = "F50L512M41A",
+		.id        = {0xC8, 0x20},
+		.id_len    = 2,
+		.chipsize  = _64M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ESMT F50L1G41A 1Gbit */
+	{
+		.name      = "F50L1G41A",
+		.id        = {0xC8, 0x21},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* GD 3.3v GD5F1GQ5UEYIGY/GD5F1GQ5UEYIGR 1Gbit */
+	{
+		.name      = "GD5F1GQ5UEYIGY",
+		.id        = {0xc8, 0x51},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 133),
+			&READ_DUAL(1, INFINITE, 133),
+			&READ_QUAD(1, INFINITE, 133),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 133),
+			&WRITE_QUAD(0, 256, 133),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 133),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* ESMT F50L1G41LB-104YG2ME 1Gbit */
+	{
+		.name      = "F50L1G41LB-104YG2ME",
+		.id        = {0xC8, 0x01, 0X7F},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* GD 3.3v GD5F1GQ4UAYIG 1Gbit */
+	{
+		.name      = "GD5F1GQ4UAYIG",
+		.id        = {0xc8, 0xf1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8v GD5F1GQ5REYIG 1Gbit */
+	{
+		.name      = "GD5F1GQ5REYIG",
+		.id        = {0xc8, 0x41},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F1GQ4UEYIHY 1Gbit */
+	{
+		.name      = "GD5F1GQ4UEYIHY",
+		.id        = {0xc8, 0xd9},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8v GD5F1GQ4RB9IG 1Gbit */
+	{
+		.name      = "GD5F1GQ4RB9IG",
+		.id        = {0xc8, 0xc1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F1GQ4UBYIG 1Gbit */
+	{
+		.name      = "GD5F1GQ4UBYIG",
+		.id        = {0xc8, 0xd1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F2GQ4UAYIG 2Gbit */
+	{
+		.name      = "GD5F2GQ4UAYIG",
+		.id        = {0xc8, 0xf2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F2GQ4U9IGR/BYIG 2Gbit */
+	{
+		.name      = "GD5F2GQ4U9IGR/BYIG",
+		.id        = {0xc8, 0xd2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F2GQ5UEYIG 2Gbit */
+	{
+		.name      = "GD5F2GQ5UEYIG",
+		.id        = {0xc8, 0x52},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_DUAL_ADDR(2, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			&READ_QUAD_ADDR(4, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8v GD5F2GQ5REYIG 2Gbit */
+	{
+        .name      = "GD5F2GQ5REYIG",
+        .id        = {0xc8, 0x42},
+        .id_len    = 2,
+        .chipsize  = _256M,
+        .erasesize = _128K,
+        .pagesize  = _2K,
+        .oobsize   = 128,
+        .badblock_pos = BBP_FIRST_PAGE,
+        .read      = {
+            &READ_STD(1, INFINITE, 24),
+            &READ_FAST(1, INFINITE, 104),
+            &READ_DUAL(1, INFINITE, 104),
+            &READ_DUAL_ADDR(2, INFINITE, 104),
+            &READ_QUAD(1, INFINITE, 104),
+            &READ_QUAD_ADDR(4, INFINITE, 104),
+            0
+        },
+        .write     = {
+            &WRITE_STD(0, 256, 104),
+            &WRITE_QUAD(0, 256, 104),
+            0
+        },
+        .erase     = {
+            &ERASE_SECTOR_128K(0, _128K, 104),
+            0
+        },
+        .driver    = &spi_driver_general,
+    },
+
+	/* GD 3.3v GD5F4GQ4UAYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4UAYIG",
+		.id        = {0xc8, 0xf4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F4GQ4UBYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4UBYIG",
+		.id        = {0xc8, 0xd4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F4GQ6UEYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ6UEYIG",
+		.id        = {0xc8, 0x55},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24), /* 24MHz */
+			&READ_FAST(1, INFINITE, 104),  /* 104MHz */
+			&READ_DUAL(1, INFINITE, 104),  /* 104MHz */
+			&READ_DUAL_ADDR(2, INFINITE, 104),  /* 104MHz */
+			&READ_QUAD(1, INFINITE, 104),  /* 104MHz */
+			&READ_QUAD_ADDR(4, INFINITE, 104),  /* 104MHz */
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),  /* 24MHz */
+			&WRITE_QUAD(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),  /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8V GD5F1GQ4RB9IGR 1Gbit */
+	{
+		.name      = "GD5F1GQ4RB9IGR",
+		.id        = {0xc8, 0xc1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_DUAL_ADDR(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			&READ_QUAD_ADDR(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8V GD5F2GQ4RB9IGR 2Gbit */
+	{
+		.name      = "GD5F2GQ4RB9IGR",
+		.id        = {0xc8, 0xc2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_DUAL_ADDR(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			&READ_QUAD_ADDR(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+	/* GD 1.8V 5F4GQ6RE9IG 4Gbit */
+	{
+		.name      = "GD5F4GQ6RE9IG",
+		.id        = {0xc8, 0x45},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(2, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(4, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+	/* GD 1.8V GD5F4GQ4RAYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4RAYIG",
+		.id        = {0xc8, 0xe4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_DUAL_ADDR(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			&READ_QUAD_ADDR(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Winbond 1.8V W25N02JWZEIF 2Gbit */
+	{
+		.name      = "W25N02JWZEIF",
+		.id        = {0xef, 0xbf, 0x22},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(2, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver  = &spi_driver_general,
+	},
+
+	/* GD 1.8V 5F4GQ4RBYIG 4Gbit */
+	{
+		.name      = "5F4GQ4RBYIG",
+		.id        = {0xc8, 0xc4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Winbond W25N01GV 1Gbit 3.3V */
+	{
+		.name      = "W25N01GV",
+		.id        = {0xef, 0xaa, 0x21},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_DUAL_ADDR(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			&READ_QUAD_ADDR(2, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Winbond W25N01GWZEIG 1Gbit 1.8V */
+	{
+		.name      = "W25N01GWZEIG",
+		.id        = {0xef, 0xba, 0x21},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_DUAL_ADDR(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			&READ_QUAD_ADDR(2, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ATO ATO25D1GA 1Gbit */
+	{
+		.name      = "ATO25D1GA",
+		.id        = {0x9b, 0x12},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF1GE4AB 1Gbit */
+	{
+		.name      = "MX35LF1GE4AB",
+		.id        = {0xc2, 0x12},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35UF1G14AC 1Gbit 1.8V */
+	{
+		.name      = "MX35UF1G14AC",
+		.id        = {0xc2, 0x90},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF2GE4AB 2Gbit SOP-16Pin */
+	{
+		.name      = "MX35LF2GE4AB",
+		.id        = {0xc2, 0x22},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF2G14AC 2GBit */
+	{
+		.name      = "MX35LF2G14AC",
+		.id        = {0xc2, 0x20},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35UF2G14AC 2Gbit 1.8V */
+	{
+		.name      = "MX35UF2G14AC",
+		.id        = {0xc2, 0xa0},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Paragon PN26G01A 1Gbit */
+	{
+		.name      = "PN26G01A",
+		.id        = {0xa1, 0xe1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 108),
+			&READ_DUAL(1, INFINITE, 108),
+			&READ_DUAL_ADDR(1, INFINITE, 108),
+			&READ_QUAD(1, INFINITE, 108),
+			&READ_QUAD_ADDR(1, INFINITE, 108),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 108),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Paragon PN26G02A 2Gbit */
+	{
+		.name      = "PN26G02A",
+		.id        = {0xa1, 0xe2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 108),
+			&READ_DUAL(1, INFINITE, 108),
+			&READ_DUAL_ADDR(1, INFINITE, 108),
+			&READ_QUAD(1, INFINITE, 108),
+			&READ_QUAD_ADDR(1, INFINITE, 108),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 108),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* All-flash AFS1GQ4UAC 1Gbit */
+	{
+		.name      = "AFS1GQ4UAC",
+		.id        = {0xc1, 0x51},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* All-flash AFS2GQ4UAD 2Gbit */
+	{
+		.name      = "AFS2GQ4UAD",
+		.id        = {0xc1, 0x52},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* TOSHIBA TC58CVG0S3H 1Gbit */
+	{
+		.name      = "TC58CVG0S3H",
+		.id        = {0x98, 0xc2},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	{
+		.name      = "TC58CVG0S3HRAIJ",
+		.id        = {0x98, 0xe2, 0x40},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 133),
+			&READ_DUAL(1, INFINITE, 133),
+			&READ_QUAD(1, INFINITE, 133),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 133),
+			&WRITE_QUAD(0, 256, 133),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 133),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+	/* TOSHIBA TC58CYG0S3H 1.8V 1Gbit */
+	{
+		.name      = "TC58CYG0S3H",
+		.id        = {0x98, 0xb2},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG0S3HRAIJ 1.8V 1Gbit */
+	{
+		.name      = "TC58CYG0S3HRAIJ",
+		.id        = {0x98, 0xD2, 0x40},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 133),
+			&READ_DUAL(1, INFINITE, 133),
+			&READ_QUAD(1, INFINITE, 133),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 133),
+			&WRITE_QUAD(0, 256, 133),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 133),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG1S3H 2Gbit */
+	{
+		.name      = "TC58CVG1S3H",
+		.id        = {0x98, 0xcb},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG1S3HRAIJ 2Gbit */
+	{
+		.name      = "TC58CVG1S3HRAIJ",
+		.id        = {0x98, 0xeb, 0x40},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 133),
+			&READ_DUAL(1, INFINITE, 133),
+			&READ_QUAD(1, INFINITE, 133),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 133),
+			&WRITE_QUAD(0, 256, 133),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 133),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG1S3H 1.8V 2Gbit */
+	{
+		.name      = "TC58CYG1S3H",
+		.id        = {0x98, 0xbb},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 75),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 75),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG1S3HRAIJ 1.8V 2Gbit */
+	{
+		.name      = "TC58CYG1S3HRAIJ",
+		.id        = {0x98, 0xdb, 0x40},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 133),
+			&READ_DUAL(1, INFINITE, 133),
+			&READ_QUAD(1, INFINITE, 133),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 133),
+			&WRITE_QUAD(0, 256, 133),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 133),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG2S0H 4Gbit */
+	{
+		.name      = "TC58CVG2S0H",
+		.id        = {0x98, 0xcd},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 104),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG2S0HRAIJ 4Gbit */
+	{
+		.name      = "TC58CVG2S0HRAIJ",
+		.id        = {0x98, 0xed, 0x51},
+		.id_len    = 3,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 133),
+			&READ_DUAL(1, INFINITE, 133),
+			&READ_QUAD(1, INFINITE, 133),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 133),
+			&WRITE_QUAD(0, 256, 133),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 133),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG2S0H 1.8V 4Gbit */
+	{
+		.name      = "TC58CYG2S0H",
+		.id        = {0x98, 0xbd},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 75),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 75),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* KIOXIA TH58CYG2S0HRAIJ 1.8V 4Gbit */
+	{
+		.name      = "TH58CYG2S0HRAIJ",
+		.id        = {0x98, 0xdd, 0x51},
+		.id_len    = 3,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24), /* 24MHz */
+			&READ_FAST(1, INFINITE, 133), /* 133MHz */
+			&READ_DUAL(1, INFINITE, 133), /* 133MHz */
+			&READ_QUAD(1, INFINITE, 133), /* 133MHz */
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 133), /* 133MHz */
+			&WRITE_QUAD(0, 256, 133), /* 133MHz */
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 133), /* 133MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* KIOXIA TH58CYG3S0H 1.8V 8Gbit */
+	{
+		.name      = "TH58CYG3S0H",
+		.id        = {0x98, 0xd4, 0x51},
+		.id_len    = 3,
+		.chipsize  = _1G,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24), /* 24MHz */
+			&READ_FAST(1, INFINITE, 133), /* 133MHz */
+			&READ_DUAL(1, INFINITE, 133), /* 133MHz */
+			&READ_QUAD(1, INFINITE, 133), /* 133MHz */
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 133), /* 133MHz */
+			&WRITE_QUAD(0, 256, 133), /* 133MHz */
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 133), /* 133MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* HeYangTek HYF1GQ4UAACAE 1Gbit */
+	{
+		.name      = "HYF1GQ4UAACAE",
+		.id        = {0xc9, 0x51},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* HeYangTek HYF2GQ4UAACAE 2Gbit */
+	{
+		.name      = "HYF2GQ4UAACAE",
+		.id        = {0xc9, 0x52},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* HeYangTek HYF4GQ4UAACBE 4Gbit */
+	{
+		.name      = "HYF4GQ4UAACBE",
+		.id        = {0xc9, 0xd4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Dosilicon 3.3V DS35Q1GA-IB 1Gbit */
+	{
+		.name      = "DS35Q1GA-IB",
+		.id        = {0xe5, 0x71},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* XTX 3.3V XT26G01B 1Gbit */
+	{
+		.name      = "XT26G01B",
+		.id        = {0x0B, 0xF1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Etron 1.8V EM78F044VCA-H 8Gbit */
+	{
+		.name      = "EM78F044VCA-H",
+		.id        = {0xD5, 0x8D},
+		.id_len    = 2,
+		.chipsize  = _512M * 2,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 100),
+			&READ_DUAL(1, INFINITE, 100),
+			&READ_DUAL_ADDR(1, INFINITE, 100),
+			&READ_QUAD(1, INFINITE, 100),
+			&READ_QUAD_ADDR(1, INFINITE, 100),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 100),
+			&WRITE_QUAD(0, 256, 100),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 100),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Etron 1.8V EM78E044VCA-H 4Gbit */
+	{
+		.name      = "EM78E044VCA-H",
+		.id        = {0xD5, 0x8C},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 100),
+			&READ_DUAL(1, INFINITE, 100),
+			&READ_DUAL_ADDR(1, INFINITE, 100),
+			&READ_QUAD(1, INFINITE, 100),
+			&READ_QUAD_ADDR(1, INFINITE, 100),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 100),
+			&WRITE_QUAD(0, 256, 100),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 100),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Etron 1.8V EM78D044VCF-H 2Gbit */
+	{
+		.name      = "EM78D044VCF-H",
+		.id        = {0xd5, 0x81},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_DUAL_ADDR(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			&READ_QUAD_ADDR(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Etron 3.3V EM73C044VCC-H 1Gbit */
+	{
+		.name      = "EM73C044VCC-H",
+		.id        = {0xd5, 0x22},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Micron MT29F4G01ABBFDWB 4GBit 1.8V */
+	{
+		.name      = "MT29F4G01ABBFDWB",
+		.id        = {0x2C, 0x35},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 80),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Dosilicon 3.3V DS35Q2GA-IB 1Gb */
+	{
+		.name      = "DS35Q2GA-IB",
+		.id        = {0xe5, 0x72},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* FM 3.3v FM25S01-DND-A-G  1Gbit */
+	{
+		.name      = "FM25S01-DND-A-G",
+		.id        = {0xa1, 0xa1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24), /* 24MHz */
+			&READ_FAST(1, INFINITE, 104), /* 104MHz */
+			&READ_DUAL(1, INFINITE, 104), /* 104MHz */
+			&READ_DUAL_ADDR(1, INFINITE, 40), /* 40MHz */
+			&READ_QUAD(1, INFINITE, 104), /* 104MHz */
+			&READ_QUAD_ADDR(2, INFINITE, 40), /* 40MHz */
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104), /* 104MHz */
+			&WRITE_QUAD(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* FM 3.3v FM25S01A 1Gbit */
+	{
+		.name      = "FM25S01A",
+		.id        = {0xa1, 0xe4},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24), /* 104MHz */
+			&READ_FAST(1, INFINITE, 104), /* 104MHz */
+			&READ_DUAL(1, INFINITE, 104), /* 104MHz */
+			&READ_DUAL_ADDR(1, INFINITE, 40), /* 40MHz */
+			&READ_QUAD(1, INFINITE, 104), /* 104MHz */
+			&READ_QUAD_ADDR(2, INFINITE, 40), /* 40MHz */
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104), /* 104MHz */
+			&WRITE_QUAD(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	{   .id_len    = 0, },
+};
+
+
+static void hifmc100_spi_nand_search_rw(struct spi_nand_info *spiinfo,
+					struct spi_op *spiop_rw, u_int iftype, u_int max_dummy, int rw_type)
+{
+	int ix = 0;
+	struct spi_op **spiop, **fitspiop;
+
+	for (fitspiop = spiop = (rw_type ? spiinfo->write : spiinfo->read);
+			(*spiop) && ix < MAX_SPI_OP; spiop++, ix++) {
+		if (((*spiop)->iftype & iftype)
+				&& ((*spiop)->dummy <= max_dummy)
+				&& (*fitspiop)->iftype < (*spiop)->iftype) {
+			fitspiop = spiop;
+		}
+	}
+	memcpy(spiop_rw, (*fitspiop), sizeof(struct spi_op));
+}
+
+
+static void hifmc100_spi_nand_get_erase(const struct spi_nand_info *spiinfo,
+					struct spi_op *spiop_erase)
+{
+	int ix;
+
+	spiop_erase->size = 0;
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spiinfo->erase[ix] == NULL) {
+			break;
+		}
+		if (spiinfo->erasesize == spiinfo->erase[ix]->size) {
+			memcpy(&spiop_erase[ix], spiinfo->erase[ix],
+			       sizeof(struct spi_op));
+			break;
+		}
+	}
+}
+
+
+static void hifmc100_map_spi_op(struct hifmc_spi *spi)
+{
+	unsigned char ix;
+	const int iftype_read[] = {
+		SPI_IF_READ_STD,    IF_TYPE_STD,
+		SPI_IF_READ_FAST,   IF_TYPE_STD,
+		SPI_IF_READ_DUAL,   IF_TYPE_DUAL,
+		SPI_IF_READ_DUAL_ADDR,  IF_TYPE_DIO,
+		SPI_IF_READ_QUAD,   IF_TYPE_QUAD,
+		SPI_IF_READ_QUAD_ADDR,  IF_TYPE_QIO,
+		0,          0,
+	};
+	const int iftype_write[] = {
+		SPI_IF_WRITE_STD,   IF_TYPE_STD,
+		SPI_IF_WRITE_QUAD,  IF_TYPE_QUAD,
+		0,          0,
+	};
+	const char *if_str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+
+	FMC_PR(BT_DBG, "\t||*-Start Get SPI operation iftype\n");
+
+	for (ix = 0; iftype_write[ix]; ix += 2) {
+		if (spi->write->iftype == iftype_write[ix]) {
+			spi->write->iftype = iftype_write[ix + 1];
+			break;
+		}
+	}
+	FMC_PR(BT_DBG, "\t|||-Get best write iftype: %s \n",
+	       if_str[spi->write->iftype]);
+
+	for (ix = 0; iftype_read[ix]; ix += 2) {
+		if (spi->read->iftype == iftype_read[ix]) {
+			spi->read->iftype = iftype_read[ix + 1];
+			break;
+		}
+	}
+	FMC_PR(BT_DBG, "\t|||-Get best read iftype: %s \n",
+	       if_str[spi->read->iftype]);
+
+	spi->erase->iftype = IF_TYPE_STD;
+	FMC_PR(BT_DBG, "\t|||-Get best erase iftype: %s \n",
+	       if_str[spi->erase->iftype]);
+
+	FMC_PR(BT_DBG, "\t||*-End Get SPI operation iftype \n");
+}
+
+
+static void hifmc100_spi_ids_probe(struct mtd_info *mtd,
+				   struct spi_nand_info *spi_dev)
+{
+	u_char reg;
+	int ret;
+	struct nand_chip *chip = NULL;
+	struct hifmc_host *host = NULL;
+	struct hifmc_spi *spi = NULL;
+
+	if(mtd == NULL || spi_dev == NULL) {
+		DB_MSG("Error: mtd or spi_dev is NULL!\n");
+		return;
+	}
+	chip = mtd_to_nand(mtd);
+	if (chip == NULL || chip->priv == NULL) {
+		DB_MSG("Error: chip is NULL!\n");
+		return;
+	}
+	host = chip->priv;
+	if (host->spi == NULL) {
+		DB_MSG("Error: host->spi is NULL!\n");
+		return;
+	}
+	spi = host->spi;
+	FMC_PR(BT_DBG, "\t|*-Start match SPI operation & chip init\n");
+
+	spi->host = host;
+	spi->name = spi_dev->name;
+	spi->driver = spi_dev->driver;
+	if(!spi->driver) {
+		 DB_MSG("Error: host->driver is NULL!\n");
+		 return;
+	}
+
+	hifmc100_spi_nand_search_rw(spi_dev, spi->read,
+				    HIFMC_SPI_NAND_SUPPORT_READ,
+				    HIFMC_SPI_NAND_SUPPORT_MAX_DUMMY, RW_OP_READ);
+	FMC_PR(BT_DBG, "\t||-Save spi->read op cmd:%#x\n", spi->read->cmd);
+
+	hifmc100_spi_nand_search_rw(spi_dev, spi->write,
+				    HIFMC_SPI_NAND_SUPPORT_WRITE,
+				    HIFMC_SPI_NAND_SUPPORT_MAX_DUMMY, RW_OP_WRITE);
+	FMC_PR(BT_DBG, "\t||-Save spi->write op cmd:%#x\n", spi->write->cmd);
+
+	hifmc100_spi_nand_get_erase(spi_dev, spi->erase);
+	FMC_PR(BT_DBG, "\t||-Save spi->erase op cmd:%#x\n", spi->erase->cmd);
+
+	hifmc100_map_spi_op(spi);
+
+	if (spi->driver->qe_enable) {
+		spi->driver->qe_enable(spi);
+	}
+
+	/* Disable write protection */
+	ret = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, &reg);
+	if (ret)
+		return;
+	FMC_PR(BT_DBG, "\t||-Get protect status[%#x]: %#x\n", PROTECT_ADDR,
+	       reg);
+	if (ANY_BP_ENABLE(reg)) {
+		reg &= ~ALL_BP_MASK;
+		ret = spi_nand_feature_op(spi, SET_OP, PROTECT_ADDR, &reg);
+		if (ret)
+		    return;
+		FMC_PR(BT_DBG, "\t||-Set [%#x]FT %#x\n", PROTECT_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		ret = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, &reg);
+		if (ret)
+		    return;
+		FMC_PR(BT_DBG, "\t||-Check BP disable result: %#x\n", reg);
+		if (ANY_BP_ENABLE(reg)) {
+			DB_MSG("Error: Write protection disable failed!\n");
+		}
+	}
+
+	/* Disable chip internal ECC */
+	ret = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, &reg);
+	if (ret)
+	    return;
+	FMC_PR(BT_DBG, "\t||-Get feature status[%#x]: %#x\n", FEATURE_ADDR,
+	       reg);
+	if (reg & FEATURE_ECC_ENABLE) {
+		reg &= ~FEATURE_ECC_ENABLE;
+		ret = spi_nand_feature_op(spi, SET_OP, FEATURE_ADDR, &reg);
+		if (ret)
+		    return;
+		FMC_PR(BT_DBG, "\t||-Set [%#x]FT: %#x\n", FEATURE_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		ret = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, &reg);
+		if (ret)
+		    return;
+		FMC_PR(BT_DBG, "\t||-Check internal ECC disable result: %#x\n",
+		       reg);
+		if (reg & FEATURE_ECC_ENABLE) {
+			DB_MSG("Error: Chip internal ECC disable failed!\n");
+		}
+	}
+
+	hifmc_cs_user[host->cmd_op.cs]++;
+
+	FMC_PR(BT_DBG, "\t|*-End match SPI operation & chip init\n");
+}
+
+static struct nand_flash_dev spi_nand_dev;
+
+static struct nand_flash_dev *spi_nand_get_flash_info(struct mtd_info *mtd,
+		unsigned char *id)
+{
+	unsigned char ix;
+	int len = 0;
+	char buffer[100];
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	struct spi_nand_info *spi_dev = hifmc_spi_nand_flash_table;
+	struct nand_flash_dev *type = &spi_nand_dev;
+
+	FMC_PR(BT_DBG, "\t*-Start find SPI Nand flash\n");
+
+	len = sprintf(buffer, "SPI Nand(cs %d) ID: %#x %#x",
+		      host->cmd_op.cs, id[0], id[1]);
+
+	for (; spi_dev->id_len; spi_dev++) {
+		if (!access_ok(VERIFY_READ, id, spi_dev->id_len)) {
+			DB_MSG("err:spi_nand_get_flash_info access_ok fail\n");
+			return NULL;
+		}
+		if (memcmp(id, spi_dev->id, spi_dev->id_len)) {
+			continue;
+		}
+
+		for (ix = 2; ix < spi_dev->id_len; ix++) {
+			if((spi_dev->id_len <= MAX_SPI_NAND_ID_LEN)) {
+				len += sprintf(buffer + len, " %#x", id[ix]);
+			}
+		}
+		pr_info("%s\n", buffer);
+
+		FMC_PR(BT_DBG, "\t||-CS(%d) found SPI Nand: %s\n",
+		       host->cmd_op.cs, spi_dev->name);
+
+		type->name = spi_dev->name;
+		memcpy(type->id, spi_dev->id, spi_dev->id_len);
+		type->pagesize = spi_dev->pagesize;
+		type->chipsize = (unsigned int)(spi_dev->chipsize >> 20);
+		type->erasesize = spi_dev->erasesize;
+		type->id_len = spi_dev->id_len;
+		type->oobsize = spi_dev->oobsize;
+		FMC_PR(BT_DBG, "\t|-Save struct nand_flash_dev info\n");
+
+		mtd->oobsize = spi_dev->oobsize;
+		mtd->erasesize = spi_dev->erasesize;
+		mtd->writesize = spi_dev->pagesize;
+		chip->chipsize = spi_dev->chipsize;
+
+		hifmc100_spi_ids_probe(mtd, spi_dev);
+
+		FMC_PR(BT_DBG, "\t*-Found SPI nand: %s\n", spi_dev->name);
+
+		return type;
+	}
+
+	FMC_PR(BT_DBG, "\t*-Not found SPI nand flash, %s\n", buffer);
+
+	return NULL;
+}
+
+
+void hifmc_spi_nand_ids_register(void)
+{
+	pr_info("SPI Nand ID Table Version %s\n", SPI_NAND_ID_TAB_VER);
+	get_spi_nand_flash_type_hook = spi_nand_get_flash_info;
+}
+
+#ifdef CONFIG_PM
+
+void hifmc100_spi_nand_config(struct hifmc_host *host)
+{
+	u_char reg;
+	int ret;
+	struct hifmc_spi *spi = NULL;
+	static const char *str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+
+	if((host == NULL) || (host->spi == NULL)) {
+		DB_MSG("Error: host or host->spi is NULL!\n");
+		return;
+	}
+	spi = host->spi;
+	/* judge whether support QUAD read/write or not, set it if yes */
+	FMC_PR(PM_DBG, "\t|-SPI read iftype: %s write iftype: %s\n",
+	       str[spi->read->iftype], str[spi->write->iftype]);
+
+	if (spi->driver->qe_enable) {
+		spi->driver->qe_enable(spi);
+	}
+
+	/* Disable write protection */
+	ret = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, &reg);
+	if (ret)
+	    return;
+	FMC_PR(PM_DBG, "\t|-Get protect status[%#x]: %#x\n", PROTECT_ADDR,
+	       reg);
+	if (ANY_BP_ENABLE(reg)) {
+		reg &= ~ALL_BP_MASK;
+		ret = spi_nand_feature_op(spi, SET_OP, PROTECT_ADDR, &reg);
+		if (ret)
+		    return;
+		FMC_PR(PM_DBG, "\t|-Set [%#x]FT %#x\n", PROTECT_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		ret = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, &reg);
+		if (ret)
+		    return;
+		FMC_PR(PM_DBG, "\t|-Check BP disable result: %#x\n", reg);
+		if (ANY_BP_ENABLE(reg)) {
+			DB_MSG("Error: Write protection disable failed!\n");
+		}
+	}
+
+	/* Disable chip internal ECC */
+	ret = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, &reg);
+	if (ret)
+	    return;
+	FMC_PR(PM_DBG, "\t|-Get feature status[%#x]: %#x\n", FEATURE_ADDR,
+	       reg);
+	if (reg & FEATURE_ECC_ENABLE) {
+		reg &= ~FEATURE_ECC_ENABLE;
+		ret = spi_nand_feature_op(spi, SET_OP, FEATURE_ADDR, &reg);
+		if (ret)
+		    return;
+		FMC_PR(PM_DBG, "\t|-Set [%#x]FT: %#x\n", FEATURE_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		ret = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, &reg);
+		if (ret)
+		    return;
+		FMC_PR(PM_DBG, "\t|-Check internal ECC disable result: %#x\n",
+		       reg);
+		if (reg & FEATURE_ECC_ENABLE) {
+			DB_MSG("Error: Chip internal ECC disable failed!\n");
+		}
+	}
+}
+
+#endif /* CONFIG_PM */
diff --git a/drivers/mtd/nand/hifmc100_nand/Kconfig b/drivers/mtd/nand/hifmc100_nand/Kconfig
new file mode 100644
index 000000000..188c9a77a
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100_nand/Kconfig
@@ -0,0 +1,50 @@
+#
+# drivers/mtd/nand/hifmc100_nand/Kconfig
+# add by hisilicon 2017.10.26
+#
+
+menuconfig MTD_NAND_HIFMC100
+	bool "Hisilicon Flash Memory Controller v100 Nand devices support"
+	depends on MFD_HISI_FMC && !MTD_SPI_NAND_HISI_BVT
+	select MISC_FILESYSTEMS
+	select MTD_BLOCK
+	select YAFFS_FS
+	select YAFFS_YAFFS2
+	help
+	  Hisilicon Flash Memory Controller version 100 is called hifmc100 for
+	  short. The controller support DMA transfers while reading or writing
+	  the Nand flash.
+
+if MTD_NAND_HIFMC100
+
+config HIFMC100_NAND_EDO_MODE
+	bool "the Extended Data Out(EDO) mode"
+	help
+	  In Extended data out (EDO), a new data cycle is started while the data
+	  output of the previous cycle is still active. This process of cycle
+	  overlapping, called pipelining, increases processing speed by about
+	  10 nanoseconds per cycle,increasing computer performance by about 5
+	  percent compared to performance using FMP.
+
+config RW_H_WIDTH
+	int "the width of Read/Write HIGH Hold Time (0 to 15)"
+	range 0 15
+	default 10 if (ARCH_HI3559AV100 || ARCH_HI3569V100)
+	help
+	  the Read/Write HIGH Hold Time of nand flash
+
+config R_L_WIDTH
+	int "the Read pulse width (0 to 15)"
+	range 0 15
+	default 10 if (ARCH_HI3559AV100 || ARCH_HI3569V100)
+	help
+	  the Read/Write LOW Hold Time of nand flash
+
+config W_L_WIDTH
+	int "the Write pulse width (0 to 15)"
+	range 0 15
+	default 10 if (ARCH_HI3559AV100 || ARCH_HI3569V100)
+	help
+	  the Read/Write LOW Hold Time of nand flash
+
+endif # End of MTD_NAND_HIFMC100
diff --git a/drivers/mtd/nand/hifmc100_nand/Makefile b/drivers/mtd/nand/hifmc100_nand/Makefile
new file mode 100644
index 000000000..623363cfc
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100_nand/Makefile
@@ -0,0 +1,26 @@
+#
+# The Flash Memory Controller v100 Device Driver for hisilicon
+#
+# Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+#
+# This program is free software; you can redistribute  it and/or modify it
+# under  the terms of  the GNU General  Public License as published by the
+# Free Software Foundation;  either version 2 of the  License, or (at your
+# option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+#
+
+#
+# drivers/mtd/nand/hifmc100_nand/Makefile
+#
+
+obj-y	+= hifmc_nand_spl_ids.o
+obj-y	+= hifmc100_nand.o hifmc100_nand_os.o
diff --git a/drivers/mtd/nand/hifmc100_nand/hifmc100_nand.c b/drivers/mtd/nand/hifmc100_nand/hifmc100_nand.c
new file mode 100644
index 000000000..5c08d4beb
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100_nand/hifmc100_nand.c
@@ -0,0 +1,1170 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/compiler.h>
+#include <linux/delay.h>
+#include <linux/printk.h>
+#include <linux/clk.h>
+#include <linux/mfd/hisi_fmc.h>
+
+#include "../raw/hinfc_gen.h"
+#include "hifmc100_nand_os.h"
+#include "hifmc100_nand.h"
+
+#include <mach/platform.h>
+
+static void hifmc100_dma_transfer(struct hifmc_host *host, unsigned int todev)
+{
+	unsigned int reg = (unsigned int)host->dma_buffer;
+	char *op = todev ? "write" : "read";
+
+	FMC_PR(DMA_DB, "\t\t *-Start %s page dma transfer\n", op);
+
+	hifmc_writel(host, FMC_DMA_SADDR_D0, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set ADDR0[%#x]%#x\n", FMC_DMA_SADDR_D0, reg);
+
+#ifdef CONFIG_64BIT
+	reg = (unsigned int)((host->dma_buffer & FMC_DMA_SADDRH_MASK) >> 32);
+	hifmc_writel(host, FMC_DMA_SADDRH_D0, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set ADDRH0[%#x]%#x\n", FMC_DMA_SADDRH_D0, reg);
+#endif
+
+	reg += FMC_DMA_ADDR_OFFSET;
+	hifmc_writel(host, FMC_DMA_SADDR_D1, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set ADDR1[%#x]%#x\n", FMC_DMA_SADDR_D1, reg);
+
+	reg += FMC_DMA_ADDR_OFFSET;
+	hifmc_writel(host, FMC_DMA_SADDR_D2, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set ADDR2[%#x]%#x\n", FMC_DMA_SADDR_D2, reg);
+
+	reg += FMC_DMA_ADDR_OFFSET;
+	hifmc_writel(host, FMC_DMA_SADDR_D3, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set ADDR3[%#x]%#x\n", FMC_DMA_SADDR_D3, reg);
+
+	reg = host->dma_oob;
+	hifmc_writel(host, FMC_DMA_SADDR_OOB, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set OOB[%#x]%#x\n", FMC_DMA_SADDR_OOB, reg);
+
+#ifdef CONFIG_64BIT
+	reg = (unsigned int)((host->dma_oob & FMC_DMA_SADDRH_MASK) >> 32);
+	hifmc_writel(host, FMC_DMA_SADDRH_OOB, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set ADDRH0[%#x]%#x\n", FMC_DMA_SADDRH_OOB, reg);
+#endif
+
+	if (host->ecctype == NAND_ECC_0BIT) {
+		hifmc_writel(host, FMC_DMA_LEN, FMC_DMA_LEN_SET(host->oobsize));
+		FMC_PR(DMA_DB, "\t\t |-Set LEN[%#x]%#x\n", FMC_DMA_LEN, reg);
+	}
+	reg = FMC_OP_READ_DATA_EN | FMC_OP_WRITE_DATA_EN;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	reg = FMC_DMA_AHB_CTRL_DMA_PP_EN |
+	      FMC_DMA_AHB_CTRL_BURST16_EN |
+	      FMC_DMA_AHB_CTRL_BURST8_EN |
+	      FMC_DMA_AHB_CTRL_BURST4_EN;
+	hifmc_writel(host, FMC_DMA_AHB_CTRL, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set AHBCTRL[%#x]%#x\n", FMC_DMA_AHB_CTRL, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs) |
+	      OP_CFG_ADDR_NUM(host->addr_cycle);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = OP_CTRL_DMA_OP_READY;
+	if (todev) {
+		reg |= OP_CTRL_RW_OP(todev);
+	}
+	hifmc_writel(host, FMC_OP_CTRL, reg);
+	FMC_PR(DMA_DB, "\t\t |-Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, reg);
+
+	FMC_DMA_WAIT_CPU_FINISH(host);
+
+	FMC_PR(DMA_DB, "\t\t *-End %s page dma transfer\n", op);
+
+	return;
+}
+
+
+static void hifmc100_send_cmd_write(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(WR_DBG, "\t|*-Start send page programme cmd\n");
+
+	if (*host->bbm != 0xFF && *host->bbm != 0x00) {
+		pr_info("WARNING: attempt to write an invalid bbm. " \
+			"page: 0x%08x, mark: 0x%02x,\n",
+			GET_PAGE_INDEX(host), *host->bbm);
+	}
+
+	host->enable_ecc_randomizer(host, ENABLE, ENABLE);
+
+	reg = host->addr_value[1];
+	hifmc_writel(host, FMC_ADDRH, reg);
+	FMC_PR(WR_DBG, "\t||-Set ADDRH[%#x]%#x\n", FMC_ADDRH, reg);
+
+	reg = host->addr_value[0] & 0xffff0000;
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(WR_DBG, "\t||-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = FMC_CMD_CMD2(NAND_CMD_PAGEPROG) | FMC_CMD_CMD1(NAND_CMD_SEQIN);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(WR_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	*host->epm = 0x0000;
+
+	hifmc100_dma_transfer(host, RW_OP_WRITE);
+
+	FMC_PR(WR_DBG, "\t|*-End send page read cmd\n");
+}
+
+
+static void hifmc100_send_cmd_read(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(RD_DBG, "\t*-Start send page read cmd\n");
+
+	if ((host->addr_value[0] == host->cache_addr_value[0]) &&
+			(host->addr_value[1] == host->cache_addr_value[1])) {
+		FMC_PR(RD_DBG, "\t*-Cache hit! addr1[%#x], addr0[%#x]\n",
+		       host->addr_value[1], host->addr_value[0]);
+		return;
+	}
+
+	host->page_status = 0;
+
+	host->enable_ecc_randomizer(host, ENABLE, ENABLE);
+
+	reg = FMC_INT_CLR_ALL;
+	hifmc_writel(host, FMC_INT_CLR, reg);
+	FMC_PR(RD_DBG, "\t|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	reg = host->nand_cfg;
+	hifmc_writel(host, FMC_CFG, reg);
+	FMC_PR(RD_DBG, "\t|-Set CFG[%#x]%#x\n", FMC_CFG, reg);
+
+	reg = host->addr_value[1];
+	hifmc_writel(host, FMC_ADDRH, reg);
+	FMC_PR(RD_DBG, "\t|-Set ADDRH[%#x]%#x\n", FMC_ADDRH, reg);
+
+	reg = host->addr_value[0] & 0xffff0000;
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(RD_DBG, "\t|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = FMC_CMD_CMD2(NAND_CMD_READSTART) | FMC_CMD_CMD1(NAND_CMD_READ0);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(RD_DBG, "\t|-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	hifmc100_dma_transfer(host, RW_OP_READ);
+
+	if (hifmc_readl(host, FMC_INT) & FMC_INT_ERR_INVALID) {
+		host->page_status |= HIFMC100_PS_UC_ECC;
+	}
+
+	host->cache_addr_value[0] = host->addr_value[0];
+	host->cache_addr_value[1] = host->addr_value[1];
+
+	FMC_PR(RD_DBG, "\t*-End send page read cmd\n");
+}
+
+
+static void hifmc100_send_cmd_erase(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(ER_DBG, "\t *-Start send cmd erase\n");
+
+	/* Don't case the read retry config */
+	host->enable_ecc_randomizer(host, DISABLE, DISABLE);
+
+	reg = host->addr_value[0];
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(ER_DBG, "\t |-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = FMC_CMD_CMD2(NAND_CMD_ERASE2) | FMC_CMD_CMD1(NAND_CMD_ERASE1);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(ER_DBG, "\t |-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs) |
+	      OP_CFG_ADDR_NUM(host->addr_cycle);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(ER_DBG, "\t |-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	/* need to config WAIT_READY_EN */
+	reg = FMC_OP_WAIT_READY_EN |
+	      FMC_OP_CMD1_EN |
+	      FMC_OP_CMD2_EN |
+	      FMC_OP_ADDR_EN |
+	      FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(ER_DBG, "\t |-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	FMC_PR(ER_DBG, "\t |*-End send cmd erase\n");
+}
+
+
+static void hifmc100_ecc_randomizer(struct hifmc_host *host, int ecc_en,
+				    int randomizer_en)
+{
+	unsigned int old_reg, reg;
+	unsigned int  change = 0;
+	char *ecc_op = ecc_en ? "Quit" : "Enter";
+	char *rand_op = randomizer_en ? "Enable" : "Disable";
+
+	if (IS_NAND_RANDOM(host)) {
+		reg = old_reg = hifmc_readl(host, FMC_GLOBAL_CFG);
+		if (randomizer_en) {
+			reg |= FMC_GLOBAL_CFG_RANDOMIZER_EN;
+		} else {
+			reg &= ~FMC_GLOBAL_CFG_RANDOMIZER_EN;
+		}
+
+		if (old_reg != reg) {
+			FMC_PR(EC_DBG, "\t |*-Start %s randomizer\n", rand_op);
+			FMC_PR(EC_DBG, "\t ||-Get global CFG[%#x]%#x\n",
+			       FMC_GLOBAL_CFG, old_reg);
+			hifmc_writel(host, FMC_GLOBAL_CFG, reg);
+			FMC_PR(EC_DBG, "\t ||-Set global CFG[%#x]%#x\n",
+			       FMC_GLOBAL_CFG, reg);
+			change++;
+		}
+	}
+
+	old_reg = hifmc_readl(host, FMC_CFG);
+	reg = (ecc_en ? host->nand_cfg : host->nand_cfg_ecc0);
+
+	if (old_reg != reg) {
+		FMC_PR(EC_DBG, "\t |%s-Start %s ECC0 mode\n", change ? "|" : "*",
+		       ecc_op);
+		FMC_PR(EC_DBG, "\t ||-Get CFG[%#x]%#x\n", FMC_CFG, old_reg);
+		hifmc_writel(host, FMC_CFG, reg);
+		FMC_PR(EC_DBG, "\t ||-Set CFG[%#x]%#x\n", FMC_CFG, reg);
+		change++;
+	}
+
+	if (EC_DBG && change) {
+		FMC_PR(EC_DBG, "\t |*-End randomizer and ECC0 mode config\n");
+	}
+}
+
+
+static void hifmc100_send_cmd_status(struct hifmc_host *host)
+{
+	unsigned int regval;
+
+	host->enable_ecc_randomizer(host, DISABLE, DISABLE);
+
+	regval = OP_CFG_FM_CS(host->cmd_op.cs);
+	hifmc_writel(host, FMC_OP_CFG, regval);
+
+	regval = FMC_OP_READ_STATUS_EN | FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, regval);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+}
+
+
+static void hifmc100_send_cmd_readid(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(BT_DBG, "\t *-Start read nand flash ID\n");
+
+	host->enable_ecc_randomizer(host, DISABLE, DISABLE);
+
+	reg = FMC_DATA_NUM_CNT(host->cmd_op.data_no);
+	hifmc_writel(host, FMC_DATA_NUM, reg);
+	FMC_PR(BT_DBG, "\t |-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = FMC_CMD_CMD1(NAND_CMD_READID);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(BT_DBG, "\t |-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = 0;
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(BT_DBG, "\t |-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs) |
+	      OP_CFG_ADDR_NUM(READ_ID_ADDR_NUM);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(BT_DBG, "\t |-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_OP_CMD1_EN |
+	      FMC_OP_ADDR_EN |
+	      FMC_OP_READ_DATA_EN |
+	      FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(BT_DBG, "\t |-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	host->addr_cycle = 0x0;
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	FMC_PR(BT_DBG, "\t *-End read nand flash ID\n");
+}
+
+
+static void hifmc100_send_cmd_reset(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(BT_DBG, "\t *-Start reset nand flash\n");
+
+	reg = FMC_CMD_CMD1(NAND_CMD_RESET);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(BT_DBG, "\t |-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(BT_DBG, "\t |-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_OP_CMD1_EN |
+	      FMC_OP_WAIT_READY_EN |
+	      FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(BT_DBG, "\t |-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	FMC_PR(BT_DBG, "\t *-End reset nand flash\n");
+}
+
+
+static unsigned char hifmc100_read_byte(struct mtd_info *mtd)
+{
+	unsigned char value = 0;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READID) {
+		value = hifmc_readb((void __iomem *)(chip->IO_ADDR_R + host->offset));
+		host->offset++;
+		if (host->cmd_op.data_no == host->offset) {
+			host->cmd_op.l_cmd = 0;
+		}
+		return value;
+	}
+
+	if (host->cmd_op.cmd == NAND_CMD_STATUS) {
+		value = hifmc_readl(host, FMC_STATUS);
+		if (host->cmd_op.l_cmd == NAND_CMD_ERASE1) {
+			FMC_PR(ER_DBG, "\t*-Erase WP status: %#x\n", value);
+		}
+		if (host->cmd_op.l_cmd == NAND_CMD_PAGEPROG) {
+			FMC_PR(WR_DBG, "\t*-Write WP status: %#x\n", value);
+		}
+		return value;
+	}
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READOOB) {
+		value = hifmc_readb((void __iomem *)(host->buffer +
+					host->pagesize + host->offset));
+		host->offset++;
+		return value;
+	}
+
+	host->offset++;
+
+	return hifmc_readb((void __iomem *)(host->buffer + host->column +
+				host->offset - 1));
+}
+
+
+static unsigned short hifmc100_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	host->offset += 2;
+	return hifmc_readw(host->buffer + host->column + host->offset - 2);
+}
+
+
+static void hifmc100_write_buf(struct mtd_info *mtd,
+			       const u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+#ifdef HIFMC100_NAND_SUPPORT_REG_WRITE
+	if (buf == chip->oob_poi) {
+		memcpy((char *)host->iobase + host->pagesize, buf, len);
+	} else {
+		memcpy((char *)host->iobase, buf, len);
+	}
+#else
+	if (buf == chip->oob_poi) {
+		memcpy((char *)host->buffer + host->pagesize, buf, len);
+	} else {
+		memcpy((char *)host->buffer, buf, len);
+	}
+#endif
+	return;
+}
+
+#ifdef CONFIG_HISI_NAND_ECC_STATUS_REPORT
+
+static void hifmc100_ecc_err_num_count(struct mtd_info *mtd,
+				       u_int ecc_st, u_int reg)
+{
+	u_char err_num;
+
+	if (ecc_st > 4) {
+		ecc_st = 4;
+	}
+
+	while (ecc_st) {
+		err_num = GET_ECC_ERR_NUM(--ecc_st, reg);
+		if (err_num == 0xff) {
+			mtd->ecc_stats.failed++;
+		} else {
+			mtd->ecc_stats.corrected += err_num;
+		}
+	}
+}
+#endif
+
+
+static void hifmc100_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+#ifdef HIFMC100_NAND_SUPPORT_REG_READ
+	if (buf == chip->oob_poi) {
+		memcpy(buf, (char *)host->iobase + host->pagesize, len);
+	} else {
+		memcpy(buf, (char *)host->iobase, len);
+	}
+#else
+	if (buf == chip->oob_poi) {
+		memcpy(buf, (char *)host->buffer + host->pagesize, len);
+	} else {
+		memcpy(buf, (char *)host->buffer, len);
+	}
+#endif
+
+#ifdef CONFIG_HISI_NAND_ECC_STATUS_REPORT
+	if (buf != chip->oob_poi) {
+		u_int reg;
+		u_int ecc_step = host->pagesize >> 10;
+
+		/* 2K or 4K or 8K(1) or 16K(1-1) pagesize */
+		reg = hifmc_readl(host, HIFMC100_ECC_ERR_NUM0_BUF0);
+		hifmc100_ecc_err_num_count(mtd, ecc_step, reg);
+
+		if (ecc_step > 4) {
+			/* 8K(2) or 16K(1-2) pagesize */
+			reg = hifmc_readl(host, HIFMC100_ECC_ERR_NUM1_BUF0);
+			hifmc100_ecc_err_num_count(mtd, ecc_step, reg);
+			if (ecc_step > 8) {
+				/* 16K(2-1) pagesize */
+				reg = hifmc_readl(host,
+						  HIFMC100_ECC_ERR_NUM0_BUF1);
+				hifmc100_ecc_err_num_count(mtd, ecc_step, reg);
+				/* 16K(2-2) pagesize */
+				reg = hifmc_readl(host,
+						  HIFMC100_ECC_ERR_NUM1_BUF1);
+				hifmc100_ecc_err_num_count(mtd, ecc_step, reg);
+			}
+		}
+	}
+#endif
+
+	return;
+}
+
+
+static void hifmc100_select_chip(struct mtd_info *mtd, int chipselect)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	if (chipselect < 0) {
+		mutex_unlock(&fmc_switch_mutex);
+		return;
+	}
+
+	mutex_lock(&fmc_switch_mutex);
+
+	if (chipselect > CONFIG_HIFMC100_MAX_NAND_CHIP) {
+		DB_BUG("Error: Invalid chip select: %d\n", chipselect);
+	}
+
+	host->cmd_op.cs = chipselect;
+	if (host->mtd != mtd) {
+		host->mtd = mtd;
+	}
+
+	switch (chip->state) {
+	case FL_ERASING:
+		host->cmd_op.l_cmd = NAND_CMD_ERASE1;
+		if (ER_DBG) {
+			pr_info("\n");
+		}
+		FMC_PR(ER_DBG, "\t*-Erase chip: %d\n", chipselect);
+		break;
+	case FL_WRITING:
+		host->cmd_op.l_cmd = NAND_CMD_PAGEPROG;
+		if (WR_DBG) {
+			pr_info("\n");
+		}
+		FMC_PR(WR_DBG, "\t*-Write chip: %d\n", chipselect);
+		break;
+	case FL_READING:
+		host->cmd_op.l_cmd = NAND_CMD_READ0;
+		if (RD_DBG) {
+			pr_info("\n");
+		}
+		FMC_PR(RD_DBG, "\t*-Read chip: %d\n", chipselect);
+		break;
+	default:
+		break;
+	}
+}
+
+
+static void hifmc100_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned ctrl)
+{
+	unsigned char cmd;
+	int is_cache_invalid = 1;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	if (ctrl & NAND_ALE) {
+		unsigned int addr_value = 0;
+		unsigned int addr_offset = 0;
+
+		if (ctrl & NAND_CTRL_CHANGE) {
+			host->addr_cycle = 0x0;
+			host->addr_value[0] = 0x0;
+			host->addr_value[1] = 0x0;
+		}
+		addr_offset = host->addr_cycle << 3;
+
+		if (host->addr_cycle >= HIFMC100_ADDR_CYCLE_MASK) {
+			addr_offset = (host->addr_cycle -
+				       HIFMC100_ADDR_CYCLE_MASK) << 3;
+			addr_value = 1;
+		}
+
+		host->addr_value[addr_value] |=
+			(((unsigned int)dat & 0xff) << addr_offset);
+
+		host->addr_cycle++;
+	}
+
+	if ((ctrl & NAND_CLE) && (ctrl & NAND_CTRL_CHANGE)) {
+		cmd = (unsigned int)dat & 0xff;
+		host->cmd_op.cmd = cmd;
+		switch (cmd) {
+		case NAND_CMD_PAGEPROG:
+			host->offset = 0;
+			host->send_cmd_pageprog(host);
+			break;
+
+		case NAND_CMD_READSTART:
+			is_cache_invalid = 0;
+			if (host->addr_value[0] == host->pagesize) {
+				host->cmd_op.l_cmd = NAND_CMD_READOOB;
+			}
+			host->send_cmd_readstart(host);
+			break;
+
+		case NAND_CMD_ERASE2:
+			host->cmd_op.l_cmd = cmd;
+			host->send_cmd_erase(host);
+			break;
+
+		case NAND_CMD_READID:
+			memset((u_char *)(chip->IO_ADDR_R), 0, MAX_NAND_ID_LEN);
+			host->cmd_op.l_cmd = cmd;
+			host->cmd_op.data_no = MAX_NAND_ID_LEN;
+			host->send_cmd_readid(host);
+			break;
+
+		case NAND_CMD_STATUS:
+			host->send_cmd_status(host);
+			break;
+
+		case NAND_CMD_READ0:
+			host->cmd_op.l_cmd = cmd;
+			break;
+
+		case NAND_CMD_RESET:
+			host->send_cmd_reset(host);
+			break;
+
+		case NAND_CMD_SEQIN:
+		case NAND_CMD_ERASE1:
+		default:
+			break;
+		}
+	}
+
+	/* pass pagesize and ecctype to kernel when startup. */
+	host->enable_ecc_randomizer(host, ENABLE, ENABLE);
+
+	if ((dat == NAND_CMD_NONE) && host->addr_cycle) {
+		if (host->cmd_op.cmd == NAND_CMD_SEQIN ||
+		    host->cmd_op.cmd == NAND_CMD_READ0 ||
+		    host->cmd_op.cmd == NAND_CMD_READID) {
+			host->offset = 0x0;
+			host->column = (host->addr_value[0] & 0xffff);
+		}
+	}
+
+	if (is_cache_invalid) {
+		host->cache_addr_value[0] = ~0;
+		host->cache_addr_value[1] = ~0;
+	}
+}
+
+
+static int hifmc100_dev_ready(struct mtd_info *mtd)
+{
+	return 0x1;
+}
+
+
+/*
+ * 'host->epm' only use the first oobfree[0] field, it looks very simple, But...
+ */
+static int hifmc_ooblayout_ecc_default(struct mtd_info *mtd, int section,
+				       struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 32;
+	oobregion->offset = 32;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_default(struct mtd_info *mtd, int section,
+					struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 30;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static struct mtd_ooblayout_ops hifmc_ooblayout_default_ops = {
+	.ecc = hifmc_ooblayout_ecc_default,
+	.free = hifmc_ooblayout_free_default,
+};
+
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+static int hifmc_ooblayout_ecc_4k16bit(struct mtd_info *mtd, int section,
+				       struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 14;
+	oobregion->offset = 14;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_4k16bit(struct mtd_info *mtd, int section,
+					struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 14;
+	oobregion->offset = 2;
+
+	return 0;
+}
+tatic struct mtd_ooblayout_ops hifmc_ooblayout_4k16bit_ops = {
+	.ecc = hifmc_ooblayout_ecc_4k16bit,
+	.free = hifmc_ooblayout_free_4k16bit,
+};
+
+static int hifmc_ooblayout_ecc_2k16bit(struct mtd_info *mtd, int section,
+				       struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 6;
+	oobregion->offset = 6;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_2k16bit(struct mtd_info *mtd, int section,
+					struct mtd_oob_region *oobregion)
+{
+	if (section) {
+		return -ERANGE;
+	}
+
+	oobregion->length = 6;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static struct mtd_ooblayout_ops hifmc_ooblayout_2k16bit_ops = {
+	.ecc = hifmc_ooblayout_ecc_2k16bit,
+	.free = hifmc_ooblayout_free_2k16bit,
+};
+#endif
+
+/* ecc/pagesize get from NAND controller */
+static struct nand_config_info hifmc100_nand_hw_auto_config_table[] = {
+	{NAND_PAGE_16K, NAND_ECC_64BIT, 64, 1824, &hifmc_ooblayout_default_ops}, /* 1824 */
+	{NAND_PAGE_16K, NAND_ECC_40BIT, 40, 1200, &hifmc_ooblayout_default_ops}, /* 1152 */
+	{NAND_PAGE_16K, NAND_ECC_0BIT,  0, 32,          &hifmc_ooblayout_default_ops},
+
+	{NAND_PAGE_8K, NAND_ECC_64BIT, 64, 928, &hifmc_ooblayout_default_ops}, /* 928 */
+	{NAND_PAGE_8K, NAND_ECC_40BIT, 40, 600, &hifmc_ooblayout_default_ops}, /* 592 */
+	{NAND_PAGE_8K, NAND_ECC_24BIT, 24, 368, &hifmc_ooblayout_default_ops}, /* 368 */
+	{NAND_PAGE_8K, NAND_ECC_0BIT,  0, 32, &hifmc_ooblayout_default_ops},
+
+	{NAND_PAGE_4K, NAND_ECC_24BIT, 24, 200, &hifmc_ooblayout_default_ops}, /* 200 */
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	{NAND_PAGE_4K, NAND_ECC_16BIT, 16, 128, &hifmc_ooblayout_4k16bit_ops}, /* 128 */
+#endif
+	{NAND_PAGE_4K, NAND_ECC_8BIT, 8, 128, &hifmc_ooblayout_default_ops}, /* 88 */
+	{NAND_PAGE_4K, NAND_ECC_0BIT, 0, 32, &hifmc_ooblayout_default_ops},
+
+	{NAND_PAGE_2K, NAND_ECC_24BIT, 24, 128, &hifmc_ooblayout_default_ops}, /* 116 */
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	{NAND_PAGE_2K, NAND_ECC_16BIT, 16, 64, &hifmc_ooblayout_2k16bit_ops}, /* 64 */
+#endif
+	{NAND_PAGE_2K, NAND_ECC_8BIT,  8, 64, &hifmc_ooblayout_default_ops}, /* 60 */
+	{NAND_PAGE_2K, NAND_ECC_0BIT,  0, 32, &hifmc_ooblayout_default_ops},
+
+	{0,     0,      0,      0,      NULL},
+};
+
+
+/*
+ *  0 - This NAND NOT support randomizer
+ *  1 - This NAND support randomizer.
+ */
+static int hifmc100_nand_support_randomizer(u_int pageisze, u_int ecctype)
+{
+	switch (pageisze) {
+	case _8K:
+		return (ecctype >= NAND_ECC_24BIT && ecctype <= NAND_ECC_80BIT);
+	case _16K:
+		return (ecctype >= NAND_ECC_40BIT && ecctype <= NAND_ECC_80BIT);
+	case _32K:
+		return (ecctype >= NAND_ECC_40BIT && ecctype <= NAND_ECC_80BIT);
+	default:
+		return 0;
+	}
+}
+
+
+/* used the best correct arithmetic. */
+static struct nand_config_info *hifmc100_get_config_type_info(
+	struct mtd_info *mtd, struct nand_dev_t *nand_dev)
+{
+	struct nand_config_info *best = NULL;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	struct nand_config_info *info = hifmc100_nand_hw_auto_config_table;
+
+	nand_dev->start_type = "Auto";
+	nand_dev->flags |= (IS_NANDC_HW_AUTO(host) | IS_NANDC_CONFIG_DONE(host));
+
+	for (; info->ooblayout_ops; info++) {
+		if (match_page_type_to_size(info->pagetype) != mtd->writesize) {
+			continue;
+		}
+
+		if (mtd->oobsize < info->oobsize) {
+			continue;
+		}
+
+		if (!best || (best->ecctype < info->ecctype)) {
+			best = info;
+		}
+	}
+
+	return best;
+}
+
+
+static unsigned int hifmc100_get_ecc_reg(struct hifmc_host *host,
+		const struct nand_config_info *info, struct nand_dev_t *nand_dev)
+{
+	host->ecctype = info->ecctype;
+	FMC_PR(BT_DBG, "\t |-Save best EccType %d(%s)\n", host->ecctype,
+	       match_ecc_type_to_str(info->ecctype));
+
+	nand_dev->ecctype = host->ecctype;
+
+	return FMC_CFG_ECC_TYPE(match_ecc_type_to_reg(info->ecctype));
+}
+
+
+static unsigned int hifmc100_get_page_reg(struct hifmc_host *host,
+		const struct nand_config_info *info)
+{
+	host->pagesize = match_page_type_to_size(info->pagetype);
+	FMC_PR(BT_DBG, "\t |-Save best PageSize %d(%s)\n", host->pagesize,
+	       match_page_type_to_str(info->pagetype));
+
+	return FMC_CFG_PAGE_SIZE(match_page_type_to_reg(info->pagetype));
+}
+
+
+static unsigned int hifmc100_get_block_reg(struct hifmc_host *host,
+		const struct nand_config_info *info)
+{
+	unsigned int block_reg = 0;
+	unsigned int page_per_block;
+	struct mtd_info *mtd = host->mtd;
+
+	host->block_page_mask = ((mtd->erasesize / mtd->writesize) - 1);
+	page_per_block = mtd->erasesize / match_page_type_to_size(info->pagetype);
+	switch (page_per_block) {
+	case 64:
+		block_reg = BLOCK_SIZE_64_PAGE;
+		break;
+	case 128:
+		block_reg = BLOCK_SIZE_128_PAGE;
+		break;
+	case 256:
+		block_reg = BLOCK_SIZE_256_PAGE;
+		break;
+	case 512:
+		block_reg = BLOCK_SIZE_512_PAGE;
+		break;
+	default:
+		DB_MSG("Can't support block %#x and page %#x size\n",
+		       mtd->erasesize, mtd->writesize);
+	}
+
+	return FMC_CFG_BLOCK_SIZE(block_reg);
+}
+
+
+static void hifmc100_set_fmc_cfg_reg(struct hifmc_host *host,
+				    const struct nand_config_info *type_info, struct nand_dev_t *nand_dev)
+{
+	unsigned int page_reg, ecc_reg, block_reg, reg_fmc_cfg;
+
+	ecc_reg = hifmc100_get_ecc_reg(host, type_info, nand_dev);
+	page_reg = hifmc100_get_page_reg(host, type_info);
+	block_reg = hifmc100_get_block_reg(host, type_info);
+
+	if (hifmc100_nand_support_randomizer(host->pagesize, host->ecctype)) {
+		host->flags |= IS_NAND_RANDOM(nand_dev);
+	}
+
+	/*
+	 * Check if hardware enable randomizer PIN, But NAND does not need
+	 * randomizer. We will notice user.
+	 */
+	if (IS_NAND_RANDOM(host) &&
+			!hifmc100_nand_support_randomizer(host->pagesize,
+							  host->ecctype)) {
+		DB_BUG(ERSTR_HARDWARE
+		       "This NAND flash does not support `randomizer`, "
+		       "Please don't configure hardware randomizer PIN.");
+	}
+	/* Save value of FMC_CFG and FMC_CFG_ECC0 to turn on/off ECC */
+	reg_fmc_cfg = hifmc_readl(host, FMC_CFG);
+	reg_fmc_cfg &= ~(PAGE_SIZE_MASK | ECC_TYPE_MASK | BLOCK_SIZE_MASK);
+	reg_fmc_cfg |= ecc_reg | page_reg | block_reg;
+	host->nand_cfg = reg_fmc_cfg;
+	host->nand_cfg_ecc0 = (host->nand_cfg & ~ECC_TYPE_MASK) | ECC_TYPE_0BIT;
+	FMC_PR(BT_DBG, "\t|-Save FMC_CFG[%#x]: %#x and FMC_CFG_ECC0: %#x\n",
+	       FMC_CFG, host->nand_cfg, host->nand_cfg_ecc0);
+
+	/* pass pagesize and ecctype to kernel when spiflash startup. */
+	host->enable_ecc_randomizer(host, ENABLE, ENABLE);
+
+	/*
+	 * If it want to support the 'read retry' feature, the 'randomizer'
+	 * feature must be support first.
+	 */
+	host->read_retry = NULL;
+
+	if (host->read_retry && !IS_NAND_RANDOM(host)) {
+		DB_BUG(ERSTR_HARDWARE
+		       "This Nand flash need to enable 'randomizer' feature. "
+		       "Please configure hardware randomizer PIN.");
+	}
+}
+
+
+static void hifmc100_set_oob_info(struct mtd_info *mtd,
+				  struct nand_config_info *info, struct nand_dev_t *nand_dev)
+{
+	int buffer_len;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	struct mtd_oob_region hifmc_oobregion = {0, 0};
+
+	if (info->ecctype != NAND_ECC_0BIT) {
+		mtd->oobsize = info->oobsize;
+	}
+	mtd->oobavail = HIFMC100_NAND_OOBSIZE_FOR_YAFFS;
+
+	host->oobsize = mtd->oobsize;
+
+	buffer_len = host->pagesize + host->oobsize;
+
+	memset(host->buffer, 0xff, buffer_len);
+	host->dma_oob = host->dma_buffer + host->pagesize;
+
+	host->bbm = (unsigned char *)(host->buffer + host->pagesize +
+				      HIFMC100_BAD_BLOCK_POS);
+
+	info->ooblayout_ops->free(mtd, 0, &hifmc_oobregion);
+
+	mtd_set_ooblayout(mtd, info->ooblayout_ops);
+
+	/* EB bits locate in the bottom two of CTRL(30) */
+	host->epm = (u_short *)(host->buffer + host->pagesize +
+				hifmc_oobregion.offset + 28);
+
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	if (best->ecctype == NAND_ECC_16BIT) {
+		if (host->pagesize == _2K) {
+			/* EB bits locate in the bottom two of CTRL(4) */
+			host->epm = (u_short *)(host->buffer + host->pagesize +
+						hifmc_oobregion.offset + 4);
+		} else if (host->pagesize == _4K) {
+			/* EB bit locate in the bottom two of CTRL(14) */
+			host->epm = (u_short *)(host->buffer + host->pagesize +
+						hifmc_oobregion.offset + 12);
+		}
+	}
+#endif
+}
+
+static int hifmc100_set_config_info(struct mtd_info *mtd,
+				    struct nand_chip *chip, struct nand_dev_t *dev)
+{
+	struct hifmc_host *host = chip->priv;
+	struct nand_dev_t *nand_dev = dev;
+	struct nand_config_info *type_info = NULL;
+
+	FMC_PR(BT_DBG, "\t*-Start config Block Page OOB and Ecc\n");
+
+	type_info = hifmc100_get_config_type_info(mtd, nand_dev);
+	WARN_ON(!type_info);
+
+	FMC_PR(BT_DBG, "\t|-%s Config, PageSize %s EccType %s OobSize %d\n",
+	       nand_dev->start_type, nand_page_name(type_info->pagetype),
+	       nand_ecc_name(type_info->ecctype), type_info->oobsize);
+
+	/* Set the page_size, ecc_type, block_size of FMC_CFG[0x0] register */
+	hifmc100_set_fmc_cfg_reg(host, type_info, nand_dev);
+
+	hifmc100_set_oob_info(mtd, type_info, nand_dev);
+
+	if (mtd->writesize > NAND_MAX_PAGESIZE ||
+	    mtd->oobsize > NAND_MAX_OOBSIZE) {
+		DB_BUG(ERSTR_DRIVER
+		       "Driver does not support this Nand Flash. Please " \
+		       "increase NAND_MAX_PAGESIZE and NAND_MAX_OOBSIZE.\n");
+	}
+
+	/* Some Nand Flash devices have subpage structure */
+	if (mtd->writesize != host->pagesize) {
+		unsigned int shift = 0;
+		unsigned int writesize = mtd->writesize;
+
+		while (writesize > host->pagesize) {
+			writesize >>= 1;
+			shift++;
+		}
+		chip->chipsize = chip->chipsize >> shift;
+		mtd->erasesize = mtd->erasesize >> shift;
+		mtd->writesize = host->pagesize;
+		pr_info("Nand divide into 1/%u\n", (1 << shift));
+	}
+
+	FMC_PR(BT_DBG, "\t*-End config Block Page Oob and Ecc\n");
+
+	return 0;
+}
+
+
+static void hifmc100_chip_init(struct nand_chip *chip)
+{
+	struct hifmc_host *host = chip->priv;
+
+	memset((char *)chip->IO_ADDR_R, 0xff, host->dma_len);
+
+	chip->read_byte = hifmc100_read_byte;
+	chip->read_word = hifmc100_read_word;
+	chip->write_buf = hifmc100_write_buf;
+	chip->read_buf = hifmc100_read_buf;
+
+	chip->select_chip = hifmc100_select_chip;
+
+	chip->cmd_ctrl = hifmc100_cmd_ctrl;
+	chip->dev_ready = hifmc100_dev_ready;
+
+	chip->chip_delay = FMC_CHIP_DELAY;
+
+	chip->options = NAND_NEED_READRDY | NAND_BROKEN_XD |
+			NAND_SKIP_BBTSCAN;
+
+	chip->ecc.mode = NAND_ECC_NONE;
+}
+
+
+static int hifmc100_host_init(struct hifmc_host *host)
+{
+	unsigned int reg, flash_type;
+
+	FMC_PR(BT_DBG, "\t *-Start nand host init\n");
+
+	reg = hifmc_readl(host, FMC_CFG);
+	FMC_PR(BT_DBG, "\t |-Read FMC CFG[%#x]%#x\n", FMC_CFG, reg);
+	flash_type = GET_SPI_FLASH_TYPE(reg);
+	if (flash_type != FLASH_TYPE_NAND) {
+		DB_MSG("Error: Flash type isn't Nand flash. reg[%#x]\n", reg);
+		reg |= FMC_CFG_FLASH_SEL(FLASH_TYPE_NAND);
+		FMC_PR(BT_DBG, "\t |-Change flash type to Nand flash\n");
+	}
+
+	if ((reg & FMC_CFG_OP_MODE_MASK) == FMC_CFG_OP_MODE_BOOT) {
+		reg |= FMC_CFG_OP_MODE(FMC_CFG_OP_MODE_NORMAL);
+		FMC_PR(BT_DBG, "\t |-Controller enter normal mode\n");
+	}
+	hifmc_writel(host, FMC_CFG, reg);
+	FMC_PR(BT_DBG, "\t |-Set CFG[%#x]%#x\n", FMC_CFG, reg);
+
+	host->nand_cfg = reg;
+	host->nand_cfg_ecc0 = (reg & ~ECC_TYPE_MASK) | ECC_TYPE_0BIT;
+
+	reg = hifmc_readl(host, FMC_GLOBAL_CFG);
+	FMC_PR(BT_DBG, "\t |-Read global CFG[%#x]%#x\n", FMC_GLOBAL_CFG, reg);
+	if (reg & FMC_GLOBAL_CFG_RANDOMIZER_EN) {
+		host->flags &= ~NAND_RANDOMIZER;
+		FMC_PR(BT_DBG, "\t |-Default disable randomizer\n");
+		reg &= ~FMC_GLOBAL_CFG_RANDOMIZER_EN;
+		hifmc_writel(host, FMC_GLOBAL_CFG, reg);
+		FMC_PR(BT_DBG, "\t |-Set global CFG[%#x]%#x\n", FMC_GLOBAL_CFG, reg);
+	}
+
+#ifdef CONFIG_HIFMC100_NAND_EDO_MODE
+	/* enable EDO node */
+	reg = hifmc_readl(host, FMC_GLOBAL_CFG);
+	hifmc_writel(host, FMC_GLOBAL_CFG, SET_NAND_EDO_MODE_EN(reg));
+#endif
+
+	host->addr_cycle = 0;
+	host->addr_value[0] = 0;
+	host->addr_value[1] = 0;
+	host->cache_addr_value[0] = ~0;
+	host->cache_addr_value[1] = ~0;
+
+	host->send_cmd_pageprog = hifmc100_send_cmd_write;
+	host->send_cmd_status = hifmc100_send_cmd_status;
+	host->send_cmd_readstart = hifmc100_send_cmd_read;
+	host->send_cmd_erase = hifmc100_send_cmd_erase;
+	host->send_cmd_readid = hifmc100_send_cmd_readid;
+	host->send_cmd_reset = hifmc100_send_cmd_reset;
+
+	/*
+	 * check if start from nand.
+	 * This register REG_SYSSTAT is set in start.S
+	 * When start in NAND (Auto), the ECC/PAGESIZE driver don't detect.
+	 */
+	host->flags |= NANDC_HW_AUTO;
+
+	if (GET_SYS_BOOT_MODE(reg) == BOOT_FROM_NAND) {
+		host->flags |= NANDC_CONFIG_DONE;
+		FMC_PR(BT_DBG, "\t |-Auto config pagesize and ecctype\n");
+	}
+
+	host->enable_ecc_randomizer = hifmc100_ecc_randomizer;
+
+	FMC_PR(BT_DBG, "\t *-End nand host init\n");
+
+	return 0;
+}
+
+
+int hifmc100_nand_init(struct nand_chip *chip)
+{
+	struct hifmc_host *host = chip->priv;
+
+	/* enable and set system clock */
+	clk_prepare_enable(host->clk);
+
+	/* fmc ip version check */
+	host->version = hifmc_readl(host, FMC_VERSION);
+	if (host->version != HIFMC_VER_100) {
+		return -EFAULT;
+	}
+	pr_info("Found Flash Memory Controller v100 Nand Driver\n");
+
+	/* hifmc host init */
+	if (hifmc100_host_init(host)) {
+		DB_MSG("Error: Nand host init failed!\n");
+		return -EFAULT;
+	}
+	host->chip = chip;
+
+	hifmc_writel(host,
+		     FMC_PND_PWIDTH_CFG,
+		     PWIDTH_CFG_RW_HCNT(CONFIG_RW_H_WIDTH) |
+		     PWIDTH_CFG_R_LCNT(CONFIG_R_L_WIDTH) |
+		     PWIDTH_CFG_W_LCNT(CONFIG_W_L_WIDTH));
+
+	/* hifmc nand_chip struct init */
+	hifmc100_chip_init(chip);
+
+	hifmc_spl_ids_register();
+	hinfc_param_adjust = hifmc100_set_config_info;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+void hifmc100_nand_config(const struct hifmc_host *host)
+{
+	/* enable system clock */
+	clk_prepare_enable(host->clk);
+	FMC_PR(PM_DBG, "\t |-enable system clock\n");
+}
+#endif  /* CONFIG_PM */
diff --git a/drivers/mtd/nand/hifmc100_nand/hifmc100_nand.h b/drivers/mtd/nand/hifmc100_nand/hifmc100_nand.h
new file mode 100644
index 000000000..fba2f43ba
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100_nand/hifmc100_nand.h
@@ -0,0 +1,151 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __HIFMC100_NAND_H__
+#define __HIFMC100_NAND_H__
+
+#include <linux/mfd/hisi_fmc.h>
+
+/******************************************************************************/
+/* These macroes are for debug only, reg option is slower then dma option */
+#undef HIFMC100_NAND_SUPPORT_REG_READ
+/* #define HIFMC100_NAND_SUPPORT_REG_READ */
+
+#undef HIFMC100_NAND_SUPPORT_REG_WRITE
+/* #define HIFMC100_NAND_SUPPORT_REG_WRITE */
+
+/*****************************************************************************/
+#define HIFMC100_ECC_ERR_NUM0_BUF0      0xc0
+#define HIFMC100_ECC_ERR_NUM1_BUF0      0xc4
+#define HIFMC100_ECC_ERR_NUM0_BUF1      0xc8
+#define HIFMC100_ECC_ERR_NUM1_BUF1      0xcc
+
+#define GET_ECC_ERR_NUM(_i, _reg)       (((_reg) >> ((_i) * 8)) & 0xff)
+
+/*****************************************************************************/
+#define NAND_MAX_PAGESIZE           32768
+#define NAND_MAX_OOBSIZE            4800
+
+#define CONFIG_SUPPORT_YAFFS
+#define HIFMC100_NAND_OOBSIZE_FOR_YAFFS     32
+
+/*****************************************************************************/
+#define REG_CNT_HIGH_BLOCK_NUM_SHIFT        10
+
+#define REG_CNT_BLOCK_NUM_MASK          0x3ff
+#define REG_CNT_BLOCK_NUM_SHIFT         22
+
+#define REG_CNT_PAGE_NUM_MASK           0x3f
+#define REG_CNT_PAGE_NUM_SHIFT          16
+
+/*****************************************************************************/
+#define HIFMC100_ADDR_CYCLE_MASK        0x4
+#define NAND_EDO_MODE_SHIFT            9
+#define NAND_EDO_MODE_MASK             (1<<NAND_EDO_MODE_SHIFT)
+#define SET_NAND_EDO_MODE_EN(reg)      ((reg) | NAND_EDO_MODE_MASK)
+/*****************************************************************************/
+struct hifmc_host {
+	struct nand_chip *chip;
+	struct mtd_info  *mtd;
+
+	struct hifmc_cmd_op cmd_op;
+	void __iomem *regbase;
+	void __iomem *iobase;
+
+	/* Controller config option nand flash */
+	unsigned int nand_cfg;
+	unsigned int nand_cfg_ecc0;
+
+	unsigned int offset;
+
+	struct device *dev;
+
+	/* This is maybe an un-aligment address, only for malloc or free */
+	char *buforg;
+	char *buffer;
+
+#ifdef CONFIG_64BIT
+	unsigned long long dma_buffer;
+	unsigned long long dma_oob;
+#else
+	unsigned int dma_buffer;
+	unsigned int dma_oob;
+#endif
+	unsigned int dma_len;
+
+	unsigned int addr_cycle;
+	unsigned int addr_value[2];
+	unsigned int cache_addr_value[2];
+
+	unsigned int column;
+	unsigned int block_page_mask;
+
+	unsigned int ecctype;
+	unsigned int pagesize;
+	unsigned int oobsize;
+
+	int  need_rr_data;
+#define HIFMC100_READ_RETRY_DATA_LEN         128
+	char rr_data[HIFMC100_READ_RETRY_DATA_LEN];
+	int  version;
+	int   add_partition;
+
+	/* BOOTROM read two bytes to detect the bad block flag */
+#define HIFMC100_BAD_BLOCK_POS              0
+	unsigned char *bbm;  /* nand bad block mark */
+	unsigned short *epm;  /* nand empty page mark */
+	unsigned int flags;
+
+#define HIFMC100_PS_UC_ECC        0x01 /* page has ecc error */
+#define HIFMC100_PS_BAD_BLOCK     0x02 /* bad block */
+#define HIFMC100_PS_EMPTY_PAGE    0x04 /* page is empty */
+#define HIFMC100_PS_EPM_ERROR     0x0100 /* empty page mark word has error. */
+#define HIFMC100_PS_BBM_ERROR     0x0200 /* bad block mark word has error. */
+	unsigned int page_status;
+
+	struct clk *clk;
+
+	void (*send_cmd_pageprog)(struct hifmc_host *host);
+	void (*send_cmd_status)(struct hifmc_host *host);
+	void (*send_cmd_readstart)(struct hifmc_host *host);
+	void (*send_cmd_erase)(struct hifmc_host *host);
+	void (*send_cmd_readid)(struct hifmc_host *host);
+	void (*send_cmd_reset)(struct hifmc_host *host);
+	void (*enable)(int enable);
+
+	void (*enable_ecc_randomizer)(struct hifmc_host *host,
+				      int ecc_en, int randomizer_en);
+
+	void (*detect_ecc)(struct hifmc_host *host);
+
+	struct read_retry_t *read_retry;
+};
+
+extern struct nand_dev_t g_nand_dev;
+
+int hifmc100_nand_init(struct nand_chip *chip);
+
+extern void hifmc_spl_ids_register(void);
+
+#ifdef CONFIG_PM
+void hifmc100_nand_config(const struct hifmc_host *host);
+#endif
+
+#endif /* End of __HIFMC100_NAND_H__ */
diff --git a/drivers/mtd/nand/hifmc100_nand/hifmc100_nand_os.c b/drivers/mtd/nand/hifmc100_nand/hifmc100_nand_os.c
new file mode 100644
index 000000000..0849cd3cb
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100_nand/hifmc100_nand_os.c
@@ -0,0 +1,180 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/of_platform.h>
+
+#include "hifmc100_nand_os.h"
+#include "hifmc100_nand.h"
+#include <linux/mfd/hisi_fmc.h>
+
+static inline int mtd_has_partitions(void)
+{
+	return 1;
+}
+
+static int hisi_nand_os_probe(struct platform_device *pltdev)
+{
+	int len;
+	int result = 0;
+	struct hifmc_host *host = NULL;
+	struct nand_chip *chip = NULL;
+	struct mtd_info *mtd = NULL;
+	int nr_parts = 0;
+	struct mtd_partition *parts = NULL;
+	struct device *dev = &pltdev->dev;
+	struct device_node *np = NULL;
+	struct hisi_fmc *fmc = dev_get_drvdata(dev->parent);
+
+	if (!fmc) {
+		dev_err(dev, "get mfd fmc devices failed\n");
+		return -ENXIO;
+	}
+
+	len = sizeof(struct hifmc_host) + sizeof(struct nand_chip)
+	      + sizeof(struct mtd_info);
+	host = devm_kzalloc(dev, len, GFP_KERNEL);
+	if (!host) {
+		return -ENOMEM;
+	}
+	memset((char *)host, 0, len);
+	platform_set_drvdata(pltdev, host);
+
+	host->dev = &pltdev->dev;
+	host->chip = chip = (struct nand_chip *)&host[1];
+	host->mtd = mtd = nand_to_mtd(chip);
+	host->regbase = fmc->regbase;
+	host->iobase = fmc->iobase;
+	host->clk = fmc->clk;
+	chip->IO_ADDR_R = chip->IO_ADDR_W = host->iobase;
+	host->buffer = fmc->buffer;
+	host->dma_buffer = fmc->dma_buffer;
+	host->dma_len = fmc->dma_len;
+
+	/* hifmc Nand host init */
+	chip->priv = host;
+	result = hifmc100_nand_init(chip);
+	if (result) {
+		DB_MSG("Error: host init failed! result: %d\n", result);
+		goto fail;
+	}
+
+	np = of_get_next_available_child(dev->of_node, NULL);
+	mtd->name = np->name;
+	mtd->type = MTD_NANDFLASH;
+	mtd->priv = chip;
+	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->owner = THIS_MODULE;
+
+	if (nand_scan(mtd, CONFIG_HIFMC100_MAX_NAND_CHIP)) {
+		result = -ENXIO;
+		goto fail;
+	}
+
+	result = mtd_device_register(host->mtd, parts, nr_parts);
+	if (result) {
+		kfree(parts);
+		parts = NULL;
+	}
+
+	return (result == 1) ? -ENODEV : 0;
+
+fail:
+	clk_disable_unprepare(host->clk);
+	nand_release(mtd);
+	return result;
+}
+
+static int hisi_nand_os_remove(struct platform_device *pltdev)
+{
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+
+	clk_disable_unprepare(host->clk);
+	nand_release(host->mtd);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int hifmc100_nand_os_suspend(struct platform_device *pltdev,
+				    pm_message_t state)
+{
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+	struct device *dev = &pltdev->dev;
+	if (!host || !host->clk) {
+		dev_err(dev,"host or host->clk is null err\n");
+		return 0;
+	}
+
+	while ((hifmc_readl(host, FMC_OP) & FMC_OP_REG_OP_START)) {
+		_cond_resched();
+	}
+
+	while ((hifmc_readl(host, FMC_OP_CTRL) & OP_CTRL_DMA_OP_READY)) {
+		_cond_resched();
+	}
+
+	clk_disable_unprepare(host->clk);
+	FMC_PR(PM_DBG, "\t|-disable system clock\n");
+	return 0;
+}
+
+static int hifmc100_nand_os_resume(struct platform_device *pltdev)
+{
+	int cs;
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+	struct nand_chip *chip = NULL;
+
+	if (!host) {
+		return 0;
+	}
+	chip = host->chip;
+
+	for (cs = 0; cs < chip->numchips; cs++) {
+		host->send_cmd_reset(host);
+	}
+
+	hifmc100_nand_config(host);
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static const struct of_device_id hisi_nand_dt_ids[] = {
+	{ .compatible = "hisilicon,hisi_nand" },
+	{ } /* sentinel */
+};
+MODULE_DEVICE_TABLE(of, hisi_nand_dt_ids);
+
+static struct platform_driver hisi_nand_driver = {
+	.driver = {
+		.name   = "hisi_nand",
+		.of_match_table = hisi_nand_dt_ids,
+	},
+	.probe  = hisi_nand_os_probe,
+	.remove = hisi_nand_os_remove,
+#ifdef CONFIG_PM
+	.suspend    = hifmc100_nand_os_suspend,
+	.resume     = hifmc100_nand_os_resume,
+#endif
+};
+module_platform_driver(hisi_nand_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("BVT_BSP");
+MODULE_DESCRIPTION("Hisilicon Flash Memory Controller V100 Nand Driver");
diff --git a/drivers/mtd/nand/hifmc100_nand/hifmc100_nand_os.h b/drivers/mtd/nand/hifmc100_nand/hifmc100_nand_os.h
new file mode 100644
index 000000000..a27813530
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100_nand/hifmc100_nand_os.h
@@ -0,0 +1,72 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __HIFMC100_NAND_OS_H__
+#define __HIFMC100_NAND_OS_H__
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/rawnand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <asm/errno.h>
+#include <asm/setup.h>
+#include <linux/io.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <linux/resource.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+
+#if (KERNEL_VERSION(3, 4, 5) <= LINUX_VERSION_CODE)
+#include "../../mtdcore.h"
+#endif
+
+
+#define DEFAULT_NAND_PAGESIZE   2048
+#define DEFAULT_NAND_OOBSIZE    64
+
+#define NAND_BUFFER_LEN     (DEFAULT_NAND_PAGESIZE + DEFAULT_NAND_OOBSIZE)
+
+
+#ifndef CONFIG_RW_H_WIDTH
+#define CONFIG_RW_H_WIDTH   (10)
+#warning NOT config CONFIG_RW_H_WIDTH, used default value, maybe invalid.
+#endif
+
+#ifndef CONFIG_R_L_WIDTH
+#define CONFIG_R_L_WIDTH    (10)
+#warning NOT config CONFIG_R_L_WIDTH, used default value, maybe invalid.
+#endif
+
+#ifndef CONFIG_W_L_WIDTH
+#define CONFIG_W_L_WIDTH    (10)
+#warning NOT config CONFIG_W_L_WIDTH, used default value, maybe invalid.
+#endif
+
+extern void hifmc100_nand_controller_enable(int enable);
+
+#endif /* End of __HIFMC100_NAND_OS_H__ */
diff --git a/drivers/mtd/nand/hifmc100_nand/hifmc_nand_spl_ids.c b/drivers/mtd/nand/hifmc100_nand/hifmc_nand_spl_ids.c
new file mode 100644
index 000000000..b03510a44
--- /dev/null
+++ b/drivers/mtd/nand/hifmc100_nand/hifmc_nand_spl_ids.c
@@ -0,0 +1,982 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <asm/setup.h>
+#include <linux/mtd/nand.h>
+#include <linux/mfd/hisi_fmc.h>
+#include <linux/uaccess.h>
+
+#include "../raw/hinfc_gen.h"
+#include "hifmc100_nand.h"
+
+
+#define _768K           (_256K + _512K)
+
+
+struct nand_flash_special_dev {
+	unsigned char id[8];
+	int length;             /* length of id. */
+	unsigned long long chipsize;
+	struct nand_flash_dev *(*probe)(unsigned char *id);
+	char *name;
+
+	unsigned long pagesize;
+	unsigned long erasesize;
+	unsigned long oobsize;
+	unsigned long options;
+	unsigned int read_retry_type;
+
+#define BBP_LAST_PAGE                    0x01
+#define BBP_FIRST_PAGE                   0x02
+	unsigned int badblock_pos;
+	int flags;
+};
+
+
+/*                    this is nand probe function.                           */
+
+
+static struct nand_flash_dev *hynix_probe_v02(unsigned char *id)
+{
+	struct nand_flash_dev *type = &g_nand_dev.flash_dev;
+
+	int pagesizes[]   = {_2K, _4K, _8K, 0};
+	int oobsizes[]    = {128, 224, 448, 0, 0, 0, 0, 0};
+	int blocksizes[]  = {_128K, _256K, _512K, _768K, _1M, _2M, 0, 0};
+
+	int blocktype = (((id[3] >> 5) & 0x04) | ((id[3] >> 4) & 0x03));
+	int oobtype   = (((id[3] >> 2) & 0x03) | ((id[3] >> 4) & 0x04));
+
+	type->options   = 0;
+	type->pagesize  = pagesizes[(id[3] & 0x03)];
+	type->erasesize = blocksizes[blocktype];
+	type->oobsize = oobsizes[oobtype];
+
+	return type;
+}
+
+
+static struct nand_flash_dev *samsung_probe_v02(unsigned char *id)
+{
+	struct nand_flash_dev *type = &g_nand_dev.flash_dev;
+
+	int pagesizes[]   = {_2K, _4K, _8K, 0};
+	int oobsizes[]    = {0, 128, 218, 400, 436, 0, 0, 0};
+	int blocksizes[]  = {_128K, _256K, _512K, _1M, 0, 0, 0, 0};
+
+	int blocktype = (((id[3] >> 5) & 0x04) | ((id[3] >> 4) & 0x03));
+	int oobtype   = (((id[3] >> 4) & 0x04) | ((id[3] >> 2) & 0x03));
+
+	type->options   = 0;
+	type->pagesize  = pagesizes[(id[3] & 0x03)];
+	type->erasesize = blocksizes[blocktype];
+	type->oobsize = oobsizes[oobtype];
+
+	return type;
+}
+
+#define DRV_VERSION     "1.40"
+
+/*
+ * samsung:  27nm need randomizer, 21nm need read retry;
+ * micron:   25nm need read retry, datasheet will explain read retry.
+ * toshaba   32nm need randomizer, 24nm need read retry.
+ * hynix:    2xnm need read retry.
+ *
+ *      The special nand flash ID table version 1.39
+ *
+ * manufactory  |  type  |       name        |   ecc_type  | version_tag
+ * Micron       |  MLC   |  MT29F64G08CBABA  |   40bit/1k  |  1.36
+ * Micron       |  MLC   |  MT29F32G08CBADA  |   40bit/1k  |
+ * Micron       |  SLC   |  MT29F8G08ABxBA   |   4bit/512  |
+ * Micron       |  MLC   |  MT29F16G08CBABx  |   12bit/512 |
+ * Micron       |  MLC   |  MT29F16G08CBACA  |   24bit/1k  |
+ * Micron       |  MLC   |  MT29F32G08CBACA  |   24bit/1k  |
+ * Micron       |  MLC   |  MT29F64G08CxxAA  |   24bit/1k  |
+ * Micron       |  MLC   |  MT29F256G08CJAAA |   24bit/1k  |   2CE
+ * Micron       |  MLC   |  MT29F256G08CMCBB |   24bit/1k  |
+ * Micron       |  SLC   |  MT29F8G08ABACA   |   8bit/512  |
+ * Micron       |  SLC   |  MT29F4G08ABAEA   |   8bit/512  |
+ * Micron       |  SLC   |  MT29F2G08ABAFA   |   8bit/512  |
+ * Micron       |  SLC   |  MT29F16G08ABACA  |   8bit/512  |
+ * Toshiba      |  MLC   |  TC58NVG4D2FTA00  |   24bit/1k  |
+ * Toshiba      |  MLC   |  TH58NVG6D2FTA20  |   24bit/1k  |   2CE
+ * Toshiba      |  MLC   |  TC58NVG5D2HTA00  |   40bit/1k  |
+ * Toshiba      |  MLC   |  TC58NVG6D2GTA00  |   40bit/1k  |
+ * Toshiba      |  MLC   |  TC58NVG6DCJTA00  |             |
+ * Toshiba      |  MLC   |  TC58TEG5DCJTA00  |             |
+ * Toshiba      |  SLC   |  TC58NVG0S3HTA00  |   8bit/512  |
+ * Toshiba      |  SLC   |  TC58NVG1S3HTA00  |   8bit/512  |
+ * Toshiba      |  SLC   |  TC58NVG1S3ETA00  |   4bit/512  |
+ * Toshiba      |  SLC   |  TC58NVG3S0FTA00  |   4bit/512  |
+ * Toshiba      |  SLC   |  TC58NVG2S0FTA00  |   4bit/512  |
+ * Toshiba      |  SLC   |  TH58NVG2S3HTA00  |   4bit/512  |
+ * Toshiba      |  TLC   |  TC58NVG5T2JTA00  |   60bit/1k  |
+ * Toshiba      |  TLC   |  TC58TEG5DCKTAx0  |   60bit/1k  |
+ * Toshiba      |  MLC   |  Tx58TEGxDDKTAx0  |             |
+ * Samsung      |  MLC   |  K9LB(HC/PD/MD)G08U0(1)D  |   8bit/512B  |
+ * Samsung      |  MLC   |  K9GAG08U0E       |   24bit/1KB |
+ * Samsung      |  MLC   |  K9LBG08U0E       |   24bit/1KB |
+ * Samsung      |  MLC   |  K9G8G08U0C       |   24bit/1KB |
+ * Samsung      |  MLC   |  K9GAG08U0F       |   24bit/1KB |
+ * Samsung      |  MLC   |  K9LBG08U0M       |             |
+ * Samsung      |  MLC   |  K9GBG08U0A       |   24bit/1KB |
+ * Samsung      |  MLC   |  K9GBG08U0B       |   40bit/1KB |
+ * Hynix        |  MLC   |  H27UAG8T2A       |             |
+ * Hynix        |  MLC   |  H27UAG8T2B       |             |
+ * Hynix        |  MLC   |  H27UBG8T2A       |             |
+ * Hynix        |  MLC   |  H27UBG8T2BTR     |   24bit/1KB |
+ * Hynix        |  MLC   |  H27UCG8T2A       |   40bit/1KB |
+ * Hynix        |  MLC   |  H27UBG8T2C       |   40bit/1KB |
+ * MISC         |  MLC   |  P1UAGA30AT-GCA   |   8bit/512  |
+ * MISC         |  MLC   |  PSU8GA30AT-GIA/ASU8GA30IT-G30CA  |   4bit/512  |
+ * MISC         |  SLC   |  PSU2GA30AT       |   1bit/512  |   1.36
+ * Toshiba      |  SLC   |  TC58NVG2S0HTA00  |   24bit/1K  |   1.37
+ * Toshiba      |  SLC   |  TC58NVG3S0HTA00  |   24bit/1K  |   1.37
+ * Micron       |  SLC   |  MT29F2G08ABAEA   |   4bit/512 |
+ * Spansion     |  SLC   | S34ML02G200TFI000     | 24bit/1K |
+ * Spansion     |  SLC   | S34ML04G200TFI000     | 24bit/1K |  1.38
+ * MXIC Macronix|  SLC   | MX30UF2G18AC 1.8V | 4bit/512 |  1.39
+ * Spansion     |  SLC   | S34MS01G200TFI00 1.8V | 4bit/512 |  1.40
+ * Spansion     |  SLC   | S34MS02G200TFI00 1.8V | 24bit/1K |  1.40
+ * Spansion     |  SLC   | S34MS04G200TFI00 1.8V | 24bit/1K |  1.40
+ *
+ */
+static struct nand_flash_special_dev nand_flash_special_table[] = {
+
+	/************************* 1.8V MXIC Macronix **************************/
+	{       /* SLC 4bit/512 1.8V */
+		.name      = "MX30UF2G18AC",
+		.id        = {0xC2, 0xAA, 0x90, 0x15, 0x06},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	/****************************** Spansion *******************************/
+
+	{      /* SLC S34ML02G200TFI000 */
+		.name      = "S34ML02G200TFI000",
+		.id        = {0x01, 0xDA, 0x90, 0x95, 0x46, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	{      /* SLC S34ML04G200TFI000 */
+		.name      = "S34ML04G200TFI000",
+		.id        = {0x01, 0xDC, 0x90, 0x95, 0x56, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _512M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	{      /* SLC S34MS02G200TFI00 1.8V */
+		.name      = "S34MS02G200TFI00",
+		.id        = {0x01, 0xAA, 0x90, 0x15, 0x46, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	{      /* SLC S34MS04G200TFI00 1.8V */
+		.name      = "S34MS04G200TFI00",
+		.id        = {0x01, 0xAC, 0x90, 0x15, 0x56, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _512M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	/****************************** Micron *******************************/
+
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F64G08CBABA",
+		.id        = {0x2C, 0x64, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_MICRON,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = NAND_RANDOMIZER | NAND_CHIP_MICRON,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F32G08CBADA",
+		.id        = {0x2C, 0x44, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_MICRON,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* SLC 4bit/512 */
+		.name      = "MT29F8G08ABxBA",
+		.id        = {0x2C, 0x38, 0x00, 0x26, 0x85, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _1G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _512K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 12bit/512 */
+		.name      = "MT29F16G08CBABx",
+		.id        = {0x2C, 0x48, 0x04, 0x46, 0x85, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _2G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F16G08CBACA",
+		.id        = {0x2C, 0x48, 0x04, 0x4A, 0xA5, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _2G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F32G08CBACA",
+		.id        = {0x2C, 0x68, 0x04, 0x4A, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F64G08CxxAA",
+		.id        = {0x2C, 0x88, 0x04, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 24bit/1k 2CE */
+		.name      = "MT29F256G08CJAAA",
+		.id        = {0x2C, 0xA8, 0x05, 0xCB, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _16G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F256G08CMCBB",
+		.id        = {0x2C, 0x64, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F8G08ABACA",
+		.id        = {0x2C, 0xD3, 0x90, 0xA6, 0x64, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _1G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F4G08ABAEA",
+		.id        = {0x2C, 0xDC, 0x90, 0xA6, 0x54, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _512M,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F2G08ABAFA",
+		.id        = {0x2C, 0xDA, 0x90, 0x95, 0x04, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{      /* SLC MT29F2G08ABAEA */
+		.name      = "MT29F2G08ABAEA",
+		.id        = {0x2C, 0xDA, 0x90, 0x95, 0x06, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F16G08ABACA",
+		.id        = {0x2C, 0x48, 0x00, 0x26, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _2G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _512K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	/****************************** Toshaba *******************************/
+
+	{       /* MLC 24bit/1k 32nm */
+		.name      = "TC58NVG4D2FTA00",
+		.id        = {0x98, 0xD5, 0x94, 0x32, 0x76, 0x55, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _2G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _1M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1k 32nm 2CE */
+		.name      = "TH58NVG6D2FTA20",
+		.id        = {0x98, 0xD7, 0x94, 0x32, 0x76, 0x55, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _1M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 40bit/1k 24nm */
+		.name      = "TC58NVG5D2HTA00 24nm",
+		.id        = {0x98, 0xD7, 0x94, 0x32, 0x76, 0x56, 0x08, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _1M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{       /* MLC 40bit/1k */
+		.name      = "TC58NVG6D2GTA00",
+		.id        = {0x98, 0xDE, 0x94, 0x82, 0x76, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 19nm */
+		.name      = "TC58NVG6DCJTA00 19nm",
+		.id        = {0x98, 0xDE, 0x84, 0x93, 0x72, 0x57, 0x08, 0x04},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = _16K,
+		.erasesize = _4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{       /* MLC 19nm */
+		.name      = "TC58TEG5DCJTA00 19nm",
+		.id        = {0x98, 0xD7, 0x84, 0x93, 0x72, 0x57, 0x08, 0x04},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _16K,
+		.erasesize = _4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER | NAND_CHIP_TOSHIBA_TOGGLE_10,
+	},
+	{       /* SLC 8bit/512 */
+		.name      = "TC58NVG0S3HTA00",
+		.id        = {0x98, 0xF1, 0x80, 0x15, 0x72, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _128M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		/*
+		 * Datasheet: read one column of any page in each block. If the
+		 * data of the column is 00 (Hex), define the block as a bad
+		 * block.
+		 */
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 8bit/512 */
+		.name      = "TC58NVG1S3HTA00",
+		.id        = {0x98, 0xDA, 0x90, 0x15, 0x76, 0x16, 0x08, 0x00},
+		.length    = 7,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG1S3ETA00",
+		.id        = {0x98, 0xDA, 0x90, 0x15, 0x76, 0x14, 0x03, 0x00},
+		.length    = 7,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG3S0FTA00",
+		.id        = {0x98, 0xD3, 0x90, 0x26, 0x76, 0x15, 0x02, 0x08},
+		.length    = 8,
+		.chipsize  = _1G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _256K,
+		.oobsize   = 232,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 24bit/1k */
+		.name      = "TC58NVG3S0HTA00",
+		.id        = {0x98, 0xD3, 0x91, 0x26, 0x76, 0x16, 0x08, 0x00},
+		.length    = 8,
+		.chipsize  = _1G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _256K,
+		.oobsize   = 256,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 24bit/1k */
+		.name      = "TC58NVG2S0HTA00",
+		.id        = {0x98, 0xDC, 0x90, 0x26, 0x76, 0x16, 0x08, 0x00},
+		.length    = 8,
+		.chipsize  = _512M,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _256K,
+		.oobsize   = 256,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG2S0FTA00",
+		.id        = {0x98, 0xDC, 0x90, 0x26, 0x76, 0x15, 0x01, 0x08},
+		.length    = 8,
+		.chipsize  = _512M,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TH58NVG2S3HTA00",
+		.id        = {0x98, 0xDC, 0x91, 0x15, 0x76},
+		.length    = 5,
+		.chipsize  = _512M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* TLC 60bit/1k 19nm */
+		.name      = "TC58NVG5T2JTA00 19nm TLC",
+		/* datasheet says 6 ids id data, but really has 8 ids. */
+		.id        = {0x98, 0xD7, 0x98, 0x92, 0x72, 0x57, 0x08, 0x10},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _4M,
+		.oobsize   = 1024,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{ /* TLC 60bit/1k 19nm */
+		.name      = "TC58TEG5DCKTAx0 19nm MLC",
+		/* datasheet says 6 ids id data, but really has 8 ids. */
+		.id    = {0x98, 0xD7, 0x84, 0x93, 0x72, 0x50, 0x08, 0x04},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _16K,
+		.erasesize = _4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_19nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{
+		.name      = "Tx58TEGxDDKTAx0 19nm MLC",
+		.id    = {0x98, 0xDE, 0x94, 0x93, 0x76, 0x50},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _16K,
+		.erasesize = _4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_19nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	/******************************* Samsung ******************************/
+	{       /* MLC 8bit/512B */
+		.name     = "K9LB(HC/PD/MD)G08U0(1)D",
+		.id       = {0xEC, 0xD7, 0xD5, 0x29, 0x38, 0x41, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name      = "K9GAG08U0E",
+		.id        = {0xEC, 0xD5, 0x84, 0x72, 0x50, 0x42, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _2G,
+		.probe     = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name     = "K9LBG08U0E",
+		.id       = {0xEC, 0xD7, 0xC5, 0x72, 0x54, 0x42, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name     = "K9G8G08U0C",
+		.id       = {0xEC, 0xD3, 0x84, 0x72, 0x50, 0x42, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = _1G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "K9GAG08U0F",
+		.id        = {0xEC, 0xD5, 0x94, 0x76, 0x54, 0x43, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _2G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _1M,
+		.oobsize   = 512,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC */
+		.name      = "K9LBG08U0M",
+		.id        = {0xEC, 0xD7, 0x55, 0xB6, 0x78, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _512K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "K9GBG08U0A 20nm",
+		.id        = {0xEC, 0xD7, 0x94, 0x7A, 0x54, 0x43, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _1M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_SAMSUNG,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "K9GBG08U0B",
+		.id        = {0xEC, 0xD7, 0x94, 0x7E, 0x64, 0x44, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _1M,
+		.oobsize   = 1024,
+		.options   = 0,
+		.read_retry_type = NAND_RR_SAMSUNG,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+
+	/*********************************** Hynix ****************************/
+	{       /* MLC */
+		.name     = "H27UAG8T2A",
+		.id       = { 0xAD, 0xD5, 0x94, 0x25, 0x44, 0x41, },
+		.length   = 6,
+		.chipsize = _2G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC */
+		.name     = "H27UAG8T2B",
+		.id       = { 0xAD, 0xD5, 0x94, 0x9A, 0x74, 0x42, },
+		.length   = 6,
+		.chipsize = _2G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC */
+		.name     = "H27UBG8T2A",
+		.id       = { 0xAD, 0xD7, 0x94, 0x9A, 0x74, 0x42, },
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{
+		.name      = "H27UBG8T2BTR 26nm",
+		.id        = { 0xAD, 0xD7, 0x94, 0xDA, 0x74, 0xC3, },
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_BG_BDIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "H27UCG8T2A",
+		.id        = { 0xAD, 0xDE, 0x94, 0xDA, 0x74, 0xC4, },
+		.length    = 6,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_CG_ADIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "H27UBG8T2C",
+		.id        = { 0xAD, 0xD7, 0x94, 0x91, 0x60, 0x44, },
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = _8K,
+		.erasesize = _2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_BG_CDIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+
+	/********************** MISC ******************************************/
+	{        /* MLC 8bit/512 */
+		.name      = "P1UAGA30AT-GCA",
+		.id        = { 0xC8, 0xD5, 0x14, 0x29, 0x34, 0x01, },
+		.length    = 6,
+		.chipsize  = _2G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _512K,
+		.oobsize   = 218,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 4bit/512 */
+		/*
+		 * PowerFlash ASU8GA30IT-G30CA ID and MIRA PSU8GA30AT-GIA ID are
+		 * the same ID
+		 */
+		.name      = "PSU8GA30AT-GIA/ASU8GA30IT-G30CA",
+		.id        = { 0xC8, 0xD3, 0x90, 0x19, 0x34, 0x01, },
+		.length    = 6,
+		.chipsize  = _1G,
+		.probe     = NULL,
+		.pagesize  = _4K,
+		.erasesize = _256K,
+		.oobsize   = 218,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 1bit/512 */
+		.name      = "PSU2GA30AT",
+		.id        = { 0x7F, 0x7F, 0x7F, 0x7F, 0xC8, 0xDA, 0x00, 0x15, },
+		.length    = 8,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = _2K,
+		.erasesize = _128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{{0}, 0, 0, 0, 0, 0, 0, 0, 0},
+};
+
+struct nand_dev_t g_nand_dev;
+
+struct nand_flash_dev *hifmc_get_spl_flash_type(struct mtd_info *mtd,
+		unsigned char *id)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_flash_special_dev *spl_dev = nand_flash_special_table;
+	struct nand_flash_dev *type = &g_nand_dev.flash_dev;
+	struct nand_dev_t *nand_dev = &g_nand_dev;
+
+	FMC_PR(BT_DBG, "\t *-Start find special nand flash\n");
+
+	pr_info("Nand ID: %#X %#X %#X %#X %#X %#X %#X %#X\n", id[0], id[1],
+		id[2], id[3], id[4], id[5], id[6], id[7]);
+
+	for (; spl_dev->length; spl_dev++) {
+		if (!access_ok(VERIFY_READ, id, spl_dev->length)) {
+			pr_info("err: access_ok verify fail\n");
+			return NULL;
+		}
+		if (memcmp(id, spl_dev->id, spl_dev->length)) {
+			continue;
+		}
+
+		FMC_PR(BT_DBG, "\t |-Found special Nand flash: %s\n",
+		       spl_dev->name);
+
+		if (spl_dev->probe) {
+			type = spl_dev->probe(id);
+		} else {
+			type->options   = spl_dev->options;
+			type->pagesize  = spl_dev->pagesize;
+			type->erasesize = spl_dev->erasesize;
+			type->oobsize = spl_dev->oobsize;
+		}
+
+		type->name = spl_dev->name;
+		type->id_len = spl_dev->length;
+		memcpy(type->id, id, type->id_len);
+		type->chipsize = (unsigned int)(spl_dev->chipsize >> 20);
+		FMC_PR(BT_DBG, "\t |-Save struct nand_flash_dev info\n");
+
+		memcpy(nand_dev->ids, id, MAX_NAND_ID_LEN);
+		nand_dev->oobsize = type->oobsize;
+		nand_dev->flags = spl_dev->flags;
+		nand_dev->read_retry_type = spl_dev->read_retry_type;
+		FMC_PR(BT_DBG, "\t |-Save struct nand_dev_t information\n");
+
+		mtd->oobsize = spl_dev->oobsize;
+		mtd->erasesize = spl_dev->erasesize;
+		mtd->writesize = spl_dev->pagesize;
+		chip->chipsize = spl_dev->chipsize;
+		mtd->size = spl_dev->chipsize;
+
+		return type;
+	}
+	nand_dev->read_retry_type = NAND_RR_NONE;
+
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+	chip->read_byte(mtd);
+	chip->read_byte(mtd);
+
+	FMC_PR(BT_DBG, "\t *-Not found special nand flash\n");
+
+	return NULL;
+}
+
+
+void hifmc_spl_ids_register(void)
+{
+	pr_info("Special NAND id table Version %s\n", DRV_VERSION);
+	get_spi_nand_flash_type_hook = hifmc_get_spl_flash_type;
+}
diff --git a/drivers/mtd/nand/raw/Makefile b/drivers/mtd/nand/raw/Makefile
index 2930f5b90..7817ec61d 100644
--- a/drivers/mtd/nand/raw/Makefile
+++ b/drivers/mtd/nand/raw/Makefile
@@ -59,7 +59,7 @@ obj-$(CONFIG_MTD_NAND_MESON)		+= meson_nand.o
 obj-$(CONFIG_MTD_NAND_CADENCE)		+= cadence-nand-controller.o
 obj-$(CONFIG_MTD_NAND_ARASAN)		+= arasan-nand-controller.o
 
-nand-objs := nand_base.o nand_legacy.o nand_bbt.o nand_timings.o nand_ids.o
+nand-objs := nand_base.o nand_bbt.o nand_timings.o nand_ids.o hinfc_gen.o hinfc_spl_ids.o match_table.o
 nand-objs += nand_onfi.o
 nand-objs += nand_jedec.o
 nand-objs += nand_amd.o
diff --git a/drivers/mtd/nand/raw/hinfc_gen.c b/drivers/mtd/nand/raw/hinfc_gen.c
new file mode 100644
index 000000000..127edd6b4
--- /dev/null
+++ b/drivers/mtd/nand/raw/hinfc_gen.c
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/mfd/hisi_fmc.h>
+#include "match_table.h"
+#include "hinfc_gen.h"
+
+struct nand_flash_dev *(*get_spi_nand_flash_type_hook)(struct mtd_info *mtd,
+		unsigned char *id) = NULL;
+
+static struct match_t match_ecc[] = {
+	MATCH_SET_TYPE_DATA(NAND_ECC_NONE, "none"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_0BIT, "none"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_1BIT_512, "1bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_4BIT, "4bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_4BIT_512, "4bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_4BYTE, "4byte/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_8BIT, "4bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_8BIT_512, "8bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_8BYTE, "8byte/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_13BIT, "13bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_16BIT, "8bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_18BIT, "18bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_24BIT, "24bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_27BIT, "27bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_32BIT, "32bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_40BIT, "40bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_41BIT, "41bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_48BIT, "48bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_60BIT, "60bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_72BIT, "72bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_80BIT, "80bit/1k"),
+};
+
+const char *nand_ecc_name(int type)
+{
+	return (char *)match_type_to_data(match_ecc, ARRAY_SIZE(match_ecc),
+					  type, "unknown");
+}
+
+char *get_ecctype_str(enum ecc_type ecctype)
+{
+	static char *ecctype_string[] = {
+		"None", "1bit/512Byte", "4bits/512Byte", "8bits/512Byte",
+		"24bits/1K", "40bits/1K", "unknown", "unknown"
+	};
+	return ecctype_string[(ecctype & 0x07)];
+}
+
+static struct match_type_str page2name[] = {
+	{ NAND_PAGE_512B, "512" },
+	{ NAND_PAGE_2K,   "2K" },
+	{ NAND_PAGE_4K,   "4K" },
+	{ NAND_PAGE_8K,   "8K" },
+	{ NAND_PAGE_16K,  "16K" },
+	{ NAND_PAGE_32K,  "32K" },
+};
+
+const char *nand_page_name(int type)
+{
+	return type2str(page2name, ARRAY_SIZE(page2name), type, "unknown");
+}
+
+char *get_pagesize_str(enum page_type pagetype)
+{
+	static char *pagesize_str[] = {
+		"512", "2K", "4K", "8K", "16K", "unknown",
+		"unknown", "unknown"
+	};
+	return pagesize_str[(pagetype & 0x07)];
+}
+
+static struct match_reg_type page2size[] = {
+	{ _512B, NAND_PAGE_512B },
+	{ _2K, NAND_PAGE_2K },
+	{ _4K, NAND_PAGE_4K },
+	{ _8K, NAND_PAGE_8K },
+	{ _16K, NAND_PAGE_16K },
+	{ _32K, NAND_PAGE_32K },
+};
+
+unsigned int get_pagesize(enum page_type pagetype)
+{
+	unsigned int pagesize[] = {
+		_512B, _2K, _4K, _8K, _16K, 0, 0, 0
+	};
+	return pagesize[(pagetype & 0x07)];
+}
+
+int nandpage_size2type(int size)
+{
+	return reg2type(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+
+int nandpage_type2size(int size)
+{
+	return type2reg(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+
+char *nand_dbgfs_options;
+
+static int __init dbgfs_options_setup(char *s)
+{
+	nand_dbgfs_options = s;
+	return 1;
+}
+__setup("nanddbgfs=", dbgfs_options_setup);
+
+int get_bits(unsigned int n)
+{
+	int loop;
+	int ret = 0;
+
+	if (!n)
+		return 0;
+
+	if (n > 0xFFFF)
+		loop = n > 0xFFFFFF ? 32 : 24;
+	else
+		loop = n > 0xFF ? 16 : 8;
+
+	while (loop-- > 0 && n) {
+		if (n & 1)
+			ret++;
+		n >>= 1;
+	}
+	return ret;
+}
+
+#define et_ecc_none	0x00
+#define et_ecc_4bit	0x02
+#define et_ecc_8bit	0x03
+#define et_ecc_24bit1k	0x04
+#define et_ecc_40bit1k	0x05
+#define et_ecc_64bit1k	0x06
+
+static struct match_reg_type ecc_yaffs_type_t[] = {
+	{et_ecc_none,		NAND_ECC_0BIT},
+	{et_ecc_4bit,		NAND_ECC_8BIT},
+	{et_ecc_8bit,		NAND_ECC_16BIT},
+	{et_ecc_24bit1k,	NAND_ECC_24BIT},
+	{et_ecc_40bit1k,	NAND_ECC_40BIT},
+	{et_ecc_64bit1k,	NAND_ECC_64BIT}
+};
+
+unsigned char match_ecc_type_to_yaffs(unsigned char type)
+{
+	return type2reg(ecc_yaffs_type_t, ARRAY_SIZE(ecc_yaffs_type_t), type,
+			et_ecc_4bit);
+}
+
+static struct match_t page_table[] = {
+	{NAND_PAGE_2K,	PAGE_SIZE_2KB,	"2K"},
+	{NAND_PAGE_4K,	PAGE_SIZE_4KB,	"4K"},
+	{NAND_PAGE_8K,	PAGE_SIZE_8KB,	"8K"},
+	{NAND_PAGE_16K,	PAGE_SIZE_16KB,	"16K"},
+};
+
+unsigned char match_page_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(page_table, ARRAY_SIZE(page_table), reg,
+				 NAND_PAGE_2K);
+}
+
+unsigned char match_page_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(page_table, ARRAY_SIZE(page_table), type,
+				 PAGE_SIZE_2KB);
+}
+
+const char *match_page_type_to_str(unsigned char type)
+{
+	return match_type_to_data(page_table, ARRAY_SIZE(page_table), type,
+				  "unknown");
+}
+
+static struct match_t ecc_table[] = {
+	{NAND_ECC_0BIT,		ECC_TYPE_0BIT,	"none"},
+	{NAND_ECC_8BIT,		ECC_TYPE_8BIT,	"4bit/512"},
+	{NAND_ECC_16BIT,	ECC_TYPE_16BIT,	"8bit/512"},
+	{NAND_ECC_24BIT,	ECC_TYPE_24BIT,	"24bit/1K"},
+	{NAND_ECC_28BIT,	ECC_TYPE_28BIT,	"28bit/1K"},
+	{NAND_ECC_40BIT,	ECC_TYPE_40BIT,	"40bit/1K"},
+	{NAND_ECC_64BIT,	ECC_TYPE_64BIT,	"64bit/1K"},
+};
+
+unsigned char match_ecc_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(ecc_table, ARRAY_SIZE(ecc_table), reg,
+				 NAND_ECC_8BIT);
+}
+
+unsigned char match_ecc_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(ecc_table, ARRAY_SIZE(ecc_table), type,
+				 ECC_TYPE_8BIT);
+}
+
+const char *match_ecc_type_to_str(unsigned char type)
+{
+	return match_type_to_data(ecc_table, ARRAY_SIZE(ecc_table), type,
+				  "unknown");
+}
+
+static struct match_t page_type_size_table[] = {
+	{NAND_PAGE_2K,	_2K,	NULL},
+	{NAND_PAGE_4K,	_4K,	NULL},
+	{NAND_PAGE_8K,	_8K,	NULL},
+	{NAND_PAGE_16K,	_16K,	NULL},
+};
+
+unsigned char match_page_size_to_type(unsigned int size)
+{
+	return match_reg_to_type(page_type_size_table,
+				 ARRAY_SIZE(page_type_size_table), size, NAND_PAGE_2K);
+}
+
+unsigned int match_page_type_to_size(unsigned char type)
+{
+	return match_type_to_reg(page_type_size_table,
+				 ARRAY_SIZE(page_type_size_table), type, _2K);
+}
\ No newline at end of file
diff --git a/drivers/mtd/nand/raw/hinfc_gen.h b/drivers/mtd/nand/raw/hinfc_gen.h
new file mode 100644
index 000000000..673ab8361
--- /dev/null
+++ b/drivers/mtd/nand/raw/hinfc_gen.h
@@ -0,0 +1,281 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __HINFC_GEN_H__
+#define __HINFC_GEN_H__
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/rawnand.h>
+#include <linux/string_helpers.h>
+#include <asm/setup.h>
+#include <linux/module.h>
+
+#define HINFC_VER_300                   (0x300)
+#define HINFC_VER_301                   (0x301)
+#define HINFC_VER_310                   (0x310)
+#define HINFC_VER_504                   (0x504)
+#define HINFC_VER_505                   (0x505)
+#define HINFC_VER_600                   (0x600)
+#define HINFC_VER_610                   (0x610)
+#define HINFC_VER_620                   (0x620)
+
+#define HISNFC_VER_100                  (0x400)
+
+#define NAND_PAGE_512B                   0
+#define NAND_PAGE_1K                     1
+#define NAND_PAGE_2K                     2
+#define NAND_PAGE_4K                     3
+#define NAND_PAGE_8K                     4
+#define NAND_PAGE_16K                    5
+#define NAND_PAGE_32K                    6
+
+#define NAND_ECC_NONE                    0
+#define NAND_ECC_0BIT                    0
+#define NAND_ECC_1BIT                    1
+#define NAND_ECC_1BIT_512                1
+#define NAND_ECC_4BIT                    2
+#define NAND_ECC_4BIT_512                2
+#define NAND_ECC_4BYTE                   2
+#define NAND_ECC_8BIT                    2
+#define NAND_ECC_8BIT_512                3
+#define NAND_ECC_8BYTE                   3
+#define NAND_ECC_13BIT                   4
+#define NAND_ECC_16BIT                   5
+#define NAND_ECC_18BIT                   6
+#define NAND_ECC_24BIT                   7
+#define NAND_ECC_27BIT                   8
+#define NAND_ECC_28BIT                   9
+#define NAND_ECC_32BIT                   10
+#define NAND_ECC_40BIT                   11
+#define NAND_ECC_41BIT                   12
+#define NAND_ECC_42BIT                   13
+#define NAND_ECC_48BIT                   14
+#define NAND_ECC_60BIT                   15
+#define NAND_ECC_64BIT                   16
+#define NAND_ECC_72BIT                   17
+#define NAND_ECC_80BIT                   18
+
+enum ecc_type {
+	et_ecc_none    = 0x00,
+	et_ecc_1bit    = 0x01,
+	et_ecc_4bit    = 0x02,
+	et_ecc_8bit    = 0x03,
+	et_ecc_24bit1k = 0x04,
+	et_ecc_40bit1k = 0x05,
+	et_ecc_64bit1k = 0x06,
+};
+
+enum page_type {
+	pt_pagesize_512   = 0x00,
+	pt_pagesize_2K    = 0x01,
+	pt_pagesize_4K    = 0x02,
+	pt_pagesize_8K    = 0x03,
+	pt_pagesize_16K   = 0x04,
+};
+
+struct nand_config_info {
+	unsigned int pagetype;
+	unsigned int ecctype;
+	unsigned int ecc_strength;
+	unsigned int oobsize;
+	struct mtd_ooblayout_ops *ooblayout_ops;
+};
+
+struct hinfc_host;
+
+struct nand_sync {
+#define SET_NAND_SYNC_TYPE(_mfr, _onfi, _version) \
+	((((_mfr) & 0xFF) << 16) | (((_version) & 0xFF) << 8) \
+	 | ((_onfi) & 0xFF))
+
+#define GET_NAND_SYNC_TYPE_MFR(_type) (((_type) >> 16) & 0xFF)
+#define GET_NAND_SYNC_TYPE_VER(_type) (((_type) >> 8) & 0xFF)
+#define GET_NAND_SYNC_TYPE_INF(_type) ((_type) & 0xFF)
+
+#define NAND_TYPE_ONFI_23_MICRON    \
+	SET_NAND_SYNC_TYPE(NAND_MFR_MICRON, NAND_IS_ONFI, 0x23)
+#define NAND_TYPE_ONFI_30_MICRON    \
+	SET_NAND_SYNC_TYPE(NAND_MFR_MICRON, NAND_IS_ONFI, 0x30)
+#define NAND_TYPE_TOGGLE_TOSHIBA    \
+	SET_NAND_SYNC_TYPE(NAND_MFR_TOSHIBA, 0, 0)
+#define NAND_TYPE_TOGGLE_SAMSUNG    \
+	SET_NAND_SYNC_TYPE(NAND_MFR_SAMSUNG, 0, 0)
+
+#define NAND_TYPE_TOGGLE_10         SET_NAND_SYNC_TYPE(0, 0, 0x10)
+#define NAND_TYPE_ONFI_30           SET_NAND_SYNC_TYPE(0, NAND_IS_ONFI, 0x30)
+#define NAND_TYPE_ONFI_23           SET_NAND_SYNC_TYPE(0, NAND_IS_ONFI, 0x23)
+
+	int type;
+	int (*enable)(struct nand_chip *chip);
+	int (*disable)(struct nand_chip *chip);
+};
+
+struct read_retry_t {
+	int type;
+	int count;
+	int (*set_rr_param)(struct hinfc_host *host, int param);
+	int (*get_rr_param)(struct hinfc_host *host);
+	int (*reset_rr_param)(struct hinfc_host *host);
+};
+
+struct ecc_info_t {
+	int pagesize;
+	int ecctype;
+	int threshold;
+	int section;
+	void (*dump)(struct hinfc_host *host, unsigned char ecc[],
+		     int *max_bitsflag);
+};
+
+struct nand_dev_t {
+	struct nand_flash_dev flash_dev;
+
+	char *start_type;
+	unsigned char ids[8];
+	int oobsize;
+	int ecctype;
+
+	/* (Controller) support ecc/page detect, driver don't need detect */
+#define NANDC_HW_AUTO                         0x01
+	/* (Controller) support ecc/page detect,
+	 * and current ecc/page config finish */
+#define NANDC_CONFIG_DONE                     0x02
+	/* (Controller) is sync, default is async */
+#define NANDC_IS_SYNC_BOOT                    0x04
+
+/* (NAND) need randomizer */
+#define NAND_RANDOMIZER                       0x10
+/* (NAND) is ONFI interface, combine with sync/async symble */
+#define NAND_IS_ONFI                          0x20
+/* (NAND) support async and sync, such micron onfi, toshiba toggle 1.0 */
+#define NAND_MODE_SYNC_ASYNC                  0x40
+/* (NAND) support only sync, such samsung sync. */
+#define NAND_MODE_ONLY_SYNC                   0x80
+
+#define NAND_CHIP_MICRON   (NAND_MODE_SYNC_ASYNC | NAND_IS_ONFI)
+/* This NAND is async, or sync/async, default is async mode,
+ * toggle1.0 interface */
+#define NAND_CHIP_TOSHIBA_TOGGLE_10  (NAND_MODE_SYNC_ASYNC)
+/* This NAND is only sync mode, toggle2.0 interface */
+#define NAND_CHIP_TOSHIBA_TOGGLE_20   (NAND_MODE_ONLY_SYNC)
+/* This NAND is only sync mode */
+#define NAND_CHIP_SAMSUNG  (NAND_MODE_ONLY_SYNC)
+
+	unsigned int flags;
+
+#define NAND_RR_NONE                   0x00
+#define NAND_RR_HYNIX_BG_BDIE          0x10
+#define NAND_RR_HYNIX_BG_CDIE          0x11
+#define NAND_RR_HYNIX_CG_ADIE          0x12
+#define NAND_RR_MICRON                 0x20
+#define NAND_RR_SAMSUNG                0x30
+#define NAND_RR_TOSHIBA_24nm           0x40
+#define NAND_RR_TOSHIBA_19nm           0x41
+	int read_retry_type;
+};
+
+
+#define IS_NANDC_HW_AUTO(_host)         ((_host)->flags & NANDC_HW_AUTO)
+#define IS_NANDC_CONFIG_DONE(_host)     ((_host)->flags & NANDC_CONFIG_DONE)
+#define IS_NANDC_SYNC_BOOT(_host)       ((_host)->flags & NANDC_IS_SYNC_BOOT)
+
+#define IS_NAND_RANDOM(_dev)         ((_dev)->flags & NAND_RANDOMIZER)
+#define IS_NAND_ONLY_SYNC(_dev)      ((_dev)->flags & NAND_MODE_ONLY_SYNC)
+#define IS_NAND_SYNC_ASYNC(_dev)     ((_dev)->flags & NAND_MODE_SYNC_ASYNC)
+#define IS_NAND_ONFI(_dev)           ((_dev)->flags & NAND_IS_ONFI)
+
+#define ERSTR_HARDWARE  "Hardware configuration error. "
+#define ERSTR_DRIVER    "Driver does not support. "
+
+#define ENABLE                    1
+#define DISABLE                   0
+
+char *get_ecctype_str(enum ecc_type ecctype);
+
+char *get_pagesize_str(enum page_type pagetype);
+
+unsigned int get_pagesize(enum page_type pagetype);
+
+const char *nand_ecc_name(int type);
+
+const char *nand_page_name(int type);
+
+int nandpage_size2type(int size);
+
+int nandpage_type2size(int size);
+
+extern int (*hinfc_param_adjust)(struct mtd_info *mtd, struct nand_chip *chip,
+				 struct nand_dev_t *nand_dev);
+
+extern struct nand_flash_dev *(*nand_get_flash_type_func)(struct mtd_info *mtd,
+							  struct nand_chip *chip,
+							  struct nand_dev_t *spinand_dev_t);
+
+extern struct nand_flash_dev *(*get_spi_nand_flash_type_hook)
+(struct mtd_info *mtd, unsigned char *id);
+
+extern int (*hinfc_param_adjust)(struct mtd_info *,
+				 struct nand_chip *, struct nand_dev_t *);
+
+struct nand_flash_dev *hinfc_get_flash_type(struct mtd_info *mtd,
+					    struct nand_chip *chip,
+					    u8 *id_data, int *busw);
+
+extern struct nand_flash_dev *(*get_spi_nand_flash_type_hook)
+(struct mtd_info *mtd, unsigned char *id);
+
+void hinfc_nand_param_adjust(struct mtd_info *mtd, struct nand_chip *chip);
+
+void hinfc_show_info(struct mtd_info *mtd, const char *vendor, char *chipname);
+
+void hinfc_show_chipsize(struct nand_chip *chip);
+
+int get_bits(unsigned int n);
+
+#define hinfc_pr_msg(_fmt, arg...) printk(_fmt, ##arg)
+
+#define hinfc_pr_bug(fmt, args...) do { \
+	printk("%s(%d): bug " fmt, __FILE__, __LINE__, ##args); \
+	while (1) \
+		; \
+} while (0)
+
+#define PR_MSG(_fmt, arg...) \
+	    printk(_fmt, ##arg)
+
+extern char *nand_dbgfs_options;
+
+extern unsigned char match_page_reg_to_type(unsigned char reg);
+
+extern unsigned char match_page_type_to_reg(unsigned char type);
+
+extern const char *match_page_type_to_str(unsigned char type);
+
+extern unsigned char match_ecc_reg_to_type(unsigned char reg);
+
+extern unsigned char match_ecc_type_to_reg(unsigned char type);
+
+extern const char *match_ecc_type_to_str(unsigned char type);
+
+extern unsigned char match_page_size_to_type(unsigned int size);
+
+extern unsigned int match_page_type_to_size(unsigned char type);
+
+const char *nand_ecc_name(int type);
+
+#endif /* End of __HINFC_GEN_H__ */
\ No newline at end of file
diff --git a/drivers/mtd/nand/raw/hinfc_spl_ids.c b/drivers/mtd/nand/raw/hinfc_spl_ids.c
new file mode 100644
index 000000000..0fd7db974
--- /dev/null
+++ b/drivers/mtd/nand/raw/hinfc_spl_ids.c
@@ -0,0 +1,970 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mfd/hisi_fmc.h>
+#include "hinfc_gen.h"
+
+struct nand_flash_special_dev {
+	unsigned char id[8];
+	int length;             /* length of id. */
+	unsigned long long chipsize;
+	struct nand_flash_dev *(*probe)(struct nand_dev_t *nand_dev);
+	char *name;
+
+	unsigned long pagesize;
+	unsigned long erasesize;
+	unsigned long oobsize;
+	unsigned long options;
+	unsigned int read_retry_type;
+
+#define BBP_LAST_PAGE                    0x01
+#define BBP_FIRST_PAGE                   0x02
+	unsigned int badblock_pos;
+	unsigned int flags;
+};
+
+
+/*                    this is nand probe function.                           */
+
+
+static struct nand_flash_dev *hynix_probe_v02(
+	struct nand_dev_t *nand_dev)
+{
+	unsigned char *id = nand_dev->ids;
+	struct nand_flash_dev *type = &nand_dev->flash_dev;
+
+	int pagesizes[]   = {SZ_2K, SZ_4K, SZ_8K, 0};
+	int oobsizes[]    = {128, 224, 448, 0, 0, 0, 0, 0};
+	int blocksizes[]  = {SZ_128K, SZ_256K, SZ_512K,
+			     (SZ_256K + SZ_512K), SZ_1M, SZ_2M, 0, 0
+			    };
+
+	int blocktype = (((id[3] >> 5) & 0x04) | ((id[3] >> 4) & 0x03));
+	int oobtype   = (((id[3] >> 2) & 0x03) | ((id[3] >> 4) & 0x04));
+
+	type->options   = 0;
+	type->pagesize  = pagesizes[(id[3] & 0x03)];
+	type->erasesize = blocksizes[blocktype];
+	nand_dev->oobsize = oobsizes[oobtype];
+
+	return type;
+}
+
+
+static struct nand_flash_dev *samsung_probe_v02(
+	struct nand_dev_t *nand_dev)
+{
+	unsigned char *id = nand_dev->ids;
+	struct nand_flash_dev *type = &nand_dev->flash_dev;
+
+	int pagesizes[]   = {SZ_2K, SZ_4K, SZ_8K, 0};
+	int oobsizes[]    = {0, 128, 218, 400, 436, 0, 0, 0};
+	int blocksizes[]  = {SZ_128K, SZ_256K, SZ_512K, SZ_1M, 0, 0, 0, 0};
+
+	int blocktype = (((id[3] >> 5) & 0x04) | ((id[3] >> 4) & 0x03));
+	int oobtype   = (((id[3] >> 4) & 0x04) | ((id[3] >> 2) & 0x03));
+
+	type->options   = 0;
+	type->pagesize  = pagesizes[(id[3] & 0x03)];
+	type->erasesize = blocksizes[blocktype];
+	nand_dev->oobsize = oobsizes[oobtype];
+
+	return type;
+}
+
+
+#define DRV_VERSION     "1.38"
+
+
+/*
+ * samsung:  27nm need randomizer, 21nm need read retry;
+ * micron:   25nm need read retry, datasheet will explain read retry.
+ * toshaba   32nm need randomizer, 24nm need read retry.
+ * hynix:    2xnm need read retry.
+ *
+ *		The special nand flash ID table version 1.37
+ *
+ * manufactory  |  type  |       name 	     |   ecc_type  | version_tag
+ * Micron		|  MLC	 |  MT29F64G08CBABA  |   40bit/1k  |  1.36
+ * Micron		|  MLC	 |  MT29F32G08CBADA  |   40bit/1k  |
+ * Micron		|  SLC	 |  MT29F8G08ABxBA   |   4bit/512  |
+ * Micron		|  MLC	 |  MT29F16G08CBABx  |   12bit/512 |
+ * Micron		|  MLC	 |  MT29F16G08CBACA  |   24bit/1k  |
+ * Micron		|  MLC	 |  MT29F32G08CBACA  |   24bit/1k  |
+ * Micron		|  MLC	 |  MT29F64G08CxxAA  |   24bit/1k  |
+ * Micron		|  MLC	 |  MT29F256G08CJAAA |   24bit/1k  |   2CE
+ * Micron		|  MLC	 |  MT29F256G08CMCBB |   24bit/1k  |
+ * Micron		|  SLC	 |  MT29F8G08ABACA   |   8bit/512  |
+ * Micron		|  SLC	 |  MT29F4G08ABAEA   |   8bit/512  |
+ * Micron		|  SLC	 |  MT29F2G08ABAFA   |   8bit/512  |
+ * Micron		|  SLC	 |  MT29F16G08ABACA  |   8bit/512  |
+ * Toshiba		|  MLC   |  TC58NVG4D2FTA00  |   24bit/1k  |
+ * Toshiba		|  MLC   |  TH58NVG6D2FTA20  |   24bit/1k  |   2CE
+ * Toshiba		|  MLC   |  TC58NVG5D2HTA00  |   40bit/1k  |
+ * Toshiba		|  MLC   |  TC58NVG6D2GTA00  |   40bit/1k  |
+ * Toshiba		|  MLC   |  TC58NVG6DCJTA00  |			   |
+ * Toshiba		|  MLC   |  TC58TEG5DCJTA00  |			   |
+ * Toshiba		|  SLC   |  TC58NVG0S3HTA00  |   8bit/512  |
+ * Toshiba		|  SLC   |  TC58NVG1S3HTA00  |   8bit/512  |
+ * Toshiba		|  SLC   |  TC58NVG1S3ETA00  |   4bit/512  |
+ * Toshiba		|  SLC   |  TC58NVG3S0FTA00  |   4bit/512  |
+ * Toshiba		|  SLC   |  TC58NVG2S0FTA00  |   4bit/512  |
+ * Toshiba		|  SLC   |  TH58NVG2S3HTA00  |   4bit/512  |
+ * Toshiba		|  TLC   |  TC58NVG5T2JTA00  |   60bit/1k  |
+ * Toshiba		|  TLC   |  TC58TEG5DCKTAx0  |   60bit/1k  |
+ * Toshiba		|  MLC   |  Tx58TEGxDDKTAx0  |			   |
+ * Samsung		|  MLC   |  K9LB(HC/PD/MD)G08U0(1)D  |   8bit/512B  |
+ * Samsung		|  MLC   |  K9GAG08U0E	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9LBG08U0E	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9G8G08U0C	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9GAG08U0F	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9LBG08U0M	     |             |
+ * Samsung		|  MLC   |  K9GBG08U0A	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9GBG08U0B	     |   40bit/1KB |
+ * Hynix		|  MLC   |  H27UAG8T2A	     |			   |
+ * Hynix		|  MLC   |  H27UAG8T2B	     |			   |
+ * Hynix		|  MLC   |  H27UBG8T2A	     |			   |
+ * Hynix		|  MLC   |  H27UBG8T2BTR	 |	 24bit/1KB |
+ * Hynix		|  MLC   |  H27UCG8T2A		 |	 40bit/1KB |
+ * Hynix		|  MLC   |  H27UBG8T2C		 |	 40bit/1KB |
+ * MISC			|  MLC   |  P1UAGA30AT-GCA	 |	 8bit/512  |
+ * MISC			|  MLC   |  PSU8GA30AT-GIA/ASU8GA30IT-G30CA	 |	 4bit/512  |
+ * MISC			|  SLC   |  PSU2GA30AT   	 |	 1bit/512  |   1.36
+ * Toshiba		|  SLC   |  TC58NVG2S0HTA00  |	 24bit/1K  |   1.37
+ * Toshiba		|  SLC   |  TC58NVG3S0HTA00  |   24bit/1K  |   1.37
+ * Micron		|  SLC	 |  MT29F2G08ABAEA   |   4bit/512 |
+ * Spansion		|  SLC	 | S34ML02G200TFI000	 | 24bit/1K |
+ * Spansion		|  SLC	 | S34ML04G200TFI000	 | 24bit/1K |  1.38
+ *
+ */
+
+static struct nand_flash_special_dev nand_flash_special_dev[] = {
+
+/****************************** Spansion *******************************/
+
+	{ /* SLC S34ML02G200TFI000 */
+		.name      = "S34ML02G200TFI000",
+		.id        = {0x01, 0xDA, 0x90, 0x95, 0x46, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	{ /* SLC S34ML04G200TFI000 */
+		.name      = "S34ML04G200TFI000",
+		.id        = {0x01, 0xDC, 0x90, 0x95, 0x56, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _512M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	/****************************** Micron *******************************/
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F64G08CBABA",
+		.id        = {0x2C, 0x64, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_MICRON,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = NAND_RANDOMIZER | NAND_CHIP_MICRON,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F32G08CBADA",
+		.id        = {0x2C, 0x44, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_MICRON,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* SLC 4bit/512 */
+		.name      = "MT29F8G08ABxBA",
+		.id        = {0x2C, 0x38, 0x00, 0x26, 0x85, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_512K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 12bit/512 */
+		.name      = "MT29F16G08CBABx",
+		.id        = {0x2C, 0x48, 0x04, 0x46, 0x85, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F16G08CBACA",
+		.id        = {0x2C, 0x48, 0x04, 0x4A, 0xA5, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F32G08CBACA",
+		.id        = {0x2C, 0x68, 0x04, 0x4A, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F64G08CxxAA",
+		.id        = {0x2C, 0x88, 0x04, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k 2CE */
+		.name      = "MT29F256G08CJAAA",
+		.id        = {0x2C, 0xA8, 0x05, 0xCB, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _16G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F256G08CMCBB",
+		.id        = {0x2C, 0x64, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F8G08ABACA",
+		.id        = {0x2C, 0xD3, 0x90, 0xA6, 0x64, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F4G08ABAEA",
+		.id        = {0x2C, 0xDC, 0x90, 0xA6, 0x54, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_512M,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F2G08ABAFA",
+		.id        = {0x2C, 0xDA, 0x90, 0x95, 0x04, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{ /* SLC MT29F2G08ABAEA */
+		.name      = "MT29F2G08ABAEA",
+		.id        = {0x2C, 0xDA, 0x90, 0x95, 0x06, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F16G08ABACA",
+		.id        = {0x2C, 0x48, 0x00, 0x26, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_512K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+/****************************** Toshaba *******************************/
+
+	{       /* MLC 24bit/1k 32nm */
+		.name      = "TC58NVG4D2FTA00",
+		.id        = {0x98, 0xD5, 0x94, 0x32, 0x76, 0x55, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1k 32nm 2CE */
+		.name      = "TH58NVG6D2FTA20",
+		.id        = {0x98, 0xD7, 0x94, 0x32, 0x76, 0x55, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 40bit/1k 24nm */
+		.name      = "TC58NVG5D2HTA00 24nm",
+		.id        = {0x98, 0xD7, 0x94, 0x32, 0x76, 0x56, 0x08, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{       /* MLC 40bit/1k */
+		.name      = "TC58NVG6D2GTA00",
+		.id        = {0x98, 0xDE, 0x94, 0x82, 0x76, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 19nm */
+		.name      = "TC58NVG6DCJTA00 19nm",
+		.id        = {0x98, 0xDE, 0x84, 0x93, 0x72, 0x57, 0x08, 0x04},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_16K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{       /* MLC 19nm */
+		.name      = "TC58TEG5DCJTA00 19nm",
+		.id        = {0x98, 0xD7, 0x84, 0x93, 0x72, 0x57, 0x08, 0x04},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_16K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER | NAND_CHIP_TOSHIBA_TOGGLE_10,
+	},
+	{       /* SLC 8bit/512 */
+		.name      = "TC58NVG0S3HTA00",
+		.id        = {0x98, 0xF1, 0x80, 0x15, 0x72, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_128M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		/*
+		 * Datasheet: read one column of any page in each block. If the
+		 * data of the column is 00 (Hex), define the block as a bad
+		 * block.
+		 */
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 8bit/512 */
+		.name      = "TC58NVG1S3HTA00",
+		.id        = {0x98, 0xDA, 0x90, 0x15, 0x76, 0x16, 0x08, 0x00},
+		.length    = 7,
+		.chipsize  = SZ_256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG1S3ETA00",
+		.id        = {0x98, 0xDA, 0x90, 0x15, 0x76, 0x14, 0x03, 0x00},
+		.length    = 7,
+		.chipsize  = SZ_256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG3S0FTA00",
+		.id        = {0x98, 0xD3, 0x90, 0x26, 0x76, 0x15, 0x02, 0x08},
+		.length    = 8,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 232,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG3S0HTA00",
+		.id        = {0x98, 0xD3, 0x91, 0x26, 0x76, 0x16, 0x08, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 256,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 24bit/1k */
+		.name      = "TC58NVG2S0HTA00",
+		.id        = {0x98, 0xDC, 0x90, 0x26, 0x76, 0x16, 0x08, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_512M,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 256,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG2S0FTA00",
+		.id        = {0x98, 0xDC, 0x90, 0x26, 0x76, 0x15, 0x01, 0x08},
+		.length    = 8,
+		.chipsize  = SZ_512M,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TH58NVG2S3HTA00",
+		.id        = {0x98, 0xDC, 0x91, 0x15, 0x76},
+		.length    = 5,
+		.chipsize  = SZ_512M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* TLC 60bit/1k 19nm */
+		.name      = "TC58NVG5T2JTA00 19nm TLC",
+		.id        = {0x98, 0xD7, 0x98, 0x92, 0x72, 0x57, 0x08, 0x10},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1024,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{ /* TLC 60bit/1k 19nm */
+		.name	   = "TC58TEG5DCKTAx0 19nm MLC",
+		/* datasheet says 6 ids id data, but really has 8 ids. */
+		.id	   = {0x98, 0xD7, 0x84, 0x93, 0x72, 0x50, 0x08, 0x04},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe	   = NULL,
+		.pagesize  = SZ_16K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_19nm,
+		.badblock_pos	 = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{
+		.name	   = "Tx58TEGxDDKTAx0 19nm MLC",
+		.id	   = {0x98, 0xDE, 0x94, 0x93, 0x76, 0x50},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe	   = NULL,
+		.pagesize  = SZ_16K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_19nm,
+		.badblock_pos	 = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+/******************************* Samsung ******************************/
+	{       /* MLC 8bit/512B */
+		.name     = "K9LB(HC/PD/MD)G08U0(1)D",
+		.id       = {0xEC, 0xD7, 0xD5, 0x29, 0x38, 0x41, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name      = "K9GAG08U0E",
+		.id        = {0xEC, 0xD5, 0x84, 0x72, 0x50, 0x42, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = SZ_2G,
+		.probe     = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name     = "K9LBG08U0E",
+		.id       = {0xEC, 0xD7, 0xC5, 0x72, 0x54, 0x42, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name     = "K9G8G08U0C",
+		.id       = {0xEC, 0xD3, 0x84, 0x72, 0x50, 0x42, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = SZ_1G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "K9GAG08U0F",
+		.id        = {0xEC, 0xD5, 0x94, 0x76, 0x54, 0x43, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 512,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC */
+		.name      = "K9LBG08U0M",
+		.id        = {0xEC, 0xD7, 0x55, 0xB6, 0x78, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_512K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "K9GBG08U0A 20nm",
+		.id        = {0xEC, 0xD7, 0x94, 0x7A, 0x54, 0x43, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_SAMSUNG,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "K9GBG08U0B",
+		.id        = {0xEC, 0xD7, 0x94, 0x7E, 0x64, 0x44, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 1024,
+		.options   = 0,
+		.read_retry_type = NAND_RR_SAMSUNG,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+
+/*********************************** Hynix ****************************/
+	{       /* MLC */
+		.name     = "H27UAG8T2A",
+		.id       = { 0xAD, 0xD5, 0x94, 0x25, 0x44, 0x41, },
+		.length   = 6,
+		.chipsize = SZ_2G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC */
+		.name     = "H27UAG8T2B",
+		.id       = { 0xAD, 0xD5, 0x94, 0x9A, 0x74, 0x42, },
+		.length   = 6,
+		.chipsize = SZ_2G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC */
+		.name     = "H27UBG8T2A",
+		.id       = { 0xAD, 0xD7, 0x94, 0x9A, 0x74, 0x42, },
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{
+		.name      = "H27UBG8T2BTR 26nm",
+		.id        = { 0xAD, 0xD7, 0x94, 0xDA, 0x74, 0xC3, },
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_BG_BDIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "H27UCG8T2A",
+		.id        = { 0xAD, 0xDE, 0x94, 0xDA, 0x74, 0xC4, },
+		.length    = 6,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_CG_ADIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "H27UBG8T2C",
+		.id        = { 0xAD, 0xD7, 0x94, 0x91, 0x60, 0x44, },
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_BG_CDIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+
+/********************** MISC ******************************************/
+	{        /* MLC 8bit/512 */
+		.name      = "P1UAGA30AT-GCA",
+		.id        = { 0xC8, 0xD5, 0x14, 0x29, 0x34, 0x01, },
+		.length    = 6,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_512K,
+		.oobsize   = 218,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 4bit/512 */
+		/*
+		 * PowerFlash ASU8GA30IT-G30CA ID and MIRA PSU8GA30AT-GIA ID are
+		 * the same ID
+		 */
+		.name      = "PSU8GA30AT-GIA/ASU8GA30IT-G30CA",
+		.id        = { 0xC8, 0xD3, 0x90, 0x19, 0x34, 0x01, },
+		.length    = 6,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 218,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 1bit/512 */
+		.name      = "PSU2GA30AT",
+		.id        = { 0x7F, 0x7F, 0x7F, 0x7F, 0xC8, 0xDA, 0x00, 0x15, },
+		.length    = 8,
+		.chipsize  = SZ_256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{{0}, 0, 0, 0, 0, 0, 0, 0, 0},
+};
+
+#define NUM_OF_SPECIAL_DEVICE  \
+	(sizeof(nand_flash_special_dev) / sizeof(struct nand_flash_special_dev))
+
+int (*hinfc_param_adjust)(struct mtd_info *, struct nand_chip *,
+			  struct nand_dev_t *) = NULL;
+
+static struct nand_dev_t __nand_dev;
+
+
+static struct nand_flash_dev *hinfc_nand_probe(struct mtd_info *mtd,
+					       struct nand_chip *chip,
+					       struct nand_dev_t *nand_dev)
+{
+	struct nand_flash_special_dev *spl_dev = NULL;
+	unsigned char *byte = nand_dev->ids;
+	struct nand_flash_dev *type = &nand_dev->flash_dev;
+
+	hinfc_pr_msg("Nand ID: 0x%02X 0x%02X 0x%02X 0x%02X",
+		     byte[0], byte[1], byte[2], byte[3]);
+	hinfc_pr_msg(" 0x%02X 0x%02X 0x%02X 0x%02X\n",
+		     byte[4], byte[5], byte[6], byte[7]);
+
+	for (spl_dev = nand_flash_special_dev; spl_dev->length; spl_dev++) {
+		if (memcmp(byte, spl_dev->id, spl_dev->length))
+			continue;
+
+		hinfc_pr_msg("The Special NAND id table Version: %s\n", DRV_VERSION);
+
+		if (spl_dev->probe) {
+			type = spl_dev->probe(nand_dev);
+		} else {
+			type->options   = spl_dev->options;
+			type->pagesize  = spl_dev->pagesize;
+			type->erasesize = spl_dev->erasesize;
+			nand_dev->oobsize = spl_dev->oobsize;
+		}
+
+		nand_dev->read_retry_type = spl_dev->read_retry_type;
+		nand_dev->flags = spl_dev->flags;
+
+		type->id[1] = byte[1];
+		type->chipsize = (unsigned long)(spl_dev->chipsize >> 20);
+		type->name = spl_dev->name;
+		return type;
+	}
+	nand_dev->read_retry_type = NAND_RR_NONE;
+
+	return NULL;
+}
+
+
+struct nand_flash_dev *hinfc_get_flash_type(struct mtd_info *mtd,
+					    struct nand_chip *chip,
+					    u8 *id_data, int *busw)
+{
+	struct nand_flash_dev *type = NULL;
+	struct nand_dev_t *nand_dev = &__nand_dev;
+
+	memset(nand_dev, 0, sizeof(struct nand_dev_t));
+	memcpy(nand_dev->ids, id_data, 8);
+
+	if (!hinfc_nand_probe(mtd, chip, nand_dev))
+		return NULL;
+
+	type = &nand_dev->flash_dev;
+
+	if (!mtd->name)
+		mtd->name = type->name;
+
+	chip->chipsize = (uint64_t)type->chipsize << 20;
+	mtd->erasesize = type->erasesize;
+	mtd->writesize = type->pagesize;
+	mtd->oobsize   = nand_dev->oobsize;
+	*busw = (type->options & NAND_BUSWIDTH_16);
+
+	return type;
+}
+
+
+void hinfc_nand_param_adjust(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct nand_dev_t *nand_dev = &__nand_dev;
+
+	if (!nand_dev->oobsize)
+		nand_dev->oobsize = mtd->oobsize;
+
+	if (hinfc_param_adjust)
+		hinfc_param_adjust(mtd, chip, nand_dev);
+}
+
+
+void hinfc_show_info(struct mtd_info *mtd, const char *vendor, char *chipname)
+{
+	struct nand_dev_t *nand_dev = &__nand_dev;
+
+	if (IS_NAND_RANDOM(nand_dev))
+		hinfc_pr_msg("Randomizer \n");
+
+	if (nand_dev->read_retry_type != NAND_RR_NONE)
+		hinfc_pr_msg("Read-Retry \n");
+
+	if (nand_dev->start_type)
+		hinfc_pr_msg("Nand(%s): ", nand_dev->start_type);
+	else
+		hinfc_pr_msg("Nand: ");
+
+	hinfc_pr_msg("OOB:%dB ", nand_dev->oobsize);
+	hinfc_pr_msg("ECC:%s ", nand_ecc_name(nand_dev->ecctype));
+}
+
+
+void hinfc_show_chipsize(struct nand_chip *chip)
+{
+}
diff --git a/drivers/mtd/nand/raw/internals.h b/drivers/mtd/nand/raw/internals.h
index 012876e14..be6bb9c30 100644
--- a/drivers/mtd/nand/raw/internals.h
+++ b/drivers/mtd/nand/raw/internals.h
@@ -17,8 +17,12 @@
  * NAND Flash Manufacturer ID Codes
  */
 #define NAND_MFR_AMD		0x01
-#define NAND_MFR_ATO		0x9b
 #define NAND_MFR_EON		0x92
+#define NAND_MFR_WINBOND	0xef
+#define NAND_MFR_ATO		0x9b
+#define NAND_MFR_MXIC		0xc2
+#define NAND_MFR_ALL_FLASH	0xc1
+#define NAND_MFR_PARAGON	0xa1
 #define NAND_MFR_ESMT		0xc8
 #define NAND_MFR_FUJITSU	0x04
 #define NAND_MFR_HYNIX		0xad
@@ -32,7 +36,10 @@
 #define NAND_MFR_STMICRO	0x20
 /* Kioxia is new name of Toshiba memory. */
 #define NAND_MFR_TOSHIBA	0x98
-#define NAND_MFR_WINBOND	0xef
+#define NAND_MFR_GD_ESMT	0xc8
+#define NAND_MFR_HEYANGTEK	0xc9
+#define NAND_MFR_DOSILICON	0xe5
+#define NAND_MFR_FIDELIX	0xf8
 
 /**
  * struct nand_manufacturer_ops - NAND Manufacturer operations
diff --git a/drivers/mtd/nand/raw/match_table.c b/drivers/mtd/nand/raw/match_table.c
new file mode 100644
index 000000000..6bad75f97
--- /dev/null
+++ b/drivers/mtd/nand/raw/match_table.c
@@ -0,0 +1,102 @@
+/******************************************************************************
+ *    COPYRIGHT (C) Hisilicon.2013
+ *    All rights reserved.
+ * ***
+ *    Create by Hisilicon 2013-08-15
+ *
+ *****************************************************************************/
+
+#include <linux/string.h>
+#include "match_table.h"
+
+int reg2type(struct match_reg_type *table, int length, int reg, int def)
+{
+	while (length-- > 0) {
+		if (table->reg == reg) {
+			return table->type;
+		}
+		table++;
+	}
+	return def;
+}
+
+int type2reg(struct match_reg_type *table, int length, int type, int def)
+{
+	while (length-- > 0) {
+		if (table->type == type) {
+			return table->reg;
+		}
+		table++;
+	}
+	return def;
+}
+
+int str2type(struct match_type_str *table, int length, const char *str,
+	     int size, int def)
+{
+	while (length-- > 0) {
+		if (!strncmp(table->str, str, size)) {
+			return table->type;
+		}
+		table++;
+	}
+	return def;
+}
+
+const char *type2str(struct match_type_str *table, int length, int type,
+		     const char *def)
+{
+	while (length-- > 0) {
+		if (table->type == type) {
+			return table->str;
+		}
+		table++;
+	}
+	return def;
+}
+
+int match_reg_to_type(struct match_t *table, int nr_table, int reg, int def)
+{
+	while (nr_table-- > 0) {
+		if (table->reg == reg) {
+			return table->type;
+		}
+		table++;
+	}
+	return def;
+}
+
+int match_type_to_reg(struct match_t *table, int nr_table, int type, int def)
+{
+	while (nr_table-- > 0) {
+		if (table->type == type) {
+			return table->reg;
+		}
+		table++;
+	}
+	return def;
+}
+
+int match_data_to_type(struct match_t *table, int nr_table, const char *data,
+		       int size, int def)
+{
+	while (nr_table-- > 0) {
+		if (!memcmp(table->data, data, size)) {
+			return table->type;
+		}
+		table++;
+	}
+	return def;
+}
+
+void *match_type_to_data(struct match_t *table, int nr_table, int type,
+			 void *def)
+{
+	while (nr_table-- > 0) {
+		if (table->type == type) {
+			return table->data;
+		}
+		table++;
+	}
+	return def;
+}
diff --git a/drivers/mtd/nand/raw/match_table.h b/drivers/mtd/nand/raw/match_table.h
new file mode 100644
index 000000000..9c5f0af09
--- /dev/null
+++ b/drivers/mtd/nand/raw/match_table.h
@@ -0,0 +1,51 @@
+/******************************************************************************
+ *    COPYRIGHT (C) Hisilicon 2013
+ *    All rights reserved.
+ * ***
+ *    Create by Hisilicon 2013-08-15
+ *
+ *****************************************************************************/
+#ifndef __MATCH_TABLE_H__
+#define __MATCH_TABLE_H__
+
+struct match_reg_type {
+	int reg;
+	int type;
+};
+
+struct match_type_str {
+	int type;
+	const char *str;
+};
+
+struct match_t {
+	int type;
+	int reg;
+	void *data;
+};
+
+#define MATCH_SET_TYPE_REG(_type, _reg)   {(_type), (_reg), (void *)0}
+#define MATCH_SET_TYPE_DATA(_type, _data) {(_type), 0, (void *)(_data)}
+#define MATCH_SET(_type, _reg, _data)     {(_type), (_reg), (void *)(_data)}
+
+int reg2type(struct match_reg_type *table, int length, int reg, int def);
+
+int type2reg(struct match_reg_type *table, int length, int type, int def);
+
+int str2type(struct match_type_str *table, int length, const char *str,
+	     int size, int def);
+
+const char *type2str(struct match_type_str *table, int length, int type,
+		     const char *def);
+
+int match_reg_to_type(struct match_t *table, int nr_table, int reg, int def);
+
+int match_type_to_reg(struct match_t *table, int nr_table, int type, int def);
+
+int match_data_to_type(struct match_t *table, int nr_table, const char *data,
+		       int size, int def);
+
+void *match_type_to_data(struct match_t *table, int nr_table, int type,
+			 void *def);
+
+#endif /* End of __MATCH_TABLE_H__ */
diff --git a/drivers/mtd/nand/raw/nand_base.c b/drivers/mtd/nand/raw/nand_base.c
index 1f0d542d5..e2f2d86e3 100644
--- a/drivers/mtd/nand/raw/nand_base.c
+++ b/drivers/mtd/nand/raw/nand_base.c
@@ -44,6 +44,7 @@
 #include <linux/of.h>
 #include <linux/gpio/consumer.h>
 
+#include "hinfc_gen.h"
 #include "internals.h"
 
 static int nand_pairing_dist3_get_info(struct mtd_info *mtd, int page,
@@ -3968,6 +3969,10 @@ static int nand_do_write_ops(struct nand_chip *chip, loff_t to,
 	int ret;
 	int oob_required = oob ? 1 : 0;
 
+#ifdef CONFIG_ARCH_HISI_BVT
+    oob_required = 1;
+#endif
+
 	ops->retlen = 0;
 	if (!writelen)
 		return 0;
@@ -4695,7 +4700,8 @@ static int nand_detect(struct nand_chip *chip, struct nand_flash_dev *type)
 	const struct nand_manufacturer_desc *manufacturer_desc;
 	struct mtd_info *mtd = nand_to_mtd(chip);
 	struct nand_memory_organization *memorg;
-	int busw, ret;
+	int busw = 0;
+	int ret = 0;
 	u8 *id_data = chip->id.data;
 	u8 maf_id, dev_id;
 	u64 targetsize;
@@ -4752,6 +4758,30 @@ static int nand_detect(struct nand_chip *chip, struct nand_flash_dev *type)
 	manufacturer_desc = nand_get_manufacturer_desc(maf_id);
 	chip->manufacturer.desc = manufacturer_desc;
 
+#ifdef CONFIG_ARCH_HISI_BVT
+
+#ifndef CONFIG_MTD_SPI_NAND_HISI_BVT
+	/* Parallel Nand Flash */
+
+	/* The 3rd id byte holds MLC / multichip data */
+	chip->bits_per_cell = nand_get_bits_per_cell(id_data[2]);
+#endif
+
+	if (get_spi_nand_flash_type_hook)
+	    type = get_spi_nand_flash_type_hook(mtd, id_data);
+
+	if (type)
+	    goto ident_done;
+#ifdef CONFIG_MTD_SPI_NAND_HISI_BVT
+	else {
+	    pr_info("This device[%02x,%02x] cannot found in spi nand id table!!\n",
+		    maf_id, dev_id);
+	    return -ENODEV;
+	}
+#endif
+
+#endif /* endif CONFIG_ARCH_HISI_BVT */
+
 	if (!type)
 		type = nand_flash_ids;
 
@@ -4816,12 +4846,16 @@ static int nand_detect(struct nand_chip *chip, struct nand_flash_dev *type)
 					   memorg->pages_per_eraseblock);
 
 ident_done:
+#ifdef CONFIG_ARCH_HISI_BVT
+	hinfc_nand_param_adjust(mtd, chip);
+#endif
 	if (!mtd->name)
 		mtd->name = chip->parameters.model;
 
 	if (chip->options & NAND_BUSWIDTH_AUTO) {
 		WARN_ON(busw & NAND_BUSWIDTH_16);
 		nand_set_defaults(chip);
+		printk("NAND_BUSWIDTH_AUTO,line:%d",__LINE__);
 	} else if (busw != (chip->options & NAND_BUSWIDTH_16)) {
 		/*
 		 * Check, if buswidth is correct. Hardware drivers should set
@@ -4869,6 +4903,10 @@ static int nand_detect(struct nand_chip *chip, struct nand_flash_dev *type)
 	pr_info("%d MiB, %s, erase size: %d KiB, page size: %d, OOB size: %d\n",
 		(int)(targetsize >> 20), nand_is_slc(chip) ? "SLC" : "MLC",
 		mtd->erasesize >> 10, mtd->writesize, mtd->oobsize);
+
+	/* Print ecc type and ecc mode about hisilicon flash controller */
+	hinfc_show_info(mtd, nand_manufacturer_name(manufacturer_desc), type->name);
+
 	return 0;
 
 free_detect_allocation:
diff --git a/drivers/mtd/nand/raw/nand_ids.c b/drivers/mtd/nand/raw/nand_ids.c
index b9945791a..e59b4f017 100644
--- a/drivers/mtd/nand/raw/nand_ids.c
+++ b/drivers/mtd/nand/raw/nand_ids.c
@@ -172,6 +172,11 @@ static const struct nand_manufacturer_desc nand_manufacturer_descs[] = {
 	{NAND_MFR_AMD, "AMD/Spansion", &amd_nand_manuf_ops},
 	{NAND_MFR_ATO, "ATO"},
 	{NAND_MFR_EON, "Eon"},
+	{NAND_MFR_WINBOND,	"Winbond"},
+	{NAND_MFR_ATO,		"ATO"},
+	{NAND_MFR_MXIC,		"MXIC"},
+	{NAND_MFR_ALL_FLASH,	"All-flash"},
+	{NAND_MFR_PARAGON,	"Paragon"},
 	{NAND_MFR_ESMT, "ESMT", &esmt_nand_manuf_ops},
 	{NAND_MFR_FUJITSU, "Fujitsu"},
 	{NAND_MFR_HYNIX, "Hynix", &hynix_nand_manuf_ops},
@@ -184,7 +189,10 @@ static const struct nand_manufacturer_desc nand_manufacturer_descs[] = {
 	{NAND_MFR_SANDISK, "SanDisk"},
 	{NAND_MFR_STMICRO, "ST Micro"},
 	{NAND_MFR_TOSHIBA, "Toshiba", &toshiba_nand_manuf_ops},
-	{NAND_MFR_WINBOND, "Winbond"},
+	{NAND_MFR_HEYANGTEK, "HeYangTek"},
+	{NAND_MFR_DOSILICON, "Dosilicon"},
+	{NAND_MFR_FIDELIX, "Fidelix/Dosi"}, /* Fidelix was purchased by Dosilicon */
+	{0x0, "Unknown"}
 };
 
 /**
diff --git a/drivers/mtd/spi-nor/controllers/Kconfig b/drivers/mtd/spi-nor/controllers/Kconfig
index 5c0e0ec2e..bffa9c1a6 100644
--- a/drivers/mtd/spi-nor/controllers/Kconfig
+++ b/drivers/mtd/spi-nor/controllers/Kconfig
@@ -10,11 +10,12 @@ config SPI_ASPEED_SMC
 	  the host firmware. The implementation only supports SPI NOR.
 
 config SPI_HISI_SFC
-	tristate "Hisilicon FMC SPI NOR Flash Controller(SFC)"
-	depends on ARCH_HISI || COMPILE_TEST
-	depends on HAS_IOMEM
+	tristate "Hisilicon FMCV100 SPI-NOR Flash Controller(SFC)"
+	depends on ARCH_HISI || ARCH_HISI_BVT || COMPILE_TEST
+	depends on HAS_IOMEM && HAS_DMA
 	help
-	  This enables support for HiSilicon FMC SPI NOR flash controller.
+	  This enables support for hisilicon flash memory contrller ver100
+	  (FMCV100)- SPI-NOR flash controller.
 
 config SPI_NXP_SPIFI
 	tristate "NXP SPI Flash Interface (SPIFI)"
@@ -62,3 +63,31 @@ config SPI_INTEL_SPI_PLATFORM
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called intel-spi-platform.
+
+config MTD_SPI_IDS
+    bool "SPI Flash Timing Cycles Probe Function"
+    default n
+    help
+      This option enables hisfc300/hisfc350 used spi flash timing cylces
+      probe function.
+      If your use hisfc300 and hisfc350, this function should be select.
+
+config CLOSE_SPI_8PIN_4IO
+	bool "Close SPI device Quad SPI mode for some 8PIN chip"
+	default y if ARCH_HISI_BVT
+	help
+	Hifmcv100 and Hisfcv350 support Quad SPI mode and Quad&addr SPI mode.
+	But some 8PIN chip does not support this mode when HOLD/IO3 PIN
+	was used by reset operation.
+	Usually, your should not config this option.
+
+config HISI_SPI_BLOCK_PROTECT
+	bool "Hisilicon Spi Nor Device BP(Block Protect) Support"
+	depends on SPI_HISI_SFC
+	default y if SPI_HISI_SFC
+	help
+	  HISI SFC supports BP(Block Protect) feature to preestablish a series
+	  area to avoid writing and erasing, except to reading. With this macro
+	  definition we can get the BP info which was setted before. The
+	  BOTTOM/TOP bit is setted to BOTTOM, it means the lock area starts
+	  from 0 address.
diff --git a/drivers/net/ethernet/hisilicon/Kconfig b/drivers/net/ethernet/hisilicon/Kconfig
index 44f9279cd..cf0b370d0 100644
--- a/drivers/net/ethernet/hisilicon/Kconfig
+++ b/drivers/net/ethernet/hisilicon/Kconfig
@@ -137,4 +137,6 @@ config HNS3_ENET
 
 endif #HNS3
 
+source "drivers/net/ethernet/hisilicon/higmac/Kconfig"
+
 endif # NET_VENDOR_HISILICON
diff --git a/drivers/net/ethernet/hisilicon/Makefile b/drivers/net/ethernet/hisilicon/Makefile
index 7f76d4120..95598fffc 100644
--- a/drivers/net/ethernet/hisilicon/Makefile
+++ b/drivers/net/ethernet/hisilicon/Makefile
@@ -8,4 +8,5 @@ obj-$(CONFIG_HIP04_ETH) += hip04_eth.o
 obj-$(CONFIG_HNS_MDIO) += hns_mdio.o
 obj-$(CONFIG_HNS) += hns/
 obj-$(CONFIG_HNS3) += hns3/
-obj-$(CONFIG_HISI_FEMAC) += hisi_femac.o
+obj-$(CONFIG_HISI_FEMAC) += hisi-femac/
+obj-$(CONFIG_HIETH_GMAC) += higmac/
diff --git a/drivers/net/ethernet/hisilicon/higmac/Kconfig b/drivers/net/ethernet/hisilicon/higmac/Kconfig
new file mode 100644
index 000000000..97b173e00
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/Kconfig
@@ -0,0 +1,106 @@
+#
+# higmac family network device configuration
+#
+
+menuconfig HIETH_GMAC
+	tristate "hieth gmac family network device support"
+	select PHYLIB
+	select RESET_CONTROLLER
+	help
+	  This selects the hieth gmac family network device.
+	  The gigabit switch fabric (GSF) receives and transmits data over Ethernet
+	  ports at 10/100/1000 Mbit/s in full-duplex or half-duplex mode.
+	  The Ethernet port exchanges data with the CPU port, and supports
+	  the energy efficient Ethernet (EEE) and wake on LAN (WoL) functions.
+
+if HIETH_GMAC
+
+config HIGMAC_DDR_64BIT
+	bool "higmac ddr width 64 bit"
+	depends on ARM64
+	default n
+	help
+	  This define the higmac supports DDR width 64 bit.
+	  In the newest version, the DDR size may be 8G.
+	  But in old version, the higmac only supports DDR width 32 bit.
+	  The default value is false.
+
+config HIGMAC_DESC_4WORD
+        bool "higmac descriptor size is 4 words"
+        default y
+        help
+	  This define the size of higmac descriptor structure.
+	  In the newest version, descriptor size is 4 words.
+	  But in some old version, the size is 8 words.
+	  The default value is true.
+
+config HIGMAC_RXCSUM
+        bool "higmac Receive checksumming offload supported"
+        default y
+        help
+	  This indicate MAC support Receive checksumming offload.
+	  Support IPv4 and IPv6, tcp and udp.
+	  The default value is enabled.
+	  If old version MAC does not support, disable this option please.
+
+config RX_FLOW_CTRL_SUPPORT
+	bool "rx flow ctrl supported"
+	default y
+	help
+	  Rx flow ctrl supported, default is enabled.
+	  When we received pause frame,
+	  we will stop transmiting data frame for some time.
+	  The stopping time is the time filled in pause frame.
+
+config TX_FLOW_CTRL_SUPPORT
+	bool "tx flow ctrl supported"
+	default y
+	help
+	  Tx flow ctrl supported, default is enabled.
+	  When we has no buffer to receive packet,
+	  we will send pause frame.
+	  When buffer is available, we will send zero-quanta pause frame.
+
+config TX_FLOW_CTRL_PAUSE_TIME
+	hex "tx flow ctrl pause time"
+	default "0xFFFF"
+	help
+	  The pause time filled in the sending pause frame.
+	  The unit is the time for transmiting 512 bit data.
+	  This value is 16 bit, so its value is 0x0000~0xFFFF.
+	  The default value is 0xFFFF.
+
+config TX_FLOW_CTRL_PAUSE_INTERVAL
+	hex "tx flow ctrl pause interval"
+	default "0xFFFF"
+	help
+	  The interval time for sending pause frame.
+	  When the remainint amount of receive queue is below tx flow ctrl active threshold,
+	  we will wait this time to transmiting pause frame.
+	  The unit is the time for transmiting 512 bit data.
+	  This value is 16 bit, so its value is 0x0000~0xFFFF.
+	  The default value is 0xFFFF.
+
+config TX_FLOW_CTRL_ACTIVE_THRESHOLD
+	int "tx flow ctrl active threshold"
+	default "16"
+	range 1 127
+	help
+	  The threshold for activing tx flow ctrl.
+	  When the left amount of receive queue descriptors is below this threshold,
+	  hardware will send pause frame immediately.
+	  We advise this value is set smaller than 64. Too bigger is not a good choice.
+	  This value must be smaller than tx flow ctrl deactive threshold.
+
+config TX_FLOW_CTRL_DEACTIVE_THRESHOLD
+	int "tx flow ctrl deactive threshold"
+	default "32"
+	range 1 127
+	help
+	  The threshold for deactiving tx flow ctrl.
+	  When the left amount of receive queue descriptors is above or equal with this threshold,
+	  hardware will exit flow control state.
+	  We advise this value is set smaller than 64. Too bigger is not a good choice.
+	  This value must be larger than tx flow ctrl active threshold.
+
+endif # HIETH_GMAC
diff --git a/drivers/net/ethernet/hisilicon/higmac/Makefile b/drivers/net/ethernet/hisilicon/higmac/Makefile
new file mode 100644
index 000000000..b19e27d42
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_HIETH_GMAC) += hieth-gmac.o
+hieth-gmac-objs := board.o higmac.o pm.o util.o autoeee/autoeee.o autoeee/phy_id_table.o
diff --git a/drivers/net/ethernet/hisilicon/higmac/autoeee/autoeee.c b/drivers/net/ethernet/hisilicon/higmac/autoeee/autoeee.c
new file mode 100644
index 000000000..05c2b6205
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/autoeee/autoeee.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver autoeee process
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#include "autoeee.h"
+#include "../higmac.h"
+#include <linux/phy.h>
+#include <linux/micrel_phy.h>
+
+static u32 set_link_stat(struct higmac_netdev_local const *ld)
+{
+	u32 link_stat = 0;
+
+	switch (ld->phy->speed) {
+	case SPEED_10:
+		link_stat |= HIGMAC_SPD_10M;
+		break;
+	case SPEED_100:
+		link_stat |= HIGMAC_SPD_100M;
+		break;
+	case SPEED_1000:
+		link_stat |= HIGMAC_SPD_1000M;
+		break;
+	default:
+		break;
+	}
+	return link_stat;
+}
+
+static void set_eee_clk(struct higmac_netdev_local const *ld, u32 phy_id)
+{
+	u32 v;
+
+	if ((phy_id & REALTEK_PHY_MASK) == REALTEK_PHY_ID_8211E) {
+		v = readl(ld->gmac_iobase + EEE_CLK);
+		v &= ~MASK_EEE_CLK;
+		v |= BIT_DISABLE_TX_CLK;
+		writel(v, ld->gmac_iobase + EEE_CLK);
+	} else if ((phy_id & MICREL_PHY_ID_MASK) == PHY_ID_KSZ9031) {
+		v = readl(ld->gmac_iobase + EEE_CLK);
+		v &= ~MASK_EEE_CLK;
+		v |= (BIT_DISABLE_TX_CLK | BIT_PHY_KSZ9031);
+		writel(v, ld->gmac_iobase + EEE_CLK);
+	}
+}
+
+static void enable_eee(struct higmac_netdev_local const *ld)
+{
+	u32 v;
+
+	/* EEE_1us: 0x7c for 125M */
+	writel(0x7c, ld->gmac_iobase +
+	       EEE_TIME_CLK_CNT);
+	writel(0x1e0400, ld->gmac_iobase + EEE_TIMER);
+
+	v = readl(ld->gmac_iobase + EEE_LINK_STATUS);
+	v |= 0x3 << 1; /* auto EEE and ... */
+	v |= BIT_PHY_LINK_STATUS; /* phy linkup */
+	writel(v, ld->gmac_iobase + EEE_LINK_STATUS);
+
+	v = readl(ld->gmac_iobase + EEE_ENABLE);
+	v |= BIT_EEE_ENABLE; /* enable EEE */
+	writel(v, ld->gmac_iobase + EEE_ENABLE);
+}
+
+static void set_phy_eee_mode(struct higmac_netdev_local const *ld)
+{
+	u32 v;
+	if (netif_msg_wol(ld))
+		pr_info("enter phy-EEE mode\n");
+
+	v = readl(ld->gmac_iobase + EEE_ENABLE);
+	v &= ~BIT_EEE_ENABLE; /* disable auto-EEE */
+	writel(v, ld->gmac_iobase + EEE_ENABLE);
+}
+
+void init_autoeee(struct higmac_netdev_local *ld)
+{
+	int phy_id;
+	int eee_available, lp_eee_capable;
+	u32 v, link_stat;
+	struct phy_info *phy_info = NULL;
+	if (ld == NULL || ld->eee_init == NULL || ld->phy == NULL)
+		return;
+	phy_id = ld->phy->phy_id;
+	if (ld->eee_init != NULL)
+		goto eee_init;
+
+	phy_info = phy_search_ids(phy_id);
+	if (phy_info == NULL)
+		goto not_support;
+
+	eee_available = phy_info->eee_available;
+	if (netif_msg_wol(ld) && phy_info->name != NULL)
+		pr_info("fit phy_id:0x%x, phy_name:%s, eee:%d\n",
+			phy_info->phy_id, phy_info->name, eee_available);
+
+	if (!eee_available)
+		goto not_support;
+
+	if (eee_available == PHY_EEE) {
+		set_phy_eee_mode(ld);
+		return;
+	}
+
+	ld->eee_init = phy_info->eee_init;
+eee_init:
+	link_stat = set_link_stat(ld);
+
+	lp_eee_capable = ld->eee_init(ld->phy);
+	if (lp_eee_capable < 0)
+		return;
+
+	if (ld->phy->link) {
+		if (((u32)lp_eee_capable) & link_stat) {
+			set_eee_clk(ld, phy_id);
+			enable_eee(ld);
+
+			if (netif_msg_wol(ld))
+				pr_info("enter auto-EEE mode\n");
+		} else {
+			if (netif_msg_wol(ld))
+				pr_info("link partner not support EEE\n");
+		}
+	} else {
+		v = readl(ld->gmac_iobase + EEE_LINK_STATUS);
+		v &= ~(BIT_PHY_LINK_STATUS); /* phy linkdown */
+		writel(v, ld->gmac_iobase + EEE_LINK_STATUS);
+	}
+
+	return;
+
+not_support:
+	ld->eee_init = NULL;
+	if (netif_msg_wol(ld))
+		pr_info("non-EEE mode\n");
+}
+
+void eee_phy_linkdown(struct higmac_netdev_local const *ld)
+{
+	u32 v;
+	if (ld == NULL)
+		return;
+	v = readl(ld->gmac_iobase + EEE_LINK_STATUS);
+	/* update phy link state */
+	v &= ~BIT_PHY_LINK_STATUS;
+	writel(v, ld->gmac_iobase + EEE_LINK_STATUS);
+}
+
+void eee_phy_linkup(struct higmac_netdev_local const *ld)
+{
+	u32 v;
+	if (ld == NULL)
+		return;
+	v = readl(ld->gmac_iobase + EEE_LINK_STATUS);
+	/* update phy link state */
+	v |= BIT_PHY_LINK_STATUS;
+	writel(v, ld->gmac_iobase + EEE_LINK_STATUS);
+}
diff --git a/drivers/net/ethernet/hisilicon/higmac/autoeee/autoeee.h b/drivers/net/ethernet/hisilicon/higmac/autoeee/autoeee.h
new file mode 100644
index 000000000..30cbb9799
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/autoeee/autoeee.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: autoeee head file
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#ifndef	_AUTO_EEE_H
+#define	_AUTO_EEE_H
+
+#include "../higmac.h"
+
+#define NO_EEE          0
+#define MAC_EEE         1
+#define PHY_EEE         2
+#define PARTNER_EEE     2
+
+struct phy_info {
+	char *name;
+	int phy_id;
+	char eee_available; /* eee support by this phy */
+	int (*eee_init)(struct phy_device *phy_dev);
+};
+
+/* GMAC register definition */
+#define EEE_CLK			0x800
+#define MASK_EEE_CLK		(0x3 << 20)
+#define BIT_DISABLE_TX_CLK	BIT(21)
+#define BIT_PHY_KSZ9031		BIT(20)
+#define EEE_ENABLE		0x808
+#define BIT_EEE_ENABLE		BIT(0)
+#define EEE_TIMER		0x80C
+#define EEE_LINK_STATUS		0x810
+#define BIT_PHY_LINK_STATUS	BIT(0)
+#define EEE_TIME_CLK_CNT	0x814
+
+/* ----------------------------phy register-------------------------------*/
+/* MMD: MDIO Manageable Device */
+#define MACR		0x0D
+#define MAADR		0x0E
+#define EEE_DEV		0x3
+#define EEE_CAPABILITY	0x14
+#define	EEELPAR_DEV	0x7
+#define EEELPAR		0x3D /* EEE link partner ability register */
+#define EEE_ADVERTISE	0x3c
+#define LP_1000BASE_EEE	BIT(2)
+#define LP_100BASE_EEE	BIT(1)
+
+struct phy_info *phy_search_ids(int phy_id);
+void init_autoeee(struct higmac_netdev_local *ld);
+
+#endif
diff --git a/drivers/net/ethernet/hisilicon/higmac/autoeee/phy_id_table.c b/drivers/net/ethernet/hisilicon/higmac/autoeee/phy_id_table.c
new file mode 100644
index 000000000..d98bbf1f0
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/autoeee/phy_id_table.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac phy id table
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#include "../higmac.h"
+#include "autoeee.h"
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/phy.h>
+
+struct phy_info phy_info_table[];
+
+struct phy_info *phy_search_ids(int phy_id)
+{
+	int i;
+	struct phy_info *fit_info = NULL;
+
+	for (i = 0; phy_info_table[i].name; i++) {
+		if (phy_id == phy_info_table[i].phy_id) {
+			fit_info = &phy_info_table[i];
+			break;
+		}
+	}
+
+	return fit_info;
+}
+
+static inline int phy_mmd_read(struct phy_device *phy_dev,
+			       u32 mmd_device, u32 regnum)
+{
+	phy_write(phy_dev, MACR, mmd_device); /* function = 00 address */
+	phy_write(phy_dev, MAADR, regnum);
+	phy_write(phy_dev, MACR, 0x4000 | mmd_device); /* function = 01 data */
+
+	return phy_read(phy_dev, MAADR);
+}
+
+static inline int phy_mmd_write(struct phy_device *phy_dev, u32 mmd_device,
+				u32 regnum, u16 val)
+{
+	phy_write(phy_dev, MACR, mmd_device); /* function = 00 address */
+	phy_write(phy_dev, MAADR, regnum);
+	phy_write(phy_dev, MACR, 0x4000 | mmd_device); /* function = 01 data */
+
+	return phy_write(phy_dev, MAADR, val);
+}
+
+static int smsc_lan8740_init(struct phy_device *phy_dev)
+{
+	static int first_time = 0;
+	int v;
+	u32 eee_type = 0;
+
+	if (!first_time) {
+		/* Realtek LAN 8740 start to enable eee */
+		int eee_lan;
+
+		eee_lan = phy_read(phy_dev, 0x10);
+		if (eee_lan < 0)
+			return eee_lan;
+		eee_lan = (u32)eee_lan | 0x4;
+		phy_write(phy_dev, 0x10, eee_lan);
+		eee_lan = phy_read(phy_dev, 0x10);
+		if (eee_lan < 0)
+			return eee_lan;
+		/* auto negotiate after enable eee */
+		eee_lan = phy_read(phy_dev, 0x0);
+		if (eee_lan < 0)
+			return eee_lan;
+		eee_lan = (u32)eee_lan | 0x200;
+		phy_write(phy_dev, 0x0, eee_lan);
+		first_time = 1;
+	}
+
+	v = phy_mmd_read(phy_dev, EEELPAR_DEV, EEELPAR);
+	if ((u32)v & LP_1000BASE_EEE)
+		eee_type |= HIGMAC_SPD_1000M;
+	if ((u32)v & LP_100BASE_EEE)
+		eee_type |= HIGMAC_SPD_100M;
+
+	return (int)eee_type;
+}
+
+#define RTL8211EG_MAC	0
+#if RTL8211EG_MAC
+static int rtl8211eg_mac_init(struct phy_device *phy_dev)
+{
+	static int first_time = 0;
+	/* Realtek 8211EG start reset to change eee to mac */
+	int v;
+	u32 eee_type = 0;
+
+	if (!first_time) {
+		int tmp;
+
+		phy_write(phy_dev, 0x1f, 0x0);
+		phy_write(phy_dev, MII_BMCR, BMCR_RESET); /* reset phy */
+		do { /* wait phy restart over */
+			udelay(1);
+			tmp = phy_read(phy_dev, MII_BMSR);
+			/* no need to wait AN finished */
+			tmp &= (BMSR_ANEGCOMPLETE | BMSR_ANEGCAPABLE);
+		} while (!tmp);
+
+		phy_write(phy_dev, 0x1f, 0x7);
+		phy_write(phy_dev, 0x1e, 0x20);
+		phy_write(phy_dev, 0x1b, 0xa03a);
+		phy_write(phy_dev, 0x1f, 0x0);
+
+		first_time = 1;
+	}
+
+	v = phy_mmd_read(phy_dev, EEELPAR_DEV, EEELPAR);
+	if ((u32)v & LP_1000BASE_EEE)
+		eee_type |= HIGMAC_SPD_1000M;
+	if ((u32)v & LP_100BASE_EEE)
+		eee_type |= HIGMAC_SPD_100M;
+
+	return (int)eee_type;
+}
+#else
+static int rtl8211eg_init(struct phy_device *phy_dev)
+{
+	u32 eee_type = 0;
+	u32 v;
+
+	v = (u32)phy_mmd_read(phy_dev, EEELPAR_DEV, EEELPAR);
+	if (v & LP_1000BASE_EEE)
+		eee_type |= HIGMAC_SPD_1000M;
+	if (v & LP_100BASE_EEE)
+		eee_type |= HIGMAC_SPD_100M;
+
+	return (int)eee_type;
+}
+#endif
+
+static int festa_v200_init(struct phy_device *phy_dev)
+{
+	static int first_time_init = 0;
+	int v;
+	u32 eee_type = 0;
+
+	if (!first_time_init) {
+		/* EEE_CAPABILITY register: support 100M-BaseT */
+		v = phy_mmd_read(phy_dev, EEE_DEV, EEE_CAPABILITY);
+		phy_mmd_write(phy_dev, EEE_DEV, EEE_CAPABILITY,
+			      ((u32)v) | BIT(1));
+
+		/* EEE_ADVERTISEMENT register: advertising 100M-BaseT */
+		v = phy_mmd_read(phy_dev, EEELPAR_DEV, EEE_ADVERTISE);
+		phy_mmd_write(phy_dev, EEELPAR_DEV, EEE_ADVERTISE,
+			      ((u32)v) | BIT(1));
+
+		v = phy_read(phy_dev, MII_BMCR);
+		if (v < 0)
+			return v;
+		v = (u32)v | (BMCR_ANENABLE | BMCR_ANRESTART);
+		phy_write(phy_dev, MII_BMCR, v); /* auto-neg restart */
+
+		first_time_init = 1;
+	}
+
+	v = phy_mmd_read(phy_dev, EEELPAR_DEV, EEELPAR);
+	if ((u32)v & LP_1000BASE_EEE)
+		eee_type |= HIGMAC_SPD_1000M;
+	if ((u32)v & LP_100BASE_EEE)
+		eee_type |= HIGMAC_SPD_100M;
+
+	return (int)eee_type;
+}
+
+struct phy_info phy_info_table[] = {
+	/* phy_name      phy_id      eee_available  phy_driver */
+	{"SMSC LAN8740", 0x0007c110, MAC_EEE, &smsc_lan8740_init},
+#if RTL8211EG_MAC
+	{"Realtek 8211EG", 0x001cc915, MAC_EEE, &rtl8211eg_mac_init},
+#else
+	{"Realtek 8211EG", 0x001cc915, PHY_EEE, &rtl8211eg_init},
+#endif
+	{"Festa V200", HISILICON_PHY_ID_FESTAV200, MAC_EEE, &festa_v200_init},
+};
diff --git a/drivers/net/ethernet/hisilicon/higmac/board.c b/drivers/net/ethernet/hisilicon/higmac/board.c
new file mode 100644
index 000000000..b7a1d879d
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/board.c
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver board file
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/reset.h>
+#include "higmac.h"
+
+void higmac_mac_core_reset(struct higmac_netdev_local *priv)
+{
+	/* undo reset */
+	if (priv == NULL || priv->port_rst == NULL)
+		return;
+	reset_control_deassert(priv->port_rst);
+	usleep_range(50, 60); /* wait 50~60us */
+
+	/* soft reset mac port */
+	reset_control_assert(priv->port_rst);
+	usleep_range(50, 60); /* wait 50~60us */
+	/* undo reset */
+	reset_control_deassert(priv->port_rst);
+}
+
+void higmac_hw_internal_phy_reset(struct higmac_netdev_local *priv)
+{
+}
+
+void higmac_hw_phy_reset(struct higmac_netdev_local *priv)
+{
+	if (priv == NULL)
+		return;
+	if (priv->internal_phy)
+		higmac_hw_internal_phy_reset(priv);
+	else
+		higmac_hw_external_phy_reset(priv);
+}
+
+void higmac_hw_external_phy_reset(struct higmac_netdev_local *priv)
+{
+	if (priv == NULL)
+		return;
+	if (priv->phy_rst != NULL) {
+		/* write 0 to cancel reset */
+		reset_control_deassert(priv->phy_rst);
+		msleep(50); /* wait 50ms */
+
+		/* HIFONE or 98cv200 use CRG register to reset phy */
+		/* RST_BIT, write 0 to reset phy, write 1 to cancel reset */
+		reset_control_assert(priv->phy_rst);
+
+		/*
+		 * delay some time to ensure reset ok,
+		 * this depends on PHY hardware feature
+		 */
+		msleep(50); /* wait 50ms */
+
+		/* write 0 to cancel reset */
+		reset_control_deassert(priv->phy_rst);
+		/* delay some time to ensure later MDIO access */
+		msleep(50); /* wait 50ms */
+	}
+}
+
+void higmac_internal_phy_clk_disable(struct higmac_netdev_local const *priv)
+{
+}
+
+void higmac_internal_phy_clk_enable(struct higmac_netdev_local const *priv)
+{
+}
+
+void higmac_hw_all_clk_disable(struct higmac_netdev_local *priv)
+{
+	/*
+	 * If macif clock is enabled when suspend, we should
+	 * disable it here.
+	 * Because when resume, PHY will link up again and
+	 * macif clock will be enabled too. If we don't disable
+	 * macif clock in suspend, macif clock will be enabled twice.
+	 */
+	if (priv == NULL || priv->clk == NULL || priv->netdev == NULL || priv->macif_clk == NULL)
+		return;
+
+	if (priv->netdev->flags & IFF_UP)
+		clk_disable_unprepare(priv->macif_clk);
+
+	/*
+	 * This is called in suspend, when net device is down,
+	 * MAC clk is disabled.
+	 * So we need to judge whether MAC clk is enabled,
+	 * otherwise kernel will WARNING if clk disable twice.
+	 */
+	if (priv->netdev->flags & IFF_UP)
+		clk_disable_unprepare(priv->clk);
+
+	if (priv->internal_phy)
+		higmac_internal_phy_clk_disable(priv);
+}
+
+void higmac_hw_all_clk_enable(struct higmac_netdev_local *priv)
+{
+	if (priv == NULL || priv->netdev == NULL || priv->clk == NULL)
+		return;
+
+	if (priv->internal_phy)
+		higmac_internal_phy_clk_enable(priv);
+
+	if (priv->netdev->flags & IFF_UP)
+		clk_prepare_enable(priv->macif_clk);
+
+	/* If net device is down when suspend, we should not enable MAC clk. */
+	if (priv->netdev->flags & IFF_UP)
+		clk_prepare_enable(priv->clk);
+}
diff --git a/drivers/net/ethernet/hisilicon/higmac/higmac.c b/drivers/net/ethernet/hisilicon/higmac/higmac.c
new file mode 100644
index 000000000..e77712344
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/higmac.c
@@ -0,0 +1,2645 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver main process
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#include "higmac.h"
+#include "util.h"
+#include "autoeee/autoeee.h"
+#include "sockioctl.h"
+#include "pm.h"
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/dma-mapping.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+#include <linux/atomic.h>
+#include <linux/platform_device.h>
+#include <linux/capability.h>
+#include <linux/time.h>
+#include <asm/setup.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+
+#include <linux/circ_buf.h>
+#include <linux/of_net.h>
+#include <linux/of_mdio.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+
+#define has_tso_cap(hw_cap)		((((hw_cap) >> 28) & 0x3) == VER_TSO)
+#define has_rxhash_cap(hw_cap)		((hw_cap) & BIT(30))
+#define has_rss_cap(hw_cap)		((hw_cap) & BIT(31))
+
+#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
+static int debug = -1;
+module_param(debug, int, 0000);
+MODULE_PARM_DESC(debug, "Debug level (0=none,...,16=all)");
+
+static void higmac_set_desc_depth(struct higmac_netdev_local const *priv,
+		  u32 rx, u32 tx)
+{
+	u32 reg, val;
+	int i;
+
+	writel(BITS_RX_FQ_DEPTH_EN, priv->gmac_iobase + RX_FQ_REG_EN);
+	val = readl(priv->gmac_iobase + RX_FQ_DEPTH);
+	val &= ~Q_ADDR_HI8_MASK;
+	val |= rx << DESC_WORD_SHIFT;
+	writel(val, priv->gmac_iobase + RX_FQ_DEPTH);
+	writel(0, priv->gmac_iobase + RX_FQ_REG_EN);
+
+	writel(BITS_RX_BQ_DEPTH_EN, priv->gmac_iobase + RX_BQ_REG_EN);
+	val = readl(priv->gmac_iobase + RX_BQ_DEPTH);
+	val &= ~Q_ADDR_HI8_MASK;
+	val |= rx << DESC_WORD_SHIFT;
+	writel(val, priv->gmac_iobase + RX_BQ_DEPTH);
+	for (i = 1; i < priv->num_rxqs; i++) {
+		reg = rx_bq_depth_queue(i);
+		val = readl(priv->gmac_iobase + reg);
+		val &= ~Q_ADDR_HI8_MASK;
+		val |= rx << DESC_WORD_SHIFT;
+		writel(val, priv->gmac_iobase + reg);
+	}
+	writel(0, priv->gmac_iobase + RX_BQ_REG_EN);
+
+	writel(BITS_TX_BQ_DEPTH_EN, priv->gmac_iobase + TX_BQ_REG_EN);
+	val = readl(priv->gmac_iobase + TX_BQ_DEPTH);
+	val &= ~Q_ADDR_HI8_MASK;
+	val |= tx << DESC_WORD_SHIFT;
+	writel(val, priv->gmac_iobase + TX_BQ_DEPTH);
+	writel(0, priv->gmac_iobase + TX_BQ_REG_EN);
+
+	writel(BITS_TX_RQ_DEPTH_EN, priv->gmac_iobase + TX_RQ_REG_EN);
+	val = readl(priv->gmac_iobase + TX_RQ_DEPTH);
+	val &= ~Q_ADDR_HI8_MASK;
+	val |= tx << DESC_WORD_SHIFT;
+	writel(val, priv->gmac_iobase + TX_RQ_DEPTH);
+	writel(0, priv->gmac_iobase + TX_RQ_REG_EN);
+}
+
+static void higmac_set_rx_fq(struct higmac_netdev_local const *priv,
+		  dma_addr_t phy_addr)
+{
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	u32 val;
+#endif
+	writel(BITS_RX_FQ_START_ADDR_EN, priv->gmac_iobase + RX_FQ_REG_EN);
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	val = readl(priv->gmac_iobase + RX_FQ_DEPTH);
+	val &= Q_ADDR_HI8_MASK;
+	val |= (phy_addr >> REG_BIT_WIDTH) << Q_ADDR_HI8_OFFSET;
+	writel(val, priv->gmac_iobase + RX_FQ_DEPTH);
+#endif
+	writel((u32)phy_addr, priv->gmac_iobase + RX_FQ_START_ADDR);
+	writel(0, priv->gmac_iobase + RX_FQ_REG_EN);
+}
+
+static void higmac_set_rx_bq(struct higmac_netdev_local const *priv,
+		  dma_addr_t phy_addr)
+{
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	u32 val;
+#endif
+	writel(BITS_RX_BQ_START_ADDR_EN, priv->gmac_iobase + RX_BQ_REG_EN);
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	val = readl(priv->gmac_iobase + RX_BQ_DEPTH);
+	val &= Q_ADDR_HI8_MASK;
+	val |= (phy_addr >> REG_BIT_WIDTH) << Q_ADDR_HI8_OFFSET;
+	writel(val, priv->gmac_iobase + RX_BQ_DEPTH);
+#endif
+	writel((u32)phy_addr, priv->gmac_iobase + RX_BQ_START_ADDR);
+	writel(0, priv->gmac_iobase + RX_BQ_REG_EN);
+}
+
+static void higmac_set_tx_bq(struct higmac_netdev_local const *priv,
+		  dma_addr_t phy_addr)
+{
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	u32 val;
+#endif
+	writel(BITS_TX_BQ_START_ADDR_EN, priv->gmac_iobase + TX_BQ_REG_EN);
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	val = readl(priv->gmac_iobase + TX_BQ_DEPTH);
+	val &= Q_ADDR_HI8_MASK;
+	val |= (phy_addr >> REG_BIT_WIDTH) << Q_ADDR_HI8_OFFSET;
+	writel(val, priv->gmac_iobase + TX_BQ_DEPTH);
+#endif
+	writel((u32)phy_addr, priv->gmac_iobase + TX_BQ_START_ADDR);
+	writel(0, priv->gmac_iobase + TX_BQ_REG_EN);
+}
+
+static void higmac_set_tx_rq(struct higmac_netdev_local const *priv,
+		  dma_addr_t phy_addr)
+{
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	u32 val;
+#endif
+	writel(BITS_TX_RQ_START_ADDR_EN, priv->gmac_iobase + TX_RQ_REG_EN);
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	val = readl(priv->gmac_iobase + TX_RQ_DEPTH);
+	val &= Q_ADDR_HI8_MASK;
+	val |= (phy_addr >> REG_BIT_WIDTH) << Q_ADDR_HI8_OFFSET;
+	writel(val, priv->gmac_iobase + TX_RQ_DEPTH);
+#endif
+	writel((u32)phy_addr, priv->gmac_iobase + TX_RQ_START_ADDR);
+	writel(0, priv->gmac_iobase + TX_RQ_REG_EN);
+}
+
+static void higmac_hw_set_desc_addr(struct higmac_netdev_local const *priv)
+{
+	u32 reg;
+	int i;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	u32 val;
+#endif
+
+	higmac_set_rx_fq(priv, priv->RX_FQ.phys_addr);
+	higmac_set_rx_bq(priv, priv->RX_BQ.phys_addr);
+	higmac_set_tx_rq(priv, priv->TX_RQ.phys_addr);
+	higmac_set_tx_bq(priv, priv->TX_BQ.phys_addr);
+
+	for (i = 1; i < priv->num_rxqs; i++) {
+		reg = rx_bq_start_addr_queue(i);
+		writel(BITS_RX_BQ_START_ADDR_EN,
+		       priv->gmac_iobase + RX_BQ_REG_EN);
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		val = readl(priv->gmac_iobase + reg);
+		val &= Q_ADDR_HI8_MASK;
+		val |= ((priv->pool[BASE_QUEUE_NUMS + i].phys_addr) >> REG_BIT_WIDTH) <<
+		       Q_ADDR_HI8_OFFSET;
+		writel(val, priv->gmac_iobase + reg);
+#endif
+		/* pool 3 add i */
+		writel((u32)(priv->pool[BASE_QUEUE_NUMS + i].phys_addr),
+		       priv->gmac_iobase + reg);
+		writel(0, priv->gmac_iobase + RX_BQ_REG_EN);
+	}
+}
+
+static void higmac_set_rss_cap(struct higmac_netdev_local const *priv)
+{
+	u32 val = 0;
+
+	if (priv->has_rxhash_cap)
+		val |= BIT_RXHASH_CAP;
+	if (priv->has_rss_cap)
+		val |= BIT_RSS_CAP;
+	writel(val, priv->gmac_iobase + HW_CAP_EN);
+}
+
+/* config AXI bus burst and outstanding for better performance */
+static void higmac_axi_bus_cfg(struct higmac_netdev_local *priv)
+{
+	if (!priv->axi_bus_cfg_base)
+		return;
+
+#if defined(CONFIG_ARCH_HI3519) || defined(CONFIG_ARCH_HI3519V101) || \
+	defined(CONFIG_ARCH_HI3559) || defined(CONFIG_ARCH_HI3556) || \
+	defined(CONFIG_ARCH_HI3516AV200)
+	if (!(readl(priv->axi_bus_cfg_base) >> BURST_OUTSTANDING_OFFSET))
+		writel(BURST4_OUTSTANDING1, priv->axi_bus_cfg_base);
+#elif defined(CONFIG_ARCH_HI3521A) || defined(CONFIG_ARCH_HI3531A)
+	writel(BURST4_OUTSTANDING1, priv->axi_bus_cfg_base);
+#endif
+}
+
+static void higmac_hw_init(struct higmac_netdev_local *priv)
+{
+	u32 val;
+	u32 reg;
+	int i;
+
+	higmac_axi_bus_cfg(priv);
+
+	/* disable and clear all interrupts */
+	writel(0, priv->gmac_iobase + ENA_PMU_INT);
+	writel(~0, priv->gmac_iobase + RAW_PMU_INT);
+
+	for (i = 1; i < priv->num_rxqs; i++) {
+		reg = rss_ena_int_queue(i);
+		writel(0, priv->gmac_iobase + reg);
+	}
+	writel(~0, priv->gmac_iobase + RSS_RAW_PMU_INT);
+
+	/* enable CRC erro packets filter */
+	val = readl(priv->gmac_iobase + REC_FILT_CONTROL);
+	val |= BIT_CRC_ERR_PASS;
+	writel(val, priv->gmac_iobase + REC_FILT_CONTROL);
+
+	/* set tx min packet length */
+	val = readl(priv->gmac_iobase + CRF_MIN_PACKET);
+	val &= ~BIT_MASK_TX_MIN_LEN;
+	val |= ETH_HLEN << BIT_OFFSET_TX_MIN_LEN;
+	writel(val, priv->gmac_iobase + CRF_MIN_PACKET);
+
+	/* fix bug for udp and ip error check */
+	writel(CONTROL_WORD_CONFIG, priv->gmac_iobase + CONTROL_WORD);
+
+	writel(0, priv->gmac_iobase + COL_SLOT_TIME);
+
+	writel(DUPLEX_HALF, priv->gmac_iobase + MAC_DUPLEX_HALF_CTRL);
+
+	/* interrupt when rcv packets >= RX_BQ_INT_THRESHOLD */
+	val = RX_BQ_INT_THRESHOLD |
+		(TX_RQ_INT_THRESHOLD << BITS_OFFSET_TX_RQ_IN_TH);
+	writel(val, priv->gmac_iobase + IN_QUEUE_TH);
+
+	/* RX_BQ/TX_RQ in timeout threshold */
+	writel(0x10000, priv->gmac_iobase + RX_BQ_IN_TIMEOUT_TH);
+
+	writel(0x18000, priv->gmac_iobase + TX_RQ_IN_TIMEOUT_TH);
+
+	higmac_set_desc_depth(priv, RX_DESC_NUM, TX_DESC_NUM);
+}
+
+static inline void higmac_irq_enable(struct higmac_netdev_local *ld)
+{
+	if (ld == NULL)
+		return;
+	writel(RX_BQ_IN_INT | RX_BQ_IN_TIMEOUT_INT
+		| TX_RQ_IN_INT | TX_RQ_IN_TIMEOUT_INT,
+		ld->gmac_iobase + ENA_PMU_INT);
+}
+
+static void higmac_irq_enable_queue(struct higmac_netdev_local *ld,
+				    int rxq_id)
+{
+	if (rxq_id) {
+		u32 reg;
+
+		reg = rss_ena_int_queue(rxq_id);
+		writel(~0, ld->gmac_iobase + reg);
+	} else {
+		higmac_irq_enable(ld);
+	}
+}
+
+static inline void higmac_irq_enable_all_queue(struct higmac_netdev_local *ld)
+{
+	int i;
+	if (ld == NULL)
+		return;
+	for (i = 0; i < ld->num_rxqs; i++)
+		higmac_irq_enable_queue(ld, i);
+}
+
+static inline void higmac_irq_disable(struct higmac_netdev_local const *ld)
+{
+	if (ld == NULL)
+		return;
+	writel(0, ld->gmac_iobase + ENA_PMU_INT);
+}
+
+static void higmac_irq_disable_queue(struct higmac_netdev_local const *ld,
+		  int rxq_id)
+{
+	if (rxq_id) {
+		u32 reg;
+
+		reg = rss_ena_int_queue(rxq_id);
+		writel(0, ld->gmac_iobase + reg);
+	} else {
+		higmac_irq_disable(ld);
+	}
+}
+
+static inline void higmac_irq_disable_all_queue(struct higmac_netdev_local const *ld)
+{
+	int i;
+	if (ld == NULL)
+		return;
+	for (i = 0; i < ld->num_rxqs; i++)
+		higmac_irq_disable_queue(ld, i);
+}
+
+static bool higmac_queue_irq_disabled(struct higmac_netdev_local *ld,
+				      int rxq_id)
+{
+	u32 reg, val;
+
+	if (rxq_id)
+		reg = rss_ena_int_queue(rxq_id);
+	else
+		reg = ENA_PMU_INT;
+	val = readl(ld->gmac_iobase + reg);
+
+	return !val;
+}
+
+static inline void higmac_hw_desc_enable(struct higmac_netdev_local const *ld)
+{
+	if (ld == NULL)
+		return;
+	writel(0xF, ld->gmac_iobase + DESC_WR_RD_ENA);
+}
+
+static inline void higmac_hw_desc_disable(struct higmac_netdev_local const *ld)
+{
+	if (ld == NULL)
+		return;
+	writel(0, ld->gmac_iobase + DESC_WR_RD_ENA);
+}
+
+static inline void higmac_port_enable(struct higmac_netdev_local const *ld)
+{
+	if (ld == NULL)
+		return;
+	writel(BITS_TX_EN | BITS_RX_EN, ld->gmac_iobase + PORT_EN);
+}
+
+static inline void higmac_port_disable(struct higmac_netdev_local const *ld)
+{
+	if (ld != NULL) {
+		writel(0, ld->gmac_iobase + PORT_EN);
+	}
+}
+
+/* set gmac's multicast list, here we setup gmac's mc filter */
+static void higmac_gmac_multicast_list(struct net_device const *dev)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+	unsigned int rec_filter;
+
+	rec_filter = readl(ld->gmac_iobase + REC_FILT_CONTROL);
+	/*
+	 * when set gmac in promisc mode
+	 * a. dev in IFF_PROMISC mode
+	 */
+	if ((dev->flags & IFF_PROMISC)) {
+		/* promisc mode.received all pkgs. */
+		rec_filter &= ~(BIT_BC_DROP_EN | BIT_MC_MATCH_EN |
+				BIT_UC_MATCH_EN);
+	} else {
+		/* drop uc pkgs with field 'DA' not match our's */
+		rec_filter |= BIT_UC_MATCH_EN;
+
+		if (dev->flags & IFF_BROADCAST) /* no broadcast */
+			rec_filter &= ~BIT_BC_DROP_EN;
+		else
+			rec_filter |= BIT_BC_DROP_EN;
+
+		if (netdev_mc_empty(dev) || !(dev->flags & IFF_MULTICAST)) {
+			/* haven't join any mc group */
+			writel(0, ld->gmac_iobase + PORT_MC_ADDR_LOW);
+			writel(0, ld->gmac_iobase + PORT_MC_ADDR_HIGH);
+			rec_filter |= BIT_MC_MATCH_EN;
+		} else if (netdev_mc_count(dev) == 1 &&
+				(dev->flags & IFF_MULTICAST)) {
+			struct netdev_hw_addr *ha = NULL;
+			unsigned int d;
+
+			netdev_for_each_mc_addr(ha, dev) {
+				d = (ha->addr[0] << 8) | (ha->addr[1]); /* shift left 8bits */
+				writel(d, ld->gmac_iobase + PORT_MC_ADDR_HIGH);
+				/* addr2 3 shift left 24 16 bits */
+				d = (ha->addr[2] << 24) | (ha->addr[3] << 16) |
+				     (ha->addr[4] << 8) | (ha->addr[5]); /* a4 << 8 | a5 */
+				writel(d, ld->gmac_iobase + PORT_MC_ADDR_LOW);
+			}
+			rec_filter |= BIT_MC_MATCH_EN;
+		} else {
+			rec_filter &= ~BIT_MC_MATCH_EN;
+		}
+	}
+	writel(rec_filter, ld->gmac_iobase + REC_FILT_CONTROL);
+}
+
+/*
+ * the func stop the hw desc and relaim the software skb resource
+ * before reusing the gmac, you'd better reset the gmac
+ */
+void higmac_reclaim_rx_tx_resource(struct higmac_netdev_local *ld)
+{
+	unsigned long rxflags, txflags;
+	int rd_offset, wr_offset;
+	int i;
+	if (ld == NULL)
+		return;
+	higmac_irq_disable_all_queue(ld);
+	higmac_hw_desc_disable(ld);
+	writel(STOP_RX_TX, ld->gmac_iobase + STOP_CMD);
+
+	spin_lock_irqsave(&ld->rxlock, rxflags);
+	/* RX_BQ: logic write pointer */
+	wr_offset = readl(ld->gmac_iobase + RX_BQ_WR_ADDR);
+	/* RX_BQ: software read pointer */
+	rd_offset = readl(ld->gmac_iobase + RX_BQ_RD_ADDR);
+	/* prevent to reclaim skb in rx bottom half */
+	writel(wr_offset, ld->gmac_iobase + RX_BQ_RD_ADDR);
+
+	for (i = 1; i < ld->num_rxqs; i++) {
+		u32 rx_bq_wr_reg, rx_bq_rd_reg;
+
+		rx_bq_wr_reg = rx_bq_wr_addr_queue(i);
+		rx_bq_rd_reg = rx_bq_rd_addr_queue(i);
+
+		wr_offset = readl(ld->gmac_iobase + rx_bq_wr_reg);
+		writel(wr_offset, ld->gmac_iobase + rx_bq_rd_reg);
+	}
+
+	/* RX_FQ: software write pointer */
+	wr_offset = readl(ld->gmac_iobase + RX_FQ_WR_ADDR);
+	/* RX_FQ: logic read pointer */
+	rd_offset = readl(ld->gmac_iobase + RX_FQ_RD_ADDR);
+	if (!rd_offset)
+		rd_offset = (RX_DESC_NUM - 1) << DESC_BYTE_SHIFT;
+	else
+		rd_offset -= DESC_SIZE;
+	/* stop to feed hw desc */
+	writel(rd_offset, ld->gmac_iobase + RX_FQ_WR_ADDR);
+
+	for (i = 0; i < ld->RX_FQ.count; i++) {
+		if (!ld->RX_FQ.skb[i])
+			ld->RX_FQ.skb[i] = SKB_MAGIC;
+	}
+	spin_unlock_irqrestore(&ld->rxlock, rxflags);
+
+	/*
+	 * no need to wait pkts in TX_RQ finish to free all skb,
+	 * because higmac_xmit_reclaim is in the tx_lock,
+	 */
+	spin_lock_irqsave(&ld->txlock, txflags);
+	/* TX_RQ: logic write */
+	wr_offset = readl(ld->gmac_iobase + TX_RQ_WR_ADDR);
+	/* TX_RQ: software read */
+	rd_offset = readl(ld->gmac_iobase + TX_RQ_RD_ADDR);
+	/* stop to reclaim tx skb */
+	writel(wr_offset, ld->gmac_iobase + TX_RQ_RD_ADDR);
+
+	/* TX_BQ: logic read */
+	rd_offset = readl(ld->gmac_iobase + TX_BQ_RD_ADDR);
+	if (!rd_offset)
+		rd_offset = (TX_DESC_NUM - 1) << DESC_BYTE_SHIFT;
+	else
+		rd_offset -= DESC_SIZE;
+	/* stop software tx skb */
+	writel(rd_offset, ld->gmac_iobase + TX_BQ_WR_ADDR);
+
+	for (i = 0; i < ld->TX_BQ.count; i++) {
+		if (!ld->TX_BQ.skb[i])
+			ld->TX_BQ.skb[i] = SKB_MAGIC;
+	}
+	spin_unlock_irqrestore(&ld->txlock, txflags);
+}
+
+static void higmac_monitor_func(struct timer_list *t);
+static void higmac_set_multicast_list(struct net_device *dev);
+
+static void higmac_hw_set_mac_addr(struct net_device *dev)
+{
+	struct higmac_netdev_local *priv = netdev_priv(dev);
+	unsigned char *mac = dev->dev_addr;
+	u32 val;
+
+	val = mac[1] | (mac[0] << 8); /* shift left 8 bits */
+	writel(val, priv->gmac_iobase + STATION_ADDR_HIGH);
+	/* mac 2 3 4 5 shift left 24 16 8 0 bits */
+	val = mac[5] | (mac[4] << 8) | (mac[3] << 16) | (mac[2] << 24);
+	writel(val, priv->gmac_iobase + STATION_ADDR_LOW);
+}
+
+static u32 higmac_rx_refill(struct higmac_netdev_local *priv);
+
+static void higmac_free_rx_skb(struct higmac_netdev_local *ld)
+{
+	struct sk_buff *skb = NULL;
+	int i;
+
+	for (i = 0; i < ld->RX_FQ.count; i++) {
+		skb = ld->RX_FQ.skb[i];
+		if (skb != NULL) {
+			ld->rx_skb[i] = NULL;
+			ld->RX_FQ.skb[i] = NULL;
+			if (skb == SKB_MAGIC)
+				continue;
+			dev_kfree_skb_any(skb);
+			/*
+			 * need to unmap the skb here
+			 * but there is no way to get the dma_addr here,
+			 * and unmap(TO_DEVICE) ops do nothing in fact,
+			 * so we ignore to call
+			 * dma_unmap_single(dev, dma_addr, skb->len,
+			 *      DMA_TO_DEVICE)
+			 */
+		}
+	}
+}
+
+static void higmac_free_tx_skb(struct higmac_netdev_local *ld)
+{
+	struct sk_buff *skb = NULL;
+	int i;
+
+	for (i = 0; i < ld->TX_BQ.count; i++) {
+		skb = ld->TX_BQ.skb[i];
+		if (skb != NULL) {
+			ld->tx_skb[i] = NULL;
+			ld->TX_BQ.skb[i] = NULL;
+			if (skb == SKB_MAGIC)
+				continue;
+			dev_kfree_skb_any(skb);
+			/* unmap the skb */
+		}
+	}
+}
+
+/* reset and re-config gmac */
+void higmac_restart(struct higmac_netdev_local *ld)
+{
+	unsigned long rxflags, txflags;
+	if (ld == NULL || ld->netdev == NULL)
+		return;
+	/* restart hw engine now */
+	higmac_mac_core_reset(ld);
+
+	spin_lock_irqsave(&ld->rxlock, rxflags);
+	spin_lock_irqsave(&ld->txlock, txflags);
+
+	higmac_free_rx_skb(ld);
+	higmac_free_tx_skb(ld);
+
+	pmt_reg_restore(ld);
+	higmac_hw_init(ld);
+	higmac_hw_set_mac_addr(ld->netdev);
+	higmac_hw_set_desc_addr(ld);
+
+	/* we don't set macif here, it will be set in adjust_link */
+	if (ld->netdev->flags & IFF_UP) {
+		/*
+		 * when resume, only do the following operations
+		 * when dev is up before suspend.
+		 */
+		higmac_rx_refill(ld);
+		higmac_set_multicast_list(ld->netdev);
+
+		higmac_hw_desc_enable(ld);
+		higmac_port_enable(ld);
+		higmac_irq_enable_all_queue(ld);
+	}
+	spin_unlock_irqrestore(&ld->txlock, txflags);
+	spin_unlock_irqrestore(&ld->rxlock, rxflags);
+}
+
+static int higmac_net_set_mac_address(struct net_device *dev, void *p)
+{
+	int ret;
+
+	ret = eth_mac_addr(dev, p);
+	if (!ret)
+		higmac_hw_set_mac_addr(dev);
+
+	return ret;
+}
+
+#define HIGMAC_LINK_CHANGE_PROTECT
+#define HIGMAC_MAC_TX_RESET_IN_LINKUP
+
+#ifdef HIGMAC_LINK_CHANGE_PROTECT
+#define HIGMAC_MS_TO_NS 1000000ULL
+#define HIGMAC_FLUSH_WAIT_TIME (100*HIGMAC_MS_TO_NS)
+/* protect code */
+static void higmac_linkup_flush(struct higmac_netdev_local *ld)
+{
+	int tx_bq_wr_offset, tx_bq_rd_offset;
+	unsigned long long time_limit, time_now;
+
+	time_now = sched_clock();
+	time_limit = time_now + HIGMAC_FLUSH_WAIT_TIME;
+
+	do {
+		tx_bq_wr_offset = readl(ld->gmac_iobase + TX_BQ_WR_ADDR);
+		tx_bq_rd_offset = readl(ld->gmac_iobase + TX_BQ_RD_ADDR);
+
+		time_now = sched_clock();
+		if (unlikely((long long)time_now -
+				(long long)time_limit >= 0))
+			break;
+	} while (tx_bq_rd_offset != tx_bq_wr_offset);
+
+	mdelay(1);
+}
+#endif
+
+#ifdef HIGMAC_MAC_TX_RESET_IN_LINKUP
+static void higmac_mac_tx_state_engine_reset(struct higmac_netdev_local *priv)
+{
+	u32 val;
+
+	val = readl(priv->gmac_iobase + MAC_CLEAR);
+	val |= BIT_TX_SOFT_RESET;
+	writel(val, priv->gmac_iobase + MAC_CLEAR);
+
+	mdelay(5); /* wait 5ms */
+
+	val = readl(priv->gmac_iobase + MAC_CLEAR);
+	val &= ~BIT_TX_SOFT_RESET;
+	writel(val, priv->gmac_iobase + MAC_CLEAR);
+}
+#endif
+
+static void higmac_adjust_link(struct net_device *dev)
+{
+	struct higmac_netdev_local *priv = NULL;
+	struct phy_device *phy = NULL;
+	bool link_status_changed = false;
+	if (dev == NULL)
+		return;
+	priv = netdev_priv(dev);
+	if (priv == NULL || priv->phy == NULL)
+		return;
+	phy = priv->phy;
+	if (phy->link) {
+		if ((priv->old_speed != phy->speed) ||
+				(priv->old_duplex != phy->duplex)) {
+#ifdef HIGMAC_LINK_CHANGE_PROTECT
+			unsigned long txflags;
+
+			spin_lock_irqsave(&priv->txlock, txflags);
+
+			higmac_linkup_flush(priv);
+#endif
+			higmac_config_port(dev, phy->speed, phy->duplex);
+#ifdef HIGMAC_MAC_TX_RESET_IN_LINKUP
+			higmac_mac_tx_state_engine_reset(priv);
+#endif
+#ifdef HIGMAC_LINK_CHANGE_PROTECT
+			spin_unlock_irqrestore(&priv->txlock, txflags);
+#endif
+			higmac_set_flow_ctrl_state(priv, phy->pause);
+
+			if (priv->autoeee)
+				init_autoeee(priv);
+
+			link_status_changed = true;
+			priv->old_link = 1;
+			priv->old_speed = phy->speed;
+			priv->old_duplex = phy->duplex;
+		}
+	} else if (priv->old_link) {
+		link_status_changed = true;
+		priv->old_link = 0;
+		priv->old_speed = SPEED_UNKNOWN;
+		priv->old_duplex = DUPLEX_UNKNOWN;
+	}
+
+	if (link_status_changed && netif_msg_link(priv))
+		phy_print_status(phy);
+}
+
+int higmac_tx_avail(struct higmac_netdev_local const *ld)
+{
+	unsigned int tx_bq_wr_offset, tx_bq_rd_offset;
+	if (ld == NULL)
+		return -ENOMEM;
+	tx_bq_wr_offset = readl(ld->gmac_iobase + TX_BQ_WR_ADDR);
+	tx_bq_rd_offset = readl(ld->gmac_iobase + TX_BQ_RD_ADDR);
+
+	return (tx_bq_rd_offset >> DESC_BYTE_SHIFT) + TX_DESC_NUM -
+		(tx_bq_wr_offset >> DESC_BYTE_SHIFT) - 1;
+}
+
+static int higmac_init_sg_desc_queue(struct higmac_netdev_local *ld)
+{
+	ld->sg_count = ld->TX_BQ.count + HIGMAC_SG_DESC_ADD;
+	if (has_cap_cci(ld->hw_cap)) {
+		ld->dma_sg_desc = kmalloc_array(ld->sg_count,
+						sizeof(struct sg_desc),
+						GFP_KERNEL);
+		if (ld->dma_sg_desc)
+			ld->dma_sg_phy = virt_to_phys(ld->dma_sg_desc);
+	} else {
+		ld->dma_sg_desc = (struct sg_desc *)dma_alloc_coherent(ld->dev,
+				  ld->sg_count * sizeof(struct sg_desc),
+				  &ld->dma_sg_phy, GFP_KERNEL);
+	}
+
+	if (!ld->dma_sg_desc) {
+		pr_err("alloc sg desc dma error!\n");
+		return -ENOMEM;
+	}
+#ifdef HIGMAC_TSO_DEBUG
+	pr_info("Higmac dma_sg_phy: 0x%pK\n", (void *)(uintptr_t)ld->dma_sg_phy);
+#endif
+
+	ld->sg_head = 0;
+	ld->sg_tail = 0;
+
+	return 0;
+}
+
+static void higmac_destroy_sg_desc_queue(struct higmac_netdev_local *ld)
+{
+	if (ld->dma_sg_desc) {
+		if (has_cap_cci(ld->hw_cap))
+			kfree(ld->dma_sg_desc);
+		else
+			dma_free_coherent(ld->dev,
+					  ld->sg_count * sizeof(struct sg_desc),
+					  ld->dma_sg_desc, ld->dma_sg_phy);
+		ld->dma_sg_desc = NULL;
+	}
+}
+
+static bool higmac_rx_fq_empty(struct higmac_netdev_local const *priv)
+{
+	u32 start, end;
+
+	start = readl(priv->gmac_iobase + RX_FQ_WR_ADDR);
+	end = readl(priv->gmac_iobase + RX_FQ_RD_ADDR);
+	if (start == end)
+		return true;
+	else
+		return false;
+}
+
+static bool higmac_rxq_has_packets(struct higmac_netdev_local const *priv, int rxq_id)
+{
+	u32 rx_bq_rd_reg, rx_bq_wr_reg;
+	u32 start, end;
+
+	rx_bq_rd_reg = rx_bq_rd_addr_queue(rxq_id);
+	rx_bq_wr_reg = rx_bq_wr_addr_queue(rxq_id);
+
+	start = readl(priv->gmac_iobase + rx_bq_rd_reg);
+	end = readl(priv->gmac_iobase + rx_bq_wr_reg);
+	if (start == end)
+		return false;
+	else
+		return true;
+}
+
+static void higmac_monitor_func(struct timer_list *t)
+{
+	struct higmac_netdev_local *ld = from_timer(ld, t, monitor);
+	struct net_device *dev = NULL;
+	u32 refill_cnt;
+
+	if (ld == NULL) {
+		higmac_trace(HIGMAC_NORMAL_LEVEL, "ld is null");
+		return;
+	}
+
+	if (ld->netdev == NULL) {
+		higmac_trace(HIGMAC_NORMAL_LEVEL, "ld->netdev is null");
+		return;
+	}
+	dev_hold(ld->netdev);
+	dev = ld->netdev;
+	if (!netif_running(dev)) {
+		dev_put(dev);
+		higmac_trace(HIGMAC_NORMAL_LEVEL, "network driver is stopped");
+		return;
+	}
+	dev_put(dev);
+
+	spin_lock(&ld->rxlock);
+	refill_cnt = higmac_rx_refill(ld);
+	if (!refill_cnt && higmac_rx_fq_empty(ld)) {
+		int rxq_id;
+
+		for (rxq_id = 0; rxq_id < ld->num_rxqs; rxq_id++) {
+			if (higmac_rxq_has_packets(ld, rxq_id))
+				napi_schedule(&ld->q_napi[rxq_id].napi);
+		}
+	}
+	spin_unlock(&ld->rxlock);
+
+	ld->monitor.expires = jiffies + HIGMAC_MONITOR_TIMER;
+	mod_timer(&ld->monitor, ld->monitor.expires);
+}
+
+static u32 higmac_rx_refill(struct higmac_netdev_local *priv)
+{
+	struct higmac_desc *desc = NULL;
+	struct sk_buff *skb = NULL;
+	struct cyclic_queue_info dma_info;
+	u32 len = HIETH_MAX_FRAME_SIZE;
+	dma_addr_t addr;
+	u32 refill_cnt = 0;
+	u32 i;
+	/* software write pointer */
+	dma_info.start = dma_cnt(readl(priv->gmac_iobase + RX_FQ_WR_ADDR));
+	/* logic read pointer */
+	dma_info.end = dma_cnt(readl(priv->gmac_iobase + RX_FQ_RD_ADDR));
+	dma_info.num = CIRC_SPACE(dma_info.start, dma_info.end, RX_DESC_NUM);
+
+	for (i = 0, dma_info.pos = dma_info.start; i < dma_info.num; i++) {
+		if (priv->RX_FQ.skb[dma_info.pos] || priv->rx_skb[dma_info.pos])
+			break;
+
+		skb = netdev_alloc_skb_ip_align(priv->netdev, len);
+		if (unlikely(skb == NULL))
+			break;
+
+		if (!has_cap_cci(priv->hw_cap)) {
+			addr = dma_map_single(priv->dev, skb->data, len,
+					      DMA_FROM_DEVICE);
+			if (dma_mapping_error(priv->dev, addr)) {
+				dev_kfree_skb_any(skb);
+				break;
+			}
+		} else {
+			addr = virt_to_phys(skb->data);
+		}
+
+		desc = priv->RX_FQ.desc + dma_info.pos;
+		desc->data_buff_addr = (u32)addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		desc->reserve31 = addr >> REG_BIT_WIDTH;
+#endif
+		priv->RX_FQ.skb[dma_info.pos] = skb;
+		priv->rx_skb[dma_info.pos] = skb;
+
+		desc->buffer_len = len - 1;
+		desc->data_len = 0;
+		desc->fl = 0;
+		desc->descvid = DESC_VLD_FREE;
+		desc->skb_id = dma_info.pos;
+
+		refill_cnt++;
+		dma_info.pos = dma_ring_incr(dma_info.pos, RX_DESC_NUM);
+	}
+
+	/*
+	 * This barrier is important here.  It is required to ensure
+	 * the ARM CPU flushes it's DMA write buffers before proceeding
+	 * to the next instruction, to ensure that GMAC will see
+	 * our descriptor changes in memory
+	 */
+	higmac_sync_barrier();
+
+	if (dma_info.pos != dma_info.start)
+		writel(dma_byte(dma_info.pos), priv->gmac_iobase + RX_FQ_WR_ADDR);
+
+	return refill_cnt;
+}
+
+static void higmac_rx_skbput(struct net_device *dev, struct sk_buff *skb,
+			     struct higmac_desc *desc, int rxq_id)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+	dma_addr_t addr;
+	u32 len;
+	int ret;
+
+	len = desc->data_len;
+
+	if (!has_cap_cci(ld->hw_cap)) {
+		addr = desc->data_buff_addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		addr |= (dma_addr_t)(desc->reserve31) << REG_BIT_WIDTH;
+#endif
+		dma_unmap_single(ld->dev, addr, HIETH_MAX_FRAME_SIZE,
+				 DMA_FROM_DEVICE);
+	}
+
+	skb_put(skb, len);
+	if (skb->len > HIETH_MAX_FRAME_SIZE) {
+		netdev_err(dev, "rcv len err, len = %d\n", skb->len);
+		dev->stats.rx_errors++;
+		dev->stats.rx_length_errors++;
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_NONE;
+
+#if defined(CONFIG_HIGMAC_RXCSUM)
+	ret = higmac_rx_checksum(dev, skb, desc);
+	if (unlikely(ret)) {
+		return;
+	}
+#endif
+	if ((dev->features & NETIF_F_RXHASH) && desc->has_hash)
+		skb_set_hash(skb, desc->rxhash, desc->l3_hash ?
+			     PKT_HASH_TYPE_L3 : PKT_HASH_TYPE_L4);
+
+	skb_record_rx_queue(skb, rxq_id);
+
+	napi_gro_receive(&ld->q_napi[rxq_id].napi, skb);
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += len;
+}
+
+static int higmac_rx_skb(struct net_device *dev, struct higmac_desc *desc,
+			 u16 skb_id, int rxq_id)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+	struct sk_buff *skb = NULL;
+
+	spin_lock(&ld->rxlock);
+	skb = ld->rx_skb[skb_id];
+	if (unlikely(skb == NULL)) {
+		spin_unlock(&ld->rxlock);
+		netdev_err(dev, "inconsistent rx_skb\n");
+		return -1;
+	}
+
+	/* data consistent check */
+	if (unlikely(skb != ld->RX_FQ.skb[skb_id])) {
+		netdev_err(dev, "desc->skb(0x%p),RX_FQ.skb[%d](0x%p)\n",
+			   skb, skb_id, ld->RX_FQ.skb[skb_id]);
+		if (ld->RX_FQ.skb[skb_id] == SKB_MAGIC) {
+			spin_unlock(&ld->rxlock);
+			return 0;
+		}
+		WARN_ON(1);
+	} else {
+		ld->RX_FQ.skb[skb_id] = NULL;
+	}
+	spin_unlock(&ld->rxlock);
+
+	higmac_rx_skbput(dev, skb, desc, rxq_id);
+	return 0;
+}
+
+static int higmac_rx(struct net_device *dev, int limit, int rxq_id)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+	struct higmac_desc *desc = NULL;
+	struct cyclic_queue_info dma_info;
+	u32 rx_bq_rd_reg, rx_bq_wr_reg;
+	u16 skb_id;
+	u32 i;
+
+	rx_bq_rd_reg = rx_bq_rd_addr_queue(rxq_id);
+	rx_bq_wr_reg = rx_bq_wr_addr_queue(rxq_id);
+
+	/* software read pointer */
+	dma_info.start = dma_cnt(readl(ld->gmac_iobase + rx_bq_rd_reg));
+	/* logic write pointer */
+	dma_info.end = dma_cnt(readl(ld->gmac_iobase + rx_bq_wr_reg));
+	dma_info.num = CIRC_CNT(dma_info.end, dma_info.start, RX_DESC_NUM);
+	if (dma_info.num > limit)
+		dma_info.num = limit;
+
+	/* ensure get updated desc */
+	rmb();
+	for (i = 0, dma_info.pos = dma_info.start; i < dma_info.num; i++) {
+		if (rxq_id)
+			desc = ld->pool[BASE_QUEUE_NUMS + rxq_id].desc + dma_info.pos;
+		else
+			desc = ld->RX_BQ.desc + dma_info.pos;
+		skb_id = desc->skb_id;
+
+		if (unlikely(higmac_rx_skb(dev, desc, skb_id, rxq_id)))
+			break;
+
+		spin_lock(&ld->rxlock);
+		ld->rx_skb[skb_id] = NULL;
+		spin_unlock(&ld->rxlock);
+		dma_info.pos = dma_ring_incr(dma_info.pos, RX_DESC_NUM);
+	}
+
+	if (dma_info.pos != dma_info.start)
+		writel(dma_byte(dma_info.pos), ld->gmac_iobase + rx_bq_rd_reg);
+
+	spin_lock(&ld->rxlock);
+	higmac_rx_refill(ld);
+	spin_unlock(&ld->rxlock);
+
+	return dma_info.num;
+}
+
+#ifdef HIGMAC_TSO_DEBUG
+unsigned int id_send;
+unsigned int id_free;
+struct send_pkt_info pkt_rec[MAX_RECORD];
+#endif
+
+static int higmac_check_tx_err(struct higmac_netdev_local *ld,
+			       struct higmac_tso_desc *tx_bq_desc, unsigned int desc_pos)
+{
+	unsigned int tx_err = tx_bq_desc->tx_err;
+
+	if (unlikely(tx_err & ERR_ALL)) {
+		struct sg_desc *desc_cur = NULL;
+		int *sg_word = NULL;
+		int i;
+
+		WARN((tx_err & ERR_ALL),
+		     "TX ERR: desc1=0x%x, desc2=0x%x, desc5=0x%x\n",
+		     tx_bq_desc->data_buff_addr,
+		     tx_bq_desc->desc1.val, tx_bq_desc->tx_err);
+
+		desc_cur = ld->dma_sg_desc + ld->TX_BQ.sg_desc_offset[desc_pos];
+		sg_word = (int *)desc_cur;
+		for (i = 0; i < sizeof(struct sg_desc) / sizeof(int); i++)
+			pr_err("%s,%d: sg_desc word[%d]=0x%x\n",
+			       __func__, __LINE__, i, sg_word[i]);
+
+		return -1;
+	}
+
+	return 0;
+}
+
+static void higmac_xmit_release_gso_sg(struct higmac_netdev_local *ld,
+				       struct higmac_tso_desc *tx_rq_desc, unsigned int desc_pos)
+{
+	struct sg_desc *desc_cur = NULL;
+	int nfrags = tx_rq_desc->desc1.tx.nfrags_num;
+	unsigned int desc_offset;
+	dma_addr_t addr;
+	size_t len;
+	int i;
+
+	desc_offset = ld->TX_BQ.sg_desc_offset[desc_pos];
+	WARN_ON(desc_offset != ld->sg_tail);
+	desc_cur = ld->dma_sg_desc + desc_offset;
+
+	addr = desc_cur->linear_addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	addr |= (dma_addr_t)(desc_cur->reserv3 >>
+			     SG_DESC_HI8_OFFSET) <<
+		REG_BIT_WIDTH;
+#endif
+	len = desc_cur->linear_len;
+	dma_unmap_single(ld->dev, addr, len, DMA_TO_DEVICE);
+	for (i = 0; i < nfrags; i++) {
+		addr = desc_cur->frags[i].addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		addr |= (dma_addr_t)
+			(desc_cur->frags[i].reserved >>
+			 SG_DESC_HI8_OFFSET) <<
+			REG_BIT_WIDTH;
+#endif
+		len = desc_cur->frags[i].size;
+		dma_unmap_page(ld->dev, addr, len,
+			       DMA_TO_DEVICE);
+	}
+}
+
+static int higmac_xmit_release_gso(struct higmac_netdev_local *ld,
+				   struct higmac_tso_desc *tx_rq_desc, unsigned int desc_pos)
+{
+	int pkt_type;
+	int nfrags = tx_rq_desc->desc1.tx.nfrags_num;
+	dma_addr_t addr;
+	size_t len;
+
+	if (unlikely(higmac_check_tx_err(ld, tx_rq_desc, desc_pos) < 0)) {
+		/* dev_close */
+		higmac_irq_disable_all_queue(ld);
+		higmac_hw_desc_disable(ld);
+
+		netif_carrier_off(ld->netdev);
+		netif_stop_queue(ld->netdev);
+
+		phy_stop(ld->phy);
+		del_timer_sync(&ld->monitor);
+		return -1;
+	}
+
+	if (tx_rq_desc->desc1.tx.tso_flag || nfrags)
+		pkt_type = PKT_SG;
+	else
+		pkt_type = PKT_NORMAL;
+
+	if (pkt_type == PKT_NORMAL) {
+		if (!has_cap_cci(ld->hw_cap)) {
+			addr = tx_rq_desc->data_buff_addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+			addr |= (dma_addr_t)(tx_rq_desc->reserve_desc2 &
+					     TX_DESC_HI8_MASK) <<
+				REG_BIT_WIDTH;
+#endif
+			len = tx_rq_desc->desc1.tx.data_len;
+			dma_unmap_single(ld->dev, addr, len, DMA_TO_DEVICE);
+		}
+	} else {
+		if (!has_cap_cci(ld->hw_cap))
+			higmac_xmit_release_gso_sg(ld, tx_rq_desc, desc_pos);
+
+		ld->sg_tail = (ld->sg_tail + 1) % ld->sg_count;
+	}
+
+#ifdef HIGMAC_TSO_DEBUG
+	if (id_free >= MAX_RECORD)
+		id_free = 0;
+	pkt_rec[id_free].status = 0;
+	id_free++;
+#endif
+
+	return 0;
+}
+
+static int higmac_xmit_reclaim_release(struct net_device *dev,
+				       struct sk_buff *skb, struct higmac_desc *desc, u32 pos)
+{
+	struct higmac_netdev_local *priv = netdev_priv(dev);
+	struct higmac_tso_desc *tso_desc = NULL;
+	dma_addr_t addr;
+
+	if (priv->tso_supported) {
+		tso_desc = (struct higmac_tso_desc *)desc;
+		return higmac_xmit_release_gso(priv, tso_desc, pos);
+	} else if (!has_cap_cci(priv->hw_cap)) {
+		addr = desc->data_buff_addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		addr |= (dma_addr_t)(desc->rxhash & TX_DESC_HI8_MASK) <<
+			REG_BIT_WIDTH;
+#endif
+		dma_unmap_single(priv->dev, addr, skb->len, DMA_TO_DEVICE);
+	}
+	return 0;
+}
+
+static void higmac_xmit_reclaim(struct net_device *dev)
+{
+	struct sk_buff *skb = NULL;
+	struct higmac_desc *desc = NULL;
+	struct higmac_netdev_local *priv = netdev_priv(dev);
+	unsigned int bytes_compl = 0;
+	unsigned int pkts_compl = 0;
+	struct cyclic_queue_info dma_info;
+	u32 i;
+
+	spin_lock(&priv->txlock);
+
+	/* software read */
+	dma_info.start = dma_cnt(readl(priv->gmac_iobase + TX_RQ_RD_ADDR));
+	/* logic write */
+	dma_info.end = dma_cnt(readl(priv->gmac_iobase + TX_RQ_WR_ADDR));
+	dma_info.num = CIRC_CNT(dma_info.end, dma_info.start, TX_DESC_NUM);
+
+	for (i = 0, dma_info.pos = dma_info.start; i < dma_info.num; i++) {
+		skb = priv->tx_skb[dma_info.pos];
+		if (unlikely(skb == NULL)) {
+			netdev_err(dev, "inconsistent tx_skb\n");
+			break;
+		}
+
+		if (skb != priv->TX_BQ.skb[dma_info.pos]) {
+			netdev_err(dev, "wired, tx skb[%d](%p) != skb(%p)\n",
+				   dma_info.pos, priv->TX_BQ.skb[dma_info.pos], skb);
+			if (priv->TX_BQ.skb[dma_info.pos] == SKB_MAGIC)
+				goto next;
+		}
+
+		pkts_compl++;
+		bytes_compl += skb->len;
+		desc = priv->TX_RQ.desc + dma_info.pos;
+		if (higmac_xmit_reclaim_release(dev, skb, desc, dma_info.pos) < 0)
+			break;
+
+		priv->TX_BQ.skb[dma_info.pos] = NULL;
+next:
+		priv->tx_skb[dma_info.pos] = NULL;
+		dev_consume_skb_any(skb);
+		dma_info.pos = dma_ring_incr(dma_info.pos, TX_DESC_NUM);
+	}
+
+	if (dma_info.pos != dma_info.start)
+		writel(dma_byte(dma_info.pos), priv->gmac_iobase + TX_RQ_RD_ADDR);
+
+	if (pkts_compl || bytes_compl)
+		netdev_completed_queue(dev, pkts_compl, bytes_compl);
+
+	if (unlikely(netif_queue_stopped(priv->netdev)) && pkts_compl)
+		netif_wake_queue(priv->netdev);
+
+	spin_unlock(&priv->txlock);
+}
+
+static int higmac_poll(struct napi_struct *napi, int budget)
+{
+	struct higmac_napi *q_napi = container_of(napi,
+						  struct higmac_napi, napi);
+	struct higmac_netdev_local *priv = q_napi->ndev_priv;
+	int work_done = 0;
+	int num;
+	u32 ints;
+	u32 raw_int_reg, raw_int_mask;
+
+	dev_hold(priv->netdev);
+	if (q_napi->rxq_id) {
+		raw_int_reg = RSS_RAW_PMU_INT;
+		raw_int_mask = def_int_mask_queue((u32)q_napi->rxq_id);
+	} else {
+		raw_int_reg = RAW_PMU_INT;
+		raw_int_mask = DEF_INT_MASK;
+	}
+
+	do {
+		if (!q_napi->rxq_id)
+			higmac_xmit_reclaim(priv->netdev);
+		num = higmac_rx(priv->netdev, budget - work_done, q_napi->rxq_id);
+		work_done += num;
+		if (work_done >= budget)
+			break;
+
+		ints = readl(priv->gmac_iobase + raw_int_reg);
+		ints &= raw_int_mask;
+		writel(ints, priv->gmac_iobase + raw_int_reg);
+	} while (ints || higmac_rxq_has_packets(priv, q_napi->rxq_id));
+
+	if (work_done < budget) {
+		napi_complete(napi);
+		higmac_irq_enable_queue(priv, q_napi->rxq_id);
+	}
+
+	dev_put(priv->netdev);
+	return work_done;
+}
+
+static irqreturn_t higmac_interrupt(int irq, void *dev_id)
+{
+	struct higmac_napi *q_napi = (struct higmac_napi *)dev_id;
+	struct higmac_netdev_local *ld = q_napi->ndev_priv;
+	u32 ints;
+	u32 raw_int_reg, raw_int_mask;
+
+	if (higmac_queue_irq_disabled(ld, q_napi->rxq_id))
+		return IRQ_NONE;
+
+	if (q_napi->rxq_id) {
+		raw_int_reg = RSS_RAW_PMU_INT;
+		raw_int_mask = def_int_mask_queue((u32)q_napi->rxq_id);
+	} else {
+		raw_int_reg = RAW_PMU_INT;
+		raw_int_mask = DEF_INT_MASK;
+	}
+
+	ints = readl(ld->gmac_iobase + raw_int_reg);
+	ints &= raw_int_mask;
+	writel(ints, ld->gmac_iobase + raw_int_reg);
+
+	if (likely(ints || higmac_rxq_has_packets(ld, q_napi->rxq_id))) {
+		higmac_irq_disable_queue(ld, q_napi->rxq_id);
+		napi_schedule(&q_napi->napi);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int higmac_xmit_gso_sg_frag(struct higmac_netdev_local *ld,
+				   struct sk_buff *skb, struct sg_desc *desc_cur,
+				   struct higmac_tso_desc *tx_bq_desc, unsigned int desc_pos)
+{
+	int nfrags = skb_shinfo(skb)->nr_frags;
+	dma_addr_t addr;
+	dma_addr_t dma_addr;
+	phys_addr_t phys_addr;
+	int i, ret;
+
+	for (i = 0; i < nfrags; i++) {
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+		int len = frag->size;
+
+		if (!has_cap_cci(ld->hw_cap)) {
+			dma_addr = skb_frag_dma_map(ld->dev, frag, 0,
+						    len, DMA_TO_DEVICE);
+			ret = dma_mapping_error(ld->dev, dma_addr);
+			if (unlikely(ret)) {
+				pr_err("skb frag DMA Mapping fail");
+				return -EFAULT;
+			}
+			desc_cur->frags[i].addr = (u32)dma_addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+			desc_cur->frags[i].reserved =
+				(dma_addr >> REG_BIT_WIDTH) <<
+				SG_DESC_HI8_OFFSET;
+#endif
+		} else {
+			phys_addr =
+				page_to_phys(skb_frag_page(frag)) + frag->page_offset;
+			desc_cur->frags[i].addr = (u32)phys_addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+			desc_cur->frags[i].reserved =
+				(phys_addr >> REG_BIT_WIDTH) <<
+				SG_DESC_HI8_OFFSET;
+#endif
+		}
+		desc_cur->frags[i].size = len;
+	}
+
+	addr = ld->dma_sg_phy + ld->sg_head * sizeof(struct sg_desc);
+	tx_bq_desc->data_buff_addr = (u32)addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	tx_bq_desc->reserve_desc2 = (addr >> REG_BIT_WIDTH) &
+				    TX_DESC_HI8_MASK;
+#endif
+	ld->TX_BQ.sg_desc_offset[desc_pos] = ld->sg_head;
+
+	ld->sg_head = (ld->sg_head + 1) % ld->sg_count;
+
+	return 0;
+}
+
+static int higmac_xmit_gso_sg(struct higmac_netdev_local *ld,
+			      struct sk_buff *skb,
+			      struct higmac_tso_desc *tx_bq_desc, unsigned int desc_pos)
+{
+	struct sg_desc *desc_cur = NULL;
+	dma_addr_t dma_addr;
+	phys_addr_t phys_addr;
+	int ret;
+
+	if (unlikely(((ld->sg_head + 1) % ld->sg_count) == ld->sg_tail)) {
+		/* SG pkt, but sg desc all used */
+		pr_err("WARNING: sg desc all used.\n");
+		return -EBUSY;
+	}
+
+	desc_cur = ld->dma_sg_desc + ld->sg_head;
+
+	/* deal with ipv6_id */
+	if (tx_bq_desc->desc1.tx.tso_flag &&
+			tx_bq_desc->desc1.tx.ip_ver == PKT_IPV6 &&
+			tx_bq_desc->desc1.tx.prot_type == PKT_UDP)
+		desc_cur->ipv6_id = ntohl(skb_shinfo(skb)->ip6_frag_id);
+
+	desc_cur->total_len = skb->len;
+	desc_cur->linear_len = skb_headlen(skb);
+	if (!has_cap_cci(ld->hw_cap)) {
+		dma_addr = dma_map_single(ld->dev, skb->data,
+					  desc_cur->linear_len,
+					  DMA_TO_DEVICE);
+		ret = dma_mapping_error(ld->dev, dma_addr);
+		if (unlikely(ret)) {
+			pr_err("DMA Mapping fail");
+			return -EFAULT;
+		}
+		desc_cur->linear_addr = (u32)dma_addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		desc_cur->reserv3 = (dma_addr >> REG_BIT_WIDTH) <<
+				    SG_DESC_HI8_OFFSET;
+#endif
+	} else {
+		phys_addr = virt_to_phys(skb->data);
+		desc_cur->linear_addr = (u32)phys_addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		desc_cur->reserv3 = (phys_addr >> REG_BIT_WIDTH) <<
+				    SG_DESC_HI8_OFFSET;
+#endif
+	}
+
+	ret = higmac_xmit_gso_sg_frag(ld, skb, desc_cur, tx_bq_desc, desc_pos);
+	if (unlikely(ret))
+		return ret;
+
+	return 0;
+}
+
+static int higmac_xmit_gso(struct higmac_netdev_local *ld, struct sk_buff *skb,
+			   struct higmac_tso_desc *tx_bq_desc, unsigned int desc_pos)
+{
+	int pkt_type = PKT_NORMAL;
+	int nfrags = skb_shinfo(skb)->nr_frags;
+	dma_addr_t addr;
+	int ret;
+
+	if (skb_is_gso(skb) || nfrags)
+		pkt_type = PKT_SG; /* TSO pkt or SG pkt */
+
+	ret = higmac_check_hw_capability(skb);
+	if (unlikely(ret))
+		return ret;
+
+	ret = higmac_get_pkt_info(ld, skb, tx_bq_desc);
+	if (unlikely(ret))
+		return ret;
+
+	if (pkt_type == PKT_NORMAL) {
+		if (!has_cap_cci(ld->hw_cap)) {
+			addr = dma_map_single(ld->dev, skb->data, skb->len, DMA_TO_DEVICE);
+			ret = dma_mapping_error(ld->dev, addr);
+			if (unlikely(ret)) {
+				pr_err("Normal Packet DMA Mapping fail.\n");
+				return -EFAULT;
+			}
+			tx_bq_desc->data_buff_addr = (u32)addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+			tx_bq_desc->reserve_desc2 = (addr >> REG_BIT_WIDTH) &
+						    TX_DESC_HI8_MASK;
+#endif
+		} else {
+			addr = virt_to_phys(skb->data);
+			tx_bq_desc->data_buff_addr = (u32)addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+			tx_bq_desc->reserve_desc2 = (addr >> REG_BIT_WIDTH) &
+						    TX_DESC_HI8_MASK;
+#endif
+		}
+	} else {
+		ret = higmac_xmit_gso_sg(ld, skb, tx_bq_desc, desc_pos);
+		if (unlikely(ret))
+			return ret;
+	}
+
+#ifdef HIGMAC_TSO_DEBUG
+	if (id_send >= MAX_RECORD)
+		id_send = 0;
+	memcpy(&pkt_rec[id_send].desc, tx_bq_desc, sizeof(struct higmac_tso_desc));
+	pkt_rec[id_send].status = 1;
+	id_send++;
+#endif
+	return 0;
+}
+
+static netdev_tx_t higmac_net_xmit(struct sk_buff *skb, struct net_device *dev);
+
+static netdev_tx_t higmac_sw_gso(struct higmac_netdev_local *ld,
+				 struct sk_buff *skb)
+{
+	struct sk_buff *segs = NULL;
+	struct sk_buff *curr_skb = NULL;
+	int ret;
+	int gso_segs = skb_shinfo(skb)->gso_segs;
+	if (gso_segs == 0 && skb_shinfo(skb)->gso_size != 0)
+		gso_segs = DIV_ROUND_UP(skb->len, skb_shinfo(skb)->gso_size);
+
+	/* Estimate the number of fragments in the worst case */
+	if (unlikely(higmac_tx_avail(ld) < gso_segs)) {
+		netif_stop_queue(ld->netdev);
+		if (higmac_tx_avail(ld) < gso_segs) {
+			ld->netdev->stats.tx_dropped++;
+			ld->netdev->stats.tx_fifo_errors++;
+			return NETDEV_TX_BUSY;
+		}
+		netif_wake_queue(ld->netdev);
+	}
+
+	segs = skb_gso_segment(skb, ld->netdev->features & ~(NETIF_F_CSUM_MASK |
+			       NETIF_F_SG | NETIF_F_GSO_SOFTWARE));
+	if (IS_ERR_OR_NULL(segs))
+		goto drop;
+
+	do {
+		curr_skb = segs;
+		segs = segs->next;
+		curr_skb->next = NULL;
+		ret = higmac_net_xmit(curr_skb, ld->netdev);
+		if (unlikely(ret != NETDEV_TX_OK))
+			pr_err_once("higmac_net_xmit error ret=%d\n", ret);
+	} while (segs != NULL);
+
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+
+drop:
+	dev_kfree_skb_any(skb);
+	ld->netdev->stats.tx_dropped++;
+	return NETDEV_TX_OK;
+}
+
+static int higmac_net_xmit_normal(struct sk_buff *skb, struct net_device *dev,
+				  struct higmac_desc *desc, u32 pos)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+	dma_addr_t addr;
+
+	if (!has_cap_cci(ld->hw_cap)) {
+		addr = dma_map_single(ld->dev, skb->data, skb->len, DMA_TO_DEVICE);
+		if (unlikely(dma_mapping_error(ld->dev, addr))) {
+			dev_kfree_skb_any(skb);
+			dev->stats.tx_dropped++;
+			ld->tx_skb[pos] = NULL;
+			ld->TX_BQ.skb[pos] = NULL;
+			return -1;
+		}
+		desc->data_buff_addr = (u32)addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		desc->rxhash = (addr >> REG_BIT_WIDTH) & TX_DESC_HI8_MASK;
+#endif
+	} else {
+		addr = virt_to_phys(skb->data);
+		desc->data_buff_addr = (u32)addr;
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+		desc->rxhash = (addr >> REG_BIT_WIDTH) & TX_DESC_HI8_MASK;
+#endif
+	}
+	desc->buffer_len = HIETH_MAX_FRAME_SIZE - 1;
+	desc->data_len = skb->len;
+	desc->fl = DESC_FL_FULL;
+	desc->descvid = DESC_VLD_BUSY;
+
+	return 0;
+}
+
+static int higmac_check_skb_len(struct sk_buff *skb, struct net_device *dev)
+{
+	if (skb->len < ETH_HLEN) {
+		dev_kfree_skb_any(skb);
+		dev->stats.tx_errors++;
+		dev->stats.tx_dropped++;
+		return -1;
+	}
+	return 0;
+}
+
+static netdev_tx_t higmac_net_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+	struct higmac_desc *desc = NULL;
+	unsigned long txflags;
+	int ret;
+	u32 pos;
+
+	if (unlikely(higmac_check_skb_len(skb, dev) < 0))
+		return NETDEV_TX_OK;
+
+	/*
+	 * if adding higmac_xmit_reclaim here, iperf tcp client
+	 * performance will be affected, from 550M(avg) to 513M~300M
+	 */
+
+	/* software write pointer */
+	pos = dma_cnt(readl(ld->gmac_iobase + TX_BQ_WR_ADDR));
+
+	spin_lock_irqsave(&ld->txlock, txflags);
+
+	if (unlikely(ld->tx_skb[pos] || ld->TX_BQ.skb[pos])) {
+		dev->stats.tx_dropped++;
+		dev->stats.tx_fifo_errors++;
+		netif_stop_queue(dev);
+		spin_unlock_irqrestore(&ld->txlock, txflags);
+
+		return NETDEV_TX_BUSY;
+	}
+
+	ld->TX_BQ.skb[pos] = skb;
+	ld->tx_skb[pos] = skb;
+
+	desc = ld->TX_BQ.desc + pos;
+
+	if (ld->tso_supported) {
+		ret = higmac_xmit_gso(ld, skb, (struct higmac_tso_desc *)desc, pos);
+		if (unlikely(ret < 0)) {
+			ld->tx_skb[pos] = NULL;
+			ld->TX_BQ.skb[pos] = NULL;
+			spin_unlock_irqrestore(&ld->txlock, txflags);
+
+			if (ret == -ENOTSUPP)
+				return higmac_sw_gso(ld, skb);
+
+			dev_kfree_skb_any(skb);
+			dev->stats.tx_dropped++;
+			return NETDEV_TX_OK;
+		}
+	} else {
+		ret = higmac_net_xmit_normal(skb, dev, desc, pos);
+		if (unlikely(ret < 0)) {
+			spin_unlock_irqrestore(&ld->txlock, txflags);
+			return NETDEV_TX_OK;
+		}
+	}
+
+	/*
+	 * This barrier is important here.  It is required to ensure
+	 * the ARM CPU flushes it's DMA write buffers before proceeding
+	 * to the next instruction, to ensure that GMAC will see
+	 * our descriptor changes in memory
+	 */
+	higmac_sync_barrier();
+	pos = dma_ring_incr(pos, TX_DESC_NUM);
+	writel(dma_byte(pos), ld->gmac_iobase + TX_BQ_WR_ADDR);
+
+	netif_trans_update(dev);
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+	netdev_sent_queue(dev, skb->len);
+
+	spin_unlock_irqrestore(&ld->txlock, txflags);
+
+	return NETDEV_TX_OK;
+}
+
+void higmac_enable_napi(struct higmac_netdev_local *priv)
+{
+	struct higmac_napi *q_napi = NULL;
+	int i;
+	if (priv == NULL)
+		return;
+	for (i = 0; i < priv->num_rxqs; i++) {
+		q_napi = &priv->q_napi[i];
+		napi_enable(&q_napi->napi);
+	}
+}
+
+void higmac_disable_napi(struct higmac_netdev_local *priv)
+{
+	struct higmac_napi *q_napi = NULL;
+	int i;
+	if (priv == NULL)
+		return;
+	for (i = 0; i < priv->num_rxqs; i++) {
+		q_napi = &priv->q_napi[i];
+		napi_disable(&q_napi->napi);
+	}
+}
+
+static int higmac_net_open(struct net_device *dev)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+	unsigned long flags;
+
+	clk_prepare_enable(ld->macif_clk);
+	clk_prepare_enable(ld->clk);
+
+	/*
+	 * If we configure mac address by
+	 * "ifconfig ethX hw ether XX:XX:XX:XX:XX:XX",
+	 * the ethX must be down state and mac core clock is disabled
+	 * which results the mac address has not been configured
+	 * in mac core register.
+	 * So we must set mac address again here,
+	 * because mac core clock is enabled at this time
+	 * and we can configure mac address to mac core register.
+	 */
+	higmac_hw_set_mac_addr(dev);
+
+	/*
+	 * We should use netif_carrier_off() here,
+	 * because the default state should be off.
+	 * And this call should before phy_start().
+	 */
+	netif_carrier_off(dev);
+	higmac_enable_napi(ld);
+	phy_start(ld->phy);
+
+	higmac_hw_desc_enable(ld);
+	higmac_port_enable(ld);
+	higmac_irq_enable_all_queue(ld);
+
+	spin_lock_irqsave(&ld->rxlock, flags);
+	higmac_rx_refill(ld);
+	spin_unlock_irqrestore(&ld->rxlock, flags);
+
+	ld->monitor.expires = jiffies + HIGMAC_MONITOR_TIMER;
+	mod_timer(&ld->monitor, ld->monitor.expires);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int higmac_net_close(struct net_device *dev)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+
+	higmac_irq_disable_all_queue(ld);
+	higmac_hw_desc_disable(ld);
+
+	higmac_disable_napi(ld);
+
+	netif_carrier_off(dev);
+	netif_stop_queue(dev);
+
+	phy_stop(ld->phy);
+	del_timer_sync(&ld->monitor);
+
+	clk_disable_unprepare(ld->clk);
+	clk_disable_unprepare(ld->macif_clk);
+
+	return 0;
+}
+
+static void higmac_net_timeout(struct net_device *dev)
+{
+	dev->stats.tx_errors++;
+
+	pr_err("tx timeout!\n");
+}
+
+static void higmac_set_multicast_list(struct net_device *dev)
+{
+	higmac_gmac_multicast_list(dev);
+}
+
+static void higmac_enable_rxcsum_drop(struct higmac_netdev_local const *ld,
+		  bool drop)
+{
+	unsigned int v;
+
+	v = readl(ld->gmac_iobase + TSO_COE_CTRL);
+	if (drop)
+		v |= COE_ERR_DROP;
+	else
+		v &= ~COE_ERR_DROP;
+	writel(v, ld->gmac_iobase + TSO_COE_CTRL);
+}
+
+static int higmac_set_features(struct net_device *dev,
+			       netdev_features_t features)
+{
+	struct higmac_netdev_local *ld = netdev_priv(dev);
+	netdev_features_t changed = dev->features ^ features;
+
+	if (changed & NETIF_F_RXCSUM) {
+		if (features & NETIF_F_RXCSUM)
+			higmac_enable_rxcsum_drop(ld, true);
+		else
+			higmac_enable_rxcsum_drop(ld, false);
+	}
+
+	return 0;
+}
+
+static struct net_device_stats *higmac_net_get_stats(struct net_device *dev)
+{
+	return &dev->stats;
+}
+
+static const struct ethtool_ops hieth_ethtools_ops = {
+	.get_drvinfo = higmac_get_drvinfo,
+	.get_link = higmac_get_link,
+	.get_settings = higmac_get_settings,
+	.set_settings = higmac_set_settings,
+	.get_pauseparam = higmac_get_pauseparam,
+	.set_pauseparam = higmac_set_pauseparam,
+	.get_msglevel = higmac_ethtool_getmsglevel,
+	.set_msglevel = higmac_ethtool_setmsglevel,
+	.get_rxfh_key_size = higmac_get_rxfh_key_size,
+	.get_rxfh_indir_size = higmac_get_rxfh_indir_size,
+	.get_rxfh = higmac_get_rxfh,
+	.set_rxfh = higmac_set_rxfh,
+	.get_rxnfc = higmac_get_rxnfc,
+	.set_rxnfc = higmac_set_rxnfc,
+};
+
+static const struct net_device_ops hieth_netdev_ops = {
+	.ndo_open = higmac_net_open,
+	.ndo_stop = higmac_net_close,
+	.ndo_start_xmit = higmac_net_xmit,
+	.ndo_tx_timeout = higmac_net_timeout,
+	.ndo_set_rx_mode = higmac_set_multicast_list,
+	.ndo_set_features = higmac_set_features,
+	.ndo_do_ioctl = higmac_ioctl,
+	.ndo_set_mac_address = higmac_net_set_mac_address,
+	.ndo_change_mtu = eth_change_mtu,
+	.ndo_get_stats = higmac_net_get_stats,
+};
+
+static int higmac_of_get_param(struct higmac_netdev_local *ld,
+			       struct device_node const *node)
+{
+	/* get auto eee */
+	ld->autoeee = of_property_read_bool(node, "autoeee");
+	/* get internal flag */
+	ld->internal_phy =
+		of_property_read_bool(node, "internal-phy");
+
+	return 0;
+}
+
+static void higmac_destroy_hw_desc_queue(struct higmac_netdev_local *priv)
+{
+	int i;
+
+	for (i = 0; i < QUEUE_NUMS + RSS_NUM_RXQS - 1; i++) {
+		if (priv->pool[i].desc) {
+			if (has_cap_cci(priv->hw_cap))
+				kfree(priv->pool[i].desc);
+			else
+				dma_free_coherent(priv->dev, priv->pool[i].size,
+						  priv->pool[i].desc,
+						  priv->pool[i].phys_addr);
+			priv->pool[i].desc = NULL;
+		}
+	}
+
+	kfree(priv->RX_FQ.skb);
+	kfree(priv->TX_BQ.skb);
+	priv->RX_FQ.skb = NULL;
+	priv->TX_BQ.skb = NULL;
+
+	if (priv->tso_supported) {
+		kfree(priv->TX_BQ.sg_desc_offset);
+		priv->TX_BQ.sg_desc_offset = NULL;
+	}
+
+	kfree(priv->tx_skb);
+	priv->tx_skb = NULL;
+
+	kfree(priv->rx_skb);
+	priv->rx_skb = NULL;
+}
+
+static int higmac_init_desc_queue_mem(struct higmac_netdev_local *priv)
+{
+	priv->RX_FQ.skb = kzalloc(priv->RX_FQ.count
+				  * sizeof(struct sk_buff *), GFP_KERNEL);
+	if (!priv->RX_FQ.skb)
+		return -ENOMEM;
+
+	priv->rx_skb = kzalloc(priv->RX_FQ.count
+			       * sizeof(struct sk_buff *), GFP_KERNEL);
+	if (priv->rx_skb == NULL)
+		return -ENOMEM;
+
+	priv->TX_BQ.skb = kzalloc(priv->TX_BQ.count
+				  * sizeof(struct sk_buff *), GFP_KERNEL);
+	if (!priv->TX_BQ.skb)
+		return -ENOMEM;
+
+	priv->tx_skb = kzalloc(priv->TX_BQ.count
+			       * sizeof(struct sk_buff *), GFP_KERNEL);
+	if (priv->tx_skb == NULL)
+		return -ENOMEM;
+
+	if (priv->tso_supported) {
+		priv->TX_BQ.sg_desc_offset = kzalloc(priv->TX_BQ.count
+						     * sizeof(int), GFP_KERNEL);
+		if (!priv->TX_BQ.sg_desc_offset)
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int higmac_init_hw_desc_queue(struct higmac_netdev_local *priv)
+{
+	struct device *dev = NULL;
+	struct higmac_desc *virt_addr = NULL;
+	dma_addr_t phys_addr = 0;
+	int size, i;
+	if (priv == NULL || priv->dev == NULL)
+		return -EINVAL;
+	dev = priv->dev;
+	if (dev == NULL)
+		return -EINVAL;
+	priv->RX_FQ.count = RX_DESC_NUM;
+	priv->RX_BQ.count = RX_DESC_NUM;
+	priv->TX_BQ.count = TX_DESC_NUM;
+	priv->TX_RQ.count = TX_DESC_NUM;
+
+	for (i = 1; i < RSS_NUM_RXQS; i++)
+		priv->pool[BASE_QUEUE_NUMS + i].count = RX_DESC_NUM;
+
+	for (i = 0; i < (QUEUE_NUMS + RSS_NUM_RXQS - 1); i++) {
+		size = priv->pool[i].count * sizeof(struct higmac_desc);
+		if (has_cap_cci(priv->hw_cap)) {
+			virt_addr = kmalloc(size, GFP_KERNEL);
+			if (virt_addr != NULL) {
+				memset(virt_addr, 0, size);
+				phys_addr = virt_to_phys(virt_addr);
+			}
+		} else {
+			virt_addr = dma_alloc_coherent(dev, size, &phys_addr, GFP_KERNEL);
+			if (virt_addr != NULL)
+				memset(virt_addr, 0, size);
+		}
+		if (virt_addr == NULL)
+			goto error_free_pool;
+
+		priv->pool[i].size = size;
+		priv->pool[i].desc = virt_addr;
+		priv->pool[i].phys_addr = phys_addr;
+	}
+
+	if (higmac_init_desc_queue_mem(priv) == -ENOMEM)
+		goto error_free_pool;
+
+	higmac_hw_set_desc_addr(priv);
+	if (has_cap_cci(priv->hw_cap))
+		pr_info("higmac: ETH MAC supporte CCI.\n");
+
+	return 0;
+
+error_free_pool:
+	higmac_destroy_hw_desc_queue(priv);
+
+	return -ENOMEM;
+}
+
+void higmac_init_napi(struct higmac_netdev_local *priv)
+{
+	struct higmac_napi *q_napi = NULL;
+	int i;
+	if (priv == NULL || priv->netdev == NULL)
+		return;
+	for (i = 0; i < priv->num_rxqs; i++) {
+		q_napi = &priv->q_napi[i];
+		q_napi->rxq_id = i;
+		q_napi->ndev_priv = priv;
+		netif_napi_add(priv->netdev, &q_napi->napi, higmac_poll,
+			       NAPI_POLL_WEIGHT);
+	}
+}
+
+void higmac_destroy_napi(struct higmac_netdev_local *priv)
+{
+	struct higmac_napi *q_napi = NULL;
+	int i;
+	if (priv == NULL)
+		return;
+	for (i = 0; i < priv->num_rxqs; i++) {
+		q_napi = &priv->q_napi[i];
+		netif_napi_del(&q_napi->napi);
+	}
+}
+
+int higmac_request_irqs(struct platform_device *pdev,
+			struct higmac_netdev_local *priv)
+{
+	struct device *dev = NULL;
+	int ret;
+	int i;
+	if (pdev == NULL || priv == NULL || priv->dev == NULL || pdev->name == NULL)
+		return -ENOMEM;
+
+	dev = priv->dev;
+	for (i = 0; i < priv->num_rxqs; i++) {
+		ret = platform_get_irq(pdev, i);
+		if (ret < 0) {
+			dev_err(dev, "No irq[%d] resource, ret=%d\n", i, ret);
+			return ret;
+		}
+		priv->irq[i] = ret;
+
+		ret = devm_request_irq(dev, priv->irq[i], higmac_interrupt,
+				       IRQF_SHARED, pdev->name,
+				       &priv->q_napi[i]);
+		if (ret) {
+			dev_err(dev, "devm_request_irq failed, ret=%d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int higmac_dev_probe_res(struct platform_device *pdev,
+				struct higmac_netdev_local *priv)
+{
+	struct device *dev = &pdev->dev;
+	struct net_device *ndev = priv->netdev;
+	struct resource *res = NULL;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, MEM_GMAC_IOBASE);
+	priv->gmac_iobase = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->gmac_iobase)) {
+		ret = PTR_ERR(priv->gmac_iobase);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, MEM_MACIF_IOBASE);
+	priv->macif_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->macif_base)) {
+		ret = PTR_ERR(priv->macif_base);
+		return ret;
+	}
+
+	/* only for some chip to fix AXI bus burst and outstanding config */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, MEM_AXI_BUS_CFG_IOBASE);
+	priv->axi_bus_cfg_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->axi_bus_cfg_base))
+		priv->axi_bus_cfg_base = NULL;
+
+	priv->port_rst = devm_reset_control_get(dev, HIGMAC_PORT_RST_NAME);
+	if (IS_ERR(priv->port_rst)) {
+		ret = PTR_ERR(priv->port_rst);
+		return ret;
+	}
+
+	priv->macif_rst = devm_reset_control_get(dev, HIGMAC_MACIF_RST_NAME);
+	if (IS_ERR(priv->macif_rst)) {
+		ret = PTR_ERR(priv->macif_rst);
+		return ret;
+	}
+
+	priv->phy_rst = devm_reset_control_get(dev, HIGMAC_PHY_RST_NAME);
+	if (IS_ERR(priv->phy_rst))
+		priv->phy_rst = NULL;
+
+	priv->clk = devm_clk_get(&pdev->dev, HIGMAC_MAC_CLK_NAME);
+	if (IS_ERR(priv->clk)) {
+		netdev_err(ndev, "failed to get clk\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret < 0) {
+		netdev_err(ndev, "failed to enable clk %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int higmac_dev_macif_clk(struct platform_device *pdev,
+				struct higmac_netdev_local *priv, struct net_device *ndev)
+{
+	int ret;
+
+	priv->macif_clk = devm_clk_get(&pdev->dev, HIGMAC_MACIF_CLK_NAME);
+	if (IS_ERR(priv->macif_clk))
+		priv->macif_clk = NULL;
+
+	if (priv->macif_clk != NULL) {
+		ret = clk_prepare_enable(priv->macif_clk);
+		if (ret < 0) {
+			netdev_err(ndev, "failed enable macif_clk %d\n", ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int higmac_dev_probe_init(struct platform_device *pdev,
+				 struct higmac_netdev_local *priv, struct net_device *ndev)
+{
+	int ret;
+
+	higmac_init_napi(priv);
+	spin_lock_init(&priv->rxlock);
+	spin_lock_init(&priv->txlock);
+	spin_lock_init(&priv->pmtlock);
+
+	/* init netdevice */
+	ndev->irq = priv->irq[0];
+	ndev->watchdog_timeo = 3 * HZ; /* 3HZ */
+	ndev->netdev_ops = &hieth_netdev_ops;
+	ndev->ethtool_ops = &hieth_ethtools_ops;
+
+	if (priv->has_rxhash_cap)
+		ndev->hw_features |= NETIF_F_RXHASH;
+	if (priv->has_rss_cap)
+		ndev->hw_features |= NETIF_F_NTUPLE;
+	if (priv->tso_supported)
+		ndev->hw_features |= NETIF_F_SG |
+				     NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+				     NETIF_F_TSO | NETIF_F_TSO6;
+
+#if defined(CONFIG_HIGMAC_RXCSUM)
+	ndev->hw_features |= NETIF_F_RXCSUM;
+	higmac_enable_rxcsum_drop(priv, true);
+#endif
+
+	ndev->features |= ndev->hw_features;
+	ndev->features |= NETIF_F_HIGHDMA | NETIF_F_GSO;
+	ndev->vlan_features |= ndev->features;
+
+	timer_setup(&priv->monitor, higmac_monitor_func, 0);
+
+	device_set_wakeup_capable(priv->dev, 1);
+	/*
+	 * when we can let phy powerdown?
+	 * In some mode, we don't want phy powerdown,
+	 * so I set wakeup enable all the time
+	 */
+	device_set_wakeup_enable(priv->dev, 1);
+
+	priv->wol_enable = false;
+
+	priv->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);
+
+#if defined(CONFIG_HIGMAC_DDR_64BIT)
+	if (!has_cap_cci(priv->hw_cap)) {
+		struct device *dev = &pdev->dev;
+		ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64)); /* 64bit */
+		if (ret) {
+			pr_err("dma set mask 64 failed! ret=%d", ret);
+			return ret;
+		}
+	}
+#endif
+
+	/* init hw desc queue */
+	ret = higmac_init_hw_desc_queue(priv);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int higmac_dev_probe_phy(struct platform_device *pdev,
+				struct higmac_netdev_local *priv, struct net_device *ndev,
+				bool fixed_link)
+{
+	int ret;
+
+	/* phy fix here?? other way ??? */
+	higmac_phy_register_fixups();
+
+	priv->phy = of_phy_connect(ndev, priv->phy_node,
+				   &higmac_adjust_link, 0, priv->phy_mode);
+	if (priv->phy == NULL || priv->phy->drv == NULL) {
+		ret = -ENODEV;
+		return ret;
+	}
+
+	/* If the phy_id is all zero and not fixed link, there is no device there */
+	if ((priv->phy->phy_id == 0) && !fixed_link) {
+		pr_info("phy %d not found\n", priv->phy->mdio.addr);
+		ret = -ENODEV;
+		return ret;
+	}
+
+	pr_info("attached PHY %d to driver %s, PHY_ID=0x%x\n",
+		priv->phy->mdio.addr, priv->phy->drv->name, priv->phy->phy_id);
+
+	/* Stop Advertising 1000BASE Capability if interface is not RGMII */
+	if ((priv->phy_mode == PHY_INTERFACE_MODE_MII) ||
+			(priv->phy_mode == PHY_INTERFACE_MODE_RMII)) {
+		priv->phy->advertising &= ~(SUPPORTED_1000baseT_Half |
+					    SUPPORTED_1000baseT_Full);
+
+		/*
+		 * Internal FE phy's reg BMSR bit8 is wrong, make the kernel
+		 * believe it has the 1000base Capability, so fix it here
+		 */
+		if (priv->phy->phy_id == HISILICON_PHY_ID_FESTAV200)
+			priv->phy->supported &= ~(ADVERTISED_1000baseT_Full |
+						  ADVERTISED_1000baseT_Half);
+	}
+
+	higmac_set_flow_ctrl_args(priv);
+	higmac_set_flow_ctrl_params(priv);
+	priv->phy->supported |= SUPPORTED_Pause;
+	if (priv->flow_ctrl)
+		priv->phy->advertising |= SUPPORTED_Pause;
+
+	if (priv->autoeee)
+		init_autoeee(priv);
+
+	ret = higmac_request_irqs(pdev, priv);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void higmac_set_hw_cap(struct platform_device *pdev,
+			      struct higmac_netdev_local *priv)
+{
+	unsigned int hw_cap;
+
+	hw_cap = readl(priv->gmac_iobase + CRF_MIN_PACKET);
+	priv->tso_supported = has_tso_cap(hw_cap);
+	priv->has_rxhash_cap = has_rxhash_cap(hw_cap);
+	priv->has_rss_cap = has_rss_cap(hw_cap);
+
+	higmac_set_rss_cap(priv);
+	higmac_get_rss_key(priv);
+	if (priv->has_rss_cap) {
+		priv->rss_info.ind_tbl_size = RSS_INDIRECTION_TABLE_SIZE;
+		higmac_get_rss(priv);
+	}
+
+	if (priv->has_rxhash_cap) {
+		priv->rss_info.hash_cfg = DEF_HASH_CFG;
+		higmac_config_hash_policy(priv);
+	}
+}
+
+static void higmac_set_mac_addr(struct net_device *ndev,
+				struct device_node *node)
+{
+	const char *mac_addr = NULL;
+
+	mac_addr = of_get_mac_address(node);
+	if (mac_addr != NULL)
+		ether_addr_copy(ndev->dev_addr, mac_addr);
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		eth_hw_addr_random(ndev);
+		netdev_warn(ndev, "using random MAC address %pM\n",
+			    ndev->dev_addr);
+	}
+
+	higmac_hw_set_mac_addr(ndev);
+}
+
+static int higmac_phy_init(struct device *dev, struct net_device *ndev,
+			   struct higmac_netdev_local *priv, struct device_node *node, bool *fixed_link)
+{
+	int ret;
+
+	/*
+	 * phy reset, should be early than "of_mdiobus_register".
+	 * becausue "of_mdiobus_register" will read PHY register by MDIO.
+	 */
+	higmac_hw_phy_reset(priv);
+
+	higmac_of_get_param(priv, node);
+
+	ret = of_get_phy_mode(node);
+	if (ret < 0) {
+		netdev_err(ndev, "not find phy-mode\n");
+		return ret;
+	}
+	priv->phy_mode = ret;
+
+	priv->phy_node = of_parse_phandle(node, "phy-handle", 0);
+	if (priv->phy_node == NULL) {
+		/* check if a fixed-link is defined in device-tree */
+		if (of_phy_is_fixed_link(node)) {
+			ret = of_phy_register_fixed_link(node);
+			if (ret < 0) {
+				dev_err(dev, "cannot register fixed PHY %d\n", ret);
+				return ret;
+			}
+
+			/*
+			 * In the case of a fixed PHY, the DT node associated
+			 * to the PHY is the Ethernet MAC DT node.
+			 */
+			priv->phy_node = of_node_get(node);
+			*fixed_link = true;
+		} else {
+			netdev_err(ndev, "not find phy-handle\n");
+			ret = -EINVAL;
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int higmac_dev_probe_device(struct platform_device *pdev,
+				   struct net_device **p_ndev, struct higmac_netdev_local **p_priv)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct net_device *ndev = NULL;
+	struct higmac_netdev_local *priv = NULL;
+	int num_rxqs;
+
+	higmac_verify_flow_ctrl_args();
+
+	if (of_device_is_compatible(node, "hisilicon,higmac-v5"))
+		num_rxqs = RSS_NUM_RXQS;
+	else
+		num_rxqs = 1;
+
+	ndev = alloc_etherdev_mqs(sizeof(struct higmac_netdev_local), 1,
+				  num_rxqs);
+	if (ndev == NULL)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, ndev);
+	SET_NETDEV_DEV(ndev, dev);
+
+	priv = netdev_priv(ndev);
+	priv->dev = dev;
+	dev_hold(ndev);
+	priv->netdev = ndev;
+	priv->num_rxqs = num_rxqs;
+
+	if (of_device_is_compatible(node, "hisilicon,higmac-v3"))
+		priv->hw_cap |= HW_CAP_CCI;
+
+	*p_ndev = ndev;
+	*p_priv = priv;
+	return 0;
+}
+
+static int higmac_dev_probe_queue(struct platform_device *pdev,
+				  struct higmac_netdev_local *priv, struct net_device *ndev, bool fixed_link)
+{
+	int ret;
+
+	ret = higmac_dev_probe_init(pdev, priv, ndev);
+	if (ret)
+		goto _error_hw_desc_queue;
+
+	if (priv->tso_supported) {
+		ret = higmac_init_sg_desc_queue(priv);
+		if (ret)
+			goto _error_sg_desc_queue;
+	}
+
+	/* register netdevice */
+	ret = register_netdev(priv->netdev);
+	if (ret) {
+		pr_err("register_ndev failed!");
+		goto _error_sg_desc_queue;
+	}
+
+	/*
+	 * reset queue here to make BQL only reset once.
+	 * if we put netdev_reset_queue() in higmac_net_open(),
+	 * the BQL will be reset when ifconfig eth0 down and up,
+	 * but the tx ring is not cleared before.
+	 * As a result, the NAPI poll will call netdev_completed_queue()
+	 * and BQL throw a bug.
+	 */
+	netdev_reset_queue(ndev);
+
+	clk_disable_unprepare(priv->clk);
+	if (priv->macif_clk != NULL)
+		clk_disable_unprepare(priv->macif_clk);
+
+	pr_info("ETH: %s, phy_addr=%d\n",
+		phy_modes(priv->phy_mode), priv->phy->mdio.addr);
+
+	dev_put(ndev);
+	return ret;
+
+_error_sg_desc_queue:
+	if (priv->tso_supported)
+		higmac_destroy_sg_desc_queue(priv);
+_error_hw_desc_queue:
+	higmac_destroy_hw_desc_queue(priv);
+	higmac_destroy_napi(priv);
+
+	return ret;
+}
+
+static int higmac_dev_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct net_device *ndev = NULL;
+	struct higmac_netdev_local *priv = NULL;
+	int ret;
+	bool fixed_link = false;
+
+	ret = higmac_dev_probe_device(pdev, &ndev, &priv);
+	if (ret)
+		return ret;
+
+	ret = higmac_dev_probe_res(pdev, priv);
+	if (ret)
+		goto out_free_netdev;
+
+	ret = higmac_dev_macif_clk(pdev, priv, ndev);
+	if (ret)
+		goto out_clk_disable;
+
+	higmac_mac_core_reset(priv);
+
+	ret = higmac_phy_init(dev, ndev, priv, node, &fixed_link);
+	if (ret)
+		goto out_macif_clk_disable;
+
+	higmac_set_mac_addr(ndev, node);
+	higmac_set_hw_cap(pdev, priv);
+
+	/* init hw controller */
+	higmac_hw_init(priv);
+
+	ret = higmac_dev_probe_phy(pdev, priv, ndev, fixed_link);
+	if (ret) {
+		if (priv->phy == NULL)
+			goto out_phy_node;
+		else
+			goto out_phy_disconnect;
+	}
+
+	ret = higmac_dev_probe_queue(pdev, priv, ndev, fixed_link);
+	if (ret)
+		goto out_phy_disconnect;
+
+	return ret;
+
+out_phy_disconnect:
+	phy_disconnect(priv->phy);
+out_phy_node:
+	of_node_put(priv->phy_node);
+out_macif_clk_disable:
+	if (priv->macif_clk != NULL)
+		clk_disable_unprepare(priv->macif_clk);
+out_clk_disable:
+	clk_disable_unprepare(priv->clk);
+out_free_netdev:
+	dev_put(ndev);
+	free_netdev(ndev);
+
+	return ret;
+}
+
+static int higmac_dev_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+
+	/* stop the gmac and free all resource */
+	del_timer_sync(&priv->monitor);
+	higmac_destroy_napi(priv);
+
+	unregister_netdev(ndev);
+
+	higmac_reclaim_rx_tx_resource(priv);
+	higmac_free_rx_skb(priv);
+	higmac_free_tx_skb(priv);
+
+	if (priv->tso_supported)
+		higmac_destroy_sg_desc_queue(priv);
+	higmac_destroy_hw_desc_queue(priv);
+
+	phy_disconnect(priv->phy);
+	of_node_put(priv->phy_node);
+
+	free_netdev(ndev);
+
+	higmac_phy_unregister_fixups();
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static void higmac_disable_irq(struct higmac_netdev_local *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_rxqs; i++)
+		disable_irq(priv->irq[i]);
+}
+
+static void higmac_enable_irq(struct higmac_netdev_local *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_rxqs; i++)
+		enable_irq(priv->irq[i]);
+}
+
+int higmac_dev_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+
+	higmac_disable_irq(priv);
+	/*
+	 * If support Wake on LAN, we should not disconnect phy
+	 * because it will call phy_suspend to power down phy.
+	 */
+	if (!priv->wol_enable)
+		phy_disconnect(priv->phy);
+	del_timer_sync(&priv->monitor);
+	/*
+	 * If suspend when netif is not up, the napi_disable will run into
+	 * dead loop and dpm_drv_timeout will give warning.
+	 */
+	if (netif_running(ndev))
+		higmac_disable_napi(priv);
+	netif_device_detach(ndev);
+
+	netif_carrier_off(ndev);
+
+	/*
+	 * If netdev is down, MAC clock is disabled.
+	 * So if we want to reclaim MAC rx and tx resource,
+	 * we must first enable MAC clock and then disable it.
+	 */
+	if (!(ndev->flags & IFF_UP))
+		clk_prepare_enable(priv->clk);
+
+	higmac_reclaim_rx_tx_resource(priv);
+
+	if (!(ndev->flags & IFF_UP))
+		clk_disable_unprepare(priv->clk);
+
+	pmt_enter(priv);
+
+	if (!priv->wol_enable) {
+		/*
+		 * if no WOL, then poweroff
+		 * no need to call genphy_resume() in resume,
+		 * because we reset everything
+		 */
+		genphy_suspend(priv->phy); /* power down phy */
+		msleep(20); /* wait 20ms */
+		higmac_hw_all_clk_disable(priv);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(higmac_dev_suspend);
+
+int higmac_dev_resume(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+	int ret;
+
+	/*
+	 * If we support Wake on LAN, we doesn't call clk_disable.
+	 * But when we resume, the uboot may off mac clock and reset phy
+	 * by re-write the mac CRG register.
+	 * So we first call clk_disable, and then clk_enable.
+	 */
+	if (priv->wol_enable)
+		higmac_hw_all_clk_disable(priv);
+
+	higmac_hw_all_clk_enable(priv);
+	/* internal FE_PHY: enable clk and reset  */
+	higmac_hw_phy_reset(priv);
+
+	/*
+	 * If netdev is down, MAC clock is disabled.
+	 * So if we want to restart MAC and re-initialize it,
+	 * we must first enable MAC clock and then disable it.
+	 */
+	if (!(ndev->flags & IFF_UP))
+		clk_prepare_enable(priv->clk);
+
+	/* power on gmac */
+	higmac_restart(priv);
+
+	/*
+	 * If support WoL, we didn't disconnect phy.
+	 * But when we resume, we reset PHY, so we want to
+	 * call phy_connect to make phy_fixup excuted.
+	 * This is important for internal PHY fix.
+	 */
+	if (priv->wol_enable)
+		phy_disconnect(priv->phy);
+
+	ret = phy_connect_direct(ndev, priv->phy, higmac_adjust_link,
+				 priv->phy_mode);
+	if (ret)
+		return ret;
+
+	/*
+	 * If we suspend and resume when net device is down,
+	 * some operations are unnecessary.
+	 */
+	if (ndev->flags & IFF_UP) {
+		priv->monitor.expires = jiffies + HIGMAC_MONITOR_TIMER;
+		mod_timer(&priv->monitor, priv->monitor.expires);
+		priv->old_link = 0;
+		priv->old_speed = SPEED_UNKNOWN;
+		priv->old_duplex = DUPLEX_UNKNOWN;
+	}
+	if (netif_running(ndev))
+		higmac_enable_napi(priv);
+	netif_device_attach(ndev);
+	if (ndev->flags & IFF_UP)
+		phy_start(priv->phy);
+	higmac_enable_irq(priv);
+
+	pmt_exit(priv);
+
+	if (!(ndev->flags & IFF_UP))
+		clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(higmac_dev_resume);
+#else
+#define higmac_dev_suspend	NULL
+#define higmac_dev_resume	NULL
+#endif
+
+static const struct of_device_id higmac_of_match[] = {
+	{ .compatible = "hisilicon,higmac", },
+	{ .compatible = "hisilicon,higmac-v1", },
+	{ .compatible = "hisilicon,higmac-v2", },
+	{ .compatible = "hisilicon,higmac-v3", },
+	{ .compatible = "hisilicon,higmac-v4", },
+	{ .compatible = "hisilicon,higmac-v5", },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, higmac_of_match);
+
+static struct platform_driver higmac_dev_driver = {
+	.probe = higmac_dev_probe,
+	.remove = higmac_dev_remove,
+	.suspend = higmac_dev_suspend,
+	.resume = higmac_dev_resume,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = HIGMAC_DRIVER_NAME,
+		.of_match_table = higmac_of_match,
+	},
+};
+
+#include "proc_dev.c"
+
+static int __init higmac_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&higmac_dev_driver);
+	if (ret)
+		return ret;
+
+	higmac_proc_create();
+
+	return 0;
+}
+
+static void __exit higmac_exit(void)
+{
+	platform_driver_unregister(&higmac_dev_driver);
+
+	higmac_proc_destroy();
+}
+
+module_init(higmac_init);
+module_exit(higmac_exit);
+
+MODULE_AUTHOR("Hisilicon");
+MODULE_DESCRIPTION("Hisilicon double GMAC driver, base on driver higmacv200");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/hisilicon/higmac/higmac.h b/drivers/net/ethernet/hisilicon/higmac/higmac.h
new file mode 100644
index 000000000..2e26d8064
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/higmac.h
@@ -0,0 +1,603 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver main process head file
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#ifndef __HIGMAC_HIGMAC_H__
+#define __HIGMAC_HIGMAC_H__
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/list.h>
+#include <linux/phy.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+
+#define STATION_ADDR_LOW		0x0000
+#define STATION_ADDR_HIGH		0x0004
+#define MAC_DUPLEX_HALF_CTRL		0x0008
+
+#define PORT_MODE			0x0040
+
+#define PORT_EN				0x0044
+#define BITS_TX_EN			BIT(2)
+#define BITS_RX_EN			BIT(1)
+
+#define FC_TX_TIMER			0x001C
+
+#define PAUSE_THR			0x0038
+
+#define PAUSE_EN			0x0048
+#define BIT_RX_FDFC			BIT(0)
+#define BIT_TX_FDFC			BIT(1)
+
+#define RX_PAUSE_EN			0x02A4
+#define BIT_RX_FQ_PAUSE_EN		BIT(0)
+#define BIT_RX_BQ_PAUSE_EN		BIT(1)
+
+#define CRF_TX_PAUSE			0x0340
+
+#define BITS_Q_PAUSE_TH_OFFSET		16
+#define BITS_Q_PAUSE_TH_MASK		0xFFFF
+
+#define REC_FILT_CONTROL		0x0064
+#define BIT_CRC_ERR_PASS		BIT(5)
+#define BIT_PAUSE_FRM_PASS		BIT(4)
+#define BIT_VLAN_DROP_EN		BIT(3)
+#define BIT_BC_DROP_EN			BIT(2)
+#define BIT_MC_MATCH_EN			BIT(1)
+#define BIT_UC_MATCH_EN			BIT(0)
+
+#define	PORT_MC_ADDR_LOW		0x0068
+#define	PORT_MC_ADDR_HIGH		0x006C
+#define MAC_CLEAR			0x0070
+#define BIT_TX_SOFT_RESET		BIT(0)
+
+#define MODE_CHANGE_EN			0x01b4
+#define BIT_MODE_CHANGE_EN		BIT(0)
+
+#define COL_SLOT_TIME			0x01c0
+
+#define CRF_MIN_PACKET			0x0210
+#define BIT_OFFSET_TX_MIN_LEN		8
+#define BIT_MASK_TX_MIN_LEN		GENMASK(13, 8)
+
+#define CONTROL_WORD			0x0214
+#define CONTROL_WORD_CONFIG		0x640
+
+#define TSO_COE_CTRL			0x02e8
+#define BIT_COE_IPHDR_DROP		BIT(4)
+#define BIT_COE_PAYLOAD_DROP		BIT(5)
+#define BIT_COE_IPV6_UDP_ZERO_DROP	BIT(6)
+#define COE_ERR_DROP			(BIT_COE_IPHDR_DROP | \
+					BIT_COE_PAYLOAD_DROP | \
+					BIT_COE_IPV6_UDP_ZERO_DROP)
+
+#define RX_FQ_START_ADDR		0x0500
+#define RX_FQ_DEPTH			0x0504
+#define REG_BIT_WIDTH			32
+#define Q_ADDR_HI8_OFFSET		24
+#define Q_ADDR_HI8_MASK			(BIT(Q_ADDR_HI8_OFFSET) - 1)
+#define TX_DESC_HI8_MASK		0xff
+#define SG_DESC_HI8_OFFSET		8
+#define RX_FQ_WR_ADDR			0x0508
+#define BITS_RX_FQ_WR_ADDR		mk_bits(0, 21)
+#define RX_FQ_RD_ADDR			0x050c
+#define BITS_RX_FQ_RD_ADDR		mk_bits(0, 21)
+#define RX_FQ_VLDDESC_CNT		0x0510
+#define BITS_RX_FQ_VLDDESC_CNT		mk_bits(0, 16)
+#define RX_FQ_ALEMPTY_TH		0x0514
+#define BITS_RX_FQ_ALEMPTY_TH		mk_bits(0, 16)
+#define RX_FQ_REG_EN			0x0518
+#define BITS_RX_FQ_START_ADDR_EN	BIT(2)
+#define BITS_RX_FQ_DEPTH_EN		BIT(1)
+#define BITS_RX_FQ_RD_ADDR_EN		mk_bits(0, 1)
+#define RX_FQ_ALFULL_TH			0x051c
+#define BITS_RX_FQ_ALFULL_TH		mk_bits(0, 16)
+
+#define RX_BQ_START_ADDR		0x0520
+#define RX_BQ_DEPTH			0x0524
+#define RX_BQ_WR_ADDR			0x0528
+#define RX_BQ_RD_ADDR			0x052c
+#define RX_BQ_FREE_DESC_CNT		0x0530
+#define BITS_RX_BQ_FREE_DESC_CNT	mk_bits(0, 16)
+#define RX_BQ_ALEMPTY_TH		0x0534
+#define BITS_RX_BQ_ALEMPTY_TH		mk_bits(0, 16)
+#define RX_BQ_REG_EN			0x0538
+#define BITS_RX_BQ_START_ADDR_EN	BIT(2)
+#define BITS_RX_BQ_DEPTH_EN		BIT(1)
+#define BITS_RX_BQ_WR_ADDR_EN		mk_bits(0, 1)
+#define RX_BQ_ALFULL_TH			0x053c
+#define BITS_RX_BQ_ALFULL_TH		mk_bits(0, 16)
+
+#define TX_BQ_START_ADDR		0x0580
+#define TX_BQ_DEPTH			0x0584
+#define TX_BQ_WR_ADDR			0x0588
+#define BITS_TX_BQ_WR_ADDR		mk_bits(0, 21)
+#define TX_BQ_RD_ADDR			0x058c
+#define BITS_TX_BQ_RD_ADDR		mk_bits(0, 21)
+#define TX_BQ_VLDDESC_CNT		0x0590
+#define BITS_TX_BQ_VLDDESC_CNT		mk_bits(0, 16)
+#define TX_BQ_ALEMPTY_TH		0x0594
+#define BITS_TX_BQ_ALEMPTY_TH		mk_bits(0, 16)
+#define TX_BQ_REG_EN			0x0598
+#define BITS_TX_BQ_START_ADDR_EN	BIT(2)
+#define BITS_TX_BQ_DEPTH_EN		BIT(1)
+#define BITS_TX_BQ_RD_ADDR_EN		mk_bits(0, 1)
+#define TX_BQ_ALFULL_TH			0x059c
+#define BITS_TX_BQ_ALFULL_TH		mk_bits(0, 16)
+
+#define TX_RQ_START_ADDR		0x05a0
+#define TX_RQ_DEPTH			0x05a4
+#define TX_RQ_WR_ADDR			0x05a8
+#define BITS_TX_RQ_WR_ADDR		mk_bits(0, 21)
+#define TX_RQ_RD_ADDR			0x05ac
+#define BITS_TX_RQ_RD_ADDR		mk_bits(0, 21)
+#define TX_RQ_FREE_DESC_CNT		0x05b0
+#define BITS_TX_RQ_FREE_DESC_CNT	mk_bits(0, 16)
+#define TX_RQ_ALEMPTY_TH		0x05b4
+#define BITS_TX_RQ_ALEMPTY_TH		mk_bits(0, 16)
+#define TX_RQ_REG_EN			0x05b8
+#define BITS_TX_RQ_START_ADDR_EN	BIT(2)
+#define BITS_TX_RQ_DEPTH_EN		BIT(1)
+#define BITS_TX_RQ_WR_ADDR_EN		mk_bits(0, 1)
+#define TX_RQ_ALFULL_TH			0x05bc
+#define BITS_TX_RQ_ALFULL_TH		mk_bits(0, 16)
+
+#define RAW_PMU_INT			0x05c0
+#define ENA_PMU_INT			0x05c4
+
+#define DESC_WR_RD_ENA				0x05CC
+
+#define IN_QUEUE_TH					0x05d8
+#define BITS_OFFSET_TX_RQ_IN_TH			16
+
+#define RX_BQ_IN_TIMEOUT_TH			0x05E0
+
+#define TX_RQ_IN_TIMEOUT_TH			0x05e4
+
+#define STOP_CMD			0x05e8
+#define BITS_TX_STOP_EN			BIT(1)
+#define BITS_RX_STOP_EN			BIT(0)
+#define	STOP_RX_TX			(BITS_TX_STOP_EN | BITS_RX_STOP_EN)
+
+#define RSS_IND_TBL			0x0c0c
+#define BIT_IND_TBL_READY		BIT(13)
+#define BIT_IND_TLB_WR			BIT(12)
+#define RSS_RAW_PMU_INT			0x0c10
+#define RSS_QUEUE1_START_ADDR		0x0c20
+#define rx_bq_start_addr_queue(i)	(RSS_QUEUE1_START_ADDR + \
+					((i) - 1) * 0x10)
+#define RSS_QUEUE1_DEPTH		0x0c24
+#define RX_BQ_WR_ADDR_QUEUE1		0x0c28
+#define RX_BQ_RD_ADDR_QUEUE1		0x0c2c
+#define RSS_QUEUE1_ENA_INT		0x0c90
+#define rss_ena_int_queue(i)		(RSS_QUEUE1_ENA_INT + ((i) - 1) * 0x4)
+#define rx_bq_depth_queue(i)		(RSS_QUEUE1_DEPTH + ((i) - 1) * 0x10)
+#define rx_bq_wr_addr_queue(i)		((i) ? (RX_BQ_WR_ADDR_QUEUE1 + \
+					((i) - 1) * 0x10) : RX_BQ_WR_ADDR)
+#define rx_bq_rd_addr_queue(i)		((i) ? (RX_BQ_RD_ADDR_QUEUE1 + \
+					((i) - 1) * 0x10) : RX_BQ_RD_ADDR)
+
+#define def_int_mask_queue(i)		(0x3 << (2 * ((i) - 1)))
+
+/* AXI burst and outstanding config */
+#define BURST_OUTSTANDING_REG		0x3014
+#define BURST4_OUTSTANDING1		0x81ff
+#define BURST_OUTSTANDING_OFFSET	16
+
+#define GMAC_SPEED_1000			0x05
+#define GMAC_SPEED_100			0x01
+#define GMAC_SPEED_10			0x00
+
+#define IPV4_HEAD_LENGTH		0x5
+
+enum higmac_tx_err {
+	ERR_NONE = 0,
+	ERR_DESC_CFG = (1 << 0),
+	ERR_DATA_LEN = (1 << 1),
+	ERR_DESC_NFRAG_NUM = (1 << 2), /* bit2 */
+	ERR_DESC_IP_HDR_LEN = (1 << 3), /* bit3 */
+	ERR_DESC_PROT_HDR_LEN = (1 << 4), /* bit4 */
+	ERR_DESC_MTU = (1 << 5), /* bit5 */
+	ERR_LINK_SGPKT_LEN = (1 << 8), /* bit8 */
+	ERR_LINK_TSOPKT_LINEAR = (1 << 9), /* bit9 */
+	ERR_LINK_NFRAG_LEN = (1 << 10), /* bit10 */
+	ERR_LINK_TOTAL_LEN = (1 << 11), /* bit11 */
+	ERR_HDR_TCP_BCMC = (1 << 12), /* bit12 */
+	ERR_HDR_UDP_BC = (1 << 13), /* bit13 */
+	ERR_HDR_VLAN_IP_TYPE = (1 << 14), /* bit14 */
+	ERR_HDR_IP_TYPE = (1 << 15), /* bit15 */
+	ERR_HDR_IP_VERSION = (1 << 16), /* bit16 */
+	ERR_HDR_IP_HDR_LEN = (1 << 17), /* bit17 */
+	ERR_HDR_IP_TOTAL_LEN = (1 << 18), /* bit18 */
+	ERR_HDR_IPV6_TTL_PROT = (1 << 19), /* bit19 */
+	ERR_HDR_IPV4_OFFSET = (1 << 20), /* bit20 */
+	ERR_HDR_IPV4_TTL_PROT = (1 << 21), /* bit21 */
+	ERR_HDR_UDP_LEN = (1 << 22), /* bit22 */
+	ERR_HDR_TCP_LEN = (1 << 23), /* bit23 */
+	ERR_DESC = (ERR_DESC_CFG | ERR_DATA_LEN |
+		    ERR_DESC_NFRAG_NUM | ERR_DESC_IP_HDR_LEN |
+		    ERR_DESC_PROT_HDR_LEN | ERR_DESC_MTU),
+	ERR_LINK = (ERR_LINK_SGPKT_LEN | ERR_LINK_TSOPKT_LINEAR |
+		    ERR_LINK_NFRAG_LEN | ERR_LINK_TOTAL_LEN),
+	ERR_HDR = (ERR_HDR_TCP_BCMC | ERR_HDR_UDP_BC |
+		   ERR_HDR_VLAN_IP_TYPE | ERR_HDR_IP_TYPE |
+		   ERR_HDR_IP_VERSION | ERR_HDR_IP_HDR_LEN |
+		   ERR_HDR_IP_TOTAL_LEN | ERR_HDR_IPV6_TTL_PROT |
+		   ERR_HDR_IPV4_OFFSET | ERR_HDR_IPV4_TTL_PROT |
+		   ERR_HDR_UDP_LEN | ERR_HDR_TCP_LEN),
+	ERR_ALL = (ERR_DESC | ERR_LINK | ERR_HDR),
+};
+
+#define HIGMAC_DRIVER_NAME	"hi_gmac_v200"
+
+#define HIGMAC_MAC_CLK_NAME	"higmac_clk"
+#define HIGMAC_MACIF_CLK_NAME	"macif_clk"
+
+#define HIGMAC_PORT_RST_NAME	"port_reset"
+#define HIGMAC_MACIF_RST_NAME	"macif_reset"
+#define HIGMAC_PHY_RST_NAME	"phy_reset"
+
+#define HIGMAC_TSO_DEBUG
+
+#include "tso.h"
+
+#if defined(CONFIG_ARCH_HI3519) || defined(CONFIG_ARCH_HI3519V101) || \
+	defined(CONFIG_ARCH_HI3516AV200)
+#ifdef readl
+#undef readl
+#undef readl_relaxed
+#undef writel
+#undef writel_relaxed
+#define readl		hi_readl
+#define readl_relaxed	hi_readl_relaxed
+#define writel		hi_writel
+#define writel_relaxed	hi_writel_relaxed
+#endif /* readl */
+#endif /* defined(CONFIG_ARCH_HI3519) || defined(CONFIG_HI3519V101) */
+
+#define HIGMAC_IOSIZE			0x1000
+#define HIGMAC_OFFSET			(HIGMAC_IOSIZE)
+
+#define RX_BQ_IN_INT			BIT(17)
+#define TX_RQ_IN_INT			BIT(19)
+#define RX_BQ_IN_TIMEOUT_INT		BIT(28)
+#define TX_RQ_IN_TIMEOUT_INT		BIT(29)
+
+#define DEF_INT_MASK			(RX_BQ_IN_INT | RX_BQ_IN_TIMEOUT_INT | \
+					TX_RQ_IN_INT | TX_RQ_IN_TIMEOUT_INT)
+
+/* write or read descriptor need memory barrier */
+#define higmac_sync_barrier() do { isb(); smp_mb(); } while (0)
+
+#define HISILICON_PHY_ID_FESTAV200      0x20669823
+#define PHY_ID_KSZ8051MNL               0x00221550
+#define PHY_ID_KSZ8081RNB               0x00221560
+#define PHY_ID_UNKNOWN                  0x00221513
+#define DEFAULT_PHY_MASK                0xfffffff0
+#define REALTEK_PHY_ID_8211E            0x001cc915
+#define REALTEK_PHY_MASK                0x001fffff
+
+enum {
+	GMAC_PORT0,
+	GMAC_PORT1,
+	GMAC_MAX_PORT,
+};
+
+enum {
+	MEM_GMAC_IOBASE,
+	MEM_MACIF_IOBASE,
+	MEM_AXI_BUS_CFG_IOBASE,
+	MEM_FWD_IOBASE,
+	MEM_CTRL_IOBASE,
+};
+
+#define HIGMAC_LINKED		BIT(0)
+#define HIGMAC_DUP_FULL		BIT(1)
+#define HIGMAC_SPD_10M		BIT(2)
+#define HIGMAC_SPD_100M		BIT(3)
+#define HIGMAC_SPD_1000M	BIT(4)
+/* Flow Control defines */
+#define FLOW_OFF        0
+#define FLOW_RX         1
+#define FLOW_TX         2
+#define FLOW_AUTO       (FLOW_TX | FLOW_RX)
+
+#define RX_BQ_INT_THRESHOLD	0x40
+#define TX_RQ_INT_THRESHOLD	0x20
+
+#define HIGMAC_MONITOR_TIMER	(msecs_to_jiffies(200))
+
+#define HIETH_MAX_FRAME_SIZE	(1600 + 128)
+#define SKB_SIZE		(HIETH_MAX_FRAME_SIZE)
+
+#define DESC_VLD_FREE		0
+#define DESC_VLD_BUSY		1
+
+#define DESC_FL_FIRST		2
+#define DESC_FL_MID		0
+#define DESC_FL_LAST		1
+#define DESC_FL_FULL		3
+
+#if defined(CONFIG_HIGMAC_DESC_4WORD)
+#define DESC_WORD_SHIFT		2
+#else
+#define DESC_WORD_SHIFT		3
+#endif
+#define DESC_BYTE_SHIFT		(DESC_WORD_SHIFT + 2)
+#define DESC_WORD_CNT		(1 << DESC_WORD_SHIFT)
+#define DESC_SIZE		(1 << DESC_BYTE_SHIFT)
+
+#define RX_DESC_NUM			1024
+#define TX_DESC_NUM			1024
+
+/* DMA descriptor ring helpers */
+#define dma_ring_incr(n, s)		(((n) + 1) & ((s) - 1))
+#define dma_cnt(n)			((n) >> DESC_BYTE_SHIFT)
+#define dma_byte(n)			((n) << DESC_BYTE_SHIFT)
+
+#define RSS_HASH_KEY_SIZE		4
+#define RSS_INDIRECTION_TABLE_SIZE	128
+#define RSS_NUM_RXQS		4
+
+#define HW_CAP_TSO			BIT(0)
+#define HW_CAP_RXCSUM			BIT(1)
+#define HW_CAP_CCI			BIT(2)
+#define has_cap_tso(hw_cap)		((hw_cap) & HW_CAP_TSO)
+#define has_cap_rxcsum(hw_cap)		((hw_cap) & HW_CAP_RXCSUM)
+#define has_cap_cci(hw_cap)		((hw_cap) & HW_CAP_CCI)
+
+#if defined(CONFIG_HIGMAC_DESC_4WORD)
+struct higmac_desc {
+	unsigned int data_buff_addr;
+
+	unsigned int buffer_len : 11;
+#if defined(CONFIG_HIGMAC_RXCSUM)
+	unsigned int reserve2 : 1;
+	unsigned int payload_csum_err : 1;
+	unsigned int header_csum_err : 1;
+	unsigned int payload_csum_done : 1;
+	unsigned int header_csum_done : 1;
+#else
+	unsigned int reserve2 : 5;
+#endif
+	unsigned int data_len : 11;
+	unsigned int reserve1 : 2;
+	unsigned int fl : 2;
+	unsigned int descvid : 1;
+
+	unsigned int rxhash;
+	unsigned int reserve3 : 8;
+	unsigned int l3_hash : 1;
+	unsigned int has_hash : 1;
+	unsigned int skb_id : 14;
+	unsigned int reserve31 : 8;
+};
+
+struct higmac_tso_desc {
+	unsigned int data_buff_addr;
+	union {
+		struct {
+			unsigned int prot_hdr_len : 4;
+			unsigned int ip_hdr_len : 4;
+			unsigned int prot_type : 1;
+			unsigned int ip_ver : 1;
+			unsigned int vlan_flag : 1;
+			unsigned int nfrags_num : 5;
+			unsigned int data_len : 11;
+			unsigned int reservel : 1;
+			unsigned int tso_flag : 1;
+			unsigned int coe_flag : 1;
+			unsigned int sg_flag : 1;
+			unsigned int hw_own : 1;
+		} tx;
+		unsigned int val;
+	} desc1;
+	unsigned int reserve_desc2;
+	unsigned int tx_err;
+};
+#else
+struct higmac_desc {
+	unsigned int data_buff_addr;
+
+	unsigned int buffer_len : 11;
+#if defined(CONFIG_HIGMAC_RXCSUM)
+	unsigned int reserve2 : 1;
+	unsigned int payload_csum_err : 1;
+	unsigned int header_csum_err : 1;
+	unsigned int payload_csum_done : 1;
+#else
+	unsigned int reserve2 : 5;
+#endif
+	unsigned int data_len : 11;
+	unsigned int reserve1 : 2;
+	unsigned int fl : 2;
+	unsigned int descvid : 1;
+
+	unsigned int rxhash;
+	unsigned int reserve3 : 8;
+	unsigned int l3_hash : 1;
+	unsigned int has_hash : 1;
+	unsigned int skb_id : 14;
+	unsigned int reserve31 : 8;
+
+	unsigned int reserve4;
+	unsigned int reserve5;
+	unsigned int reserve6;
+	unsigned int reserve7;
+};
+
+struct higmac_tso_desc {
+	unsigned int data_buff_addr;
+	union {
+		struct {
+			unsigned int prot_hdr_len : 4;
+			unsigned int ip_hdr_len : 4;
+			unsigned int prot_type : 1;
+			unsigned int ip_ver : 1;
+			unsigned int vlan_flag : 1;
+			unsigned int nfrags_num : 5;
+			unsigned int data_len : 11;
+			unsigned int reservel : 1;
+			unsigned int tso_flag : 1;
+			unsigned int coe_flag : 1;
+			unsigned int sg_flag : 1;
+			unsigned int hw_own : 1;
+		} tx;
+		unsigned int val;
+	} desc1;
+	unsigned int reserve_desc2;
+	unsigned int reserve3;
+
+	unsigned int tx_err;
+	unsigned int reserve5;
+	unsigned int reserve6;
+	unsigned int reserve7;
+};
+#endif
+
+#define SKB_MAGIC	((struct sk_buff *)0x5a)
+
+struct higmac_napi {
+	struct napi_struct napi;
+	struct higmac_netdev_local *ndev_priv;
+	int rxq_id;
+};
+
+struct higmac_rss_info {
+	u32 hash_cfg;
+	u32 ind_tbl_size;
+	u8 ind_tbl[RSS_INDIRECTION_TABLE_SIZE];
+	u8 key[RSS_HASH_KEY_SIZE];
+};
+
+#define QUEUE_NUMS	4
+#define BASE_QUEUE_NUMS 3
+
+struct higmac_netdev_local {
+#define HIGMAC_SG_DESC_ADD	64U
+	struct sg_desc *dma_sg_desc ____cacheline_aligned;
+	dma_addr_t dma_sg_phy;
+	unsigned int sg_head;
+	unsigned int sg_tail;
+	unsigned int sg_count;
+
+	void __iomem *gmac_iobase;
+	void __iomem *macif_base;
+	void __iomem *axi_bus_cfg_base;
+	int index; /* 0 -- mac0, 1 -- mac1 */
+
+	u32 hw_cap;
+	bool tso_supported;
+	bool has_rxhash_cap;
+	bool has_rss_cap;
+	int num_rxqs;
+	struct higmac_napi q_napi[RSS_NUM_RXQS];
+	int irq[RSS_NUM_RXQS];
+	struct higmac_rss_info rss_info;
+
+	struct reset_control *port_rst;
+	struct reset_control *macif_rst;
+	struct reset_control *phy_rst;
+
+	struct {
+		struct higmac_desc *desc;
+		dma_addr_t phys_addr;
+		int *sg_desc_offset;
+		/* how many desc in the desc pool */
+		unsigned int count;
+		struct sk_buff **skb;
+		unsigned int size;
+	} pool[QUEUE_NUMS + RSS_NUM_RXQS - 1];
+#define RX_FQ		pool[0]
+#define RX_BQ		pool[1]
+#define TX_BQ		pool[2]
+#define TX_RQ		pool[3]
+
+	struct sk_buff **tx_skb;
+	struct sk_buff **rx_skb;
+
+	struct device *dev;
+	struct net_device *netdev;
+	struct clk *clk;
+	struct clk *macif_clk;
+
+	struct higmac_adapter *adapter;
+
+	struct timer_list monitor;
+
+	char phy_name[MII_BUS_ID_SIZE];
+	struct phy_device *phy;
+	struct device_node *phy_node;
+	phy_interface_t phy_mode;
+	bool autoeee;
+	bool internal_phy;
+	int (*eee_init)(struct phy_device *phy_dev);
+
+	unsigned int flow_ctrl;
+	unsigned int pause;
+	unsigned int pause_interval;
+	unsigned int flow_ctrl_active_threshold;
+	unsigned int flow_ctrl_deactive_threshold;
+
+	int old_link;
+	int old_speed;
+	int old_duplex;
+
+	/* receive packet lock */
+	spinlock_t rxlock;
+	/* transmit packet lock */
+	spinlock_t txlock;
+	/* power management lock */
+	spinlock_t pmtlock;
+
+	int dev_state; /* INIT/OPEN/CLOSE */
+	char pm_state;
+	bool wol_enable;
+	u32 msg_enable;
+#define INIT			0 /* init gmac */
+#define OPEN			1 /* power on gmac */
+#define CLOSE			2 /* power off gmac */
+};
+
+enum tso_version {
+	VER_NO_TSO = 0x0,
+	VER_BYTE_SPLICE = 0x1,
+	VER_SG_COE = 0x2,
+	VER_TSO = 0x3,
+};
+
+#ifdef HIGMAC_TSO_DEBUG
+#define MAX_RECORD	100
+struct send_pkt_info {
+	struct higmac_tso_desc desc;
+	int status;
+};
+#endif
+
+struct cyclic_queue_info {
+	u32 start;
+	u32 end;
+	u32 num;
+	u32 pos;
+};
+
+int higmac_tx_avail(struct higmac_netdev_local const *ld);
+
+/* board related func */
+void higmac_mac_core_reset(struct higmac_netdev_local *priv);
+void higmac_hw_internal_phy_reset(struct higmac_netdev_local *priv);
+void higmac_hw_external_phy_reset(struct higmac_netdev_local *priv);
+void higmac_internal_phy_clk_disable(struct higmac_netdev_local const *priv);
+void higmac_internal_phy_clk_enable(struct higmac_netdev_local const *priv);
+void higmac_hw_all_clk_disable(struct higmac_netdev_local *priv);
+void higmac_hw_all_clk_enable(struct higmac_netdev_local *priv);
+
+/* board independent func */
+void higmac_hw_phy_reset(struct higmac_netdev_local *priv);
+
+#endif
diff --git a/drivers/net/ethernet/hisilicon/higmac/pm.c b/drivers/net/ethernet/hisilicon/higmac/pm.c
new file mode 100644
index 000000000..4ad8e7c0c
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/pm.c
@@ -0,0 +1,341 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver pm process
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#include <linux/crc16.h>
+#include "pm.h"
+
+struct pm_reg_config pm_reg_config_backup;
+
+static void init_crc_table(void);
+static unsigned short compute_crc(const char *message, int nbytes);
+static unsigned short calculate_crc16(const char *buf, unsigned int mask)
+{
+	char data[N];
+	int i;
+	int len = 0;
+
+	memset(data, 0, sizeof(data));
+
+	for (i = 0; i < N; i++) {
+		if (mask & 0x1)
+			data[len++] = buf[i];
+
+		mask >>= 1;
+	}
+
+	return compute_crc(data, len);
+}
+
+/* use this func in config pm func */
+void _pmt_reg_backup(struct higmac_netdev_local const *ld)
+{
+	if (ld == NULL)
+		return;
+	pm_reg_config_backup.pmt_ctrl = readl(ld->gmac_iobase + PMT_CTRL);
+	pm_reg_config_backup.pmt_mask0 = readl(ld->gmac_iobase + PMT_MASK0);
+	pm_reg_config_backup.pmt_mask1 = readl(ld->gmac_iobase + PMT_MASK1);
+	pm_reg_config_backup.pmt_mask2 = readl(ld->gmac_iobase + PMT_MASK2);
+	pm_reg_config_backup.pmt_mask3 = readl(ld->gmac_iobase + PMT_MASK3);
+	pm_reg_config_backup.pmt_cmd = readl(ld->gmac_iobase + PMT_CMD);
+	pm_reg_config_backup.pmt_offset = readl(ld->gmac_iobase + PMT_OFFSET);
+	pm_reg_config_backup.pmt_crc1_0 = readl(ld->gmac_iobase + PMT_CRC1_0);
+	pm_reg_config_backup.pmt_crc3_2 = readl(ld->gmac_iobase + PMT_CRC3_2);
+}
+
+#define	PM_SET			1
+#define PM_CLEAR		0
+
+static void pmt_config_filter(struct pm_config const *config,
+			      struct higmac_netdev_local const *ld)
+{
+	unsigned int v;
+	unsigned int cmd = 0;
+	unsigned int offset = 0;
+	unsigned short crc[FILTERS] = { 0 };
+	int reg_mask;
+	unsigned int i;
+
+	/*
+	 * filter.valid		mask.valid	mask_bytes	effect
+	 *	0		*		*		no use the filter
+	 *	1		0		*	all pkts can wake-up(non-exist)
+	 *	1		1		0		all pkts can wake-up
+	 *	1		1		!0		normal filter
+	 */
+	/* setup filter */
+	for (i = 0; i < FILTERS; i++) {
+		if (config->filter[i].valid) {
+			if (config->filter[i].offset < PM_FILTER_OFFSET_MIN)
+				continue;
+			/* high 8 bits offset and low 8 bits valid bit */
+			offset |= config->filter[i].offset << (i * 8);
+			cmd |= BIT(i * 8); /* valid bit8 */
+			/* mask offset 4i */
+			reg_mask = PMT_MASK0 + (i * 4);
+
+			/*
+			 * for logic, mask valid bit(bit31) must set to 0,
+			 * 0 is enable
+			 */
+			v = config->filter[i].mask_bytes;
+			v &= ~BIT(31); /* bit31 */
+			writel(v, ld->gmac_iobase + reg_mask);
+
+			/* crc */
+			crc[i] = calculate_crc16(config->filter[i].value, v);
+			if (i <= 1) { /* for filter0 and filter 1 */
+				v = readl(ld->gmac_iobase + PMT_CRC1_0);
+				v &= ~(0xFFFF << (16 * i)); /* 16 bits mask */
+				v |= crc[i] << (16 * i); /* 16 bits mask */
+				writel(v, ld->gmac_iobase + PMT_CRC1_0);
+			} else { /* filter2 and filter3 */
+				v = readl(ld->gmac_iobase + PMT_CRC3_2);
+				v &= ~(0xFFFF << (16 * (i - 2))); /* filer 2 3, 16 bits mask */
+				v |= crc[i] << (16 * (i - 2)); /* filer 2 3, 16 bits mask */
+				writel(v, ld->gmac_iobase + PMT_CRC3_2);
+			}
+		}
+	}
+
+	if (cmd) {
+		writel(offset, ld->gmac_iobase + PMT_OFFSET);
+		writel(cmd, ld->gmac_iobase + PMT_CMD);
+	}
+}
+
+int pmt_config_gmac(struct pm_config const *config, struct higmac_netdev_local *ld)
+{
+	unsigned int v;
+	unsigned long flags;
+
+	if (ld == NULL || config == NULL)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ld->pmtlock, flags);
+	if (config->wakeup_pkts_enable) {
+		/* disable wakeup_pkts_enable before reconfig? */
+		v = readl(ld->gmac_iobase + PMT_CTRL);
+		v &= ~BIT(2); /* bit2 */
+		writel(v, ld->gmac_iobase + PMT_CTRL); /* any side effect? */
+	} else {
+		goto config_ctrl;
+	}
+
+	pmt_config_filter(config, ld);
+
+config_ctrl:
+	v = 0;
+	if (config->uc_pkts_enable)
+		v |= BIT(9); /* bit9 uc pkts wakeup */
+	if (config->wakeup_pkts_enable)
+		v |= BIT(2); /* bit2 use filter framework */
+	if (config->magic_pkts_enable)
+		v |= BIT(1); /* magic pkts wakeup */
+
+	v |= 0x3 << 5; /* set bit5 bit6, clear irq status */
+	writel(v, ld->gmac_iobase + PMT_CTRL);
+
+	_pmt_reg_backup(ld);
+
+	spin_unlock_irqrestore(&ld->pmtlock, flags);
+
+	return 0;
+}
+
+/* pmt_config will overwrite pre-config */
+int pmt_config(struct net_device const *ndev, struct pm_config const *config)
+{
+	static int init;
+	int ret;
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+
+	if (!init)
+		init_crc_table();
+
+	ret = pmt_config_gmac(config, priv);
+	if (ret)
+		return ret;
+
+	priv->pm_state = PM_SET;
+	priv->wol_enable = true;
+	device_set_wakeup_enable(priv->dev, 1);
+
+	return 0;
+}
+
+bool pmt_enter(struct higmac_netdev_local *ld)
+{
+	int pm = false;
+	unsigned long flags;
+	if (ld == NULL)
+		return -EINVAL;
+	spin_lock_irqsave(&ld->pmtlock, flags);
+	if (ld->pm_state == PM_SET) {
+		unsigned int v;
+
+		v = readl(ld->gmac_iobase + PMT_CTRL);
+		v |= BIT(0); /* enter power down */
+		v |= BIT(3); /* bit3, enable wakeup irq */
+		v |= 0x3 << 5; /* set bit5 bit6, clear irq status */
+		writel(v, ld->gmac_iobase + PMT_CTRL);
+
+		ld->pm_state = PM_CLEAR;
+		pm = true;
+	}
+	spin_unlock_irqrestore(&ld->pmtlock, flags);
+	return pm;
+}
+
+void pmt_exit(struct higmac_netdev_local *ld)
+{
+	unsigned int v;
+	unsigned long flags;
+	if (ld == NULL)
+		return;
+	/* logic auto exit power down mode */
+	spin_lock_irqsave(&ld->pmtlock, flags);
+
+	v = readl(ld->gmac_iobase + PMT_CTRL);
+	v &= ~BIT(0); /* enter power down */
+	v &= ~BIT(3); /* bit3, enable wakeup irq */
+
+	v |= 0x3 << 5; /* set bit5 bit6, clear irq status */
+	writel(v, ld->gmac_iobase + PMT_CTRL);
+
+	spin_unlock_irqrestore(&ld->pmtlock, flags);
+
+	ld->wol_enable = false;
+}
+
+void pmt_reg_restore(struct higmac_netdev_local *ld)
+{
+	unsigned int v;
+	unsigned long flags;
+	if (ld == NULL)
+		return;
+	spin_lock_irqsave(&ld->pmtlock, flags);
+	v = pm_reg_config_backup.pmt_mask0;
+	writel(v, ld->gmac_iobase + PMT_MASK0);
+
+	v = pm_reg_config_backup.pmt_mask1;
+	writel(v, ld->gmac_iobase + PMT_MASK1);
+
+	v = pm_reg_config_backup.pmt_mask2;
+	writel(v, ld->gmac_iobase + PMT_MASK2);
+
+	v = pm_reg_config_backup.pmt_mask3;
+	writel(v, ld->gmac_iobase + PMT_MASK3);
+
+	v = pm_reg_config_backup.pmt_cmd;
+	writel(v, ld->gmac_iobase + PMT_CMD);
+
+	v = pm_reg_config_backup.pmt_offset;
+	writel(v, ld->gmac_iobase + PMT_OFFSET);
+
+	v = pm_reg_config_backup.pmt_crc1_0;
+	writel(v, ld->gmac_iobase + PMT_CRC1_0);
+
+	v = pm_reg_config_backup.pmt_crc3_2;
+	writel(v, ld->gmac_iobase + PMT_CRC3_2);
+
+	v = pm_reg_config_backup.pmt_ctrl;
+	writel(v, ld->gmac_iobase + PMT_CTRL);
+	spin_unlock_irqrestore(&ld->pmtlock, flags);
+}
+
+/* ========the following code copy from Synopsys DWC_gmac_crc_example.c====== */
+#define CRC16 /* Change it to CRC16 for CRC16 Computation */
+
+#if defined(CRC16)
+#define CRC_NAME		"CRC-16"
+#define POLYNOMIAL		0x8005
+#define INITIAL_REMAINDER	0xFFFF
+#define FINAL_XOR_VALUE		0x0000
+#define REVERSE_DATA
+#undef REVERSE_REMAINDER
+#endif
+
+#define WIDTH    (8 * sizeof(unsigned short))
+#define TOPBIT   BIT(WIDTH - 1)
+
+#ifdef REVERSE_DATA
+#undef  REVERSE_DATA
+#define reverse_data(X)		((unsigned char)reverse((X), 8))
+#else
+#undef  REVERSE_DATA
+#define reverse_data(X)		(X)
+#endif
+
+#ifdef REVERSE_REMAINDER
+#undef  REVERSE_REMAINDER
+#define reverse_remainder(X)	((unsigned short)reverse((X), WIDTH))
+#else
+#undef  REVERSE_REMAINDER
+#define reverse_remainder(X)	(X)
+#endif
+
+#define CRC_TABLE_LEN	256
+static unsigned short crc_table[CRC_TABLE_LEN];
+
+static unsigned int reverse(unsigned int data, unsigned char nbits)
+{
+	unsigned int reversed = 0x00000000;
+	unsigned char bit;
+
+	/* Reverse the data about the center bit. */
+	for (bit = 0; bit < nbits; ++bit) {
+		/* If the LSB bit is set, set the reflection of it. */
+		if (data & 0x01)
+			reversed |= BIT((nbits - 1) - bit);
+
+		data = (data >> 1);
+	}
+	return reversed;
+}
+
+/* This Initializes the partial CRC look up table */
+static void init_crc_table(void)
+{
+	unsigned short remainder;
+	unsigned int dividend;
+	unsigned char bit;
+
+	/* Compute the remainder of each possible dividend. */
+	for (dividend = 0; dividend < CRC_TABLE_LEN; ++dividend) {
+		/* Start with the dividend followed by zeros, WIDTH - 8. */
+		remainder = (unsigned short)(dividend << (WIDTH - 8));
+
+		/* Perform modulo-2 division, a bit at a time for 8 times. */
+		for (bit = 8; bit > 0; --bit) {
+			/* Try to divide the current data bit. */
+			if (remainder & TOPBIT)
+				remainder = (remainder << 1) ^ POLYNOMIAL;
+			else
+				remainder = (remainder << 1);
+		}
+
+		/* Store the result into the table. */
+		crc_table[dividend] = remainder;
+	}
+}
+
+static unsigned short compute_crc(const char *message, int nbytes)
+{
+	unsigned short remainder = INITIAL_REMAINDER;
+	int byte;
+	unsigned char data;
+
+	/* Divide the message by the polynomial, a byte at a time. */
+	for (byte = 0; byte < nbytes; ++byte) {
+		/* high 8 bits */
+		data = reverse_data(message[byte]) ^ (remainder >> (WIDTH - 8));
+		remainder = crc_table[data] ^ (remainder << 8); /* shift left 8 bits */
+	}
+
+	/* The final remainder is the CRC. */
+	return (reverse_remainder(remainder) ^ FINAL_XOR_VALUE);
+}
diff --git a/drivers/net/ethernet/hisilicon/higmac/pm.h b/drivers/net/ethernet/hisilicon/higmac/pm.h
new file mode 100644
index 000000000..e54ced46c
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/pm.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Higmac driver pm head file
+ * Author: KTP_BSP
+ * Create: 2020-05-19
+ */
+
+#ifndef __HIGMAC_PM_H__
+#define __HIGMAC_PM_H__
+
+#include "higmac.h"
+
+#define N			31
+#define FILTERS			4
+#define PM_FILTER_OFFSET_MIN	12
+struct pm_config {
+	unsigned char index; /* bit0--eth0 bit1--eth1 */
+	unsigned char uc_pkts_enable;
+	unsigned char magic_pkts_enable;
+	unsigned char wakeup_pkts_enable;
+	struct {
+		unsigned int mask_bytes : N;
+		unsigned int reserved : 1; /* userspace ignore this bit */
+		unsigned char offset; /* >= 12 */
+		unsigned char value[N]; /* byte string */
+		unsigned char valid; /* valid filter */
+	} filter[FILTERS];
+};
+
+struct pm_reg_config {
+	unsigned int pmt_ctrl;
+	unsigned int pmt_mask0;
+	unsigned int pmt_mask1;
+	unsigned int pmt_mask2;
+	unsigned int pmt_mask3;
+	unsigned int pmt_cmd;
+	unsigned int pmt_offset;
+	unsigned int pmt_crc1_0;
+	unsigned int pmt_crc3_2;
+};
+
+#define PMT_CTRL		0xa00
+#define PMT_MASK0		0xa04
+#define PMT_MASK1		0xa08
+#define PMT_MASK2		0xa0c
+#define PMT_MASK3		0xa10
+#define PMT_CMD			0xa14
+#define PMT_OFFSET		0xa18
+#define PMT_CRC1_0		0xa1c
+#define PMT_CRC3_2		0xa20
+#define MASK_INVALID_BIT	BIT(31)
+
+
+int pmt_config(struct net_device const *ndev, struct pm_config const *config);
+bool pmt_enter(struct higmac_netdev_local *ld);
+void pmt_exit(struct higmac_netdev_local *ld);
+void pmt_reg_restore(struct higmac_netdev_local *ld);
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/ethernet/hisilicon/higmac/proc_dev.c b/drivers/net/ethernet/hisilicon/higmac/proc_dev.c
new file mode 100644
index 000000000..efb654fb4
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/proc_dev.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver proc dev process
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#include "sockioctl.h"
+#include "pm.h"
+
+/* debug code */
+static int set_suspend(int eth_n)
+{
+	return 0;
+}
+
+/* debug code */
+static int set_resume(int eth_n)
+{
+	return 0;
+}
+
+static int hw_states_read(struct seq_file *m, void *v)
+{
+	return 0;
+}
+
+static struct proc_dir_entry *higmac_proc_root;
+
+static int proc_open_hw_states_read(struct inode *inode, struct file *file)
+{
+	return single_open(file, hw_states_read, PDE_DATA(inode));
+}
+
+static struct proc_file {
+	char *name;
+	const struct file_operations ops;
+
+} proc_file[] = {
+	{
+		.name = "hw_stats",
+		.ops = {
+			.open           = proc_open_hw_states_read,
+			.read           = seq_read,
+			.llseek         = seq_lseek,
+			.release        = single_release,
+		},
+	}
+};
+
+/*
+ * /proc/higmac/
+ *	|---hw_stats
+ *	|---skb_pools
+ */
+void higmac_proc_create(void)
+{
+	int i;
+
+	higmac_proc_root = proc_mkdir("higmac", NULL);
+	if (higmac_proc_root == NULL)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(proc_file); i++) {
+		struct proc_dir_entry *entry;
+
+		entry = proc_create(proc_file[i].name, 0, higmac_proc_root,
+				    &proc_file[i].ops);
+		if (entry == NULL)
+			pr_err("failed to create %s\n", proc_file[i].name);
+	}
+}
+
+void higmac_proc_destroy(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(proc_file); i++)
+		remove_proc_entry(proc_file[i].name, higmac_proc_root);
+
+	remove_proc_entry("higmac", NULL);
+}
+
+int higmac_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
+{
+	struct higmac_netdev_local *priv = NULL;
+	struct pm_config config;
+	int val = 0;
+	if (ndev == NULL || rq == NULL)
+		return -EINVAL;
+	priv = netdev_priv(ndev);
+	switch (cmd) {
+	case SIOCSETPM:
+		if (rq->ifr_data == NULL ||
+				copy_from_user(&config, rq->ifr_data, sizeof(config)))
+			return -EFAULT;
+		return pmt_config(ndev, &config);
+
+	case SIOCSETSUSPEND:
+		if (rq->ifr_data == NULL || copy_from_user(&val, rq->ifr_data, sizeof(val)))
+			return -EFAULT;
+		return set_suspend(val);
+
+	case SIOCSETRESUME:
+		if (rq->ifr_data == NULL || copy_from_user(&val, rq->ifr_data, sizeof(val)))
+			return -EFAULT;
+		return set_resume(val);
+
+	default:
+		if (!netif_running(ndev))
+			return -EINVAL;
+
+		if (priv->phy == NULL)
+			return -EINVAL;
+
+		return phy_mii_ioctl(priv->phy, rq, cmd);
+	}
+	return 0;
+}
diff --git a/drivers/net/ethernet/hisilicon/higmac/sockioctl.h b/drivers/net/ethernet/hisilicon/higmac/sockioctl.h
new file mode 100644
index 000000000..349f0f215
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/sockioctl.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver sockioctl head file
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#ifndef __HIGMAC_SOCKIOCTL_H__
+#define __HIGMAC_SOCKIOCTL_H__
+
+#include <linux/sockios.h>
+
+#define SIOCSETPM	(SIOCDEVPRIVATE + 4) /* set pmt wake up config */
+#define SIOCSETSUSPEND	(SIOCDEVPRIVATE + 5) /* call dev->suspend, debug */
+#define SIOCSETRESUME	(SIOCDEVPRIVATE + 6) /* call dev->resume, debug */
+
+int higmac_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd);
+
+#endif
diff --git a/drivers/net/ethernet/hisilicon/higmac/tso.h b/drivers/net/ethernet/hisilicon/higmac/tso.h
new file mode 100644
index 000000000..6c78d1d45
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/tso.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver tso head file
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#ifndef __HIGMAC_TSO_H__
+#define __HIGMAC_TSO_H__
+
+#define SG_FLAG		BIT(30)
+#define COE_FLAG	BIT(29)
+#define TSO_FLAG	BIT(28)
+#define VLAN_FLAG	BIT(10)
+#define IPV6_FLAG	BIT(9)
+#define UDP_FLAG	BIT(8)
+
+#define PKT_IPV6_HDR_LEN	10
+#define PKT_UDP_HDR_LEN		2
+#define WORD_TO_BYTE		4
+enum {
+	PKT_NORMAL,
+	PKT_SG
+};
+
+enum {
+	PKT_IPV4,
+	PKT_IPV6
+};
+
+enum {
+	PKT_TCP,
+	PKT_UDP
+};
+
+struct frags_info {
+	/* Word(2*i+2) */
+	u32 addr;
+	/* Word(2*i+3) */
+	u32 size : 16;
+	u32 reserved : 16;
+};
+
+struct sg_desc {
+	/* Word0 */
+	u32 total_len : 17;
+	u32 reserv : 15;
+	/* Word1 */
+	u32 ipv6_id;
+	/* Word2 */
+	u32 linear_addr;
+	/* Word3 */
+	u32 linear_len : 16;
+	u32 reserv3 : 16;
+	/* MAX_SKB_FRAGS is 18 */
+	struct frags_info frags[18];
+};
+
+#endif
diff --git a/drivers/net/ethernet/hisilicon/higmac/util.c b/drivers/net/ethernet/hisilicon/higmac/util.c
new file mode 100644
index 000000000..eae79af52
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/util.c
@@ -0,0 +1,975 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Higmac driver util file
+ * Author: KTP_BSP
+ * Create: 2020-05-19
+ */
+
+#include <linux/kernel.h>
+#include <linux/if_vlan.h>
+#include <linux/ip.h>
+#include <net/ipv6.h>
+#include <linux/reset.h>
+#include "util.h"
+
+static unsigned int flow_ctrl_en = FLOW_OFF;
+static int tx_flow_ctrl_pause_time = CONFIG_TX_FLOW_CTRL_PAUSE_TIME;
+static int tx_flow_ctrl_pause_interval = CONFIG_TX_FLOW_CTRL_PAUSE_INTERVAL;
+static int tx_flow_ctrl_active_threshold = CONFIG_TX_FLOW_CTRL_ACTIVE_THRESHOLD;
+static int tx_flow_ctrl_deactive_threshold =
+				CONFIG_TX_FLOW_CTRL_DEACTIVE_THRESHOLD;
+
+void higmac_trace(int level, const char *fmt, ...)
+{
+	if (level >= HIGMAC_TRACE_LEVEL) {
+		va_list args;
+		va_start(args, fmt);
+		printk("higmac_trace:");
+		printk(fmt, args);
+		printk("\n");
+		va_end(args);
+	}
+}
+
+void higmac_config_port(struct net_device const *dev, u32 speed, u32 duplex)
+{
+	struct higmac_netdev_local *priv = netdev_priv(dev);
+	u32 val;
+
+	switch (priv->phy_mode) {
+	case PHY_INTERFACE_MODE_RGMII:
+		if (speed == SPEED_1000)
+			val = RGMII_SPEED_1000;
+		else if (speed == SPEED_100)
+			val = RGMII_SPEED_100;
+		else
+			val = RGMII_SPEED_10;
+		break;
+	case PHY_INTERFACE_MODE_MII:
+		if (speed == SPEED_100)
+			val = MII_SPEED_100;
+		else
+			val = MII_SPEED_10;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		if (speed == SPEED_100)
+			val = RMII_SPEED_100;
+		else
+			val = RMII_SPEED_10;
+		break;
+	default:
+		netdev_warn(dev, "not supported mode\n");
+		val = MII_SPEED_10;
+		break;
+	}
+
+	if (duplex)
+		val |= GMAC_FULL_DUPLEX;
+
+	reset_control_assert(priv->macif_rst);
+	writel_relaxed(val, priv->macif_base);
+	reset_control_deassert(priv->macif_rst);
+
+	writel_relaxed(BIT_MODE_CHANGE_EN, priv->gmac_iobase + MODE_CHANGE_EN);
+	if (speed == SPEED_1000)
+		val = GMAC_SPEED_1000;
+	else if (speed == SPEED_100)
+		val = GMAC_SPEED_100;
+	else
+		val = GMAC_SPEED_10;
+	writel_relaxed(val, priv->gmac_iobase + PORT_MODE);
+	writel_relaxed(0, priv->gmac_iobase + MODE_CHANGE_EN);
+	writel_relaxed(duplex, priv->gmac_iobase + MAC_DUPLEX_HALF_CTRL);
+}
+
+int higmac_rx_checksum(struct net_device *dev, struct sk_buff *skb,
+		  struct higmac_desc const *desc)
+{
+	int hdr_csum_done, payload_csum_done;
+	int hdr_csum_err, payload_csum_err;
+	if (skb == NULL || desc == NULL || dev == NULL)
+		return -EINVAL;
+	if (dev->features & NETIF_F_RXCSUM) {
+		hdr_csum_done =	desc->header_csum_done;
+		payload_csum_done =	desc->payload_csum_done;
+		hdr_csum_err = desc->header_csum_err;
+		payload_csum_err = desc->payload_csum_err;
+
+		if (hdr_csum_done && payload_csum_done) {
+			if (unlikely(hdr_csum_err || payload_csum_err)) {
+				dev->stats.rx_errors++;
+				dev->stats.rx_crc_errors++;
+				dev_kfree_skb_any(skb);
+				return -1;
+			} else {
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+			}
+		}
+	}
+	return 0;
+}
+
+void higmac_verify_flow_ctrl_args(void)
+{
+#if defined(CONFIG_TX_FLOW_CTRL_SUPPORT)
+	flow_ctrl_en |= FLOW_TX;
+#endif
+#if defined(CONFIG_RX_FLOW_CTRL_SUPPORT)
+	flow_ctrl_en |= FLOW_RX;
+#endif
+	if (tx_flow_ctrl_active_threshold < FC_ACTIVE_MIN ||
+		tx_flow_ctrl_active_threshold > FC_ACTIVE_MAX)
+		tx_flow_ctrl_active_threshold = FC_ACTIVE_DEFAULT;
+
+	if (tx_flow_ctrl_deactive_threshold < FC_DEACTIVE_MIN ||
+		tx_flow_ctrl_deactive_threshold > FC_DEACTIVE_MAX)
+		tx_flow_ctrl_deactive_threshold = FC_DEACTIVE_DEFAULT;
+
+	if (tx_flow_ctrl_active_threshold >= tx_flow_ctrl_deactive_threshold) {
+		tx_flow_ctrl_active_threshold = FC_ACTIVE_DEFAULT;
+		tx_flow_ctrl_deactive_threshold = FC_DEACTIVE_DEFAULT;
+	}
+
+	if (tx_flow_ctrl_pause_time < 0 ||
+		tx_flow_ctrl_pause_time > FC_PAUSE_TIME_MAX)
+		tx_flow_ctrl_pause_time = FC_PAUSE_TIME_DEFAULT;
+
+	if (tx_flow_ctrl_pause_interval < 0 ||
+		tx_flow_ctrl_pause_interval > FC_PAUSE_TIME_MAX)
+		tx_flow_ctrl_pause_interval = FC_PAUSE_INTERVAL_DEFAULT;
+
+	/*
+	 * pause interval should not bigger than pause time,
+	 * but should not too smaller to avoid sending too many pause frame.
+	 */
+	if ((tx_flow_ctrl_pause_interval > tx_flow_ctrl_pause_time) ||
+		(tx_flow_ctrl_pause_interval < ((unsigned int)tx_flow_ctrl_pause_time >> 1)))
+		tx_flow_ctrl_pause_interval = tx_flow_ctrl_pause_time;
+}
+
+void higmac_set_flow_ctrl_args(struct higmac_netdev_local *ld)
+{
+	if (ld == NULL)
+		return;
+	ld->flow_ctrl = flow_ctrl_en;
+	ld->pause = tx_flow_ctrl_pause_time;
+	ld->pause_interval = tx_flow_ctrl_pause_interval;
+	ld->flow_ctrl_active_threshold = tx_flow_ctrl_active_threshold;
+	ld->flow_ctrl_deactive_threshold = tx_flow_ctrl_deactive_threshold;
+}
+
+void higmac_set_flow_ctrl_params(struct higmac_netdev_local const *ld)
+{
+	unsigned int rx_fq_empty_th;
+	unsigned int rx_fq_full_th;
+	unsigned int rx_bq_empty_th;
+	unsigned int rx_bq_full_th;
+	unsigned int rec_filter;
+	if (ld == NULL)
+		return;
+	writel(ld->pause, ld->gmac_iobase + FC_TX_TIMER);
+	writel(ld->pause_interval, ld->gmac_iobase + PAUSE_THR);
+
+	rx_fq_empty_th = readl(ld->gmac_iobase + RX_FQ_ALEMPTY_TH);
+	rx_fq_empty_th &= ~(BITS_Q_PAUSE_TH_MASK << BITS_Q_PAUSE_TH_OFFSET);
+	rx_fq_empty_th |= (ld->flow_ctrl_active_threshold <<
+			BITS_Q_PAUSE_TH_OFFSET);
+	writel(rx_fq_empty_th, ld->gmac_iobase + RX_FQ_ALEMPTY_TH);
+
+	rx_fq_full_th = readl(ld->gmac_iobase + RX_FQ_ALFULL_TH);
+	rx_fq_full_th &= ~(BITS_Q_PAUSE_TH_MASK << BITS_Q_PAUSE_TH_OFFSET);
+	rx_fq_full_th |= (ld->flow_ctrl_deactive_threshold <<
+			BITS_Q_PAUSE_TH_OFFSET);
+	writel(rx_fq_full_th, ld->gmac_iobase + RX_FQ_ALFULL_TH);
+
+	rx_bq_empty_th = readl(ld->gmac_iobase + RX_BQ_ALEMPTY_TH);
+	rx_bq_empty_th &= ~(BITS_Q_PAUSE_TH_MASK << BITS_Q_PAUSE_TH_OFFSET);
+	rx_bq_empty_th |= (ld->flow_ctrl_active_threshold <<
+			BITS_Q_PAUSE_TH_OFFSET);
+	writel(rx_bq_empty_th, ld->gmac_iobase + RX_BQ_ALEMPTY_TH);
+
+	rx_bq_full_th = readl(ld->gmac_iobase + RX_BQ_ALFULL_TH);
+	rx_bq_full_th &= ~(BITS_Q_PAUSE_TH_MASK << BITS_Q_PAUSE_TH_OFFSET);
+	rx_bq_full_th |= (ld->flow_ctrl_deactive_threshold <<
+			BITS_Q_PAUSE_TH_OFFSET);
+	writel(rx_bq_full_th, ld->gmac_iobase + RX_BQ_ALFULL_TH);
+
+	writel(0, ld->gmac_iobase + CRF_TX_PAUSE);
+
+	rec_filter = readl(ld->gmac_iobase + REC_FILT_CONTROL);
+	rec_filter |= BIT_PAUSE_FRM_PASS;
+	writel(rec_filter, ld->gmac_iobase + REC_FILT_CONTROL);
+}
+
+void higmac_set_flow_ctrl_state(struct higmac_netdev_local const *ld, int pause)
+{
+	unsigned int flow_rx_q_en;
+	unsigned int flow;
+	if (ld == NULL)
+		return;
+	flow_rx_q_en = readl(ld->gmac_iobase + RX_PAUSE_EN);
+	flow_rx_q_en &= ~(BIT_RX_FQ_PAUSE_EN | BIT_RX_BQ_PAUSE_EN);
+	if (pause && (ld->flow_ctrl & FLOW_TX))
+		flow_rx_q_en |= (BIT_RX_FQ_PAUSE_EN | BIT_RX_BQ_PAUSE_EN);
+	writel(flow_rx_q_en, ld->gmac_iobase + RX_PAUSE_EN);
+
+	flow = readl(ld->gmac_iobase + PAUSE_EN);
+	flow &= ~(BIT_RX_FDFC | BIT_TX_FDFC);
+	if (pause) {
+		if (ld->flow_ctrl & FLOW_RX)
+			flow |= BIT_RX_FDFC;
+		if (ld->flow_ctrl & FLOW_TX)
+			flow |= BIT_TX_FDFC;
+	}
+	writel(flow, ld->gmac_iobase + PAUSE_EN);
+}
+
+static __be16 higmac_get_l3_proto(struct sk_buff *skb)
+{
+	__be16 l3_proto;
+
+	l3_proto = skb->protocol;
+	if (skb->protocol == htons(ETH_P_8021Q))
+		l3_proto = vlan_get_protocol(skb);
+
+	return l3_proto;
+}
+
+static unsigned int higmac_get_l4_proto(struct sk_buff *skb)
+{
+	__be16 l3_proto;
+	unsigned int l4_proto = IPPROTO_MAX;
+
+	l3_proto = higmac_get_l3_proto(skb);
+	if (l3_proto == htons(ETH_P_IP))
+		l4_proto = ip_hdr(skb)->protocol;
+	else if (l3_proto == htons(ETH_P_IPV6))
+		l4_proto = ipv6_hdr(skb)->nexthdr;
+
+	return l4_proto;
+}
+
+static inline bool higmac_skb_is_ipv6(struct sk_buff *skb)
+{
+	return (higmac_get_l3_proto(skb) == htons(ETH_P_IPV6));
+}
+
+static inline bool higmac_skb_is_udp(struct sk_buff *skb)
+{
+	return (higmac_get_l4_proto(skb) == IPPROTO_UDP);
+}
+
+static int higmac_check_hw_capability_for_udp(struct sk_buff const *skb)
+{
+	struct ethhdr *eth;
+
+	/* hardware can't dea with UFO broadcast packet */
+	eth = (struct ethhdr *)(skb->data);
+	if (skb_is_gso(skb) && is_broadcast_ether_addr(eth->h_dest))
+		return -ENOTSUPP;
+
+	return 0;
+}
+
+static int higmac_check_hw_capability_for_ipv6(struct sk_buff *skb)
+{
+	unsigned int l4_proto;
+
+	l4_proto = ipv6_hdr(skb)->nexthdr;
+	if ((l4_proto != IPPROTO_TCP) && (l4_proto != IPPROTO_UDP)) {
+		/*
+		 * when IPv6 next header is not tcp or udp,
+		 * it means that IPv6 next header is extension header.
+		 * Hardware can't deal with this case,
+		 * so do checksumming by software or do GSO by software.
+		 */
+		if (skb_is_gso(skb))
+			return -ENOTSUPP;
+
+		if (skb->ip_summed == CHECKSUM_PARTIAL &&
+		    skb_checksum_help(skb))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static inline bool higmac_skb_is_ipv4_with_options(struct sk_buff *skb)
+{
+	return ((higmac_get_l3_proto(skb) == htons(ETH_P_IP)) &&
+		(ip_hdr(skb)->ihl > IPV4_HEAD_LENGTH));
+}
+
+int higmac_check_hw_capability(struct sk_buff *skb)
+{
+	int ret;
+
+	/*
+	 * if tcp_mtu_probe() use (2 * tp->mss_cache) as probe_size,
+	 * the linear data length will be larger than 2048,
+	 * the MAC can't handle it, so let the software do it.
+	 */
+	 if (skb == NULL)
+		return -EINVAL;
+	if (skb_is_gso(skb) && (skb_headlen(skb) > 2048)) /* 2048(2k) */
+		return -ENOTSUPP;
+
+	if (higmac_skb_is_ipv6(skb)) {
+		ret = higmac_check_hw_capability_for_ipv6(skb);
+		if (ret)
+			return ret;
+	}
+
+	if (higmac_skb_is_udp(skb)) {
+		ret = higmac_check_hw_capability_for_udp(skb);
+		if (ret)
+			return ret;
+	}
+
+	if (((skb->ip_summed == CHECKSUM_PARTIAL) || skb_is_gso(skb)) &&
+	    higmac_skb_is_ipv4_with_options(skb))
+		return -ENOTSUPP;
+
+	return 0;
+}
+
+static void higmac_do_udp_checksum(struct sk_buff *skb)
+{
+	int offset;
+	__wsum csum;
+	__sum16 udp_csum;
+
+	offset = skb_checksum_start_offset(skb);
+	WARN_ON(offset >= skb_headlen(skb));
+	csum = skb_checksum(skb, offset, skb->len - offset, 0);
+
+	offset += skb->csum_offset;
+	WARN_ON(offset + sizeof(__sum16) > skb_headlen(skb));
+	udp_csum = csum_fold(csum);
+	if (udp_csum == 0)
+		udp_csum = CSUM_MANGLED_0;
+
+	*(__sum16 *)(skb->data + offset) = udp_csum;
+
+	skb->ip_summed = CHECKSUM_NONE;
+}
+
+static int higmac_get_pkt_info_l3l4(struct higmac_tso_desc *tx_bq_desc,
+		  struct sk_buff *skb, unsigned int *l4_proto, unsigned int *max_mss,
+		  unsigned char *coe_enable)
+{
+	__be16 l3_proto; /* level 3 protocol */
+	int max_data_len = skb->len - ETH_HLEN;
+
+	l3_proto = skb->protocol;
+	if (skb->protocol == htons(ETH_P_8021Q)) {
+		l3_proto = vlan_get_protocol(skb);
+		tx_bq_desc->desc1.tx.vlan_flag = 1;
+		max_data_len -= VLAN_HLEN;
+	}
+
+	if (l3_proto == htons(ETH_P_IP)) {
+		struct iphdr *iph;
+
+		iph = ip_hdr(skb);
+		tx_bq_desc->desc1.tx.ip_ver = PKT_IPV4;
+		tx_bq_desc->desc1.tx.ip_hdr_len = iph->ihl;
+
+		if ((max_data_len >= GSO_MAX_SIZE) &&
+			(ntohs(iph->tot_len) <= (iph->ihl << 2))) /* shift left 2 */
+			iph->tot_len = htons(GSO_MAX_SIZE - 1);
+
+		*max_mss -= iph->ihl * WORD_TO_BYTE;
+		*l4_proto = iph->protocol;
+	} else if (l3_proto == htons(ETH_P_IPV6)) {
+		tx_bq_desc->desc1.tx.ip_ver = PKT_IPV6;
+		tx_bq_desc->desc1.tx.ip_hdr_len = PKT_IPV6_HDR_LEN;
+		*max_mss -= PKT_IPV6_HDR_LEN * WORD_TO_BYTE;
+		*l4_proto = ipv6_hdr(skb)->nexthdr;
+	} else {
+		*coe_enable = 0;
+	}
+
+	if (*l4_proto == IPPROTO_TCP) {
+		tx_bq_desc->desc1.tx.prot_type = PKT_TCP;
+		if (tcp_hdr(skb)->doff < sizeof(struct tcphdr) / WORD_TO_BYTE)
+			return -EFAULT;
+		tx_bq_desc->desc1.tx.prot_hdr_len = tcp_hdr(skb)->doff;
+		*max_mss -= tcp_hdr(skb)->doff * WORD_TO_BYTE;
+	} else if (*l4_proto == IPPROTO_UDP) {
+		tx_bq_desc->desc1.tx.prot_type = PKT_UDP;
+		tx_bq_desc->desc1.tx.prot_hdr_len = PKT_UDP_HDR_LEN;
+		if (l3_proto == htons(ETH_P_IPV6))
+			*max_mss -= sizeof(struct frag_hdr);
+	} else {
+		*coe_enable = 0;
+	}
+
+	return 0;
+}
+
+int higmac_get_pkt_info(struct higmac_netdev_local *ld,
+		  struct sk_buff *skb, struct higmac_tso_desc *tx_bq_desc)
+{
+	int nfrags;
+	unsigned int l4_proto = IPPROTO_MAX;
+	unsigned int max_mss = ETH_DATA_LEN;
+	unsigned char coe_enable = 0;
+	int ret;
+	if (skb == NULL || tx_bq_desc == NULL)
+		return -EINVAL;
+
+	nfrags = skb_shinfo(skb)->nr_frags;
+	if (likely(skb->ip_summed == CHECKSUM_PARTIAL))
+		coe_enable = 1;
+
+	tx_bq_desc->desc1.val = 0;
+
+	if (skb_is_gso(skb)) {
+		tx_bq_desc->desc1.tx.tso_flag = 1;
+		tx_bq_desc->desc1.tx.sg_flag = 1;
+	} else if (nfrags) {
+		tx_bq_desc->desc1.tx.sg_flag = 1;
+	}
+
+	ret = higmac_get_pkt_info_l3l4(tx_bq_desc, skb, &l4_proto, &max_mss,
+	    &coe_enable);
+	if (ret < 0)
+		return ret;
+
+	if (skb_is_gso(skb))
+		tx_bq_desc->desc1.tx.data_len =
+			(skb_shinfo(skb)->gso_size > max_mss) ? max_mss :
+					skb_shinfo(skb)->gso_size;
+	else
+		tx_bq_desc->desc1.tx.data_len = skb->len;
+
+	if (coe_enable && skb_is_gso(skb) && (l4_proto == IPPROTO_UDP))
+		higmac_do_udp_checksum(skb);
+
+	if (coe_enable)
+		tx_bq_desc->desc1.tx.coe_flag = 1;
+
+	tx_bq_desc->desc1.tx.nfrags_num = nfrags;
+
+	tx_bq_desc->desc1.tx.hw_own = DESC_VLD_BUSY;
+	return 0;
+}
+
+void higmac_get_drvinfo(struct net_device *net_dev,
+		  struct ethtool_drvinfo *info)
+{
+	if (info == NULL)
+		return;
+	strncpy(info->driver, "higmac driver", sizeof(info->driver));
+	strncpy(info->version, "higmac v200", sizeof(info->version));
+	strncpy(info->bus_info, "platform", sizeof(info->bus_info));
+}
+
+unsigned int higmac_get_link(struct net_device *net_dev)
+{
+	struct higmac_netdev_local *ld = netdev_priv(net_dev);
+
+	return ld->phy->link ? HIGMAC_LINKED : 0;
+}
+
+int higmac_get_settings(struct net_device *net_dev,
+		  struct ethtool_cmd *cmd)
+{
+	struct higmac_netdev_local *ld = netdev_priv(net_dev);
+
+	if (ld->phy != NULL)
+		return phy_ethtool_gset(ld->phy, cmd);
+
+	return -EINVAL;
+}
+
+int higmac_set_settings(struct net_device *net_dev,
+		  struct ethtool_cmd *cmd)
+{
+	struct higmac_netdev_local *ld = netdev_priv(net_dev);
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (ld->phy != NULL)
+		return phy_ethtool_sset(ld->phy, cmd);
+
+	return -EINVAL;
+}
+
+void higmac_get_pauseparam(struct net_device *net_dev,
+		  struct ethtool_pauseparam *pause)
+{
+	struct higmac_netdev_local *ld = NULL;
+	if (net_dev == NULL || pause == NULL)
+		return;
+	ld = netdev_priv(net_dev);
+
+	pause->rx_pause = 0;
+	pause->tx_pause = 0;
+	pause->autoneg = ld->phy->autoneg;
+
+	if (ld->flow_ctrl & FLOW_RX)
+		pause->rx_pause = 1;
+	if (ld->flow_ctrl & FLOW_TX)
+		pause->tx_pause = 1;
+}
+
+int higmac_set_pauseparam(struct net_device *net_dev,
+		  struct ethtool_pauseparam *pause)
+{
+	struct higmac_netdev_local *ld = netdev_priv(net_dev);
+	struct phy_device *phy = ld->phy;
+	unsigned int new_pause = FLOW_OFF;
+
+	if (pause == NULL)
+		return -ENOMEM;
+
+	if (pause->rx_pause)
+		new_pause |= FLOW_RX;
+	if (pause->tx_pause)
+		new_pause |= FLOW_TX;
+
+	if (new_pause != ld->flow_ctrl)
+		ld->flow_ctrl = new_pause;
+
+	higmac_set_flow_ctrl_state(ld, phy->pause);
+	phy->advertising &= ~SUPPORTED_Pause;
+	if (ld->flow_ctrl)
+		phy->advertising |= SUPPORTED_Pause;
+
+	if (phy->autoneg) {
+		if (netif_running(net_dev))
+			return phy_start_aneg(phy);
+	}
+
+	return 0;
+}
+
+u32 higmac_ethtool_getmsglevel(struct net_device *ndev)
+{
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+
+	return priv->msg_enable;
+}
+
+void higmac_ethtool_setmsglevel(struct net_device *ndev, u32 level)
+{
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+
+	priv->msg_enable = level;
+}
+
+u32 higmac_get_rxfh_key_size(struct net_device *ndev)
+{
+	return RSS_HASH_KEY_SIZE;
+}
+
+u32 higmac_get_rxfh_indir_size(struct net_device *ndev)
+{
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+
+	return priv->rss_info.ind_tbl_size;
+}
+
+int higmac_get_rxfh(struct net_device *ndev, u32 *indir, u8 *hkey,
+		  u8 *hfunc)
+{
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+	struct higmac_rss_info *rss = &priv->rss_info;
+
+	if (hfunc != NULL)
+		*hfunc = ETH_RSS_HASH_TOP;
+
+	if (hkey != NULL)
+		memcpy(hkey, rss->key, RSS_HASH_KEY_SIZE);
+
+	if (indir != NULL) {
+		int i;
+
+		for (i = 0; i < rss->ind_tbl_size; i++)
+			indir[i] = rss->ind_tbl[i];
+	}
+
+	return 0;
+}
+
+void higmac_get_rss_key(struct higmac_netdev_local *priv)
+{
+	struct higmac_rss_info *rss = NULL;
+	u32 hkey;
+	if (priv == NULL)
+		return;
+	rss = &priv->rss_info;
+	hkey = readl(priv->gmac_iobase + RSS_HASH_KEY);
+	*((u32 *)rss->key) = hkey;
+}
+
+static void higmac_set_rss_key(struct higmac_netdev_local *priv)
+{
+	struct higmac_rss_info *rss = &priv->rss_info;
+
+	writel(*((u32 *)rss->key), priv->gmac_iobase + RSS_HASH_KEY);
+}
+
+static int higmac_wait_rss_ready(struct higmac_netdev_local const *priv)
+{
+	void __iomem *base = priv->gmac_iobase;
+	int i;
+	const int timeout = 10000;
+
+	for (i = 0; !(readl(base + RSS_IND_TBL) & BIT_IND_TBL_READY); i++) {
+		if (i == timeout) {
+			netdev_err(priv->netdev, "wait rss ready timeout!\n");
+			return -ETIMEDOUT;
+		}
+		usleep_range(10, 20); /* wait 10~20us */
+	}
+
+	return 0;
+}
+
+static void higmac_config_rss(struct higmac_netdev_local *priv)
+{
+	struct higmac_rss_info *rss = NULL;
+	u32 rss_val;
+	unsigned int i;
+	if (priv == NULL)
+		return;
+	rss = &priv->rss_info;
+	for (i = 0; i < rss->ind_tbl_size; i++) {
+		if (higmac_wait_rss_ready(priv) != 0)
+			break;
+		rss_val = BIT_IND_TLB_WR | (rss->ind_tbl[i] << 8) | i; /* shift 8 */
+		writel(rss_val, priv->gmac_iobase + RSS_IND_TBL);
+	}
+}
+
+void higmac_get_rss(struct higmac_netdev_local *priv)
+{
+	struct higmac_rss_info *rss = NULL;
+	u32 rss_val;
+	int i;
+	if (priv == NULL)
+		return;
+	rss = &priv->rss_info;
+	for (i = 0; i < rss->ind_tbl_size; i++) {
+		if (higmac_wait_rss_ready(priv) != 0)
+			break;
+		writel(i, priv->gmac_iobase + RSS_IND_TBL);
+		if (higmac_wait_rss_ready(priv) != 0)
+			break;
+		rss_val = readl(priv->gmac_iobase + RSS_IND_TBL);
+		rss->ind_tbl[i] = (rss_val >> 10) & 0x3; /* right shift 10 */
+	}
+}
+
+int higmac_set_rxfh(struct net_device *ndev, const u32 *indir,
+		  const u8 *hkey, const u8 hfunc)
+{
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+	struct higmac_rss_info *rss = &priv->rss_info;
+
+	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)
+		return -EOPNOTSUPP;
+
+	if (indir != NULL) {
+		int i;
+
+		for (i = 0; i < rss->ind_tbl_size; i++)
+			rss->ind_tbl[i] = indir[i];
+	}
+
+	if (hkey != NULL) {
+		memcpy(rss->key, hkey, RSS_HASH_KEY_SIZE);
+		higmac_set_rss_key(priv);
+	}
+
+	higmac_config_rss(priv);
+
+	return 0;
+}
+
+static void higmac_get_rss_hash(struct ethtool_rxnfc *info, u32 hash_cfg,
+		  u32 l3_hash_en, u32 l4_hash_en, u32 vlan_hash_en)
+{
+	if (hash_cfg & l3_hash_en)
+		info->data |= RXH_IP_SRC | RXH_IP_DST;
+	if (hash_cfg & l4_hash_en)
+		info->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+	if (hash_cfg & vlan_hash_en)
+		info->data |= RXH_VLAN;
+}
+
+static int higmac_get_rss_hash_opts(struct higmac_netdev_local const *priv,
+		  struct ethtool_rxnfc *info)
+{
+	u32 hash_cfg = priv->rss_info.hash_cfg;
+
+	info->data = 0;
+
+	switch (info->flow_type) {
+	case TCP_V4_FLOW:
+		higmac_get_rss_hash(info, hash_cfg, TCPV4_L3_HASH_EN, TCPV4_L4_HASH_EN,
+			TCPV4_VLAN_HASH_EN);
+		break;
+	case TCP_V6_FLOW:
+		higmac_get_rss_hash(info, hash_cfg, TCPV6_L3_HASH_EN, TCPV6_L4_HASH_EN,
+			TCPV6_VLAN_HASH_EN);
+		break;
+	case UDP_V4_FLOW:
+		higmac_get_rss_hash(info, hash_cfg, UDPV4_L3_HASH_EN, UDPV4_L4_HASH_EN,
+			UDPV4_VLAN_HASH_EN);
+		break;
+	case UDP_V6_FLOW:
+		higmac_get_rss_hash(info, hash_cfg, UDPV6_L3_HASH_EN, UDPV6_L4_HASH_EN,
+			UDPV6_VLAN_HASH_EN);
+		break;
+	case IPV4_FLOW:
+		higmac_get_rss_hash(info, hash_cfg, IPV4_L3_HASH_EN, 0,
+			IPV4_VLAN_HASH_EN);
+		break;
+	case IPV6_FLOW:
+		higmac_get_rss_hash(info, hash_cfg, IPV6_L3_HASH_EN, 0,
+			IPV6_VLAN_HASH_EN);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int higmac_get_rxnfc(struct net_device *ndev,
+		  struct ethtool_rxnfc *info, u32 *rules)
+{
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+	int ret = -EOPNOTSUPP;
+	if (info == NULL)
+		return -EINVAL;
+	switch (info->cmd) {
+	case ETHTOOL_GRXRINGS:
+		info->data = priv->num_rxqs;
+		ret = 0;
+		break;
+	case ETHTOOL_GRXFH:
+		return higmac_get_rss_hash_opts(priv, info);
+	default:
+		break;
+	}
+	return ret;
+}
+
+void higmac_config_hash_policy(struct higmac_netdev_local const *priv)
+{
+	if (priv == NULL)
+		return;
+	writel(priv->rss_info.hash_cfg, priv->gmac_iobase + RSS_HASH_CONFIG);
+}
+
+static int higmac_set_tcp_udp_hash_cfg(struct ethtool_rxnfc const *info,
+		  u32 *hash_cfg, u32 l4_mask, u32 vlan_mask)
+{
+	switch (info->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {
+	case 0: // all bits is 0
+		*hash_cfg &= ~l4_mask;
+		break;
+	case (RXH_L4_B_0_1 | RXH_L4_B_2_3):
+		*hash_cfg |= l4_mask;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (info->data & RXH_VLAN)
+		*hash_cfg |= vlan_mask;
+	else
+		*hash_cfg &= ~vlan_mask;
+	return 0;
+}
+
+static int higmac_ip_hash_cfg(struct ethtool_rxnfc const *info,
+		  u32 *hash_cfg, u32 vlan_mask)
+{
+	if (info->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3))
+		return -EINVAL;
+	if (info->data & RXH_VLAN)
+		*hash_cfg |= vlan_mask;
+	else
+		*hash_cfg &= ~vlan_mask;
+	return 0;
+}
+
+static int higmac_set_rss_hash_opts(struct higmac_netdev_local *priv,
+		  struct ethtool_rxnfc const *info)
+{
+	u32 hash_cfg;
+	if (priv == NULL || priv->netdev == NULL)
+		return -EINVAL;
+	hash_cfg = priv->rss_info.hash_cfg;
+	netdev_info(priv->netdev, "Set RSS flow type = %d, data = %lld\n",
+		    info->flow_type, info->data);
+
+	if (!(info->data & RXH_IP_SRC) || !(info->data & RXH_IP_DST))
+		return -EINVAL;
+
+	switch (info->flow_type) {
+	case TCP_V4_FLOW:
+		if (higmac_set_tcp_udp_hash_cfg(info, &hash_cfg,
+			TCPV4_L4_HASH_EN, TCPV4_VLAN_HASH_EN) == -EINVAL)
+			return -EINVAL;
+		break;
+	case TCP_V6_FLOW:
+		if (higmac_set_tcp_udp_hash_cfg(info, &hash_cfg,
+			TCPV6_L4_HASH_EN, TCPV6_VLAN_HASH_EN) == -EINVAL)
+			return -EINVAL;
+		break;
+	case UDP_V4_FLOW:
+		if (higmac_set_tcp_udp_hash_cfg(info, &hash_cfg,
+			UDPV4_L4_HASH_EN, UDPV4_L4_HASH_EN) == -EINVAL)
+			return -EINVAL;
+		break;
+	case UDP_V6_FLOW:
+		if (higmac_set_tcp_udp_hash_cfg(info, &hash_cfg,
+			UDPV6_L4_HASH_EN, UDPV6_L4_HASH_EN) == -EINVAL)
+			return -EINVAL;
+		break;
+	case IPV4_FLOW:
+		if (higmac_ip_hash_cfg(info, &hash_cfg,
+			IPV4_VLAN_HASH_EN) == -EINVAL)
+			return -EINVAL;
+		break;
+		break;
+	case IPV6_FLOW:
+		if (higmac_ip_hash_cfg(info, &hash_cfg,
+			IPV6_VLAN_HASH_EN) == -EINVAL)
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	priv->rss_info.hash_cfg = hash_cfg;
+	higmac_config_hash_policy(priv);
+
+	return 0;
+}
+
+int higmac_set_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *info)
+{
+	struct higmac_netdev_local *priv = netdev_priv(ndev);
+	if (info == NULL)
+		return -EINVAL;
+	switch (info->cmd) {
+	case ETHTOOL_SRXFH:
+		return higmac_set_rss_hash_opts(priv, info);
+	default:
+		break;
+	}
+	return -EOPNOTSUPP;
+}
+
+static int ksz8051mnl_phy_fix(struct phy_device *phy_dev)
+{
+	u32 v;
+	int ret;
+
+	if (phy_dev->interface != PHY_INTERFACE_MODE_RMII)
+		return 0;
+
+	ret = phy_read(phy_dev, 0x1F);
+	if (ret < 0)
+		return ret;
+	v = ret;
+	v |= (1 << 7); /* set bit 7, phy RMII 50MHz clk; */
+	phy_write(phy_dev, 0x1F, v);
+
+	ret = phy_read(phy_dev, 0x16);
+	if (ret < 0)
+		return ret;
+	v = ret;
+	v |= (1 << 1); /* set phy RMII override; */
+	phy_write(phy_dev, 0x16, v);
+
+	return 0;
+}
+
+static int ksz8081rnb_phy_fix(struct phy_device *phy_dev)
+{
+	u32 v;
+	int ret;
+
+	if (phy_dev->interface != PHY_INTERFACE_MODE_RMII)
+		return 0;
+
+	ret = phy_read(phy_dev, 0x1F);
+	if (ret < 0)
+		return ret;
+	v = ret;
+	v |= (1 << 7); /* set bit 7, phy RMII 50MHz clk; */
+	phy_write(phy_dev, 0x1F, v);
+
+	return 0;
+}
+
+static int unknown_phy_fix(struct phy_device *phy_dev)
+{
+	u32 v;
+	int ret;
+
+	if (phy_dev->interface != PHY_INTERFACE_MODE_RMII)
+		return 0;
+
+	ret = phy_read(phy_dev, 0x1F);
+	if (ret < 0)
+		return ret;
+	v = ret;
+	v |= (1 << 7); /* set bit 7, phy RMII 50MHz clk; */
+	phy_write(phy_dev, 0x1F, v);
+
+	return 0;
+}
+
+static int rtl8211e_phy_fix(struct phy_device *phy_dev)
+{
+	u32 v;
+	int ret;
+
+	/* select Extension page */
+	phy_write(phy_dev, 0x1f, 0x7);
+	/* switch ExtPage 164 */
+	phy_write(phy_dev, 0x1e, 0xa4);
+
+	/* config RGMII rx pin io driver max */
+	ret = phy_read(phy_dev, 0x1c);
+	if (ret < 0)
+		return ret;
+	v = ret;
+	v = (v & 0xff03) | 0xfc;
+	phy_write(phy_dev, 0x1c, v);
+
+	/* select to page 0 */
+	phy_write(phy_dev, 0x1f, 0);
+
+	return 0;
+}
+
+void higmac_phy_register_fixups(void)
+{
+	phy_register_fixup_for_uid(PHY_ID_UNKNOWN, DEFAULT_PHY_MASK,
+				   unknown_phy_fix);
+	phy_register_fixup_for_uid(PHY_ID_KSZ8051MNL, DEFAULT_PHY_MASK,
+				   ksz8051mnl_phy_fix);
+	phy_register_fixup_for_uid(PHY_ID_KSZ8081RNB, DEFAULT_PHY_MASK,
+				   ksz8081rnb_phy_fix);
+	phy_register_fixup_for_uid(REALTEK_PHY_ID_8211E, REALTEK_PHY_MASK,
+				   rtl8211e_phy_fix);
+}
+
+void higmac_phy_unregister_fixups(void)
+{
+	phy_unregister_fixup_for_uid(PHY_ID_UNKNOWN, DEFAULT_PHY_MASK);
+	phy_unregister_fixup_for_uid(PHY_ID_KSZ8051MNL, DEFAULT_PHY_MASK);
+	phy_unregister_fixup_for_uid(PHY_ID_KSZ8081RNB, DEFAULT_PHY_MASK);
+	phy_unregister_fixup_for_uid(REALTEK_PHY_ID_8211E, REALTEK_PHY_MASK);
+}
diff --git a/drivers/net/ethernet/hisilicon/higmac/util.h b/drivers/net/ethernet/hisilicon/higmac/util.h
new file mode 100644
index 000000000..ca1c99bb5
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/higmac/util.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Higmac driver util head file
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#ifndef __HIGMAC_UTIL_H__
+#define __HIGMAC_UTIL_H__
+
+#include "higmac.h"
+
+#define HIGMAC_TRACE_LEVEL 10
+#define HIGMAC_NORMAL_LEVEL 7
+
+#define mk_bits(shift, nbits) ((((shift) & 0x1F) << 16) | ((nbits) & 0x3F))
+
+#define FC_ACTIVE_MIN		1
+#define FC_ACTIVE_DEFAULT	16
+#define FC_ACTIVE_MAX		127
+#define FC_DEACTIVE_MIN		1
+#define FC_DEACTIVE_DEFAULT	32
+#define FC_DEACTIVE_MAX		127
+
+#define FC_PAUSE_TIME_DEFAULT		0xFFFF
+#define FC_PAUSE_INTERVAL_DEFAULT	0xFFFF
+#define FC_PAUSE_TIME_MAX		0xFFFF
+
+#define HW_CAP_EN			0x0c00
+#define BIT_RSS_CAP			BIT(0)
+#define BIT_RXHASH_CAP			BIT(1)
+#define RSS_HASH_KEY			0x0c04
+#define RSS_HASH_CONFIG			0x0c08
+#define TCPV4_L3_HASH_EN		BIT(0)
+#define TCPV4_L4_HASH_EN		BIT(1)
+#define TCPV4_VLAN_HASH_EN		BIT(2)
+#define UDPV4_L3_HASH_EN		BIT(4)
+#define UDPV4_L4_HASH_EN		BIT(5)
+#define UDPV4_VLAN_HASH_EN		BIT(6)
+#define IPV4_L3_HASH_EN			BIT(8)
+#define IPV4_VLAN_HASH_EN		BIT(9)
+#define TCPV6_L3_HASH_EN		BIT(12)
+#define TCPV6_L4_HASH_EN		BIT(13)
+#define TCPV6_VLAN_HASH_EN		BIT(14)
+#define UDPV6_L3_HASH_EN		BIT(16)
+#define UDPV6_L4_HASH_EN		BIT(17)
+#define UDPV6_VLAN_HASH_EN		BIT(18)
+#define IPV6_L3_HASH_EN			BIT(20)
+#define IPV6_VLAN_HASH_EN		BIT(21)
+#define DEF_HASH_CFG			0x377377
+
+#define RGMII_SPEED_1000		0x2c
+#define RGMII_SPEED_100			0x2f
+#define RGMII_SPEED_10			0x2d
+#define MII_SPEED_100			0x0f
+#define MII_SPEED_10			0x0d
+#define RMII_SPEED_100			0x8f
+#define RMII_SPEED_10			0x8d
+#define GMAC_FULL_DUPLEX		BIT(4)
+
+void higmac_trace(int level, const char *fmt, ...);
+
+void higmac_config_port(struct net_device const *dev, u32 speed, u32 duplex);
+int higmac_rx_checksum(struct net_device *dev, struct sk_buff *skb,
+		  struct higmac_desc const *desc);
+void higmac_verify_flow_ctrl_args(void);
+void higmac_set_flow_ctrl_args(struct higmac_netdev_local *ld);
+
+int higmac_check_hw_capability(struct sk_buff *skb);
+int higmac_get_pkt_info(struct higmac_netdev_local *ld,
+			struct sk_buff *skb, struct higmac_tso_desc *tx_bq_desc);
+
+void higmac_get_drvinfo(struct net_device *net_dev,
+			struct ethtool_drvinfo *info);
+unsigned int higmac_get_link(struct net_device *net_dev);
+int higmac_get_settings(struct net_device *net_dev, struct ethtool_cmd *cmd);
+int higmac_set_settings(struct net_device *net_dev, struct ethtool_cmd *cmd);
+void higmac_get_pauseparam(struct net_device *net_dev,
+			   struct ethtool_pauseparam *pause);
+int higmac_set_pauseparam(struct net_device *net_dev,
+			  struct ethtool_pauseparam *pause);
+u32 higmac_ethtool_getmsglevel(struct net_device *ndev);
+void higmac_ethtool_setmsglevel(struct net_device *ndev, u32 level);
+u32 higmac_get_rxfh_key_size(struct net_device *ndev);
+u32 higmac_get_rxfh_indir_size(struct net_device *ndev);
+int higmac_get_rxfh(struct net_device *ndev, u32 *indir, u8 *hkey, u8 *hfunc);
+int higmac_set_rxfh(struct net_device *ndev, const u32 *indir,
+		    const u8 *hkey, const u8 hfunc);
+int higmac_get_rxnfc(struct net_device *ndev,
+		     struct ethtool_rxnfc *info, u32 *rules);
+int higmac_set_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *info);
+
+void higmac_get_rss_key(struct higmac_netdev_local *priv);
+void higmac_get_rss(struct higmac_netdev_local *priv);
+void higmac_config_hash_policy(struct higmac_netdev_local const *priv);
+
+void higmac_set_flow_ctrl_state(struct higmac_netdev_local const *ld, int pause);
+void higmac_set_flow_ctrl_params(struct higmac_netdev_local const *ld);
+
+void higmac_phy_register_fixups(void);
+void higmac_phy_unregister_fixups(void);
+#endif
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/Makefile b/drivers/net/ethernet/hisilicon/hisi-femac/Makefile
new file mode 100644
index 000000000..bfad94751
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the HISILICON Fast Ethernet network device drivers.
+#
+
+obj-$(CONFIG_HISI_FEMAC) += hisi-femac.o
+hisi-femac-objs := hisi_femac.o phy_fix.o util.o
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/festa_s28v115_2c02.h b/drivers/net/ethernet/hisilicon/hisi-femac/festa_s28v115_2c02.h
new file mode 100644
index 000000000..6c00c71a0
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/festa_s28v115_2c02.h
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Hieth driver festa_s28v115_2c02 phy fixup paramters
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#ifndef __HIETH_FESTA_S28V115_2C02_H__
+#define __HIETH_FESTA_S28V115_2C02_H__
+	0x33f9, 0xbd, 0x33fa, 0x34, 0x33fb, 0x00,
+	0x33fc, 0x39, 0x3400, 0x39, 0x3401, 0xCC,
+	0x3402, 0x2C, 0x3403, 0x02, 0x3404, 0xFD,
+	0x3405, 0xFF, 0x3406, 0xF0, 0x3407, 0xF6,
+	0x3408, 0x36, 0x3409, 0x18, 0x340A, 0x26,
+	0x340B, 0x05, 0x340C, 0xC6, 0x340D, 0x01,
+	0x340E, 0xF7, 0x340F, 0x36, 0x3410, 0x18,
+	0x3411, 0xCC, 0x3412, 0x35, 0x3413, 0x9F,
+	0x3414, 0x1A, 0x3415, 0xB3, 0x3416, 0x00,
+	0x3417, 0xD2, 0x3418, 0x27, 0x3419, 0x09,
+	0x341A, 0xFD, 0x341B, 0x00, 0x341C, 0xD2,
+	0x341D, 0x7F, 0x341E, 0x01, 0x341F, 0xBF,
+	0x3420, 0x7F, 0x3421, 0x01, 0x3422, 0xB1,
+	0x3423, 0x39, 0x3424, 0x3C, 0x3425, 0x3C,
+	0x3426, 0x30, 0x3427, 0xF6, 0x3428, 0x30,
+	0x3429, 0x55, 0x342A, 0xC0, 0x342B, 0x07,
+	0x342C, 0x18, 0x342D, 0xFE, 0x342E, 0x30,
+	0x342F, 0x4C, 0x3430, 0x18, 0x3431, 0x3A,
+	0x3432, 0x18, 0x3433, 0xE6, 0x3434, 0x00,
+	0x3435, 0x5C, 0x3436, 0xE7, 0x3437, 0x01,
+	0x3438, 0xC1, 0x3439, 0x07, 0x343A, 0x23,
+	0x343B, 0x04, 0x343C, 0xC6, 0x343D, 0x07,
+	0x343E, 0xE7, 0x343F, 0x01, 0x3440, 0x58,
+	0x3441, 0x58, 0x3442, 0x58, 0x3443, 0x58,
+	0x3444, 0x58, 0x3445, 0xE7, 0x3446, 0x00,
+	0x3447, 0xF6, 0x3448, 0x20, 0x3449, 0x04,
+	0x344A, 0xC4, 0x344B, 0x1F, 0x344C, 0xEA,
+	0x344D, 0x00, 0x344E, 0xF7, 0x344F, 0x20,
+	0x3450, 0x04, 0x3451, 0x38, 0x3452, 0x38,
+	0x3453, 0x39, 0x3454, 0x3C, 0x3455, 0x37,
+	0x3456, 0x36, 0x3457, 0x30, 0x3458, 0x1A,
+	0x3459, 0xEE, 0x345A, 0x00, 0x345B, 0x18,
+	0x345C, 0xE6, 0x345D, 0x00, 0x345E, 0x26,
+	0x345F, 0x1C, 0x3460, 0xF6, 0x3461, 0x00,
+	0x3462, 0x5C, 0x3463, 0xC5, 0x3464, 0x04,
+	0x3465, 0x27, 0x3466, 0x06, 0x3467, 0xCC,
+	0x3468, 0x36, 0x3469, 0x12, 0x346A, 0xBD,
+	0x346B, 0xF0, 0x346C, 0xA5, 0x346D, 0xF6,
+	0x346E, 0x00, 0x346F, 0x47, 0x3470, 0xC4,
+	0x3471, 0xF3, 0x3472, 0xF7, 0x3473, 0x00,
+	0x3474, 0x47, 0x3475, 0xC6, 0x3476, 0x01,
+	0x3477, 0x1A, 0x3478, 0xEE, 0x3479, 0x00,
+	0x347A, 0x20, 0x347B, 0x10, 0x347C, 0x5A,
+	0x347D, 0x26, 0x347E, 0x14, 0x347F, 0xF6,
+	0x3480, 0x00, 0x3481, 0x46, 0x3482, 0x4F,
+	0x3483, 0xC4, 0x3484, 0x0C, 0x3485, 0x83,
+	0x3486, 0x00, 0x3487, 0x08, 0x3488, 0x26,
+	0x3489, 0x05, 0x348A, 0xC6, 0x348B, 0x02,
+	0x348C, 0x18, 0x348D, 0xE7, 0x348E, 0x00,
+	0x348F, 0x5F, 0x3490, 0x38, 0x3491, 0x38,
+	0x3492, 0x39, 0x3493, 0xF6, 0x3494, 0x00,
+	0x3495, 0x5C, 0x3496, 0xC5, 0x3497, 0x04,
+	0x3498, 0x27, 0x3499, 0x06, 0x349A, 0xCC,
+	0x349B, 0x36, 0x349C, 0x08, 0x349D, 0xBD,
+	0x349E, 0xF0, 0x349F, 0xA5, 0x34A0, 0xF6,
+	0x34A1, 0x00, 0x34A2, 0x47, 0x34A3, 0xC4,
+	0x34A4, 0xF3, 0x34A5, 0xCA, 0x34A6, 0x08,
+	0x34A7, 0xF7, 0x34A8, 0x00, 0x34A9, 0x47,
+	0x34AA, 0x18, 0x34AB, 0xFE, 0x34AC, 0x00,
+	0x34AD, 0xB6, 0x34AE, 0x18, 0x34AF, 0xAD,
+	0x34B0, 0x00, 0x34B1, 0xBD, 0x34B2, 0x34,
+	0x34B3, 0x24, 0x34B4, 0xF6, 0x34B5, 0x1E,
+	0x34B6, 0x05, 0x34B7, 0xC5, 0x34B8, 0x02,
+	0x34B9, 0x27, 0x34BA, 0x0A, 0x34BB, 0xF6,
+	0x34BC, 0x1E, 0x34BD, 0x07, 0x34BE, 0xC5,
+	0x34BF, 0x02, 0x34C0, 0x27, 0x34C1, 0x03,
+	0x34C2, 0xBD, 0x34C3, 0xC0, 0x34C4, 0x33,
+	0x34C5, 0xF6, 0x34C6, 0x31, 0x34C7, 0x1F,
+	0x34C8, 0x37, 0x34C9, 0xC6, 0x34CA, 0x52,
+	0x34CB, 0xBD, 0x34CC, 0xDC, 0x34CD, 0x53,
+	0x34CE, 0x31, 0x34CF, 0xF6, 0x34D0, 0x00,
+	0x34D1, 0x41, 0x34D2, 0xC5, 0x34D3, 0x10,
+	0x34D4, 0x26, 0x34D5, 0x04, 0x34D6, 0x13,
+	0x34D7, 0x23, 0x34D8, 0x40, 0x34D9, 0x0D,
+	0x34DA, 0xBD, 0x34DB, 0x93, 0x34DC, 0xCE,
+	0x34DD, 0x1A, 0x34DE, 0xEE, 0x34DF, 0x00,
+	0x34E0, 0x18, 0x34E1, 0x6F, 0x34E2, 0x00,
+	0x34E3, 0xC6, 0x34E4, 0x04, 0x34E5, 0x20,
+	0x34E6, 0xA9, 0x34E7, 0x1A, 0x34E8, 0xEE,
+	0x34E9, 0x00, 0x34EA, 0x18, 0x34EB, 0x6F,
+	0x34EC, 0x00, 0x34ED, 0xC6, 0x34EE, 0x01,
+	0x34EF, 0x20, 0x34F0, 0x9F, 0x34F1, 0x3C,
+	0x34F2, 0x37, 0x34F3, 0x36, 0x34F4, 0x30,
+	0x34F5, 0x1A, 0x34F6, 0xEE, 0x34F7, 0x00,
+	0x34F8, 0x18, 0x34F9, 0xE6, 0x34FA, 0x00,
+	0x34FB, 0x26, 0x34FC, 0x49, 0x34FD, 0xF6,
+	0x34FE, 0x00, 0x34FF, 0x5C, 0x3500, 0xC5,
+	0x3501, 0x04, 0x3502, 0x27, 0x3503, 0x06,
+	0x3504, 0xCC, 0x3505, 0x35, 0x3506, 0xFC,
+	0x3507, 0xBD, 0x3508, 0xF0, 0x3509, 0xA5,
+	0x350A, 0xC6, 0x350B, 0x52, 0x350C, 0xBD,
+	0x350D, 0xDC, 0x350E, 0xF3, 0x350F, 0x5D,
+	0x3510, 0x27, 0x3511, 0x03, 0x3512, 0xBD,
+	0x3513, 0xC0, 0x3514, 0x22, 0x3515, 0xF6,
+	0x3516, 0x00, 0x3517, 0x46, 0x3518, 0xC5,
+	0x3519, 0x0C, 0x351A, 0x26, 0x351B, 0x0A,
+	0x351C, 0x1A, 0x351D, 0xEE, 0x351E, 0x00,
+	0x351F, 0x18, 0x3520, 0x6F, 0x3521, 0x00,
+	0x3522, 0xC6, 0x3523, 0x07, 0x3524, 0x20,
+	0x3525, 0x1D, 0x3526, 0xFC, 0x3527, 0x30,
+	0x3528, 0x0C, 0x3529, 0xBD, 0x352A, 0x93,
+	0x352B, 0x19, 0x352C, 0xBD, 0x352D, 0x9F,
+	0x352E, 0x0B, 0x352F, 0xC6, 0x3530, 0x02,
+	0x3531, 0x37, 0x3532, 0xC6, 0x3533, 0x51,
+	0x3534, 0xBD, 0x3535, 0xDC, 0x3536, 0x53,
+	0x3537, 0x31, 0x3538, 0x7F, 0x3539, 0x02,
+	0x353A, 0x07, 0x353B, 0xC6, 0x353C, 0x02,
+	0x353D, 0x1A, 0x353E, 0xEE, 0x353F, 0x00,
+	0x3540, 0x18, 0x3541, 0xE7, 0x3542, 0x00,
+	0x3543, 0x38, 0x3544, 0x38, 0x3545, 0x39,
+	0x3546, 0xC6, 0x3547, 0x52, 0x3548, 0xBD,
+	0x3549, 0xDC, 0x354A, 0xF3, 0x354B, 0x5D,
+	0x354C, 0x27, 0x354D, 0x03, 0x354E, 0xBD,
+	0x354F, 0xC0, 0x3550, 0x22, 0x3551, 0xF6,
+	0x3552, 0x00, 0x3553, 0x46, 0x3554, 0xC5,
+	0x3555, 0x0C, 0x3556, 0x26, 0x3557, 0x0A,
+	0x3558, 0x1A, 0x3559, 0xEE, 0x355A, 0x00,
+	0x355B, 0x18, 0x355C, 0x6F, 0x355D, 0x00,
+	0x355E, 0xC6, 0x355F, 0x07, 0x3560, 0x20,
+	0x3561, 0xE1, 0x3562, 0xC6, 0x3563, 0x51,
+	0x3564, 0xBD, 0x3565, 0xDC, 0x3566, 0xF3,
+	0x3567, 0x5D, 0x3568, 0x26, 0x3569, 0x04,
+	0x356A, 0xC6, 0x356B, 0x02, 0x356C, 0x20,
+	0x356D, 0xD5, 0x356E, 0xF6, 0x356F, 0x00,
+	0x3570, 0x41, 0x3571, 0xC5, 0x3572, 0x10,
+	0x3573, 0x26, 0x3574, 0x20, 0x3575, 0xF6,
+	0x3576, 0x02, 0x3577, 0x07, 0x3578, 0xC1,
+	0x3579, 0x02, 0x357A, 0x24, 0x357B, 0x19,
+	0x357C, 0x18, 0x357D, 0xFE, 0x357E, 0x02,
+	0x357F, 0x08, 0x3580, 0x18, 0x3581, 0xAD,
+	0x3582, 0x00, 0x3583, 0xF6, 0x3584, 0x02,
+	0x3585, 0x06, 0x3586, 0x27, 0x3587, 0x0D,
+	0x3588, 0xC6, 0x3589, 0x02, 0x358A, 0x37,
+	0x358B, 0xC6, 0x358C, 0x51, 0x358D, 0xBD,
+	0x358E, 0xDC, 0x358F, 0x53, 0x3590, 0x31,
+	0x3591, 0xC6, 0x3592, 0x02, 0x3593, 0x20,
+	0x3594, 0xAE, 0x3595, 0x1A, 0x3596, 0xEE,
+	0x3597, 0x00, 0x3598, 0x18, 0x3599, 0x6F,
+	0x359A, 0x00, 0x359B, 0xC6, 0x359C, 0x03,
+	0x359D, 0x20, 0x359E, 0xA4, 0x359F, 0xF6,
+	0x35A0, 0x01, 0x35A1, 0xBF, 0x35A2, 0xC1,
+	0x35A3, 0x08, 0x35A4, 0x24, 0x35A5, 0x55,
+	0x35A6, 0xBD, 0x35A7, 0xF6, 0x35A8, 0xD3,
+	0x35A9, 0x35, 0x35AA, 0xBA, 0x35AB, 0x35,
+	0x35AC, 0xC2, 0x35AD, 0x35, 0x35AE, 0xCA,
+	0x35AF, 0x35, 0x35B0, 0xD2, 0x35B1, 0x35,
+	0x35B2, 0xDA, 0x35B3, 0x35, 0x35B4, 0xE2,
+	0x35B5, 0x35, 0x35B6, 0xEA, 0x35B7, 0x35,
+	0x35B8, 0xF2, 0x35B9, 0x39, 0x35BA, 0xCC,
+	0x35BB, 0x01, 0x35BC, 0xB1, 0x35BD, 0xBD,
+	0x35BE, 0x34, 0x35BF, 0x54, 0x35C0, 0x20,
+	0x35C1, 0x36, 0x35C2, 0xCC, 0x35C3, 0x01,
+	0x35C4, 0xB1, 0x35C5, 0xBD, 0x35C6, 0xC1,
+	0x35C7, 0x52, 0x35C8, 0x20, 0x35C9, 0x2E,
+	0x35CA, 0xCC, 0x35CB, 0x01, 0x35CC, 0xB1,
+	0x35CD, 0xBD, 0x35CE, 0x34, 0x35CF, 0xF1,
+	0x35D0, 0x20, 0x35D1, 0x26, 0x35D2, 0xCC,
+	0x35D3, 0x01, 0x35D4, 0xB1, 0x35D5, 0xBD,
+	0x35D6, 0xC3, 0x35D7, 0x9A, 0x35D8, 0x20,
+	0x35D9, 0x1E, 0x35DA, 0xCC, 0x35DB, 0x01,
+	0x35DC, 0xB1, 0x35DD, 0xBD, 0x35DE, 0xC4,
+	0x35DF, 0x39, 0x35E0, 0x20, 0x35E1, 0x16,
+	0x35E2, 0xCC, 0x35E3, 0x01, 0x35E4, 0xB1,
+	0x35E5, 0xBD, 0x35E6, 0xC5, 0x35E7, 0x0B,
+	0x35E8, 0x20, 0x35E9, 0x0E, 0x35EA, 0xCC,
+	0x35EB, 0x01, 0x35EC, 0xB1, 0x35ED, 0xBD,
+	0x35EE, 0xC6, 0x35EF, 0x3A, 0x35F0, 0x20,
+	0x35F1, 0x06, 0x35F2, 0xCC, 0x35F3, 0x01,
+	0x35F4, 0xB1, 0x35F5, 0xBD, 0x35F6, 0xC7,
+	0x35F7, 0xC2, 0x35F8, 0xF7, 0x35F9, 0x01,
+	0x35FA, 0xBF, 0x35FB, 0x39, 0x35FC, 0x43,
+	0x35FD, 0x3A, 0x35FE, 0x41, 0x35FF, 0x44,
+	0x3600, 0x54, 0x3601, 0x5F, 0x3602, 0x41,
+	0x3603, 0x54, 0x3604, 0x4E, 0x3605, 0x0A,
+	0x3606, 0x0D, 0x3607, 0x00, 0x3608, 0x43,
+	0x3609, 0x3A, 0x360A, 0x45, 0x360B, 0x6E,
+	0x360C, 0x5F, 0x360D, 0x53, 0x360E, 0x74,
+	0x360F, 0x0A, 0x3610, 0x0D, 0x3611, 0x00,
+	0x3612, 0x43, 0x3613, 0x3A, 0x3614, 0x49,
+	0x3615, 0x0A, 0x3616, 0x0D, 0x3617, 0x00,
+	0x3618, 0x00, 0x3400, 0x01, 0x33f8, 0x01
+#endif
\ No newline at end of file
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/festa_s28v202_2e01.h b/drivers/net/ethernet/hisilicon/hisi-femac/festa_s28v202_2e01.h
new file mode 100644
index 000000000..758d79688
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/festa_s28v202_2e01.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hieth driver festa_s28v202_2e01 phy fixup paramters
+ * Author: KTP_BSP
+ * Create: 2020-05-11
+ */
+
+#ifndef __HIETH_FESTA_S28V202_2E01_H__
+#define __HIETH_FESTA_S28V202_2E01_H__
+	0x33f9, 0xbd, 0x33fa, 0x34, 0x33fb, 0x00,
+	0x33fc, 0x39, 0x3400, 0x39, 0x3401, 0xCC,
+	0x3402, 0x2E, 0x3403, 0x01, 0x3404, 0xFD,
+	0x3405, 0xFF, 0x3406, 0xF2, 0x3407, 0x4F,
+	0x3408, 0xFD, 0x3409, 0xFF, 0x340A, 0xF0,
+	0x340B, 0xF6, 0x340C, 0x34, 0x340D, 0xD7,
+	0x340E, 0x26, 0x340F, 0x05, 0x3410, 0xC6,
+	0x3411, 0x01, 0x3412, 0xF7, 0x3413, 0x34,
+	0x3414, 0xD7, 0x3415, 0xF6, 0x3416, 0x08,
+	0x3417, 0x00, 0x3418, 0xF7, 0x3419, 0x34,
+	0x341A, 0xD8, 0x341B, 0xC6, 0x341C, 0x01,
+	0x341D, 0xF7, 0x341E, 0x08, 0x341F, 0x00,
+	0x3420, 0x20, 0x3421, 0x0F, 0x3422, 0xCC,
+	0x3423, 0x34, 0x3424, 0x3F, 0x3425, 0x1A,
+	0x3426, 0xB3, 0x3427, 0x00, 0x3428, 0xCC,
+	0x3429, 0x27, 0x342A, 0x03, 0x342B, 0xFD,
+	0x342C, 0x00, 0x342D, 0xCC, 0x342E, 0x78,
+	0x342F, 0x08, 0x3430, 0x00, 0x3431, 0xF6,
+	0x3432, 0x08, 0x3433, 0x00, 0x3434, 0xC1,
+	0x3435, 0x02, 0x3436, 0x26, 0x3437, 0xEA,
+	0x3438, 0xF6, 0x3439, 0x34, 0x343A, 0xD8,
+	0x343B, 0xF7, 0x343C, 0x08, 0x343D, 0x00,
+	0x343E, 0x39, 0x343F, 0xBD, 0x3440, 0xF7,
+	0x3441, 0xFA, 0x3442, 0x08, 0x3443, 0xCC,
+	0x3444, 0x20, 0x3445, 0xA1, 0x3446, 0xED,
+	0x3447, 0x05, 0x3448, 0xC6, 0x3449, 0xA4,
+	0x344A, 0xED, 0x344B, 0x03, 0x344C, 0xBD,
+	0x344D, 0x8B, 0x344E, 0x82, 0x344F, 0xE7,
+	0x3450, 0x07, 0x3451, 0xC0, 0x3452, 0x02,
+	0x3453, 0x27, 0x3454, 0x11, 0x3455, 0x5A,
+	0x3456, 0x27, 0x3457, 0x0E, 0x3458, 0x5A,
+	0x3459, 0x27, 0x345A, 0x39, 0x345B, 0x5A,
+	0x345C, 0x27, 0x345D, 0x36, 0x345E, 0x5A,
+	0x345F, 0x27, 0x3460, 0x51, 0x3461, 0x5A,
+	0x3462, 0x27, 0x3463, 0x4E, 0x3464, 0x20,
+	0x3465, 0x6D, 0x3466, 0x18, 0x3467, 0xFE,
+	0x3468, 0x30, 0x3469, 0x1E, 0x346A, 0xF6,
+	0x346B, 0x30, 0x346C, 0x22, 0x346D, 0x18,
+	0x346E, 0x3A, 0x346F, 0x18, 0x3470, 0xE6,
+	0x3471, 0x00, 0x3472, 0x58, 0x3473, 0x58,
+	0x3474, 0xE7, 0x3475, 0x02, 0x3476, 0x1A,
+	0x3477, 0xEE, 0x3478, 0x05, 0x3479, 0x18,
+	0x347A, 0xE6, 0x347B, 0x00, 0x347C, 0xC4,
+	0x347D, 0x03, 0x347E, 0xEA, 0x347F, 0x02,
+	0x3480, 0x18, 0x3481, 0xE7, 0x3482, 0x00,
+	0x3483, 0x1A, 0x3484, 0xEE, 0x3485, 0x03,
+	0x3486, 0x18, 0x3487, 0xE6, 0x3488, 0x00,
+	0x3489, 0xC4, 0x348A, 0x1F, 0x348B, 0xCA,
+	0x348C, 0xC0, 0x348D, 0x18, 0x348E, 0xE7,
+	0x348F, 0x00, 0x3490, 0xC6, 0x3491, 0x09,
+	0x3492, 0x20, 0x3493, 0x3A, 0x3494, 0x1A,
+	0x3495, 0xEE, 0x3496, 0x05, 0x3497, 0x18,
+	0x3498, 0xE6, 0x3499, 0x00, 0x349A, 0xC4,
+	0x349B, 0x03, 0x349C, 0xCA, 0x349D, 0x54,
+	0x349E, 0x18, 0x349F, 0xE7, 0x34A0, 0x00,
+	0x34A1, 0x1A, 0x34A2, 0xEE, 0x34A3, 0x03,
+	0x34A4, 0x18, 0x34A5, 0xE6, 0x34A6, 0x00,
+	0x34A7, 0xC4, 0x34A8, 0x1F, 0x34A9, 0xCA,
+	0x34AA, 0x20, 0x34AB, 0x18, 0x34AC, 0xE7,
+	0x34AD, 0x00, 0x34AE, 0xC6, 0x34AF, 0x74,
+	0x34B0, 0x20, 0x34B1, 0x1C, 0x34B2, 0x1A,
+	0x34B3, 0xEE, 0x34B4, 0x05, 0x34B5, 0x18,
+	0x34B6, 0xE6, 0x34B7, 0x00, 0x34B8, 0xC4,
+	0x34B9, 0x03, 0x34BA, 0xCA, 0x34BB, 0x48,
+	0x34BC, 0x18, 0x34BD, 0xE7, 0x34BE, 0x00,
+	0x34BF, 0x1A, 0x34C0, 0xEE, 0x34C1, 0x03,
+	0x34C2, 0x18, 0x34C3, 0xE6, 0x34C4, 0x00,
+	0x34C5, 0xC4, 0x34C6, 0x1F, 0x34C7, 0xCA,
+	0x34C8, 0x20, 0x34C9, 0x18, 0x34CA, 0xE7,
+	0x34CB, 0x00, 0x34CC, 0xC6, 0x34CD, 0x52,
+	0x34CE, 0x18, 0x34CF, 0x08, 0x34D0, 0x18,
+	0x34D1, 0xE7, 0x34D2, 0x00, 0x34D3, 0xAE,
+	0x34D4, 0x00, 0x34D5, 0x38, 0x34D6, 0x39,
+	0x34D7, 0x00, 0x3400, 0x01, 0x33f8, 0x01
+#endif
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/festa_v272_2723.h b/drivers/net/ethernet/hisilicon/hisi-femac/festa_v272_2723.h
new file mode 100644
index 000000000..edb9d53bb
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/festa_v272_2723.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Hieth driver festa_v272_2723 phy fixup paramters
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#ifndef __HIETH_FESTA_V272_2723_H__
+#define __HIETH_FESTA_V272_2723_H__
+	0x33f9, 0xbd, 0x33fa, 0x34, 0x33fb, 0x00,
+	0x33fc, 0x39, 0x3400, 0x39, 0x3401, 0xCC,
+	0x3402, 0x27, 0x3403, 0x23, 0x3404, 0xFD,
+	0x3405, 0xFF, 0x3406, 0xF0, 0x3407, 0x20,
+	0x3408, 0x00, 0x3409, 0x3C, 0x340A, 0x3C,
+	0x340B, 0x30, 0x340C, 0xF6, 0x340D, 0x00,
+	0x340E, 0x4A, 0x340F, 0xC4, 0x3410, 0x7F,
+	0x3411, 0xE7, 0x3412, 0x01, 0x3413, 0xF6,
+	0x3414, 0x01, 0x3415, 0xBE, 0x3416, 0xC1,
+	0x3417, 0x02, 0x3418, 0x27, 0x3419, 0x0E,
+	0x341A, 0xE6, 0x341B, 0x01, 0x341C, 0xC1,
+	0x341D, 0x14, 0x341E, 0x27, 0x341F, 0x08,
+	0x3420, 0xC1, 0x3421, 0x18, 0x3422, 0x25,
+	0x3423, 0x09, 0x3424, 0xC1, 0x3425, 0x1B,
+	0x3426, 0x22, 0x3427, 0x05, 0x3428, 0xC6,
+	0x3429, 0x5C, 0x342A, 0xF7, 0x342B, 0x20,
+	0x342C, 0xA1, 0x342D, 0xF6, 0x342E, 0x01,
+	0x342F, 0xBF, 0x3430, 0xC1, 0x3431, 0x01,
+	0x3432, 0x26, 0x3433, 0x29, 0x3434, 0xF6,
+	0x3435, 0x30, 0x3436, 0x55, 0x3437, 0xC0,
+	0x3438, 0x05, 0x3439, 0xE7, 0x343A, 0x01,
+	0x343B, 0xC1, 0x343C, 0x13, 0x343D, 0x23,
+	0x343E, 0x04, 0x343F, 0xC6, 0x3440, 0x13,
+	0x3441, 0xE7, 0x3442, 0x01, 0x3443, 0x18,
+	0x3444, 0xFE, 0x3445, 0x30, 0x3446, 0x4C,
+	0x3447, 0x18, 0x3448, 0x3A, 0x3449, 0x18,
+	0x344A, 0xE6, 0x344B, 0x00, 0x344C, 0x58,
+	0x344D, 0x58, 0x344E, 0x58, 0x344F, 0x58,
+	0x3450, 0x58, 0x3451, 0xE7, 0x3452, 0x00,
+	0x3453, 0xF6, 0x3454, 0x20, 0x3455, 0x04,
+	0x3456, 0xC4, 0x3457, 0x1F, 0x3458, 0xEA,
+	0x3459, 0x00, 0x345A, 0xF7, 0x345B, 0x20,
+	0x345C, 0x04, 0x345D, 0x38, 0x345E, 0x38,
+	0x345F, 0x39, 0x3400, 0x01, 0x33f8, 0x01
+#endif
\ No newline at end of file
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/hisi_femac.c b/drivers/net/ethernet/hisilicon/hisi-femac/hisi_femac.c
new file mode 100644
index 000000000..48815a2d6
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/hisi_femac.c
@@ -0,0 +1,1588 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Hieth driver main process file
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#include <linux/circ_buf.h>
+#include <linux/clk.h>
+#include <linux/etherdevice.h>
+#include <linux/if_ether.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/tcp.h>
+#include <net/protocol.h>
+
+#include "phy_fix.h"
+#include "hisi_femac.h"
+#include "util.h"
+
+static void hisi_femac_irq_enable(const struct hisi_femac_priv *priv, u32 irqs)
+{
+	u32 val;
+
+	val = readl(priv->glb_base + GLB_IRQ_ENA);
+	writel(val | irqs, priv->glb_base + GLB_IRQ_ENA);
+}
+
+static void hisi_femac_irq_disable(const struct hisi_femac_priv *priv, u32 irqs)
+{
+	u32 val;
+
+	val = readl(priv->glb_base + GLB_IRQ_ENA);
+	writel(val & (~irqs), priv->glb_base + GLB_IRQ_ENA);
+}
+
+#ifdef CONFIG_FEPHY_OPT
+static u32 highflag = 0;
+static u32 lowflag = 0;
+static void hisi_femac_trim_phy(struct phy_device *phy_dev, u32 val)
+{
+	u32 val1;
+	/* 32 pieces of data */
+	int table[32] = {0x11, 0x10, 0x10, 0xf, 0xe, 0xd, 0xd, 0xc,
+			 0xb, 0xa, 0xa, 0x9, 0x8, 0x7, 0x7, 0x6,
+			 0x5, 0x5, 0x4, 0x3, 0x2, 0x2, 0x1, 0x0,
+			 0x3f, 0x3f, 0x3e, 0x3d, 0x3c, 0x3b, 0x3a
+			};
+
+	phy_write(phy_dev, MII_EXPMA, FEPHY_TRIM_CACHE);
+	phy_write(phy_dev, MII_EXPMD, val);
+	val &= 0x1f;
+	val1 = table[val];
+	phy_write(phy_dev, MII_EXPMA, FEPHY_TRIM_VALUE);
+	val = (u32)phy_read(phy_dev, MII_EXPMD);
+	val = (val1 << 2) | (val & 0x3); /* shift left 2 bits */
+	phy_write(phy_dev, MII_EXPMA, FEPHY_TRIM_VALUE);
+	phy_write(phy_dev, MII_EXPMD, val);
+}
+
+static void hisi_femac_trim(const struct net_device *dev)
+{
+	struct phy_device *phy_dev = NULL;
+	int temp;
+	u32 val;
+
+	phy_dev = dev->phydev;
+	if (phy_dev == NULL) {
+		pr_err("get phy device failed \n");
+		return;
+	}
+
+	phy_write(phy_dev, MII_EXPMA, FEPHY_TRIM_CACHE);
+	val = (u32)phy_read(phy_dev, MII_EXPMD);
+	temp = regval_to_temp(val);
+	if ((temp > HIGH_TEMP) && (highflag == 0)) {
+		highflag = 1;
+		if ((val & 0x1f) > 1)
+			val = (val & 0xe0) | ((val & 0x1f) - 1);
+		else
+			return;
+		hisi_femac_trim_phy(phy_dev, val);
+	}
+	if ((temp < NORMAL_TEMP1) && (highflag == 1)) {
+		highflag = 0;
+		if ((val & 0x1f) < 0x1f)
+			val = (val & 0xe0) | ((val & 0x1f) + 1);
+		else
+			return;
+		hisi_femac_trim_phy(phy_dev, val);
+	}
+	if ((temp > NORMAL_TEMP2) && (lowflag == 0)) {
+		lowflag = 1;
+		if ((val & 0x1f) > 1)
+			val = (val & 0xe0) | ((val & 0x1f) - 1);
+		else
+			return;
+		hisi_femac_trim_phy(phy_dev, val);
+	}
+	if ((temp < LOW_TEMP) && (lowflag == 1)) {
+		lowflag = 0;
+		if ((val & 0x1f) < 0x1f)
+			val = (val & 0xe0) | ((val & 0x1f) + 1);
+		else
+			return;
+		hisi_femac_trim_phy(phy_dev, val);
+	}
+}
+
+static void hisi_femac_watchdog(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct hisi_femac_priv *priv = container_of(dwork, struct hisi_femac_priv,
+				       watchdog_queue);
+	void __iomem *sys_reg_addr;
+	struct net_device *dev = NULL;
+	u32 val;
+
+	dev = priv->ndev;
+	if (dev == NULL) {
+		pr_err("get net device failed \n");
+		return;
+	}
+
+	sys_reg_addr = (void __iomem *)ioremap_nocache(SYS_REG_ADDR, 0x100);
+	if (!sys_reg_addr) {
+		pr_err("iomap failed \n");
+		return;
+	}
+	val = readl(sys_reg_addr + MISC_CTRL45);
+	if ((val >> 30) != 0x3) { /* bit[30 31] */
+		val |= TSENSOR_EN;
+		writel(val, sys_reg_addr + MISC_CTRL45);
+		mdelay(10); /* wait 10ms */
+	}
+	val = readl(sys_reg_addr + MISC_CTRL47) & TSENSOR_RESULT0;
+	/* high 16bit */
+	val += (readl(sys_reg_addr + MISC_CTRL47) & TSENSOR_RESULT1) >> 16;
+	val += readl(sys_reg_addr + MISC_CTRL48) & TSENSOR_RESULT2;
+	/* high 16bit */
+	val += (readl(sys_reg_addr + MISC_CTRL48) & TSENSOR_RESULT3) >> 16;
+	val = val / 4; /* average value of the 4 values */
+	if (val < LOW_TEM_VALUE || val > HIGH_TEM_VALUE) {
+		goto out;
+	}
+	hisi_femac_trim(dev);
+out:
+	iounmap(sys_reg_addr);
+	schedule_delayed_work(&priv->watchdog_queue, FEPHY_OPT_TIMER);
+}
+#endif
+
+static void hisi_femac_tx_sg_dma_unmap(const struct hisi_femac_priv *priv,
+				       const struct sk_buff *skb, unsigned int pos)
+{
+	struct tx_desc *desc_cur;
+	dma_addr_t addr;
+	u32 len;
+	int i;
+
+	desc_cur = priv->tx_ring.desc + pos;
+
+	addr = desc_cur->linear_addr;
+	len = desc_cur->linear_len;
+	dma_unmap_single(priv->dev, addr, len, DMA_TO_DEVICE);
+
+	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+		addr = desc_cur->frags[i].addr;
+		len = desc_cur->frags[i].size;
+		dma_unmap_page(priv->dev, addr, len, DMA_TO_DEVICE);
+	}
+}
+
+static void hisi_femac_tx_dma_unmap(const struct hisi_femac_priv *priv,
+				    const struct sk_buff *skb, unsigned int pos)
+{
+	if (!(skb_is_gso(skb) || skb_shinfo(skb)->nr_frags)) {
+		dma_addr_t dma_addr;
+
+		dma_addr = priv->txq.dma_phys[pos];
+		dma_unmap_single(priv->dev, dma_addr, skb->len, DMA_TO_DEVICE);
+	} else {
+		hisi_femac_tx_sg_dma_unmap(priv, skb, pos);
+	}
+}
+
+static void hisi_femac_xmit_reclaim(struct net_device *dev)
+{
+	struct sk_buff *skb = NULL;
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct hisi_femac_queue *txq = &priv->txq;
+	unsigned int bytes_compl = 0;
+	unsigned int pkts_compl = 0;
+	u32 val;
+
+	netif_tx_lock(dev);
+
+	val = readl(priv->port_base + ADDRQ_STAT) & TX_CNT_INUSE_MASK;
+	while (val < priv->tx_fifo_used_cnt) {
+		skb = txq->skb[txq->tail];
+		if (unlikely(skb == NULL)) {
+			netdev_err(dev, "xmitq_cnt_inuse=%d, tx_fifo_used=%d\n",
+				   val, priv->tx_fifo_used_cnt);
+			break;
+		}
+		hisi_femac_tx_dma_unmap(priv, skb, txq->tail);
+		pkts_compl++;
+		bytes_compl += skb->len;
+		dev_kfree_skb_any(skb);
+
+		priv->tx_fifo_used_cnt--;
+
+		val = readl(priv->port_base + ADDRQ_STAT) & TX_CNT_INUSE_MASK;
+		txq->skb[txq->tail] = NULL;
+		txq->tail = (txq->tail + 1) % txq->num;
+	}
+
+	netdev_completed_queue(dev, pkts_compl, bytes_compl);
+
+	if (unlikely(netif_queue_stopped(dev)) && pkts_compl)
+		netif_wake_queue(dev);
+
+	netif_tx_unlock(dev);
+}
+
+static void hisi_femac_get_tso_err_info(const struct hisi_femac_priv *priv)
+{
+	unsigned int reg_addr, reg_tx_info, reg_tx_err;
+	unsigned int sg_index;
+	struct tx_desc *sg_desc = NULL;
+	int *sg_word = NULL;
+	int i;
+
+	reg_addr = readl(priv->port_base + TSO_DBG_ADDR);
+	reg_tx_info = readl(priv->port_base + TSO_DBG_TX_INFO);
+	reg_tx_err = readl(priv->port_base + TSO_DBG_TX_ERR);
+
+	WARN(1, "tx err=0x%x, tx_info=0x%x, addr=0x%x\n",
+	     reg_tx_err, reg_tx_info, reg_addr);
+
+	sg_index = (reg_addr - priv->tx_ring.dma_phys) / sizeof(struct tx_desc);
+	sg_desc = priv->tx_ring.desc + sg_index;
+	sg_word = (int *)sg_desc;
+	for (i = 0; i < sizeof(struct tx_desc) / sizeof(int); i++)
+		pr_err("%s,%d: sg_desc word[%d]=0x%x\n",
+		       __func__, __LINE__, i, sg_word[i]);
+
+	/* restart MAC to transmit next packet */
+	hisi_femac_irq_disable(priv, INT_TX_ERR);
+	/*
+	 * If we need allow netcard transmit packet again.
+	 * we should readl TSO_DBG_STATE and enable irq.
+	 */
+}
+
+static netdev_tx_t hisi_femac_net_xmit(struct sk_buff *skb,
+				       struct net_device *dev);
+
+static netdev_tx_t hisi_femac_sw_gso(struct sk_buff *skb,
+				     struct net_device *dev)
+{
+	struct sk_buff *segs = NULL;
+	struct sk_buff *curr_skb = NULL;
+	netdev_features_t features = dev->features;
+
+	features &= ~(NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+		      NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO);
+	segs = skb_gso_segment(skb, features);
+	if (IS_ERR_OR_NULL(segs)) {
+		goto drop;
+	}
+
+	do {
+		curr_skb = segs;
+		segs = segs->next;
+		curr_skb->next = NULL;
+		if (hisi_femac_net_xmit(curr_skb, dev)) {
+			dev_kfree_skb(curr_skb);
+			while (segs != NULL) {
+				curr_skb = segs;
+				segs = segs->next;
+				curr_skb->next = NULL;
+				dev_kfree_skb_any(curr_skb);
+			}
+			goto drop;
+		}
+	} while (segs != NULL);
+
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+
+drop:
+	dev_kfree_skb_any(skb);
+	dev->stats.tx_dropped++;
+	return NETDEV_TX_OK;
+}
+
+static int hisi_femac_fill_sg_desc(const struct hisi_femac_priv *priv,
+				   const struct sk_buff *skb, unsigned int pos)
+{
+	struct tx_desc *desc_cur;
+	dma_addr_t addr;
+	int ret;
+	int i;
+
+	desc_cur = priv->tx_ring.desc + pos;
+
+	desc_cur->ipv6_id = ntohl(skb_shinfo(skb)->ip6_frag_id);
+
+	desc_cur->total_len = skb->len;
+	addr = dma_map_single(priv->dev, skb->data, skb_headlen(skb),
+			      DMA_TO_DEVICE);
+	if (unlikely(dma_mapping_error(priv->dev, addr))) {
+		return -EINVAL;
+	}
+	desc_cur->linear_addr = addr;
+	desc_cur->linear_len = skb_headlen(skb);
+
+	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+		int len = frag->bv_len;
+
+		addr = skb_frag_dma_map(priv->dev, frag, 0, len, DMA_TO_DEVICE);
+		ret = dma_mapping_error(priv->dev, addr);
+		if (unlikely(ret)) {
+			return -EINVAL;
+		}
+		desc_cur->frags[i].addr = addr;
+		desc_cur->frags[i].size = len;
+	}
+
+	return 0;
+}
+
+static void hisi_femac_adjust_link(struct net_device *dev)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct phy_device *phy = dev->phydev;
+	u32 status = 0;
+
+	if (phy->link)
+		status |= MAC_PORTSET_LINKED;
+	if (phy->duplex == DUPLEX_FULL)
+		status |= MAC_PORTSET_DUPLEX_FULL;
+	if (phy->speed == SPEED_100)
+		status |= MAC_PORTSET_SPEED_100M;
+
+	if ((status != priv->link_status) &&
+			((status | priv->link_status) & MAC_PORTSET_LINKED)) {
+		writel(status, priv->port_base + MAC_PORTSET);
+		priv->link_status = status;
+		phy_print_status(phy);
+
+		priv->tx_pause_en = phy->pause;
+		hisi_femac_set_flow_ctrl(priv);
+	}
+}
+
+static void hisi_femac_rx_refill(struct hisi_femac_priv *priv)
+{
+	struct hisi_femac_queue *rxq = &priv->rxq;
+	struct sk_buff *skb = NULL;
+	u32 pos;
+	u32 len;
+	dma_addr_t addr;
+	u32 alloc_rxbuf_align;
+	int reserve_room;
+
+	pos = rxq->head;
+	while (readl(priv->port_base + ADDRQ_STAT) & BIT_RX_READY) {
+		if (!CIRC_SPACE(pos, rxq->tail, rxq->num)) {
+			break;
+		}
+		if (unlikely(rxq->skb[pos])) {
+			netdev_err(priv->ndev, "err skb[%d]=%p\n",
+				   pos, rxq->skb[pos]);
+			break;
+		}
+		len = MAX_FRAME_SIZE + RXBUF_ADDR_ALIGN_SIZE;
+		skb = netdev_alloc_skb_ip_align(priv->ndev, len);
+		if (unlikely(skb == NULL)) {
+			break;
+		}
+
+		alloc_rxbuf_align = ((uintptr_t)skb->data - NET_IP_ALIGN) &
+				    (RXBUF_ADDR_ALIGN_SIZE - 1);
+		if (alloc_rxbuf_align) {
+			reserve_room = RXBUF_ADDR_ALIGN_SIZE -
+				       alloc_rxbuf_align;
+			len -= reserve_room;
+			skb_reserve(skb, reserve_room);
+		}
+
+		addr = dma_map_single(priv->dev, skb->data, len,
+				      DMA_FROM_DEVICE);
+		if (dma_mapping_error(priv->dev, addr)) {
+			dev_kfree_skb_any(skb);
+			break;
+		}
+		rxq->dma_phys[pos] = addr;
+		rxq->skb[pos] = skb;
+		writel(addr, priv->port_base + IQ_ADDR);
+		pos = (pos + 1) % rxq->num;
+	}
+	rxq->head = pos;
+}
+
+#ifdef FEMAC_RX_REFILL_IN_IRQ
+static void hisi_femac_recv_queue(struct net_device *dev, struct sk_buff *skb,
+				  u32 rx_pkt_info)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	int hdr_csum_done, hdr_csum_err;
+	int payload_csum_done, payload_csum_err;
+
+	skb->ip_summed = CHECKSUM_NONE;
+	if (dev->features & NETIF_F_RXCSUM) {
+		hdr_csum_done =
+			(rx_pkt_info >> BITS_HEADER_DONE_OFFSET) &
+			BITS_HEADER_DONE_MASK;
+		payload_csum_done =
+			(rx_pkt_info >> BITS_PAYLOAD_DONE_OFFSET) &
+			BITS_PAYLOAD_DONE_MASK;
+		hdr_csum_err =
+			(rx_pkt_info >> BITS_HEADER_ERR_OFFSET) &
+			BITS_HEADER_ERR_MASK;
+		payload_csum_err =
+			(rx_pkt_info >> BITS_PAYLOAD_ERR_OFFSET) &
+			BITS_PAYLOAD_ERR_MASK;
+
+		if (hdr_csum_done && payload_csum_done) {
+			if (unlikely(hdr_csum_err)) {
+				dev->stats.rx_errors++;
+				dev->stats.rx_crc_errors++;
+				dev_kfree_skb_any(skb);
+				return;
+			} else if (!payload_csum_err) {
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+			}
+		}
+	}
+	skb_queue_tail(&priv->rx_head, skb);
+}
+
+static void hisi_femac_pre_receive(struct net_device *dev)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct hisi_femac_queue *rxq = &priv->rxq;
+	struct sk_buff *skb = NULL;
+	u32 rx_pkt_info, pos, len;
+	unsigned long rxflags;
+
+	spin_lock_irqsave(&priv->rxlock, rxflags);
+	pos = rxq->tail;
+	while (readl(priv->glb_base + GLB_IRQ_RAW) & IRQ_INT_RX_RDY) {
+		rx_pkt_info = readl(priv->port_base + IQFRM_DES);
+		len = rx_pkt_info & RX_FRAME_LEN_MASK;
+		len -= ETH_FCS_LEN;
+
+		/* tell hardware we will deal with this packet */
+		writel(IRQ_INT_RX_RDY, priv->glb_base + GLB_IRQ_RAW);
+
+		skb = rxq->skb[pos];
+		if (unlikely(skb == NULL)) {
+			netdev_err(dev, "rx skb NULL. pos=%d\n", pos);
+			break;
+		}
+		rxq->skb[pos] = NULL;
+
+		dma_unmap_single(priv->dev, rxq->dma_phys[pos], MAX_FRAME_SIZE,
+				 DMA_FROM_DEVICE);
+		skb_put(skb, len);
+		if (unlikely(skb->len > MAX_FRAME_SIZE)) {
+			netdev_err(dev, "rcv len err, len = %d\n", skb->len);
+			dev->stats.rx_errors++;
+			dev->stats.rx_length_errors++;
+			dev_kfree_skb_any(skb);
+			goto next;
+		}
+
+		hisi_femac_recv_queue(dev, skb, rx_pkt_info);
+next:
+		pos = (pos + 1) % rxq->num;
+	}
+	rxq->tail = pos;
+
+	hisi_femac_rx_refill(priv);
+	spin_unlock_irqrestore(&priv->rxlock, rxflags);
+}
+
+static u32 hisi_femac_rx(struct net_device *dev, int limit)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct sk_buff *skb = skb_dequeue(&priv->rx_head);
+	u32 rx_pkts_num = 0;
+
+	while (skb != NULL) {
+		skb->protocol = eth_type_trans(skb, dev);
+		napi_gro_receive(&priv->napi, skb);
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += skb->len;
+		rx_pkts_num++;
+
+		if (rx_pkts_num >= limit) {
+			break;
+		}
+		skb = skb_dequeue(&priv->rx_head);
+	}
+
+	return rx_pkts_num;
+}
+#else
+static int hisi_femac_recv_queue(struct net_device *dev, struct sk_buff *skb,
+				 u32 rx_pkt_info)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	int hdr_csum_done, hdr_csum_err;
+	int payload_csum_done, payload_csum_err;
+
+	skb->ip_summed = CHECKSUM_NONE;
+	if (dev->features & NETIF_F_RXCSUM) {
+		hdr_csum_done =
+			(rx_pkt_info >> BITS_HEADER_DONE_OFFSET) &
+			BITS_HEADER_DONE_MASK;
+		payload_csum_done =
+			(rx_pkt_info >> BITS_PAYLOAD_DONE_OFFSET) &
+			BITS_PAYLOAD_DONE_MASK;
+		hdr_csum_err =
+			(rx_pkt_info >> BITS_HEADER_ERR_OFFSET) &
+			BITS_HEADER_ERR_MASK;
+		payload_csum_err =
+			(rx_pkt_info >> BITS_PAYLOAD_ERR_OFFSET) &
+			BITS_PAYLOAD_ERR_MASK;
+
+		if (hdr_csum_done && payload_csum_done) {
+			if (unlikely(hdr_csum_err)) {
+				dev->stats.rx_errors++;
+				dev->stats.rx_crc_errors++;
+				dev_kfree_skb_any(skb);
+				return -1;
+			} else if (!payload_csum_err) {
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+			}
+		}
+	}
+	return 0;
+}
+
+static u32 hisi_femac_rx(struct net_device *dev, int limit)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct hisi_femac_queue *rxq = &priv->rxq;
+	struct sk_buff *skb;
+	u32 rx_pkt_info, pos, len;
+	u32 rx_pkts_num = 0;
+
+	pos = rxq->tail;
+	while (readl(priv->glb_base + GLB_IRQ_RAW) & IRQ_INT_RX_RDY) {
+		rx_pkt_info = readl(priv->port_base + IQFRM_DES);
+		len = rx_pkt_info & RX_FRAME_LEN_MASK;
+		len -= ETH_FCS_LEN;
+
+		/* tell hardware we will deal with this packet */
+		writel(IRQ_INT_RX_RDY, priv->glb_base + GLB_IRQ_RAW);
+
+		rx_pkts_num++;
+
+		skb = rxq->skb[pos];
+		if (unlikely(!skb)) {
+			netdev_err(dev, "rx skb NULL. pos=%d\n", pos);
+			break;
+		}
+		rxq->skb[pos] = NULL;
+
+		dma_unmap_single(priv->dev, rxq->dma_phys[pos], MAX_FRAME_SIZE,
+				 DMA_FROM_DEVICE);
+		skb_put(skb, len);
+		if (unlikely(skb->len > MAX_FRAME_SIZE)) {
+			netdev_err(dev, "rcv len err, len = %d\n", skb->len);
+			dev->stats.rx_errors++;
+			dev->stats.rx_length_errors++;
+			dev_kfree_skb_any(skb);
+			goto next;
+		}
+
+		if (hisi_femac_recv_queue(dev, skb, rx_pkt_info) < 0)
+			goto next;
+
+		skb->protocol = eth_type_trans(skb, dev);
+		napi_gro_receive(&priv->napi, skb);
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += len;
+next:
+		pos = (pos + 1) % rxq->num;
+		if (rx_pkts_num >= limit) {
+			break;
+		}
+	}
+	rxq->tail = pos;
+
+	hisi_femac_rx_refill(priv);
+
+	return rx_pkts_num;
+}
+#endif
+
+static int hisi_femac_poll(struct napi_struct *napi, int budget)
+{
+	struct hisi_femac_priv *priv = container_of(napi,
+				       struct hisi_femac_priv, napi);
+	struct net_device *dev = priv->ndev;
+	int work_done = 0;
+	int task = budget;
+	u32 ints, num;
+
+	do {
+#ifdef FEMAC_RX_REFILL_IN_IRQ
+		hisi_femac_pre_receive(dev);
+#endif
+		hisi_femac_xmit_reclaim(dev);
+		num = hisi_femac_rx(dev, task);
+		work_done += num;
+		task -= num;
+		if (work_done >= budget) {
+			break;
+		}
+
+		ints = readl(priv->glb_base + GLB_IRQ_RAW);
+		writel(ints & DEF_INT_MASK,
+		       priv->glb_base + GLB_IRQ_RAW);
+	} while (ints & DEF_INT_MASK);
+
+	if (work_done < budget) {
+		napi_complete(napi);
+		hisi_femac_irq_enable(priv, DEF_INT_MASK &
+				      (~IRQ_INT_TX_PER_PACKET));
+	}
+
+	return work_done;
+}
+
+static irqreturn_t hisi_femac_interrupt(int irq, void *dev_id)
+{
+	u32 ints;
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+
+	ints = readl(priv->glb_base + GLB_IRQ_RAW);
+	if (likely(ints & DEF_INT_MASK)) {
+#ifdef FEMAC_RX_REFILL_IN_IRQ
+		hisi_femac_pre_receive(dev);
+#endif
+		writel(ints & DEF_INT_MASK,
+		       priv->glb_base + GLB_IRQ_RAW);
+		hisi_femac_irq_disable(priv, DEF_INT_MASK);
+		napi_schedule(&priv->napi);
+	}
+
+	if (has_tso_cap(priv->hw_cap) && unlikely(ints & INT_TX_ERR))
+		hisi_femac_get_tso_err_info(priv);
+
+	return IRQ_HANDLED;
+}
+
+static int hisi_femac_init_tx_descriptor_ring(struct hisi_femac_priv *priv)
+{
+	priv->tx_ring.desc = (struct tx_desc *)dma_alloc_coherent(priv->dev,
+			     TXQ_NUM * sizeof(struct tx_desc), &priv->tx_ring.dma_phys, GFP_KERNEL);
+	if (!priv->tx_ring.desc) {
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void hisi_femac_destroy_tx_descriptor_ring(struct hisi_femac_priv *priv)
+{
+	if (priv->tx_ring.desc)
+		dma_free_coherent(priv->dev, TXQ_NUM * sizeof(struct tx_desc),
+				  priv->tx_ring.desc, priv->tx_ring.dma_phys);
+	priv->tx_ring.desc = NULL;
+}
+
+static int hisi_femac_init_queue(struct device *dev,
+				 struct hisi_femac_queue *queue, unsigned int num)
+{
+	queue->skb = devm_kcalloc(dev, num, sizeof(struct sk_buff *), GFP_KERNEL);
+	if (queue->skb == NULL) {
+		return -ENOMEM;
+	}
+
+	queue->dma_phys = devm_kcalloc(dev, num, sizeof(dma_addr_t), GFP_KERNEL);
+	if (queue->dma_phys == NULL) {
+		return -ENOMEM;
+	}
+
+	queue->num = num;
+	queue->head = 0;
+	queue->tail = 0;
+
+	return 0;
+}
+
+static int hisi_femac_init_tx_and_rx_queues(struct hisi_femac_priv *priv)
+{
+	int ret;
+
+	ret = hisi_femac_init_queue(priv->dev, &priv->txq, TXQ_NUM);
+	if (ret) {
+		return ret;
+	}
+
+	ret = hisi_femac_init_queue(priv->dev, &priv->rxq, RXQ_NUM);
+	if (ret) {
+		return ret;
+	}
+
+	priv->tx_fifo_used_cnt = 0;
+
+	return 0;
+}
+
+static void hisi_femac_free_skb_rings(struct hisi_femac_priv *priv)
+{
+	struct hisi_femac_queue *txq = &priv->txq;
+	struct hisi_femac_queue *rxq = &priv->rxq;
+	struct sk_buff *skb = NULL;
+	dma_addr_t dma_addr;
+	u32 pos;
+
+	pos = rxq->tail;
+	while (pos != rxq->head) {
+		skb = rxq->skb[pos];
+		if (unlikely(skb == NULL)) {
+			netdev_err(priv->ndev, "NULL rx skb. pos=%d, head=%d\n",
+				   pos, rxq->head);
+			pos = (pos + 1) % rxq->num;
+			continue;
+		}
+
+		dma_addr = rxq->dma_phys[pos];
+		dma_unmap_single(priv->dev, dma_addr, MAX_FRAME_SIZE, DMA_FROM_DEVICE);
+
+		dev_kfree_skb_any(skb);
+		rxq->skb[pos] = NULL;
+		pos = (pos + 1) % rxq->num;
+	}
+	rxq->tail = pos;
+
+	pos = txq->tail;
+	while (pos != txq->head) {
+		skb = txq->skb[pos];
+		if (unlikely(skb == NULL)) {
+			netdev_err(priv->ndev, "NULL tx skb. pos=%d, head=%d\n",
+				   pos, txq->head);
+			pos = (pos + 1) % txq->num;
+			continue;
+		}
+		hisi_femac_tx_dma_unmap(priv, skb, pos);
+		dev_kfree_skb_any(skb);
+		txq->skb[pos] = NULL;
+		pos = (pos + 1) % txq->num;
+	}
+	txq->tail = pos;
+	priv->tx_fifo_used_cnt = 0;
+}
+
+static int hisi_femac_set_hw_mac_addr(const struct hisi_femac_priv *priv,
+				      const unsigned char *mac)
+{
+	u32 reg;
+
+	reg = mac[1] | (mac[0] << 8);  /* mac0 is high 8 bits */
+	writel(reg, priv->glb_base + GLB_HOSTMAC_H16);
+	/* addr2 [24 31] addr3 [16 23] addr4 [8 15]  addr5 [0 7] */
+	reg = mac[5] | (mac[4] << 8) | (mac[3] << 16) | (mac[2] << 24);
+	writel(reg, priv->glb_base + GLB_HOSTMAC_L32);
+
+	return 0;
+}
+
+static int hisi_femac_port_reset(const struct hisi_femac_priv *priv)
+{
+	u32 val;
+
+	val = readl(priv->glb_base + GLB_SOFT_RESET);
+	val |= SOFT_RESET_ALL;
+	writel(val, priv->glb_base + GLB_SOFT_RESET);
+
+	usleep_range(500, 800); /* wait 500-800us */
+
+	val &= ~SOFT_RESET_ALL;
+	writel(val, priv->glb_base + GLB_SOFT_RESET);
+
+	return 0;
+}
+
+static int hisi_femac_net_open(struct net_device *dev)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+
+	hisi_femac_set_hw_mac_addr(priv, dev->dev_addr);
+	/*
+	 * clear interrupts will drop the first packet MAC have received,
+	 * so do it before refill the rx free skbs.
+	 */
+	writel(IRQ_ENA_PORT0_MASK, priv->glb_base + GLB_IRQ_RAW);
+	hisi_femac_rx_refill(priv);
+
+	netif_carrier_off(dev);
+	netdev_reset_queue(dev);
+	netif_start_queue(dev);
+	napi_enable(&priv->napi);
+
+	priv->link_status = 0;
+	if (dev->phydev)
+		phy_start(dev->phydev);
+
+	hisi_femac_irq_enable(priv, IRQ_ENA_ALL | IRQ_ENA_PORT0 | DEF_INT_MASK);
+	if (has_tso_cap(priv->hw_cap))
+		hisi_femac_irq_enable(priv, INT_TX_ERR);
+
+	return 0;
+}
+
+static void hisi_femac_port_init(struct hisi_femac_priv *priv);
+
+static int hisi_femac_net_close(struct net_device *dev)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+
+	hisi_femac_irq_disable(priv, IRQ_ENA_PORT0);
+
+	if (dev->phydev)
+		phy_stop(dev->phydev);
+
+	netif_stop_queue(dev);
+	napi_disable(&priv->napi);
+
+	/*
+	 * reset MAC port first before free skb rings
+	 * to prevent potential risk of use-after-free.
+	 */
+	hisi_femac_port_reset(priv);
+	hisi_femac_port_init(priv);
+
+	priv->tx_pause_en = false;
+	hisi_femac_set_flow_ctrl(priv);
+	hisi_femac_free_skb_rings(priv);
+#ifdef FEMAC_RX_REFILL_IN_IRQ
+	skb_queue_purge(&priv->rx_head);
+#endif
+
+	return 0;
+}
+
+static bool hisi_femac_net_isready(struct net_device *dev)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct hisi_femac_queue *txq = &priv->txq;
+	u32 val;
+
+	val = readl(priv->port_base + ADDRQ_STAT);
+	val &= BIT_TX_READY;
+	if (!val) {
+		hisi_femac_irq_enable(priv, IRQ_INT_TX_PER_PACKET);
+		dev->stats.tx_dropped++;
+		dev->stats.tx_fifo_errors++;
+		netif_stop_queue(dev);
+		return false;
+	}
+
+	if (unlikely(!CIRC_SPACE(txq->head, txq->tail,
+				 txq->num))) {
+		hisi_femac_irq_enable(priv, IRQ_INT_TX_PER_PACKET);
+		dev->stats.tx_dropped++;
+		dev->stats.tx_fifo_errors++;
+		netif_stop_queue(dev);
+		return false;
+	}
+
+	return true;
+}
+
+static netdev_tx_t hisi_femac_net_xmit(struct sk_buff *skb,
+				       struct net_device *dev)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct hisi_femac_queue *txq = &priv->txq;
+	dma_addr_t addr;
+	int ret;
+	u32 pkt_info;
+
+	if (!hisi_femac_net_isready(dev))
+		return NETDEV_TX_BUSY;
+
+	ret = hisi_femac_check_hw_capability(skb);
+	if (unlikely(ret)) {
+		if (ret == -ENOTSUPP)
+			return hisi_femac_sw_gso(skb, dev);
+
+		dev_kfree_skb_any(skb);
+		dev->stats.tx_dropped++;
+		return NETDEV_TX_OK;
+	}
+
+	pkt_info = hisi_femac_get_pkt_info(skb);
+
+	if (!(skb_is_gso(skb) || skb_shinfo(skb)->nr_frags)) {
+		addr = dma_map_single(priv->dev, skb->data,
+				      skb->len, DMA_TO_DEVICE);
+		if (unlikely(dma_mapping_error(priv->dev, addr))) {
+			dev_kfree_skb_any(skb);
+			dev->stats.tx_dropped++;
+			return NETDEV_TX_OK;
+		}
+	} else {
+		ret = hisi_femac_fill_sg_desc(priv, skb, txq->head);
+		if (unlikely(ret)) {
+			dev_kfree_skb_any(skb);
+			dev->stats.tx_dropped++;
+			return NETDEV_TX_OK;
+		}
+
+		addr = priv->tx_ring.dma_phys +
+		       txq->head * sizeof(struct tx_desc);
+
+		/* Ensure desc info writen to memory before config hardware */
+		wmb();
+	}
+	txq->dma_phys[txq->head] = addr;
+
+	skb_tx_timestamp(skb);
+
+	txq->skb[txq->head] = skb;
+	txq->head = (txq->head + 1) % txq->num;
+
+	writel(addr, priv->port_base + EQ_ADDR);
+	writel(pkt_info, priv->port_base + EQFRM_LEN);
+
+	priv->tx_fifo_used_cnt++;
+
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+	netdev_sent_queue(dev, skb->len);
+
+	return NETDEV_TX_OK;
+}
+
+static int hisi_femac_set_mac_address(struct net_device *dev, void *p)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct sockaddr *skaddr = p;
+
+	if (!is_valid_ether_addr(skaddr->sa_data)) {
+		return -EADDRNOTAVAIL;
+	}
+
+	memcpy(dev->dev_addr, skaddr->sa_data, dev->addr_len);
+	dev->addr_assign_type &= ~NET_ADDR_RANDOM;
+
+	hisi_femac_set_hw_mac_addr(priv, dev->dev_addr);
+
+	return 0;
+}
+
+static void hisi_femac_enable_hw_addr_filter(const struct hisi_femac_priv *priv,
+		unsigned int reg_n, bool enable)
+{
+	u32 val;
+
+	val = readl(priv->glb_base + glb_mac_h16(reg_n));
+	if (enable) {
+		val |= BIT_MACFLT_ENA;
+	} else {
+		val &= ~BIT_MACFLT_ENA;
+	}
+	writel(val, priv->glb_base + glb_mac_h16(reg_n));
+}
+
+static void hisi_femac_set_hw_addr_filter(const struct hisi_femac_priv *priv,
+		const unsigned char *addr, unsigned int reg_n)
+{
+	unsigned int high, low;
+	u32 val;
+
+	high = glb_mac_h16(reg_n);
+	low = glb_mac_l32(reg_n);
+	/* addr2 [24 31] addr3 [16 23] addr4 [8 15]  addr5 [0 7] */
+	val = (addr[2] << 24) | (addr[3] << 16) | (addr[4] << 8) | addr[5];
+	writel(val, priv->glb_base + low);
+
+	val = readl(priv->glb_base + high);
+	val &= ~MACFLT_HI16_MASK;
+	val |= ((addr[0] << 8) | addr[1]); /* addr0 is high 8 bits */
+	val |= (BIT_MACFLT_ENA | BIT_MACFLT_FW2CPU);
+	writel(val, priv->glb_base + high);
+}
+
+static void hisi_femac_set_promisc_mode(const struct hisi_femac_priv *priv,
+					bool promisc_mode)
+{
+	u32 val;
+
+	val = readl(priv->glb_base + GLB_FWCTRL);
+	if (promisc_mode) {
+		val |= FWCTRL_FWALL2CPU;
+	} else {
+		val &= ~FWCTRL_FWALL2CPU;
+	}
+	writel(val, priv->glb_base + GLB_FWCTRL);
+}
+
+/* Handle multiple multicast addresses (perfect filtering) */
+static void hisi_femac_set_mc_addr_filter(const struct hisi_femac_priv *priv)
+{
+	struct net_device *dev = priv->ndev;
+	u32 val;
+
+	val = readl(priv->glb_base + GLB_MACTCTRL);
+	if ((netdev_mc_count(dev) > MAX_MULTICAST_ADDRESSES) ||
+			(dev->flags & IFF_ALLMULTI)) {
+		val |= MACTCTRL_MULTI2CPU;
+	} else {
+		int reg = MAX_UNICAST_ADDRESSES;
+		int i;
+		struct netdev_hw_addr *ha = NULL;
+
+		for (i = reg; i < MAX_MAC_FILTER_NUM; i++)
+			hisi_femac_enable_hw_addr_filter(priv, i, false);
+
+		netdev_for_each_mc_addr(ha, dev) {
+			hisi_femac_set_hw_addr_filter(priv, ha->addr, reg);
+			reg++;
+		}
+		val &= ~MACTCTRL_MULTI2CPU;
+	}
+	writel(val, priv->glb_base + GLB_MACTCTRL);
+}
+
+/* Handle multiple unicast addresses (perfect filtering) */
+static void hisi_femac_set_uc_addr_filter(const struct hisi_femac_priv *priv)
+{
+	struct net_device *dev = priv->ndev;
+	u32 val;
+
+	val = readl(priv->glb_base + GLB_MACTCTRL);
+	if (netdev_uc_count(dev) > MAX_UNICAST_ADDRESSES) {
+		val |= MACTCTRL_UNI2CPU;
+	} else {
+		int reg = 0;
+		int i;
+		struct netdev_hw_addr *ha = NULL;
+
+		for (i = reg; i < MAX_UNICAST_ADDRESSES; i++)
+			hisi_femac_enable_hw_addr_filter(priv, i, false);
+
+		netdev_for_each_uc_addr(ha, dev) {
+			hisi_femac_set_hw_addr_filter(priv, ha->addr, reg);
+			reg++;
+		}
+		val &= ~MACTCTRL_UNI2CPU;
+	}
+	writel(val, priv->glb_base + GLB_MACTCTRL);
+}
+
+static void hisi_femac_net_set_rx_mode(struct net_device *dev)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+
+	if (dev->flags & IFF_PROMISC) {
+		hisi_femac_set_promisc_mode(priv, true);
+	} else {
+		hisi_femac_set_promisc_mode(priv, false);
+		hisi_femac_set_mc_addr_filter(priv);
+		hisi_femac_set_uc_addr_filter(priv);
+	}
+}
+
+static int hisi_femac_net_ioctl(struct net_device *dev,
+				struct ifreq *ifreq, int cmd)
+{
+	if (!netif_running(dev)) {
+		return -EINVAL;
+	}
+
+	if (!dev->phydev) {
+		return -EINVAL;
+	}
+
+	return phy_mii_ioctl(dev->phydev, ifreq, cmd);
+}
+
+static const struct ethtool_ops hisi_femac_ethtools_ops = {
+	.get_link = ethtool_op_get_link,
+	.get_link_ksettings = phy_ethtool_get_link_ksettings,
+	.set_link_ksettings = phy_ethtool_set_link_ksettings,
+	.get_pauseparam = hisi_femac_get_pauseparam,
+	.set_pauseparam = hisi_femac_set_pauseparam,
+	.get_ts_info = ethtool_op_get_ts_info,
+};
+
+static const struct net_device_ops hisi_femac_netdev_ops = {
+	.ndo_open = hisi_femac_net_open,
+	.ndo_stop = hisi_femac_net_close,
+	.ndo_start_xmit = hisi_femac_net_xmit,
+	.ndo_do_ioctl = hisi_femac_net_ioctl,
+	.ndo_set_mac_address = hisi_femac_set_mac_address,
+	.ndo_set_rx_mode = hisi_femac_net_set_rx_mode,
+	.ndo_set_features = hisi_femac_set_features,
+};
+
+static void hisi_femac_verify_flow_ctrl_args(struct hisi_femac_priv *priv)
+{
+	if (priv->tx_pause_active_thresh < FC_ACTIVE_MIN ||
+		priv->tx_pause_active_thresh > FC_ACTIVE_MAX)
+		priv->tx_pause_active_thresh = FC_ACTIVE_DEFAULT;
+
+	if (priv->tx_pause_deactive_thresh < FC_DEACTIVE_MIN ||
+		priv->tx_pause_deactive_thresh > FC_DEACTIVE_MAX)
+		priv->tx_pause_deactive_thresh = FC_DEACTIVE_DEFAULT;
+
+	if (priv->tx_pause_active_thresh >= priv->tx_pause_deactive_thresh) {
+		priv->tx_pause_active_thresh = FC_ACTIVE_DEFAULT;
+		priv->tx_pause_deactive_thresh = FC_DEACTIVE_DEFAULT;
+	}
+}
+
+static void hisi_femac_core_reset(const struct hisi_femac_priv *priv)
+{
+	reset_control_assert(priv->mac_rst);
+	reset_control_deassert(priv->mac_rst);
+}
+
+static void hisi_femac_phy_reset(const struct hisi_femac_priv *priv)
+{
+	/*
+	 * To make sure PHY hardware reset success,
+	 * we must keep PHY in deassert state first and
+	 * then complete the hardware reset operation
+	 */
+	reset_control_deassert(priv->phy_rst);
+	hisi_femac_sleep_us(priv->phy_reset_delays[PRE_DELAY]);
+
+	reset_control_assert(priv->phy_rst);
+	/*
+	 * delay some time to ensure reset ok,
+	 * this depends on PHY hardware feature
+	 */
+	hisi_femac_sleep_us(priv->phy_reset_delays[PULSE]);
+	reset_control_deassert(priv->phy_rst);
+	/* delay some time to ensure later MDIO access */
+	hisi_femac_sleep_us(priv->phy_reset_delays[POST_DELAY]);
+}
+
+static void hisi_femac_port_init(struct hisi_femac_priv *priv)
+{
+	u32 val;
+
+	/* MAC gets link status info and phy mode by software config */
+	val = MAC_PORTSEL_STAT_CPU;
+	if (priv->ndev->phydev->interface == PHY_INTERFACE_MODE_RMII)
+		val |= MAC_PORTSEL_RMII;
+	writel(val, priv->port_base + MAC_PORTSEL);
+
+	/* clear all interrupt status */
+	writel(IRQ_ENA_PORT0_MASK, priv->glb_base + GLB_IRQ_RAW);
+	hisi_femac_irq_disable(priv, IRQ_ENA_PORT0_MASK | IRQ_ENA_PORT0);
+
+	if (has_tso_cap(priv->hw_cap)) {
+		/* enable TSO debug for error handle */
+		val = readl(priv->port_base + TSO_DBG_EN);
+		val |= BITS_TSO_DBG_EN;
+		writel(val, priv->port_base + TSO_DBG_EN);
+	}
+
+	val = readl(priv->glb_base + GLB_FWCTRL);
+	val &= ~(FWCTRL_VLAN_ENABLE | FWCTRL_FWALL2CPU);
+	val |= FWCTRL_FW2CPU_ENA;
+	writel(val, priv->glb_base + GLB_FWCTRL);
+
+	val = readl(priv->glb_base + GLB_MACTCTRL);
+	val |= (MACTCTRL_BROAD2CPU | MACTCTRL_MACT_ENA);
+	writel(val, priv->glb_base + GLB_MACTCTRL);
+
+	val = readl(priv->port_base + MAC_SET);
+	val &= ~MAX_FRAME_SIZE_MASK;
+	val |= MAX_FRAME_SIZE;
+	writel(val, priv->port_base + MAC_SET);
+
+	val = RX_COALESCED_TIMER |
+	      (RX_COALESCED_FRAMES << RX_COALESCED_FRAME_OFFSET);
+	writel(val, priv->port_base + RX_COALESCE_SET);
+
+	val = (HW_RX_FIFO_DEPTH << RX_DEPTH_OFFSET) | HW_TX_FIFO_DEPTH;
+	writel(val, priv->port_base + QLEN_SET);
+
+	hisi_femac_set_flow_ctrl(priv);
+}
+
+static int hisi_femac_drv_res(struct platform_device *pdev,
+			      struct hisi_femac_priv *priv)
+{
+	struct resource *res = NULL;
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	int ret;
+
+	if (of_device_is_compatible(node, "hisilicon,hisi-femac-v2"))
+		priv->hw_cap |= HW_CAP_TSO | HW_CAP_RXCSUM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->port_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->port_base)) {
+		ret = PTR_ERR(priv->port_base);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	priv->glb_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->glb_base)) {
+		ret = PTR_ERR(priv->glb_base);
+		return ret;
+	}
+
+	priv->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "failed to get clk\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret) {
+		dev_err(dev, "failed to enable clk %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int hisi_femac_drv_mac(struct platform_device *pdev,
+			      struct hisi_femac_priv *priv)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	const char *mac_addr = NULL;
+	struct net_device *ndev = priv->ndev;
+
+	priv->mac_rst = devm_reset_control_get(dev, "mac");
+	if (IS_ERR(priv->mac_rst))
+		return PTR_ERR(priv->mac_rst);
+
+	hisi_femac_core_reset(priv);
+
+	mac_addr = of_get_mac_address(node);
+	if (!IS_ERR(mac_addr))
+		ether_addr_copy(ndev->dev_addr, mac_addr);
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		eth_hw_addr_random(ndev);
+		dev_warn(dev, "using random MAC address %pM\n",
+			 ndev->dev_addr);
+	}
+	return 0;
+}
+
+static struct phy_device *hisi_femac_drv_phy(struct platform_device *pdev,
+		struct hisi_femac_priv *priv, int *ret)
+{
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(supported) = { 0, };
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising) = { 0, };
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct phy_device *phy = NULL;
+
+	priv->phy_rst = devm_reset_control_get(dev, "phy");
+	if (IS_ERR(priv->phy_rst)) {
+		priv->phy_rst = NULL;
+	} else {
+		*ret = of_property_read_u32_array(node, PHY_RESET_DELAYS_PROPERTY,
+						  priv->phy_reset_delays, DELAYS_NUM);
+		if (*ret)
+			return phy;
+		hisi_femac_phy_reset(priv);
+	}
+
+	phy_register_fixups();
+
+	phy = of_phy_get_and_connect(priv->ndev, node, hisi_femac_adjust_link);
+	if (phy == NULL) {
+		/* check if a fixed-link is defined in device-tree */
+		if (of_phy_is_fixed_link(node)) {
+			*ret = of_phy_register_fixed_link(node);
+			if (*ret < 0) {
+				dev_err(dev, "cannot regitster fixed link phy %d \n", *ret);
+				return phy;
+			}
+			/*
+			 * In case of a fixed link phy, the DT node associated
+			 * to the phy is the Ethernet MAC DT node.
+			 */
+			phy_interface_t iface = PHY_INTERFACE_MODE_NA;
+			of_get_phy_mode(node, &iface);
+			phy = of_phy_connect(priv->ndev, of_node_get(node), &hisi_femac_adjust_link, 0,
+					     iface);
+			if (phy == NULL) {
+				dev_err(dev, "fixed_link didnot connect successfully.\n");
+				return phy;
+			}
+		} else {
+			dev_err(dev, "connect to PHY failed!\n");
+			*ret = -ENODEV;
+			return phy;
+		}
+	}
+
+	linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, advertising);
+	linkmode_or(phy->advertising, phy->advertising, advertising);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, supported);
+	linkmode_or(phy->supported, phy->supported, supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, mask);
+	linkmode_andnot(phy->advertising, phy->advertising, mask);
+
+	phy_attached_print(phy, "phy_id=0x%.8lx, phy_mode=%s\n",
+			   (unsigned long)phy->phy_id, phy_modes(phy->interface));
+
+	return phy;
+}
+
+static void hisi_femac_drv_napi(struct platform_device *pdev,
+				struct hisi_femac_priv *priv)
+{
+	struct net_device *ndev = priv->ndev;
+
+	ndev->watchdog_timeo = 6 * HZ; /* 6HZ */
+	ndev->priv_flags |= IFF_UNICAST_FLT;
+	ndev->netdev_ops = &hisi_femac_netdev_ops;
+	ndev->ethtool_ops = &hisi_femac_ethtools_ops;
+	netif_napi_add(ndev, &priv->napi, hisi_femac_poll, FEMAC_POLL_WEIGHT);
+
+#ifdef CONFIG_FEPHY_OPT
+	INIT_DELAYED_WORK(&priv->watchdog_queue, hisi_femac_watchdog);
+	schedule_delayed_work(&priv->watchdog_queue, FEPHY_OPT_TIMER);
+#endif
+
+	if (has_tso_cap(priv->hw_cap))
+		ndev->hw_features |= NETIF_F_SG |
+						NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+						NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO;
+
+	if (has_rxcsum_cap(priv->hw_cap))
+		ndev->hw_features |= NETIF_F_RXCSUM;
+	ndev->features |= ndev->hw_features;
+	ndev->vlan_features |= ndev->features;
+
+	device_set_wakeup_capable(priv->dev, true);
+	device_set_wakeup_enable(priv->dev, true);
+
+	priv->tx_pause_en = true;
+	priv->tx_pause_active_thresh = TX_FLOW_CTRL_ACTIVE_THRESHOLD;
+	priv->tx_pause_deactive_thresh = TX_FLOW_CTRL_DEACTIVE_THRESHOLD;
+
+	hisi_femac_verify_flow_ctrl_args(priv);
+
+	hisi_femac_port_init(priv);
+
+	if (has_rxcsum_cap(priv->hw_cap))
+		hisi_femac_enable_rxcsum_drop(priv, true);
+}
+
+static int hisi_femac_drv_queues(struct platform_device *pdev,
+				 struct hisi_femac_priv *priv)
+{
+	int ret;
+
+#ifdef FEMAC_RX_REFILL_IN_IRQ
+	skb_queue_head_init(&priv->rx_head);
+	spin_lock_init(&priv->rxlock);
+#endif
+	ret = hisi_femac_init_tx_and_rx_queues(priv);
+	if (ret)
+		return ret;
+
+	if (has_tso_cap(priv->hw_cap)) {
+		ret = hisi_femac_init_tx_descriptor_ring(priv);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static int hisi_femac_drv_register(struct platform_device *pdev,
+				   struct hisi_femac_priv *priv)
+{
+	struct device *dev = &pdev->dev;
+	struct net_device *ndev = priv->ndev;
+	int ret;
+
+	ndev->irq = platform_get_irq(pdev, 0);
+	if (ndev->irq <= 0) {
+		dev_err(dev, "No irq resource\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	ret = devm_request_irq(dev, ndev->irq, hisi_femac_interrupt,
+			       IRQF_SHARED, pdev->name, ndev);
+	if (ret) {
+		dev_err(dev, "devm_request_irq %d failed!\n", ndev->irq);
+		return ret;
+	}
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(dev, "register_netdev failed!\n");
+		return ret;
+	}
+	return 0;
+}
+
+static int hisi_femac_drv_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct net_device *ndev = NULL;
+	struct hisi_femac_priv *priv = NULL;
+	struct phy_device *phy = NULL;
+	int ret;
+
+	ndev = alloc_etherdev(sizeof(*priv));
+	if (ndev == NULL)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, ndev);
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	priv = netdev_priv(ndev);
+	priv->dev = dev;
+	priv->ndev = ndev;
+
+	ret = hisi_femac_drv_res(pdev, priv);
+	if (ret)
+		goto out_free_netdev;
+
+	ret = hisi_femac_drv_mac(pdev, priv);
+	if (ret)
+		goto out_disable_clk;
+
+	phy = hisi_femac_drv_phy(pdev, priv, &ret);
+	if (phy == NULL)
+		goto out_disable_clk;
+
+	hisi_femac_drv_napi(pdev, priv);
+
+	ret = hisi_femac_drv_queues(pdev, priv);
+	if (ret)
+		goto out_disconnect_phy;
+
+	ret = hisi_femac_drv_register(pdev, priv);
+	if (ret)
+		goto out_destroy_descriptor;
+
+	return ret;
+
+out_destroy_descriptor:
+	if (has_tso_cap(priv->hw_cap))
+		hisi_femac_destroy_tx_descriptor_ring(priv);
+out_disconnect_phy:
+	netif_napi_del(&priv->napi);
+	phy_disconnect(phy);
+out_disable_clk:
+	clk_disable_unprepare(priv->clk);
+out_free_netdev:
+	free_netdev(ndev);
+
+	return ret;
+}
+
+static int hisi_femac_drv_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct hisi_femac_priv *priv = netdev_priv(ndev);
+
+	netif_napi_del(&priv->napi);
+	unregister_netdev(ndev);
+	if (has_tso_cap(priv->hw_cap))
+		hisi_femac_destroy_tx_descriptor_ring(priv);
+
+	phy_disconnect(ndev->phydev);
+#ifdef CONFIG_FEPHY_OPT
+	cancel_delayed_work_sync(&priv->watchdog_queue);
+#endif
+	clk_disable_unprepare(priv->clk);
+	free_netdev(ndev);
+
+	phy_unregister_fixups();
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int hisi_femac_drv_suspend(struct platform_device *pdev,
+				  pm_message_t state)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct hisi_femac_priv *priv = netdev_priv(ndev);
+
+	disable_irq(ndev->irq);
+	if (netif_running(ndev)) {
+		hisi_femac_net_close(ndev);
+		netif_device_detach(ndev);
+	}
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int hisi_femac_drv_resume(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct hisi_femac_priv *priv = netdev_priv(ndev);
+
+	clk_prepare_enable(priv->clk);
+	if (priv->phy_rst != NULL)
+		hisi_femac_phy_reset(priv);
+
+	if (netif_running(ndev)) {
+		hisi_femac_port_init(priv);
+		hisi_femac_net_open(ndev);
+		netif_device_attach(ndev);
+	}
+	enable_irq(ndev->irq);
+
+	return 0;
+}
+#endif
+
+static const struct of_device_id hisi_femac_match[] = {
+	{
+		.compatible = "hisilicon,hisi-femac-v1",
+	},
+	{
+		.compatible = "hisilicon,hisi-femac-v2",
+	},
+	{
+		.compatible = "hisilicon,hi3516cv500-femac",
+	},
+	{
+		.compatible = "hisilicon,hi3516cv300-femac",
+	},
+	{
+		.compatible = "hisilicon,hi3536dv100-femac",
+	},
+	{
+		.compatible = "hisilicon,hi3556v200-femac",
+	},
+	{
+		.compatible = "hisilicon,hi3559v200-femac",
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, hisi_femac_match);
+
+static struct platform_driver hisi_femac_driver = {
+	.driver = {
+		.name = "hisi-femac",
+		.of_match_table = hisi_femac_match,
+	},
+	.probe = hisi_femac_drv_probe,
+	.remove = hisi_femac_drv_remove,
+#ifdef CONFIG_PM
+	.suspend = hisi_femac_drv_suspend,
+	.resume = hisi_femac_drv_resume,
+#endif
+};
+
+module_platform_driver(hisi_femac_driver);
+
+MODULE_DESCRIPTION("Hisilicon Fast Ethernet MAC driver");
+MODULE_AUTHOR("Hisilicon");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:hisi-femac");
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/hisi_femac.h b/drivers/net/ethernet/hisilicon/hisi-femac/hisi_femac.h
new file mode 100644
index 000000000..5e260ad18
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/hisi_femac.h
@@ -0,0 +1,269 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hieth driver femac head file
+ * Author: KTP_BSP
+ * Create: 2020-05-19
+ */
+
+#ifndef __HIETH_HISI_FEMAC_H__
+#define __HIETH_HISI_FEMAC_H__
+
+/* MAC control register list */
+#define MAC_PORTSEL                0x0200
+#define MAC_PORTSEL_STAT_CPU       BIT(0)
+#define MAC_PORTSEL_RMII           BIT(1)
+#define MAC_PORTSET                0x0208
+#define MAC_PORTSET_DUPLEX_FULL    BIT(0)
+#define MAC_PORTSET_LINKED         BIT(1)
+#define MAC_PORTSET_SPEED_100M     BIT(2)
+#define MAC_SET                    0x0210
+#define MAX_FRAME_SIZE             1600
+#define MAX_FRAME_SIZE_MASK        GENMASK(10, 0)
+#define BIT_PAUSE_EN               BIT(18)
+#define RX_COALESCE_SET            0x0340
+#define RX_COALESCED_FRAME_OFFSET  24
+#define RX_COALESCED_FRAMES        8
+#define RX_COALESCED_TIMER         0x74
+#define QLEN_SET                   0x0344
+#define RX_DEPTH_OFFSET            8
+#define MAX_HW_FIFO_DEPTH          64
+#define HW_TX_FIFO_DEPTH           12
+#define HW_RX_FIFO_DEPTH           (MAX_HW_FIFO_DEPTH - HW_TX_FIFO_DEPTH)
+#define FC_LEVEL                   0x0348
+#define BITS_FC_ACTIVE_THR_OFFSET  8
+#define FC_DEACTIVE_THR_MASK       GENMASK(5, 0)
+#define FC_ACTIVE_THR_MASK         GENMASK(13, 8)
+#define BIT_FC_EN                  BIT(14)
+#define IQFRM_DES                  0x0354
+#define RX_FRAME_LEN_MASK          GENMASK(11, 0)
+#define BITS_PAYLOAD_ERR_OFFSET    28
+#define BITS_PAYLOAD_ERR_MASK      0x1
+#define BITS_HEADER_ERR_OFFSET     29
+#define BITS_HEADER_ERR_MASK       0x1
+#define BITS_PAYLOAD_DONE_OFFSET   30
+#define BITS_PAYLOAD_DONE_MASK     0x1
+#define BITS_HEADER_DONE_OFFSET    31
+#define BITS_HEADER_DONE_MASK      0x1
+#define IQ_ADDR                    0x0358
+#define EQ_ADDR                    0x0360
+#define EQFRM_LEN                  0x0364
+#define ADDRQ_STAT                 0x036C
+#define TX_CNT_INUSE_MASK          GENMASK(5, 0)
+#define BIT_TX_READY               BIT(24)
+#define BIT_RX_READY               BIT(25)
+#define RX_COE_CTRL                0x0380
+#define BIT_COE_IPV6_UDP_ZERO_DROP BIT(13)
+#define BIT_COE_PAYLOAD_DROP       BIT(14)
+#define BIT_COE_IPHDR_DROP         BIT(15)
+#define COE_ERR_DROP               (BIT_COE_IPHDR_DROP |  \
+									BIT_COE_PAYLOAD_DROP |  \
+									BIT_COE_IPV6_UDP_ZERO_DROP)
+#define TSO_DBG_EN      0x03A4
+#define BITS_TSO_DBG_EN BIT(31)
+#define TSO_DBG_STATE   0x03A8
+#define TSO_DBG_ADDR    0x03AC
+#define TSO_DBG_TX_INFO 0x03B0
+#define TSO_DBG_TX_ERR  0x03B4
+/* global control register list */
+#define GLB_HOSTMAC_L32       0x0000
+#define GLB_HOSTMAC_H16       0x0004
+#define GLB_SOFT_RESET        0x0008
+#define SOFT_RESET_ALL        BIT(0)
+#define GLB_FWCTRL            0x0010
+#define FWCTRL_VLAN_ENABLE    BIT(0)
+#define FWCTRL_FW2CPU_ENA     BIT(5)
+#define FWCTRL_FWALL2CPU      BIT(7)
+#define GLB_MACTCTRL          0x0014
+#define MACTCTRL_UNI2CPU      BIT(1)
+#define MACTCTRL_MULTI2CPU    BIT(3)
+#define MACTCTRL_BROAD2CPU    BIT(5)
+#define MACTCTRL_MACT_ENA     BIT(7)
+#define GLB_IRQ_STAT          0x0030
+#define GLB_IRQ_ENA           0x0034
+#define IRQ_ENA_PORT0_MASK    GENMASK(7, 0)
+#define IRQ_ENA_PORT0         BIT(18)
+#define IRQ_ENA_ALL           BIT(19)
+#define GLB_IRQ_RAW           0x0038
+#define IRQ_INT_RX_RDY        BIT(0)
+#define IRQ_INT_TX_PER_PACKET BIT(1)
+#define IRQ_INT_TX_FIFO_EMPTY BIT(6)
+#define IRQ_INT_MULTI_RXRDY   BIT(7)
+#define INT_TX_ERR            BIT(8)
+#define DEF_INT_MASK          (IRQ_INT_MULTI_RXRDY |  \
+							   IRQ_INT_TX_PER_PACKET |  \
+							   IRQ_INT_TX_FIFO_EMPTY)
+#define GLB_MAC_L32_BASE        0x0100
+#define GLB_MAC_H16_BASE        0x0104
+#define MACFLT_HI16_MASK        GENMASK(15, 0)
+#define BIT_MACFLT_ENA          BIT(17)
+#define BIT_MACFLT_FW2CPU       BIT(21)
+#define glb_mac_h16(reg)        (GLB_MAC_H16_BASE + ((reg) * 0x8))
+#define glb_mac_l32(reg)        (GLB_MAC_L32_BASE + ((reg) * 0x8))
+#define MAX_MAC_FILTER_NUM      8
+#define MAX_UNICAST_ADDRESSES   2
+#define MAX_MULTICAST_ADDRESSES (MAX_MAC_FILTER_NUM - MAX_UNICAST_ADDRESSES)
+/* software tx and rx queue number, should be power of 2 */
+#define TXQ_NUM                64
+#define RXQ_NUM                128
+#define FEMAC_POLL_WEIGHT      64
+#define HW_CAP_TSO             BIT(0)
+#define HW_CAP_RXCSUM          BIT(1)
+#define has_tso_cap(hw_cap)    ((hw_cap) & HW_CAP_TSO)
+#define has_rxcsum_cap(hw_cap) ((hw_cap) & HW_CAP_RXCSUM)
+#define RXBUF_ADDR_ALIGN_SIZE  64UL
+/* UDP header len is 2 word */
+#define UDP_HDR_LEN 2
+/* IPv6 header len is 10 word */
+#define IPV6_HDR_LEN 10
+#define WORD_TO_BYTE 4
+
+#define BIT_OFFSET_NFRAGS_NUM      11
+#define BIT_OFFSET_PROT_HEADER_LEN 16
+#define BIT_OFFSET_IP_HEADER_LEN   20
+#define BIT_FLAG_SG                BIT(26)
+#define BIT_FLAG_TXCSUM            BIT(27)
+#define BIT_FLAG_UDP               BIT(28)
+#define BIT_FLAG_IPV6              BIT(29)
+#define BIT_FLAG_VLAN              BIT(30)
+#define BIT_FLAG_TSO               BIT(31)
+
+#define PHY_RESET_DELAYS_PROPERTY "hisilicon,phy-reset-delays-us"
+
+/*
+ * The threshold for activing tx flow ctrl.
+ * When the left amount of receive queue descriptors is below this threshold,
+ * hardware will send pause frame immediately.
+ * We advise this value is set between 1 and 10.
+ * Too bigger is not a good choice.
+ * This value must be smaller than tx flow ctrl deactive threshold.
+ */
+#define TX_FLOW_CTRL_ACTIVE_THRESHOLD 3
+/*
+ * The threshold for deactiving tx flow ctrl.
+ * When the left amount of receive queue descriptors is
+ * above or equal with this threshold,
+ * hardware will exit flow control state.
+ * We advise this value is set between 1 and 10.
+ * Too bigger is not a good choice.
+ * This value must be larger than tx flow ctrl active threshold.
+ */
+#define TX_FLOW_CTRL_DEACTIVE_THRESHOLD 5
+#define FC_ACTIVE_MIN                   1
+#define FC_ACTIVE_DEFAULT               3
+#define FC_ACTIVE_MAX                   31
+#define FC_DEACTIVE_MIN                 1
+#define FC_DEACTIVE_DEFAULT             5
+#define FC_DEACTIVE_MAX                 31
+
+#if (defined(CONFIG_ARCH_HI3516EV200) || defined(CONFIG_ARCH_HI3516EV300) || defined(CONFIG_ARCH_HI3516DV200))
+#define CONFIG_FEPHY_OPT
+#endif
+
+#ifdef CONFIG_FEPHY_OPT
+/* FEPHY register list */
+
+#define  SYS_REG_ADDR                   0x12028000
+#define  FEPHY_TRIM_CACHE               0x3022
+#define  FEPHY_TRIM_VALUE               0x20a1
+#define  LOW_TEM_VALUE                  117
+#define  HIGH_TEM_VALUE                 915
+#define  LINK_STATUS                    0x4
+#define  IS_LINK                        0X4
+#define  SPEED_STATUS                   0x18
+#define  SPEED_100M                     0x8
+#define  LINK_AN_SR                     0x11
+#define  MISC_CTRL45                    0x00B4
+#define  MISC_CTRL47                    0x00BC
+#define  MISC_CTRL48                    0x00C0
+#define  TSENSOR_RESULT0                0x3ff
+#define  TSENSOR_RESULT1                0x3ff0000
+#define  TSENSOR_RESULT2                0x3ff
+#define  TSENSOR_RESULT3                0x3ff0000
+#define  TSENSOR_EN                     0xc3200000
+#define  HIGH_TEMP                      100
+#define  NORMAL_TEMP1                   90
+#define  NORMAL_TEMP2                   20
+#define  LOW_TEMP                       10
+#define  TSENSOR_LIMIT                  0xfffff
+#define  regval_to_temp(val)            ((val - 117) * 165 / 798 - 40)
+#define  FEPHY_OPT_TIMER                (30 * HZ)
+#endif
+
+enum phy_reset_delays {
+	PRE_DELAY,
+	PULSE,
+	POST_DELAY,
+	DELAYS_NUM,
+};
+
+struct hisi_femac_queue {
+	struct sk_buff **skb;
+	dma_addr_t *dma_phys;
+	unsigned int num;
+	unsigned int head;
+	unsigned int tail;
+};
+
+struct hisi_femac_tx_desc_ring {
+	struct tx_desc *desc;
+	dma_addr_t dma_phys;
+};
+
+#define FEMAC_RX_REFILL_IN_IRQ
+
+struct hisi_femac_priv {
+	void __iomem *port_base;
+	void __iomem *glb_base;
+	struct clk *clk;
+	struct reset_control *mac_rst;
+	struct reset_control *phy_rst;
+	u32 phy_reset_delays[DELAYS_NUM];
+	u32 link_status;
+
+#ifdef CONFIG_FEPHY_OPT
+	struct delayed_work watchdog_queue;
+#endif
+	struct device *dev;
+	struct net_device *ndev;
+
+	u32 hw_cap;
+	struct hisi_femac_queue txq;
+	struct hisi_femac_queue rxq;
+#ifdef FEMAC_RX_REFILL_IN_IRQ
+	struct sk_buff_head rx_head;
+	spinlock_t rxlock;
+#endif
+	struct hisi_femac_tx_desc_ring tx_ring;
+	u32 tx_fifo_used_cnt;
+	struct napi_struct napi;
+
+	/* 802.3x flow control */
+	bool tx_pause_en;
+	u32 tx_pause_active_thresh;
+	u32 tx_pause_deactive_thresh;
+};
+
+struct frags_info {
+	/* Word(2*i+2) */
+	u32 addr;
+	/* Word(2*i+3) */
+	u32 size : 16;
+	u32 reserved : 16;
+};
+
+struct tx_desc {
+	/* Word0 */
+	u32 total_len : 17;
+	u32 reserv : 15;
+	/* Word1 */
+	u32 ipv6_id;
+	/* Word2 */
+	u32 linear_addr;
+	/* Word3 */
+	u32 linear_len : 16;
+	u32 reserv3 : 16;
+	/* MAX_SKB_FRAGS is 30 */
+	struct frags_info frags[30];
+};
+
+#endif
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/phy_fix.c b/drivers/net/ethernet/hisilicon/hisi-femac/phy_fix.c
new file mode 100644
index 000000000..e7a3989b8
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/phy_fix.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Hieth driver phy_fix process
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#include <linux/phy.h>
+#include "phy_fix.h"
+
+static const u32 phy_v272_fix_param[] = {
+#include "festa_v272_2723.h"
+};
+
+static const u32 phy_v115_fix_param[] = {
+#include "festa_s28v115_2c02.h"
+};
+
+static const u32 phy_v202_fix_param[] = {
+#include "festa_s28v202_2e01.h"
+};
+
+static int phy_expanded_write_bulk(struct phy_device *phy_dev,
+				   const u32 reg_and_val[], int count)
+{
+	int i, v;
+	u32 reg_addr;
+	u16 val;
+
+	v = phy_read(phy_dev, MII_BMCR);
+	v = (u32)v | BMCR_PDOWN;
+	phy_write(phy_dev, MII_BMCR, v);
+
+	for (i = 0; i < count; i += 2) { /* Process 2 data at a time. */
+		reg_addr = reg_and_val[i];
+		val = (u16)reg_and_val[i + 1];
+		phy_write(phy_dev, MII_EXPMA, reg_addr);
+		phy_write(phy_dev, MII_EXPMD, val);
+	}
+
+	v = phy_read(phy_dev, MII_BMCR);
+	v = (u32)v & (~BMCR_PDOWN);
+	phy_write(phy_dev, MII_BMCR, v);
+
+	return 0;
+}
+
+static int hisilicon_fephy_v272_fix(struct phy_device *phy_dev)
+{
+	int count;
+
+	count = ARRAY_SIZE(phy_v272_fix_param);
+	if (count % 2) /* must be an even number, mod 2 */
+		pr_warn("internal FEPHY fix register count is not right.\n");
+	phy_expanded_write_bulk(phy_dev, phy_v272_fix_param, count);
+
+	return 0;
+}
+
+static int hisilicon_fephy_v115_fix(struct phy_device *phy_dev)
+{
+	int count;
+
+	count = ARRAY_SIZE(phy_v115_fix_param);
+	if (count % 2) /* must be an even number, mod 2 */
+		pr_warn("internal FEPHY fix register count is not right.\n");
+	phy_expanded_write_bulk(phy_dev, phy_v115_fix_param, count);
+
+	return 0;
+}
+
+static int hisilicon_fephy_v202_fix(struct phy_device *phy_dev)
+{
+	int count;
+
+	count = ARRAY_SIZE(phy_v202_fix_param);
+	if (count % 2) /* must be an even number, mod 2 */
+		pr_warn("internal FEPHY fix register count is not right.\n");
+	phy_expanded_write_bulk(phy_dev, phy_v202_fix_param, count);
+
+	return 0;
+}
+
+void phy_register_fixups(void)
+{
+	phy_register_fixup_for_uid(HISILICON_PHY_ID_FESTAV272,
+				   HISILICON_PHY_MASK,
+				   hisilicon_fephy_v272_fix);
+
+	phy_register_fixup_for_uid(HISILICON_PHY_ID_FESTAV115,
+				   HISILICON_PHY_MASK,
+				   hisilicon_fephy_v115_fix);
+
+	phy_register_fixup_for_uid(HISILICON_PHY_ID_FESTAV202,
+				   HISILICON_PHY_MASK,
+				   hisilicon_fephy_v202_fix);
+}
+
+void phy_unregister_fixups(void)
+{
+	phy_unregister_fixup_for_uid(HISILICON_PHY_ID_FESTAV272,
+				     HISILICON_PHY_MASK);
+
+	phy_unregister_fixup_for_uid(HISILICON_PHY_ID_FESTAV115,
+				     HISILICON_PHY_MASK);
+
+	phy_unregister_fixup_for_uid(HISILICON_PHY_ID_FESTAV202,
+				     HISILICON_PHY_MASK);
+}
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/phy_fix.h b/drivers/net/ethernet/hisilicon/hisi-femac/phy_fix.h
new file mode 100644
index 000000000..b7a725090
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/phy_fix.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2018-2020. All rights reserved.
+ * Description: Hieth driver phy fixup head file
+ * Author: KTP_BSP
+ * Create: 2018-10-08
+ */
+
+#ifndef __HIETH_PHY_FIX_H__
+#define __HIETH_PHY_FIX_H__
+
+#define HISILICON_PHY_ID_FESTAV272     0x20669901
+#define HISILICON_PHY_ID_FESTAV115     0x20669903
+#define HISILICON_PHY_ID_FESTAV202     0x20669906
+#define HISILICON_PHY_MASK             0xffffffff
+
+#define MII_EXPMD 0x1d
+#define MII_EXPMA 0x1e
+
+void phy_register_fixups(void);
+void phy_unregister_fixups(void);
+
+#endif
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/util.c b/drivers/net/ethernet/hisilicon/hisi-femac/util.c
new file mode 100644
index 000000000..4f803784e
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/util.c
@@ -0,0 +1,318 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hieth driver util file
+ * Author: KTP_BSP
+ * Create: 2020-05-19
+ */
+
+#include <linux/if_vlan.h>
+#include <linux/ip.h>
+#include <net/ipv6.h>
+#include <linux/phy.h>
+
+#include "util.h"
+
+static void hisi_femac_do_udp_checksum(struct sk_buff *skb)
+{
+	int offset;
+	__wsum csum;
+	__sum16 udp_csum;
+
+	offset = skb_checksum_start_offset(skb);
+	WARN_ON(offset >= skb_headlen(skb));
+	csum = skb_checksum(skb, offset, skb->len - offset, 0);
+
+	offset += skb->csum_offset;
+	WARN_ON(offset + sizeof(__sum16) > skb_headlen(skb));
+
+	udp_csum = csum_fold(csum);
+	if (udp_csum == 0)
+		udp_csum = CSUM_MANGLED_0;
+
+	*(__sum16 *)(skb->data + offset) = udp_csum;
+
+	skb->ip_summed = CHECKSUM_NONE;
+}
+
+static __be16 hisi_femac_get_l3_proto(struct sk_buff *skb)
+{
+	__be16 l3_proto;
+
+	l3_proto = skb->protocol;
+	if (skb->protocol == htons(ETH_P_8021Q))
+		l3_proto = vlan_get_protocol(skb);
+
+	return l3_proto;
+}
+
+static inline bool hisi_femac_skb_is_ipv6(struct sk_buff *skb)
+{
+	return (hisi_femac_get_l3_proto(skb) == htons(ETH_P_IPV6));
+}
+
+static int hisi_femac_check_hw_capability_for_ipv6(struct sk_buff *skb)
+{
+	unsigned int l4_proto;
+
+	l4_proto = ipv6_hdr(skb)->nexthdr;
+	if ((l4_proto != IPPROTO_TCP) && (l4_proto != IPPROTO_UDP)) {
+		/*
+		 * when IPv6 next header is not tcp or udp,
+		 * it means that IPv6 next header is extension header.
+		 * Hardware can't deal with this case,
+		 * so do checksumming by software or do GSO by software.
+		 */
+		if (skb_is_gso(skb)) {
+			return -ENOTSUPP;
+		}
+
+		if (skb->ip_summed == CHECKSUM_PARTIAL &&
+				skb_checksum_help(skb)) {
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+int hisi_femac_check_hw_capability(struct sk_buff *skb)
+{
+	/*
+	 * if tcp_mtu_probe() use (2 * tp->mss_cache) as probe_size,
+	 * the linear data length will be larger than 2048,
+	 * the MAC can't handle it, so let the software do it.
+	 */
+	if (skb_is_gso(skb) && (skb_headlen(skb) > 2048)) { /* max is 2048 */
+		return -ENOTSUPP;
+	}
+
+	if (hisi_femac_skb_is_ipv6(skb)) {
+		return hisi_femac_check_hw_capability_for_ipv6(skb);
+	}
+
+	return 0;
+}
+
+static unsigned int hisi_femac_get_pkt_info_gso(struct sk_buff *skb,
+		bool txcsum, unsigned int max_mss, unsigned int l4_proto)
+{
+	u32 pkt_info = 0;
+	bool do_txcsum = txcsum;
+
+	/*
+	 * Although netcard support UFO feature, it can't deal with
+	 * UDP header checksum.
+	 * So the driver will do UDP header checksum and netcard will just
+	 * fragment the packet.
+	 */
+	if (do_txcsum && skb_is_gso(skb) && (l4_proto == IPPROTO_UDP)) {
+		hisi_femac_do_udp_checksum(skb);
+		do_txcsum = false;
+	}
+
+	if (do_txcsum)
+		pkt_info |= BIT_FLAG_TXCSUM;
+
+	if (skb_is_gso(skb)) {
+		pkt_info |= (BIT_FLAG_SG | BIT_FLAG_TSO);
+	} else if (skb_shinfo(skb)->nr_frags) {
+		pkt_info |= BIT_FLAG_SG;
+	}
+
+	pkt_info |= (skb_shinfo(skb)->nr_frags << BIT_OFFSET_NFRAGS_NUM);
+	pkt_info |= (skb_is_gso(skb) ? ((skb_shinfo(skb)->gso_size > max_mss) ?
+					max_mss : skb_shinfo(skb)->gso_size) :
+					(skb->len + ETH_FCS_LEN));
+	return pkt_info;
+}
+
+u32 hisi_femac_get_pkt_info(struct sk_buff *skb)
+{
+	__be16 l3_proto;
+	unsigned int l4_proto = IPPROTO_MAX;
+	bool do_txcsum = false;
+	int max_data_len;
+	unsigned int max_mss = ETH_DATA_LEN;
+	u32 pkt_info = 0;
+
+	if (skb == NULL)
+		return 0;
+
+	max_data_len = skb->len - ETH_HLEN;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL)
+		do_txcsum = true;
+
+	l3_proto = skb->protocol;
+	if (skb->protocol == htons(ETH_P_8021Q)) {
+		l3_proto = vlan_get_protocol(skb);
+		max_data_len -= VLAN_HLEN;
+		pkt_info |= BIT_FLAG_VLAN;
+	}
+
+	if (l3_proto == htons(ETH_P_IP)) {
+		struct iphdr *iph = ip_hdr(skb);
+
+		if ((max_data_len >= GSO_MAX_SIZE) &&
+			(ntohs(iph->tot_len) <= (iph->ihl << 2))) /* trans 2 bytes */
+			iph->tot_len = htons(GSO_MAX_SIZE - 1);
+
+		max_mss -= iph->ihl * WORD_TO_BYTE;
+		pkt_info |= (iph->ihl << BIT_OFFSET_IP_HEADER_LEN);
+		l4_proto = iph->protocol;
+	} else if (l3_proto == htons(ETH_P_IPV6)) {
+		max_mss -= IPV6_HDR_LEN * WORD_TO_BYTE;
+		pkt_info |= BIT_FLAG_IPV6;
+		pkt_info |= (IPV6_HDR_LEN << BIT_OFFSET_IP_HEADER_LEN);
+		l4_proto = ipv6_hdr(skb)->nexthdr;
+	} else {
+		do_txcsum = false;
+	}
+
+	if (l4_proto == IPPROTO_TCP) {
+		max_mss -= tcp_hdr(skb)->doff * WORD_TO_BYTE;
+		pkt_info |= (tcp_hdr(skb)->doff << BIT_OFFSET_PROT_HEADER_LEN);
+	} else if (l4_proto == IPPROTO_UDP) {
+		if (l3_proto == htons(ETH_P_IPV6))
+			max_mss -= sizeof(struct frag_hdr);
+		pkt_info |= (BIT_FLAG_UDP |
+			     (UDP_HDR_LEN << BIT_OFFSET_PROT_HEADER_LEN));
+	} else {
+		do_txcsum = false;
+	}
+
+	pkt_info |= hisi_femac_get_pkt_info_gso(skb, do_txcsum, max_mss, l4_proto);
+
+	return pkt_info;
+}
+
+void hisi_femac_sleep_us(u32 time_us)
+{
+	u32 time_ms;
+
+	if (!time_us) {
+		return;
+	}
+
+	time_ms = DIV_ROUND_UP(time_us, 1000); /* add 1000us, round up */
+	if (time_ms < 20) { /* less than 20 ms */
+		usleep_range(time_us, time_us + 500); /* add maximum 500us */
+	} else {
+		msleep(time_ms);
+	}
+}
+
+void hisi_femac_set_flow_ctrl(const struct hisi_femac_priv *priv)
+{
+	unsigned int pause_en;
+	unsigned int tx_flow_ctrl;
+
+	if (priv == NULL)
+		return;
+
+	tx_flow_ctrl = readl(priv->port_base + FC_LEVEL);
+	tx_flow_ctrl &= ~FC_DEACTIVE_THR_MASK;
+	tx_flow_ctrl |= priv->tx_pause_deactive_thresh;
+	tx_flow_ctrl &= ~FC_ACTIVE_THR_MASK;
+	tx_flow_ctrl |= priv->tx_pause_active_thresh << BITS_FC_ACTIVE_THR_OFFSET;
+
+	pause_en = readl(priv->port_base + MAC_SET);
+
+	if (priv->tx_pause_en) {
+		tx_flow_ctrl |= BIT_FC_EN;
+		pause_en |= BIT_PAUSE_EN;
+	} else {
+		tx_flow_ctrl &= ~BIT_FC_EN;
+		pause_en &= ~BIT_PAUSE_EN;
+	}
+
+	writel(tx_flow_ctrl, priv->port_base + FC_LEVEL);
+
+	writel(pause_en, priv->port_base + MAC_SET);
+}
+
+void hisi_femac_get_pauseparam(struct net_device *dev,
+			       struct ethtool_pauseparam *pause)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+
+	if (dev == NULL || dev->phydev == NULL || pause == NULL)
+		return;
+
+	pause->autoneg = dev->phydev->autoneg;
+	pause->rx_pause = 1;
+	if (priv->tx_pause_en)
+		pause->tx_pause = 1;
+}
+
+int hisi_femac_set_pauseparam(struct net_device *dev,
+			      struct ethtool_pauseparam *pause)
+{
+	struct hisi_femac_priv *priv = netdev_priv(dev);
+	struct phy_device *phy = NULL;
+	int ret = 0;
+
+	if (dev == NULL || pause == NULL || pause->rx_pause == 0) {
+		return -EINVAL;
+	}
+
+	phy = dev->phydev;
+
+	if (pause->tx_pause != priv->tx_pause_en) {
+		priv->tx_pause_en = pause->tx_pause;
+		hisi_femac_set_flow_ctrl(priv);
+	}
+
+	if (phy != NULL && phy->autoneg) {
+		if (netif_running(dev)) {
+			struct ethtool_cmd cmd;
+			/* auto-negotiation automatically restarted */
+			cmd.cmd = ETHTOOL_NWAY_RST;
+			cmd.supported = phy->supported;
+			cmd.advertising = phy->advertising;
+			cmd.autoneg = phy->autoneg;
+			cmd.speed = phy->speed;
+			cmd.duplex = phy->duplex;
+			cmd.phy_address = phy->mdio.addr;
+//			ret = phy_ethtool_sset(phy, &cmd);
+		}
+	}
+
+	return ret;
+}
+
+void hisi_femac_enable_rxcsum_drop(const struct hisi_femac_priv *priv,
+				   bool drop)
+{
+	unsigned int val;
+	if (priv == NULL)
+		return;
+
+	val = readl(priv->port_base + RX_COE_CTRL);
+	val &= ~COE_ERR_DROP;
+	if (drop)
+		val |= (BIT_COE_IPHDR_DROP | BIT_COE_IPV6_UDP_ZERO_DROP);
+	writel(val, priv->port_base + RX_COE_CTRL);
+}
+
+int hisi_femac_set_features(struct net_device *dev, netdev_features_t features)
+{
+	struct hisi_femac_priv *priv = NULL;
+	netdev_features_t changed;
+
+	if (dev == NULL)
+		return -1;
+
+	priv = netdev_priv(dev);
+	changed = dev->features ^ features;
+
+	if (changed & NETIF_F_RXCSUM) {
+		if (features & NETIF_F_RXCSUM) {
+			hisi_femac_enable_rxcsum_drop(priv, true);
+		} else {
+			hisi_femac_enable_rxcsum_drop(priv, false);
+		}
+	}
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/hisilicon/hisi-femac/util.h b/drivers/net/ethernet/hisilicon/hisi-femac/util.h
new file mode 100644
index 000000000..009424857
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hisi-femac/util.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: Hieth driver util head file
+ * Author: KTP_BSP
+ * Create: 2020-05-19
+ */
+
+#ifndef __HIETH_UTIL_H__
+#define __HIETH_UTIL_H__
+
+#include "hisi_femac.h"
+
+int hisi_femac_check_hw_capability(struct sk_buff *skb);
+u32 hisi_femac_get_pkt_info(struct sk_buff *skb);
+void hisi_femac_sleep_us(u32 time_us);
+void hisi_femac_set_flow_ctrl(const struct hisi_femac_priv *priv);
+void hisi_femac_get_pauseparam(struct net_device *dev,
+			       struct ethtool_pauseparam *pause);
+int hisi_femac_set_pauseparam(struct net_device *dev,
+			      struct ethtool_pauseparam *pause);
+void hisi_femac_enable_rxcsum_drop(const struct hisi_femac_priv *priv,
+				   bool drop);
+int hisi_femac_set_features(struct net_device *dev, netdev_features_t features);
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/ethernet/hisilicon/hisi_femac.c b/drivers/net/ethernet/hisilicon/hisi_femac.c
index 57c3bc4f7..180805656 100644
--- a/drivers/net/ethernet/hisilicon/hisi_femac.c
+++ b/drivers/net/ethernet/hisilicon/hisi_femac.c
@@ -86,7 +86,7 @@
 /* software tx and rx queue number, should be power of 2 */
 #define TXQ_NUM				64
 #define RXQ_NUM				128
-#define FEMAC_POLL_WEIGHT		16
+#define FEMAC_POLL_WEIGHT		64
 
 #define PHY_RESET_DELAYS_PROPERTY	"hisilicon,phy-reset-delays-us"
 
@@ -973,6 +973,6 @@ static struct platform_driver hisi_femac_driver = {
 module_platform_driver(hisi_femac_driver);
 
 MODULE_DESCRIPTION("Hisilicon Fast Ethernet MAC driver");
-MODULE_AUTHOR("Dongpo Li <lidongpo@hisilicon.com>");
+MODULE_AUTHOR("Hisilicon");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:hisi-femac");
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c
index 7fb7a4196..1a357516b 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c
@@ -702,7 +702,7 @@ static void hns_gmac_get_strings(u32 stringset, u8 *data)
 
 static int hns_gmac_get_sset_count(int stringset)
 {
-	if (stringset == ETH_SS_STATS)
+	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ARRAY_SIZE(g_gmac_stats_string);
 
 	return 0;
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c
index d0f8b1fff..c5176565f 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c
@@ -444,7 +444,7 @@ void hns_ppe_update_stats(struct hns_ppe_cb *ppe_cb)
 
 int hns_ppe_get_sset_count(int stringset)
 {
-	if (stringset == ETH_SS_STATS)
+	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ETH_PPE_STATIC_NUM;
 	return 0;
 }
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c
index b6c8910cf..4cda44494 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c
@@ -897,7 +897,7 @@ void hns_rcb_get_stats(struct hnae_queue *queue, u64 *data)
  */
 int hns_rcb_get_ring_sset_count(int stringset)
 {
-	if (stringset == ETH_SS_STATS)
+	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return HNS_RING_STATIC_REG_NUM;
 
 	return 0;
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 3616b77ca..883c5f5db 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -2092,14 +2092,17 @@ static int mlx4_en_get_module_eeprom(struct net_device *dev,
 		ret = mlx4_get_module_info(mdev->dev, priv->port,
 					   offset, ee->len - i, data + i);
 
-		if (!ret) /* Done reading */
+		if (!ret) {
+			/* DOM was not readable after all */
+			memset(data + i, 0, ee->len - i);
 			return 0;
+		}
 
 		if (ret < 0) {
 			en_err(priv,
 			       "mlx4_get_module_info i(%d) offset(%d) bytes_to_read(%d) - FAILED (0x%x)\n",
 			       i, offset, ee->len - i, ret);
-			return 0;
+			return ret;
 		}
 
 		i += ret;
diff --git a/drivers/net/mdio/Kconfig b/drivers/net/mdio/Kconfig
index a10cc460d..42603264a 100644
--- a/drivers/net/mdio/Kconfig
+++ b/drivers/net/mdio/Kconfig
@@ -107,6 +107,13 @@ config MDIO_HISI_FEMAC
 	  This module provides a driver for the MDIO busses found in the
 	  Hisilicon SoC that have an Fast Ethernet MAC.
 
+config MDIO_HISI_GEMAC
+	tristate "Hisilicon GEMAC MDIO bus controller"
+	depends on HAS_IOMEM && OF_MDIO
+	help
+	  This module provides a driver for the MDIO busses found in the
+	  Hisilicon SoC that have an Gigabit Ethernet MAC.
+
 config MDIO_I2C
 	tristate
 	depends on I2C
diff --git a/drivers/net/mdio/Makefile b/drivers/net/mdio/Makefile
index 5c498dde4..67b74ed9d 100644
--- a/drivers/net/mdio/Makefile
+++ b/drivers/net/mdio/Makefile
@@ -9,7 +9,10 @@ obj-$(CONFIG_MDIO_BCM_UNIMAC)		+= mdio-bcm-unimac.o
 obj-$(CONFIG_MDIO_BITBANG)		+= mdio-bitbang.o
 obj-$(CONFIG_MDIO_CAVIUM)		+= mdio-cavium.o
 obj-$(CONFIG_MDIO_GPIO)			+= mdio-gpio.o
+obj-$(CONFIG_ARCH_HI3531DV200)		+= mdio_hi3531dv200_gemac.o
+obj-$(CONFIG_ARCH_HI3535AV100)		+= mdio_hi3535av100_gemac.o
 obj-$(CONFIG_MDIO_HISI_FEMAC)		+= mdio-hisi-femac.o
+obj-$(CONFIG_MDIO_HISI_GEMAC)		+= mdio-hisi-gemac.o
 obj-$(CONFIG_MDIO_I2C)			+= mdio-i2c.o
 obj-$(CONFIG_MDIO_IPQ4019)		+= mdio-ipq4019.o
 obj-$(CONFIG_MDIO_IPQ8064)		+= mdio-ipq8064.o
diff --git a/drivers/net/phy/mdio_hisi_femac.c b/drivers/net/phy/mdio_hisi_femac.c
new file mode 100644
index 000000000..25f187574
--- /dev/null
+++ b/drivers/net/phy/mdio_hisi_femac.c
@@ -0,0 +1,489 @@
+/*
+ * Hisilicon Fast Ethernet MDIO Bus Driver
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/clk.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_mdio.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+
+#define MDIO_RWCTRL		0x00
+#define MDIO_RO_DATA		0x04
+#define MDIO_WRITE		BIT(13)
+#define MDIO_RW_FINISH		BIT(15)
+#define BIT_PHY_ADDR_OFFSET	8
+#define BIT_WR_DATA_OFFSET	16
+
+#define BIT_MASK_FEPHY_ADDR	GENMASK(4, 0)
+#define BIT_FEPHY_SEL		BIT(5)
+
+#if defined(CONFIG_ARCH_HI3536DV100)
+#define BIT_OFFSET_LD_SET	0
+#define BIT_OFFSET_LDO_SET	5
+#define BIT_OFFSET_R_TUNING	8
+#elif defined(CONFIG_ARCH_HI3521DV200) || defined(CONFIG_ARCH_HI3520DV500)
+#define BIT_OFFSET_LD_SET   6
+#define BIT_OFFSET_LDO_SET  12
+#define BIT_OFFSET_R_TUNING 0
+#define DEF_LD_AM              0x9
+#define DEF_LDO_AM             0x3
+#define DEF_R_TUNING           0x16
+#else
+#define BIT_OFFSET_LD_SET	25
+#define BIT_OFFSET_LDO_SET	22
+#define BIT_OFFSET_R_TUNING	16
+#endif
+#define MII_EXPMD		0x1d
+#define MII_EXPMA		0x1e
+
+#define REG_LD_AM		0x3050
+#define BIT_MASK_LD_SET		GENMASK(4, 0)
+#define REG_LDO_AM		0x3051
+#define BIT_MASK_LDO_SET	GENMASK(2, 0)
+#define REG_R_TUNING		0x3052
+#define BIT_MASK_R_TUNING	GENMASK(5, 0)
+#define REG_WR_DONE		0x3053
+#define BIT_CFG_DONE		BIT(0)
+#define BIT_CFG_ACK		BIT(1)
+#define REG_DEF_ATE		0x3057
+#define BIT_AUTOTRIM_DONE	BIT(0)
+
+#define PHY_RESET_DELAYS_PROPERTY	"hisilicon,phy-reset-delays-us"
+
+enum phy_reset_delays {
+	PRE_DELAY,
+	PULSE,
+	POST_DELAY,
+	DELAYS_NUM,
+};
+
+struct hisi_femac_mdio_data {
+	struct clk *clk;
+	struct clk *fephy_clk;
+	struct reset_control *phy_rst;
+	struct reset_control *fephy_rst;
+	u32 phy_reset_delays[DELAYS_NUM];
+	void __iomem *membase;
+	void __iomem *fephy_iobase;
+	void __iomem *fephy_trim_iobase;
+	struct mii_bus *bus;
+	u32 phy_addr;
+};
+
+static int hisi_femac_mdio_wait_ready(struct hisi_femac_mdio_data *data)
+{
+	u32 val;
+
+	return readl_poll_timeout_atomic(data->membase + MDIO_RWCTRL,
+				  val, val & MDIO_RW_FINISH, 20, 10000);
+}
+
+static int hisi_femac_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
+{
+	struct hisi_femac_mdio_data *data = bus->priv;
+	int ret;
+
+	ret = hisi_femac_mdio_wait_ready(data);
+	if (ret)
+		return ret;
+
+	writel(((u32)mii_id << BIT_PHY_ADDR_OFFSET) | ((u32)regnum),
+		  data->membase + MDIO_RWCTRL);
+
+	ret = hisi_femac_mdio_wait_ready(data);
+	if (ret)
+		return ret;
+
+	return readl(data->membase + MDIO_RO_DATA) & 0xFFFF;
+}
+
+static int hisi_femac_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
+				 u16 value)
+{
+	struct hisi_femac_mdio_data *data = bus->priv;
+	int ret;
+
+	ret = hisi_femac_mdio_wait_ready(data);
+	if (ret)
+		return ret;
+
+	writel(MDIO_WRITE | (value << BIT_WR_DATA_OFFSET) |
+	       ((u32)mii_id << BIT_PHY_ADDR_OFFSET) | ((u32)regnum),
+	       data->membase + MDIO_RWCTRL);
+
+	return hisi_femac_mdio_wait_ready(data);
+}
+
+static void hisi_femac_sleep_us(u32 time_us)
+{
+	u32 time_ms;
+
+	if (!time_us)
+		return;
+
+	time_ms = DIV_ROUND_UP(time_us, 1000);
+	if (time_ms < 20)
+		usleep_range(time_us, time_us + 500);
+	else
+		msleep(time_ms);
+}
+
+static void hisi_femac_phy_reset(const struct hisi_femac_mdio_data *data)
+{
+	/* To make sure PHY hardware reset success,
+	 * we must keep PHY in deassert state first and
+	 * then complete the hardware reset operation
+	 */
+	reset_control_deassert(data->phy_rst);
+	hisi_femac_sleep_us(data->phy_reset_delays[PRE_DELAY]);
+
+	reset_control_assert(data->phy_rst);
+	/* delay some time to ensure reset ok,
+	 * this depends on PHY hardware feature
+	 */
+	hisi_femac_sleep_us(data->phy_reset_delays[PULSE]);
+	reset_control_deassert(data->phy_rst);
+	/* delay some time to ensure later MDIO access */
+	hisi_femac_sleep_us(data->phy_reset_delays[POST_DELAY]);
+}
+
+static void hisi_femac_get_phy_addr(struct hisi_femac_mdio_data *data,
+				    struct device_node *np)
+{
+	struct device_node *child = NULL;
+	int addr;
+
+	child = of_get_next_available_child(np, NULL);
+	if (!child) {
+		pr_err("%s: No valid PHY device node!\n", __func__);
+		return;
+	}
+
+	addr = of_mdio_parse_addr(&data->bus->dev, child);
+	if (addr < 0) {
+		pr_err("%s: get PHY address failed!\n", __func__);
+		return;
+	}
+
+	data->phy_addr = addr;
+}
+
+static inline bool hisi_femac_use_fephy(struct hisi_femac_mdio_data *data)
+{
+	/*return false;*/
+	return (data->fephy_iobase ?
+			!(readl(data->fephy_iobase) & BIT_FEPHY_SEL) : false);
+}
+
+static void hisi_femac_fephy_reset(struct hisi_femac_mdio_data *data)
+{
+	u32 val;
+
+	/* disable MDCK clock to make sure FEPHY reset success */
+	clk_disable_unprepare(data->clk);
+
+	val = readl(data->fephy_iobase);
+	val &= ~BIT_MASK_FEPHY_ADDR;
+	val |= data->phy_addr;
+	writel(val, data->fephy_iobase);
+
+	clk_prepare_enable(data->fephy_clk);
+	udelay(10); /* 10:delay */
+
+	reset_control_assert(data->fephy_rst);
+	udelay(10);
+	reset_control_deassert(data->fephy_rst);
+	/* delay at least 15ms for MDIO operation */
+	msleep(20);
+
+	clk_prepare_enable(data->clk);
+	/* delay 5ms after enable MDCK to make sure FEPHY trim safe */
+	mdelay(5);
+}
+
+static inline int fephy_expanded_read(struct mii_bus *bus, int phy_addr,
+				      u32 reg_addr)
+{
+	int ret;
+
+	hisi_femac_mdio_write(bus, phy_addr, MII_EXPMA, reg_addr);
+	ret = hisi_femac_mdio_read(bus, phy_addr, MII_EXPMD);
+
+	return ret;
+}
+
+static inline int fephy_expanded_write(struct mii_bus *bus, int phy_addr,
+				       u32 reg_addr, u16 val)
+{
+	int ret;
+
+	hisi_femac_mdio_write(bus, phy_addr, MII_EXPMA, reg_addr);
+	ret = hisi_femac_mdio_write(bus, phy_addr, MII_EXPMD, val);
+
+	return ret;
+}
+
+void hisi_femac_fephy_use_default_trim(struct hisi_femac_mdio_data *data)
+{
+	unsigned short val;
+	int timeout = 3;
+
+	pr_info("No OTP data, festa PHY use default ATE parameters!\n");
+
+	do {
+		msleep(250);
+		val = fephy_expanded_read(data->bus, data->phy_addr,
+					  REG_DEF_ATE);
+		val &= BIT_AUTOTRIM_DONE;
+	} while (!val && --timeout);
+
+	if (!timeout)
+		pr_err("festa PHY wait autotrim done timeout!\n");
+
+	mdelay(5);
+}
+
+static void hisi_femac_fephy_trim(struct hisi_femac_mdio_data *data)
+{
+	struct mii_bus *bus = data->bus;
+	u32 phy_addr = data->phy_addr;
+	int timeout = 3000;
+	u32 val;
+	u8 ld_set;
+	u8 ldo_set;
+	u8 r_tuning;
+
+	/* FEPHY get OTP trim data from special reg not fephy control reg1 */
+#if defined(CONFIG_ARCH_HI3536DV100) || \
+	defined(CONFIG_ARCH_HI3521DV200) || \
+	defined(CONFIG_ARCH_HI3520DV500)
+	val = readl(data->fephy_trim_iobase);
+#else
+	val = readl(data->fephy_iobase);
+#endif
+	ld_set = (val >> BIT_OFFSET_LD_SET) & BIT_MASK_LD_SET;
+	ldo_set = (val >> BIT_OFFSET_LDO_SET) & BIT_MASK_LDO_SET;
+	r_tuning = (val >> BIT_OFFSET_R_TUNING) & BIT_MASK_R_TUNING;
+
+#if defined(CONFIG_ARCH_HI3521DV200) || \
+	defined(CONFIG_ARCH_HI3520DV500)
+	if (!ld_set && !ldo_set && !r_tuning) {
+		ld_set = DEF_LD_AM;
+		ldo_set = DEF_LDO_AM;
+		r_tuning = DEF_R_TUNING;
+	}
+#endif
+
+	if (!ld_set && !ldo_set && !r_tuning) {
+		hisi_femac_fephy_use_default_trim(data);
+		return;
+	}
+
+	val = fephy_expanded_read(bus, phy_addr, REG_LD_AM);
+	val = (val & ~BIT_MASK_LD_SET) | (ld_set & BIT_MASK_LD_SET);
+	fephy_expanded_write(bus, phy_addr, REG_LD_AM, val);
+
+	val = fephy_expanded_read(bus, phy_addr, REG_LDO_AM);
+	val = (val & ~BIT_MASK_LDO_SET) | (ldo_set & BIT_MASK_LDO_SET);
+	fephy_expanded_write(bus, phy_addr, REG_LDO_AM, val);
+
+	val = fephy_expanded_read(bus, phy_addr, REG_R_TUNING);
+	val = (val & ~BIT_MASK_R_TUNING) | (r_tuning & BIT_MASK_R_TUNING);
+	fephy_expanded_write(bus, phy_addr, REG_R_TUNING, val);
+
+	val = fephy_expanded_read(bus, phy_addr, REG_WR_DONE);
+	if (val & BIT_CFG_ACK)
+		pr_err("festa PHY 0x3053 bit CFG_ACK value: 1\n");
+	val = val | BIT_CFG_DONE;
+	fephy_expanded_write(bus, phy_addr, REG_WR_DONE, val);
+
+	do {
+		usleep_range(100, 150);
+		val = fephy_expanded_read(bus, phy_addr, REG_WR_DONE);
+		val &= BIT_CFG_ACK;
+	} while (!val && --timeout);
+	if (!timeout)
+		pr_err("festa PHY 0x3053 wait bit CFG_ACK timeout!\n");
+
+	mdelay(5);
+
+	pr_info("FEPHY:addr=%d, la_am=0x%x, ldo_am=0x%x, r_tuning=0x%x\n",
+		phy_addr,
+		fephy_expanded_read(bus, phy_addr, REG_LD_AM),
+		fephy_expanded_read(bus, phy_addr, REG_LDO_AM),
+		fephy_expanded_read(bus, phy_addr, REG_R_TUNING));
+}
+
+static void hisi_femac_fephy_reset_and_trim(struct hisi_femac_mdio_data *data)
+{
+	hisi_femac_fephy_reset(data);
+	hisi_femac_fephy_trim(data);
+}
+
+static void hisi_femac_fephy_set_phy_addr(struct hisi_femac_mdio_data *data)
+{
+	u32 val;
+
+	if (!data->fephy_iobase)
+		return;
+
+	val = readl(data->fephy_iobase);
+	val &= ~BIT_MASK_FEPHY_ADDR;
+	val |= (data->phy_addr + 1);
+	writel(val, data->fephy_iobase);
+}
+
+static int hisi_femac_mdio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct mii_bus *bus = NULL;
+	struct hisi_femac_mdio_data *data = NULL;
+	struct resource *res = NULL;
+	int ret;
+
+	bus = mdiobus_alloc_size(sizeof(*data));
+	if (!bus)
+		return -ENOMEM;
+
+	bus->name = "hisi_femac_mii_bus";
+	bus->read = &hisi_femac_mdio_read;
+	bus->write = &hisi_femac_mdio_write;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);
+	bus->parent = &pdev->dev;
+
+	data = bus->priv;
+	data->bus = bus;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->membase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->membase)) {
+		ret = PTR_ERR(data->membase);
+		goto err_out_free_mdiobus;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res) {
+		data->fephy_iobase = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(data->fephy_iobase)) {
+			ret = PTR_ERR(data->fephy_iobase);
+			goto err_out_free_mdiobus;
+		}
+	} else {
+		data->fephy_iobase = NULL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (res) {
+		data->fephy_trim_iobase = devm_ioremap_resource(&pdev->dev,
+								res);
+		if (IS_ERR(data->fephy_trim_iobase)) {
+			ret = PTR_ERR(data->fephy_trim_iobase);
+			goto err_out_free_mdiobus;
+		}
+	} else {
+		data->fephy_trim_iobase = NULL;
+	}
+
+	data->clk = devm_clk_get(&pdev->dev, "mdio");
+	if (IS_ERR(data->clk)) {
+		ret = PTR_ERR(data->clk);
+		goto err_out_free_mdiobus;
+	}
+
+	data->fephy_clk = devm_clk_get(&pdev->dev, "phy");
+	if (IS_ERR(data->fephy_clk))
+		data->fephy_clk = NULL;
+
+	ret = clk_prepare_enable(data->clk);
+	if (ret)
+		goto err_out_free_mdiobus;
+
+	data->phy_rst = devm_reset_control_get(&pdev->dev, "external-phy");
+	if (IS_ERR(data->phy_rst)) {
+		data->phy_rst = NULL;
+	} else {
+		ret = of_property_read_u32_array(np,
+						 PHY_RESET_DELAYS_PROPERTY,
+						 data->phy_reset_delays,
+						 DELAYS_NUM);
+		if (ret)
+			goto err_out_disable_clk;
+		hisi_femac_phy_reset(data);
+	}
+
+	data->fephy_rst = devm_reset_control_get(&pdev->dev, "internal-phy");
+	if (IS_ERR(data->fephy_rst))
+		data->fephy_rst = NULL;
+
+	hisi_femac_get_phy_addr(data, np);
+	if (hisi_femac_use_fephy(data))
+		hisi_femac_fephy_reset_and_trim(data);
+	else
+		hisi_femac_fephy_set_phy_addr(data);
+
+	ret = of_mdiobus_register(bus, np);
+	if (ret)
+		goto err_out_disable_clk;
+
+	platform_set_drvdata(pdev, bus);
+
+	return 0;
+
+err_out_disable_clk:
+	clk_disable_unprepare(data->fephy_clk);
+	clk_disable_unprepare(data->clk);
+err_out_free_mdiobus:
+	mdiobus_free(bus);
+	return ret;
+}
+
+static int hisi_femac_mdio_remove(struct platform_device *pdev)
+{
+	struct mii_bus *bus = platform_get_drvdata(pdev);
+	struct hisi_femac_mdio_data *data = bus->priv;
+
+	mdiobus_unregister(bus);
+	clk_disable_unprepare(data->clk);
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static const struct of_device_id hisi_femac_mdio_dt_ids[] = {
+	{ .compatible = "hisilicon,hisi-femac-mdio" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hisi_femac_mdio_dt_ids);
+
+static struct platform_driver hisi_femac_mdio_driver = {
+	.probe = hisi_femac_mdio_probe,
+	.remove = hisi_femac_mdio_remove,
+	.driver = {
+		.name = "hisi-femac-mdio",
+		.of_match_table = hisi_femac_mdio_dt_ids,
+	},
+};
+
+module_platform_driver(hisi_femac_mdio_driver);
+
+MODULE_DESCRIPTION("Hisilicon Fast Ethernet MAC MDIO interface driver");
+MODULE_AUTHOR("Hisilicon>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/phy/mdio_hisi_gemac.c b/drivers/net/phy/mdio_hisi_gemac.c
new file mode 100644
index 000000000..79ebfa400
--- /dev/null
+++ b/drivers/net/phy/mdio_hisi_gemac.c
@@ -0,0 +1,256 @@
+/*
+ * Hisilicon Gigabit Ethernet MDIO Bus Driver
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/clk.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_mdio.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include "mdio_hisi_gemac.h"
+
+#if defined(CONFIG_ARCH_HI3519) || defined(CONFIG_ARCH_HI3519V101) || \
+	defined(CONFIG_ARCH_HI3516AV200)
+#ifdef readl
+#undef readl
+#undef writel
+#define readl		hi_readl
+#define writel		hi_writel
+#endif
+#endif
+
+#define MDIO_SINGLE_CMD		0x00
+#define MDIO_SINGLE_DATA	0x04
+#define MDIO_RDATA_STATUS	0x10
+#define BIT_PHY_ADDR_OFFSET	8
+#define MDIO_WRITE		BIT(16)
+#define MDIO_READ		BIT(17)
+#define MDIO_START		BIT(20)
+#define MDIO_START_READ		(MDIO_START | MDIO_READ)
+#define MDIO_START_WRITE	(MDIO_START | MDIO_WRITE)
+
+struct hisi_gemac_mdio_data {
+	struct clk *clk;
+	struct reset_control *phy_rst;
+	void __iomem *membase;
+};
+
+static int hisi_gemac_mdio_wait_ready(struct hisi_gemac_mdio_data *data)
+{
+	u32 val;
+
+	return readl_poll_timeout(data->membase + MDIO_SINGLE_CMD,
+				  val, !(val & MDIO_START), 20, 10000);
+}
+
+static int hisi_gemac_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
+{
+	struct hisi_gemac_mdio_data *data = bus->priv;
+	int ret;
+
+	ret = hisi_gemac_mdio_wait_ready(data);
+	if (ret)
+		return ret;
+
+	writel(MDIO_START_READ | ((u32)mii_id << BIT_PHY_ADDR_OFFSET) |
+	       ((u32)regnum),
+	       data->membase + MDIO_SINGLE_CMD);
+
+	ret = hisi_gemac_mdio_wait_ready(data);
+	if (ret)
+		return ret;
+
+	/* if read data is invalid, we just return 0 instead of -EAGAIN.
+	 * This can make MDIO more robust when reading PHY status.
+	 */
+	if (readl(data->membase + MDIO_RDATA_STATUS))
+		return 0;
+
+	return readl(data->membase + MDIO_SINGLE_DATA) >> 16;
+}
+
+static int hisi_gemac_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
+				 u16 value)
+{
+	struct hisi_gemac_mdio_data *data = bus->priv;
+	int ret;
+
+	ret = hisi_gemac_mdio_wait_ready(data);
+	if (ret)
+		return ret;
+
+	writel(value, data->membase + MDIO_SINGLE_DATA);
+	writel(MDIO_START_WRITE | ((u32)mii_id << BIT_PHY_ADDR_OFFSET) |
+	       ((u32)regnum),
+	       data->membase + MDIO_SINGLE_CMD);
+
+	return hisi_gemac_mdio_wait_ready(data);
+}
+
+static void hisi_gemac_external_phy_reset(struct hisi_gemac_mdio_data const *data)
+{
+	if (data->phy_rst) {
+		/* write 0 to cancel reset */
+		reset_control_deassert(data->phy_rst);
+		msleep(50);
+
+		/* HIFONE or 98cv200 use CRG register to reset phy */
+		/* RST_BIT, write 0 to reset phy, write 1 to cancel reset */
+		reset_control_assert(data->phy_rst);
+
+		/* delay some time to ensure reset ok,
+		 * this depends on PHY hardware feature
+		 */
+		msleep(50);
+
+		/* write 0 to cancel reset */
+		reset_control_deassert(data->phy_rst);
+		/* delay some time to ensure later MDIO access */
+		msleep(50);
+	} else {
+#if defined(CONFIG_ARCH_HI3516A)
+#include <mach/hi3516a_io.h>
+#define GPIO_BASE_ETH_PHY_RESET		0x20140000
+#define GPIO_BIT_ETH_PHY_RESET		1
+		void __iomem *gpio_base;
+		u32 val;
+
+		gpio_base = (void __iomem *)IO_ADDRESS(GPIO_BASE_ETH_PHY_RESET);
+		/* use GPIO to do hardware PHY reset */
+		/* set direction */
+		val = readl(gpio_base + 0x400);
+		val |= (1 << GPIO_BIT_ETH_PHY_RESET);
+		writel(val, gpio_base + 0x400);
+
+		/* Firstly, set to 1 regardless of the value of this pin */
+		writel(0xFF, gpio_base + (4 << GPIO_BIT_ETH_PHY_RESET));
+		msleep(20);
+
+		/* Set to 0 to reset, then sleep 200ms */
+		writel(0x0, gpio_base + (4 << GPIO_BIT_ETH_PHY_RESET));
+		msleep(20);
+
+		/* then, cancel reset, and should sleep 50ms */
+		writel(0xFF, gpio_base + (4 << GPIO_BIT_ETH_PHY_RESET));
+		msleep(200);
+#endif
+	}
+}
+
+static int hisi_gemac_mdio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct mii_bus *bus = NULL;
+	struct hisi_gemac_mdio_data *data = NULL;
+	struct resource *res = NULL;
+	int ret;
+
+	ret = hisi_gemac_pinctrl_config(pdev);
+	if (ret) {
+		pr_err("higmac pinctrl config error=%d.\n", ret);
+		return ret;
+	}
+
+	bus = mdiobus_alloc_size(sizeof(*data));
+	if (!bus)
+		return -ENOMEM;
+
+	bus->name = "hisi_gemac_mii_bus";
+	bus->read = &hisi_gemac_mdio_read;
+	bus->write = &hisi_gemac_mdio_write;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);
+	bus->parent = &pdev->dev;
+
+	data = bus->priv;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL || data == NULL) {
+		ret = -ENXIO;
+		goto err_out_free_mdiobus;
+	}
+	data->membase = devm_ioremap(&pdev->dev, res->start,
+				     resource_size(res));
+	if (!data->membase) {
+		ret = -ENOMEM;
+		goto err_out_free_mdiobus;
+	}
+
+	data->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(data->clk)) {
+		ret = PTR_ERR(data->clk);
+		goto err_out_free_mdiobus;
+	}
+
+	ret = clk_prepare_enable(data->clk);
+	if (ret)
+		goto err_out_free_mdiobus;
+
+	data->phy_rst = devm_reset_control_get(&pdev->dev, "phy_reset");
+	if (IS_ERR(data->phy_rst))
+		data->phy_rst = NULL;
+	hisi_gemac_external_phy_reset(data);
+
+	ret = of_mdiobus_register(bus, np);
+	if (ret)
+		goto err_out_disable_clk;
+
+	platform_set_drvdata(pdev, bus);
+
+	return 0;
+
+err_out_disable_clk:
+	clk_disable_unprepare(data->clk);
+err_out_free_mdiobus:
+	mdiobus_free(bus);
+	return ret;
+}
+
+static int hisi_gemac_mdio_remove(struct platform_device *pdev)
+{
+	struct mii_bus *bus = platform_get_drvdata(pdev);
+	struct hisi_gemac_mdio_data *data = bus->priv;
+
+	mdiobus_unregister(bus);
+	clk_disable_unprepare(data->clk);
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static const struct of_device_id hisi_gemac_mdio_dt_ids[] = {
+	{ .compatible = "hisilicon,hisi-gemac-mdio" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hisi_gemac_mdio_dt_ids);
+
+static struct platform_driver hisi_gemac_mdio_driver = {
+	.probe = hisi_gemac_mdio_probe,
+	.remove = hisi_gemac_mdio_remove,
+	.driver = {
+		.name = "hisi-gemac-mdio",
+		.of_match_table = hisi_gemac_mdio_dt_ids,
+	},
+};
+
+module_platform_driver(hisi_gemac_mdio_driver);
+
+MODULE_DESCRIPTION("Hisilicon Gigabit Ethernet MAC MDIO interface driver");
+MODULE_AUTHOR("Hisilicon>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/phy/mdio_hisi_gemac.h b/drivers/net/phy/mdio_hisi_gemac.h
new file mode 100644
index 000000000..5eefc01e5
--- /dev/null
+++ b/drivers/net/phy/mdio_hisi_gemac.h
@@ -0,0 +1,32 @@
+/*
+ * Hisilicon gemac pinout config headerfile.
+ *
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2019. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __MDIO_HISI_GEMAC_H__
+#define  __MDIO_HISI_GEMAC_H__
+
+#if defined(CONFIG_ARCH_HI3531DV200) || defined(CONFIG_ARCH_HI3535AV100)
+int hisi_gemac_pinctrl_config(struct platform_device *pdev);
+#else
+static inline int hisi_gemac_pinctrl_config(struct platform_device *pdev)
+{
+	return 0;
+}
+#endif
+
+#endif /* __MDIO_HISI_GEMAC_H__ */
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index db7866b6f..413159372 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -260,6 +260,28 @@ static void phy_sanitize_settings(struct phy_device *phydev)
 	}
 }
 
+int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd)
+{
+	cmd->supported = phydev->supported;
+
+	cmd->advertising = phydev->advertising;
+	cmd->lp_advertising = phydev->lp_advertising;
+
+	ethtool_cmd_speed_set(cmd, phydev->speed);
+	cmd->duplex = phydev->duplex;
+	if (phydev->interface == PHY_INTERFACE_MODE_MOCA)
+		cmd->port = PORT_BNC;
+	else
+		cmd->port = PORT_MII;
+	cmd->phy_address = phydev->mdio.addr;
+	cmd->transceiver = phy_is_internal(phydev) ?
+		XCVR_INTERNAL : XCVR_EXTERNAL;
+	cmd->autoneg = phydev->autoneg;
+	cmd->eth_tp_mdix_ctrl = phydev->mdix;
+
+	return 0;
+}
+EXPORT_SYMBOL(phy_ethtool_gset);
 void phy_ethtool_ksettings_get(struct phy_device *phydev,
 			       struct ethtool_link_ksettings *cmd)
 {
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index b4879306b..cb7b1635c 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -29,6 +29,12 @@
 #define RTL8211F_PHYCR1				0x18
 #define RTL8211F_INSR				0x1d
 
+/* RTL8211F RGMII requires special TX delays depending
+   on the actual hardware circuit/wiring.
+   TXDLY register does not need to be set
+   when pin No.25 via 4.7k-ohm to DVDD-RG.
+*/
+#define RTL8211F_RGMII_TX_DELAY_ENABLE  1
 #define RTL8211F_TX_DELAY			BIT(8)
 #define RTL8211F_RX_DELAY			BIT(3)
 
@@ -185,6 +191,10 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	u16 val;
 	int ret;
 
+#if RTL8211F_RGMII_TX_DELAY_ENABLE
+	if (phydev->interface == PHY_INTERFACE_MODE_RGMII)
+		return ret;
+#endif
 	val = RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_XTAL_OFF;
 	phy_modify_paged_changed(phydev, 0xa43, RTL8211F_PHYCR1, val, val);
 
diff --git a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
index 0d374a294..9f2151377 100644
--- a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
+++ b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
@@ -5806,6 +5806,7 @@ static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)
 	ret = usb_submit_urb(urb, GFP_KERNEL);
 	if (ret) {
 		usb_unanchor_urb(urb);
+		usb_free_urb(urb);
 		goto error;
 	}
 
diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig
index 0c473d75e..cb9f492fd 100644
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -256,5 +256,6 @@ source "drivers/pci/hotplug/Kconfig"
 source "drivers/pci/controller/Kconfig"
 source "drivers/pci/endpoint/Kconfig"
 source "drivers/pci/switch/Kconfig"
+source "drivers/pci/hipcie/Kconfig"
 
 endif
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index 522d2b974..2b9167379 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -36,5 +36,6 @@ obj-$(CONFIG_PCI_ENDPOINT)	+= endpoint/
 
 obj-y				+= controller/
 obj-y				+= switch/
+obj-$(CONFIG_HIPCIE) += hipcie/
 
 ccflags-$(CONFIG_PCI_DEBUG) := -DDEBUG
diff --git a/drivers/pci/hipcie/Kconfig b/drivers/pci/hipcie/Kconfig
new file mode 100644
index 000000000..c8d88ef66
--- /dev/null
+++ b/drivers/pci/hipcie/Kconfig
@@ -0,0 +1,27 @@
+menuconfig HIPCIE
+	bool "Hisilicon PCI Express support"
+	depends on PCI && (ARCH_HI3531DV200 || ARCH_HI3535AV100 || ARCH_HI3559AV100 || ARCH_HI3531A || ARCH_HI3519AV100 || ARCH_HI3568V100 || ARCH_HI3569V100)
+	default y if PCI
+	default n if ! PCI
+	help
+	 Hisilicon PCI Express support
+	 Choose this selection to support PCI Express uses.
+
+if HIPCIE
+
+menu "PCI Express configs"
+
+
+config LIMIT_MAX_RD_REQ_SIZE
+	bool "limit pcie max read request size"
+	depends on PCI && (ARCH_HI3531DV200 || ARCH_HI3535AV100 || ARCH_HI3559AV100 || ARCH_HI3531A || ARCH_HI3519AV100 || ARCH_HI3568V100 || ARCH_HI3569V100)
+	help
+	 The default max read request size of pcie device is 512 Byte. When pcie use
+	 the card of pcie-to-sata to connect to the sata disk, with the default max read
+	 request size value of 512 byte, would cause the low bandwidth of VDP. If you enable
+	 the LIMIT_MAX_RD_REQ_SIZE config, the max read request size of pcie device would be
+	 set to 128 byte, and the problem of VDP low band width also be avoided.
+
+endmenu
+
+endif
diff --git a/drivers/pci/hipcie/Makefile b/drivers/pci/hipcie/Makefile
new file mode 100644
index 000000000..04554201e
--- /dev/null
+++ b/drivers/pci/hipcie/Makefile
@@ -0,0 +1,8 @@
+
+obj-$(CONFIG_HIPCIE) += hipcie.o
+
+hipcie-objs	:= pcie.o
+
+ifeq ($(CONFIG_PCI_DEBUG),y)
+	        EXTRA_CFLAGS += -DPCIE_DEBUG
+endif
diff --git a/drivers/pci/hipcie/pci.h b/drivers/pci/hipcie/pci.h
new file mode 100644
index 000000000..daefc0faf
--- /dev/null
+++ b/drivers/pci/hipcie/pci.h
@@ -0,0 +1,96 @@
+/*
+ *  arch/arm/include/asm/mach/pci.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_PCI_H
+#define __ASM_MACH_PCI_H
+
+#include <linux/ioport.h>
+
+struct pci_sys_data;
+struct pci_ops;
+struct pci_bus;
+struct device;
+
+#ifdef CONFIG_PCI_MSI
+#define HISI_PCI_MSI_NR (8 * 32)
+struct hisi_msi {
+	struct msi_controller chip;
+	DECLARE_BITMAP(used, HISI_PCI_MSI_NR);
+	struct irq_domain *domain;
+	unsigned long pages;
+	struct mutex lock;
+	int irq;
+};
+#endif
+
+struct hw_pci {
+#ifdef CONFIG_PCI_DOMAINS
+	int domain;
+#endif
+#ifdef CONFIG_PCI_MSI
+	struct hisi_msi msi;
+#endif
+	struct device *dev;
+	struct pci_ops *ops;
+	int nr_controllers;
+	void **private_data;
+	int (*setup)(int nr, struct pci_sys_data *);
+	struct pci_bus *(*scan)(int nr, struct pci_sys_data *);
+	void (*preinit)(void);
+	void (*postinit)(void);
+	u8 (*swizzle)(struct pci_dev *dev, u8 *pin);
+	int (*map_irq)(const struct pci_dev *dev, u8 slot, u8 pin);
+	resource_size_t (*align_resource)(struct pci_dev *dev,
+					  const struct resource *res,
+					  resource_size_t start,
+					  resource_size_t size,
+					  resource_size_t align);
+	void (*add_bus)(struct pci_bus *bus);
+	void (*remove_bus)(struct pci_bus *bus);
+};
+
+/*
+ * Per-controller structure
+ */
+struct pci_sys_data {
+#ifdef CONFIG_PCI_DOMAINS
+	int domain;
+#endif
+	struct list_head node;
+	int busnr; /* primary bus number			*/
+	u64 mem_offset; /* bus->cpu memory mapping offset	*/
+	unsigned long io_offset; /* bus->cpu IO mapping offset		*/
+	struct pci_bus *bus; /* PCI bus				*/
+	struct list_head resources; /* root bus resources (apertures)       */
+	struct resource io_res;
+	char io_res_name[12];
+	/* Bridge swizzling */
+	u8 (*swizzle)(struct pci_dev *, u8 *);
+	/* IRQ mapping */
+	int (*map_irq)(const struct pci_dev *, u8, u8);
+	/* Resource alignement requirements	*/
+	resource_size_t (*align_resource)(struct pci_dev *dev,
+					  const struct resource *res,
+					  resource_size_t start,
+					  resource_size_t size,
+					  resource_size_t align);
+	void (*add_bus)(struct pci_bus *bus);
+	void (*remove_bus)(struct pci_bus *bus);
+	void *private_data; /* platform controller private data	*/
+};
+
+void __weak pcibios_update_irq(struct pci_dev *dev, int irq)
+{
+	dev_dbg(&dev->dev, "assigning IRQ %02d\n", irq);
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
+}
+
+
+#endif /* __ASM_MACH_PCI_H */
diff --git a/drivers/pci/hipcie/pcie.c b/drivers/pci/hipcie/pcie.c
new file mode 100644
index 000000000..4c44b6b44
--- /dev/null
+++ b/drivers/pci/hipcie/pcie.c
@@ -0,0 +1,985 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mbus.h>
+#include <asm/irq.h>
+#include <linux/of.h>
+#include <linux/of_pci.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <asm/siginfo.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/msi.h>
+#include <linux/of_irq.h>
+#include "../pci.h"
+#ifdef CONFIG_ARM64
+#include "pci.h"
+#endif
+
+#define PCIE_DBG_REG		1
+#define PCIE_DBG_FUNC		2
+#define PCIE_DBG_MODULE		3
+
+#define PCIE_DEBUG_LEVEL PCIE_DBG_MODULE
+
+/* #define PCIE_DEBUG */
+#ifdef PCIE_DEBUG
+#define pcie_debug(level, str, arg...) \
+	do { \
+		if ((level) <= PCIE_DEBUG_LEVEL) { \
+			pr_debug("%s->%d," str "\n", \
+				__func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+#else
+#define pcie_debug(level, str, arg...)
+#endif
+
+#define pcie_assert(con) \
+	do { \
+		if (!(con)) { \
+			pr_err("%s->%d,assert fail!\n", \
+				__func__, __LINE__); \
+		} \
+	} while (0)
+
+#define pcie_error(str, arg...) \
+	pr_err("%s->%d" str "\n", __func__, __LINE__, ##arg)
+
+#define __256MB__ 0x10000000
+#define __128MB__ 0x8000000
+#define __4KB__ 0x1000
+#define __8KB__ 0x2000
+#define __16KB__ 0x4000
+
+enum pcie_sel {
+	/*
+	 * No controller selected.
+	 */
+	pcie_sel_none,
+	/*
+	 * PCIE0 selected.
+	 */
+	pcie0_x1_sel,
+	/*
+	 * PCIE1 selected.
+	 */
+	pcie1_x1_sel
+};
+
+enum pcie_rc_sel {
+	pcie_controller_unselected,
+	pcie_controller_selected
+};
+
+enum pcie_controller {
+	pcie_controller_none = -1,
+	pcie_controller_0 = 0,
+	pcie_controller_1 = 1
+};
+
+struct pcie_iatu {
+	unsigned int viewport;          /* iATU Viewport Register        */
+	unsigned int region_ctrl_1;     /* Region Control 1 Register     */
+	unsigned int region_ctrl_2;     /* Region Control 2 Register     */
+	unsigned int lbar;              /* Lower Base Address Register   */
+	unsigned int ubar;              /* Upper Base Address Register   */
+	unsigned int lar;               /* Limit Address Register        */
+	unsigned int ltar; /* Lower Target Address Register */
+	unsigned int utar;              /* Upper Target Address Register */
+};
+
+#define MAX_IATU_PER_CTRLLER	(6)
+
+struct pcie_info {
+	/*
+	 * Root bus number
+	 */
+	int		root_bus_nr;
+	enum		pcie_controller controller;
+
+	/*
+	 * Devices configuration space base
+	 */
+	unsigned long	base_addr;
+
+	/*
+	 * RC configuration space base
+	 */
+	unsigned long	conf_base_addr;
+};
+
+#define MAX_PCIE_CONTROLLER_NUM  2
+static struct pcie_info pcie_info[MAX_PCIE_CONTROLLER_NUM] = {
+	{ .root_bus_nr = -1, },
+	{ .root_bus_nr = -1, }
+};
+
+static int pcie_controllers_nr;
+
+static unsigned int pcie_errorvalue;
+
+struct device_node *g_of_node = NULL;
+
+static DEFINE_SPINLOCK(cw_lock);
+
+#define msi_contrl_interrupt 0x830
+#define MSI_CTRL_UPPER_ADDR_OFF 0x824
+#define MSI_CTRL_ADDR_OFF 0x820
+#define MSI_CTRL_INT_EN_OFF0 0x828
+#define MSI_CTRL_INT_EN_OFF1 0x834
+#define MSI_CTRL_INT_EN_OFF2 0x840
+#define MSI_CTRL_INT_EN_OFF3 0x84c
+#define MSI_CTRL_INT_EN_OFF4 0x858
+#define MSI_CTRL_INT_EN_OFF5 0x864
+#define MSI_CTRL_INT_EN_OFF6 0x870
+#define MSI_CTRL_INT_EN_OFF7 0x87c
+
+#define PCIE0_MODE_SEL  (1 << 0)
+#define PCIE1_MODE_SEL  (1 << 1)
+
+#if defined(CONFIG_ARCH_HI3531DV200)
+#include "pcie_hi3531dv200.c"
+#elif defined(CONFIG_ARCH_HI3535AV100)
+#include "pcie_hi3535av100.c"
+#elif defined(CONFIG_ARCH_HI3519AV100)
+#include "pcie_hi3519av100.c"
+#elif defined(CONFIG_ARCH_HI3559AV100)
+#include "pcie_hi3559av100.c"
+#else
+#error You must have defined CONFIG_ARCH_HI35xx...
+#endif
+
+static struct pcie_info *bus_to_info(int busnr)
+{
+	int i = pcie_controllers_nr;
+	for (; i >= 0; i--) {
+		if (pcie_info[i].controller != pcie_controller_none
+				&& pcie_info[i].root_bus_nr <= busnr
+				&& pcie_info[i].root_bus_nr != -1)
+			return &pcie_info[i];
+	}
+
+	return NULL;
+}
+
+#define PCIE_CFG_BUS(busnr) ((busnr & 0xff) << 20)
+#define PCIE_CFG_DEV(devfn) ((devfn & 0xff) << 12)
+#define PCIE_CFG_REG(reg) (reg & 0xffc) /* set dword align */
+
+static inline unsigned long to_pcie_address(struct pci_bus *bus,
+		unsigned int devfn, int where)
+{
+	struct pcie_info *info = bus_to_info(bus->number);
+	unsigned long address = 0;
+
+	if (unlikely(!info)) {
+		pcie_error(
+			"%s:Cannot find corresponding controller for appointed device!", __func__);
+		BUG();
+	}
+
+	address = info->base_addr + (PCIE_CFG_BUS(bus->number)
+				     | PCIE_CFG_DEV(devfn) | PCIE_CFG_REG((unsigned int)where));
+
+	return address;
+}
+
+static inline int is_pcie_link_up(struct pcie_info *info)
+{
+	int i;
+
+	for (i = 0; i < 10000; i++) {
+		if (__arch_check_pcie_link(info))
+			break;
+		udelay(100);
+	}
+
+	return (i < 10000);
+}
+
+static int pcie_read_from_device(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 *value)
+{
+	struct pcie_info *info = bus_to_info(bus->number);
+	unsigned int val;
+	void __iomem *addr;
+	int i = 0;
+
+	if (unlikely(!info)) {
+		pcie_error(
+			"%s:Cannot find corresponding controller for appointed device!", __func__);
+		BUG();
+	}
+	if (!is_pcie_link_up(info)) {
+		pcie_debug(PCIE_DBG_MODULE, "pcie %d not link up!",
+			   info->controller);
+		return -1;
+	}
+
+	addr = (void __iomem *)(uintptr_t)to_pcie_address(bus, devfn, where);
+
+	val = readl(addr);
+
+	i = 0;
+	while (i < 2000) {
+		__asm__ __volatile__("nop\n");
+		i++;
+	}
+
+	if (pcie_errorvalue == 1) {
+		pcie_errorvalue = 0;
+		val = 0xffffffff;
+	}
+
+	if (size == 1)
+		*value = ((val >> (((unsigned int)where & 0x3) << 3)) & 0xff);
+	else if (size == 2)
+		*value = ((val >> (((unsigned int)where & 0x3) << 3)) & 0xffff);
+	else if (size == 4)
+		*value = val;
+	else {
+		pcie_error("Unknown size(%d) for read ops", size);
+		BUG();
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pcie_read_from_dbi(struct pcie_info *info, unsigned int devfn,
+			      int where, int size, u32 *value)
+{
+	unsigned int val;
+
+	/*
+	 * For host-side config space read, ignore device func nr.
+	 */
+	if (devfn > 0)
+		return -EIO;
+
+	val = (u32)readl((void *)(uintptr_t)(info->conf_base_addr +
+					     ((unsigned int)where & (~0x3))));
+
+	if (1 == size)
+		*value = (val >> (((unsigned int)where & 0x3) << 3)) & 0xff;
+	else if (2 == size)
+		*value = (val >> (((unsigned int)where & 0x3) << 3)) & 0xffff;
+	else if (4 == size)
+		*value = val;
+	else {
+		pcie_error("Unknown size for config read operation!");
+		BUG();
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pcie_read_conf(struct pci_bus *bus, unsigned int devfn,
+			  int where, int size, u32 *value)
+{
+	struct pcie_info *info = bus_to_info(bus->number);
+	int ret;
+
+	if (unlikely(!info)) {
+		pcie_error(
+			"%s:Cannot find corresponding controller for appointed device!", __func__);
+		BUG();
+	}
+
+	if (bus->number == info->root_bus_nr)
+		ret =  pcie_read_from_dbi(info, devfn, where, size, value);
+	else
+		ret =  pcie_read_from_device(bus, devfn, where, size, value);
+
+	pcie_debug(PCIE_DBG_REG,
+		   "bus %d, devfn %d, where 0x%x, size 0x%x, value 0x%x",
+		   bus->number & 0xff, devfn, where, size, *value);
+
+	return ret;
+}
+
+static int pcie_write_to_device(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 value)
+{
+	struct pcie_info *info = bus_to_info(bus->number);
+	void __iomem *addr;
+	unsigned int org;
+	unsigned long flag;
+
+	if (unlikely(!info)) {
+		pcie_error(
+			"%s:Cannot find corresponding controller for appointed device!", __func__);
+		BUG();
+	}
+
+	if (!is_pcie_link_up(info)) {
+		pcie_debug(PCIE_DBG_MODULE, "pcie %d not link up!",
+			   info->controller);
+		return -1;
+	}
+
+	spin_lock_irqsave(&cw_lock, flag);
+
+	pcie_read_from_device(bus, devfn, where, 4, &org);
+
+	addr = (void __iomem *)(uintptr_t)to_pcie_address(bus, devfn, where);
+
+	if (size == 1) {
+		org &= (~(0xff << (((unsigned int)where & 0x3) << 3)));
+		org |= (value << (((unsigned int)where & 0x3) << 3));
+	} else if (size == 2) {
+		org &= (~(0xffff << (((unsigned int)where & 0x3) << 3)));
+		org |= (value << (((unsigned int)where & 0x3) << 3));
+	} else if (size == 4) {
+		org = value;
+	} else {
+		pcie_error("Unknown size(%d) for read ops", size);
+		BUG();
+	}
+
+	writel(org, addr);
+
+	spin_unlock_irqrestore(&cw_lock, flag);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pcie_write_to_dbi(struct pcie_info *info, unsigned int devfn,
+			     int where, int size, u32 value)
+{
+	unsigned long flag;
+	unsigned int org;
+
+	spin_lock_irqsave(&cw_lock, flag);
+
+	if (pcie_read_from_dbi(info, devfn, (unsigned int)where, 4, &org)) {
+		pcie_error("Cannot read from dbi! 0x%x:0x%x:0x%x!",
+			   0, devfn, (unsigned int)where);
+		spin_unlock_irqrestore(&cw_lock, flag);
+		return -EIO;
+	}
+	if (size == 1) {
+		org &= (~(0xff << (((unsigned int)where & 0x3) << 3)));
+		org |= (value << (((unsigned int)where & 0x3) << 3));
+	} else if (size == 2) {
+		org &= (~(0xffff << (((unsigned int)where & 0x3) << 3)));
+		org |= (value << (((unsigned int)where & 0x3) << 3));
+	} else if (size == 4) {
+		org = value;
+	} else {
+		pcie_error("Unknown size(%d) for read ops", size);
+		BUG();
+	}
+	writel(org, ((void __iomem *)(uintptr_t)info->conf_base_addr +
+		     ((unsigned int)where & (~0x3))));
+
+	spin_unlock_irqrestore(&cw_lock, flag);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pcie_write_conf(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 value)
+{
+	struct pcie_info *info = bus_to_info(bus->number);
+
+	pcie_debug(PCIE_DBG_REG,
+		   "bus %d, devfn %d, where 0x%x, size 0x%x, value 0x%x",
+		   bus->number & 0xff, devfn, where, size, value);
+
+	if (unlikely(!info)) {
+		pcie_error(
+			"%s:Cannot find corresponding controller for appointed device!", __func__);
+		BUG();
+	}
+
+	if (bus->number == info->root_bus_nr)
+		return pcie_write_to_dbi(info, devfn, where, size, value);
+	else
+		return pcie_write_to_device(bus, devfn, where, size, value);
+}
+
+static struct pci_ops pcie_ops = {
+	.read = pcie_read_conf,
+	.write = pcie_write_conf,
+};
+
+void pci_set_max_rd_req_size(const struct pci_bus *bus)
+{
+	struct pci_dev *dev = NULL;
+	struct pci_bus *child = NULL;
+	int pos;
+	unsigned short dev_contrl_reg_val = 0;
+	unsigned int max_rd_req_size = 0;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		/* set device max read requset size */
+		pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+		if (pos) {
+			pci_read_config_word(dev, pos + PCI_EXP_DEVCTL,
+					     &dev_contrl_reg_val);
+			max_rd_req_size = (dev_contrl_reg_val >> 12) & 0x7;
+			if (max_rd_req_size > 0x0) {
+				dev_contrl_reg_val &= ~(max_rd_req_size << 12);
+				pci_write_config_word(dev, pos + PCI_EXP_DEVCTL,
+						      dev_contrl_reg_val);
+			}
+		}
+	}
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		BUG_ON(!dev->is_probed);
+		child = dev->subordinate;
+		if (child)
+			pci_set_max_rd_req_size(child);
+	}
+}
+
+#ifdef CONFIG_PCI_MSI
+int pci_msi_is_enable(struct platform_device *pdev)
+{
+	int msi_irq;
+
+	msi_irq = platform_get_irq_byname(pdev, "msi");
+	if (msi_irq < 0) {
+		return false;
+	}
+
+	return true;
+}
+#endif
+
+#ifdef CONFIG_ARM64
+
+static int pci_common_init(struct platform_device *pdev, struct hw_pci *hipcie)
+{
+	struct device_node *dn = pdev->dev.of_node;
+	struct pcie_info *info = NULL;
+	struct pci_bus *bus = NULL;
+	resource_size_t io_addr;
+	int ret;
+	int pcie_contrl = -1;
+	int bus_start;
+
+	LIST_HEAD(res);
+
+	ret = of_property_read_u32(dn, "pcie_controller", &pcie_contrl);
+	if (ret) {
+		pr_err("%s:No pcie_controller found!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (pcie_contrl == 0)
+		bus_start = 0;
+	else
+		bus_start = 0x2;
+
+	ret = devm_of_pci_get_host_bridge_resources(&pdev->dev, bus_start, 0xff, &res,
+						    &io_addr);
+	if (ret)
+		return ret;
+	bus = pci_create_root_bus(&pdev->dev, bus_start, &pcie_ops, hipcie, &res);
+	if (!bus)
+		return -ENOMEM;
+
+#ifdef CONFIG_PCI_MSI
+	if (pci_msi_is_enable(pdev)) {
+		bus->msi = &hipcie->msi.chip;
+	}
+#endif
+
+#ifdef CONFIG_LIMIT_MAX_RD_REQ_SIZE
+	pci_set_max_rd_req_size(bus);
+#endif
+
+	pcie_info[pcie_contrl].root_bus_nr = bus->number;
+	info = bus_to_info(bus->number);
+	if (info != NULL)
+		__arch_config_iatu_tbl(info, NULL);
+
+	pci_scan_child_bus(bus);
+	pci_assign_unassigned_bus_resources(bus);
+	pci_bus_add_devices(bus);
+
+	platform_set_drvdata(pdev, hipcie);
+
+	return 0;
+}
+#else
+static int pci_common_init_bvt(struct platform_device *pdev,
+			       struct hw_pci *hipcie)
+{
+	struct device_node *dn = pdev->dev.of_node;
+	struct pcie_info *info = NULL;
+	struct pci_bus *bus = NULL;
+	resource_size_t io_addr;
+	int ret;
+	int pcie_contrl;
+	int bus_start;
+
+	LIST_HEAD(res);
+
+	ret = of_property_read_u32(dn, "pcie_controller", &pcie_contrl);
+	if (ret) {
+		pr_err("%s:No pcie_controller found!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (pcie_contrl == 0)
+		bus_start = 0;
+	else
+		bus_start = 2;
+
+	ret = devm_of_pci_get_host_bridge_resources(&pdev->dev, bus_start, 0xff, &res, &io_addr);
+	if (ret)
+		return ret;
+
+	bus = pci_create_root_bus(&pdev->dev, bus_start, &pcie_ops, hipcie, &res);
+	if (!bus)
+		return -ENOMEM;
+
+#ifdef CONFIG_PCI_MSI
+	if (pci_msi_is_enable(pdev)) {
+		bus->msi = &hipcie->msi.chip;
+	}
+#endif
+
+#ifdef CONFIG_LIMIT_MAX_RD_REQ_SIZE
+	pci_set_max_rd_req_size(bus);
+#endif
+
+	pcie_info[pcie_contrl].root_bus_nr = bus->number;
+	info = bus_to_info(bus->number);
+	if (info != NULL) {
+		__arch_config_iatu_tbl(info, NULL);
+	}
+
+	pci_scan_child_bus(bus);
+	pci_assign_unassigned_bus_resources(bus);
+	pci_bus_add_devices(bus);
+
+	platform_set_drvdata(pdev, hipcie);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PCI_MSI
+static inline struct hisi_msi *to_hisi_msi(struct msi_controller *chip)
+{
+	return container_of(chip, struct hisi_msi, chip);
+}
+
+static int hisi_msi_alloc(struct hisi_msi *chip)
+{
+	int msi;
+
+	mutex_lock(&chip->lock);
+
+	msi = find_first_zero_bit(chip->used, HISI_PCI_MSI_NR);
+	if (msi < HISI_PCI_MSI_NR)
+		set_bit(msi, chip->used);
+	else
+		msi = -ENOSPC;
+
+	mutex_unlock(&chip->lock);
+
+	return msi;
+}
+
+static void hisi_msi_free(struct hisi_msi *chip, unsigned long irq)
+{
+	struct device *dev = chip->chip.dev;
+
+	mutex_lock(&chip->lock);
+
+	if (!test_bit(irq, chip->used))
+		dev_err(dev, "trying to free unused MSI#%lu\n", irq);
+	else
+		clear_bit(irq, chip->used);
+
+	mutex_unlock(&chip->lock);
+}
+
+static irqreturn_t hisi_pcie_msi_irq(int irq, void *data)
+{
+	struct hw_pci *hi_pcie = data;
+	struct device *dev = hi_pcie->dev;
+	struct hisi_msi *msi = &hi_pcie->msi;
+	unsigned int i;
+	unsigned int processed = 0;
+	void *dbi_base = (void *)(uintptr_t)
+			 pcie_info[hi_pcie->nr_controllers].conf_base_addr;
+
+	for (i = 0; i < 8; i++) {
+		unsigned long reg = readl(dbi_base + 0x830 + i * 0xc);
+
+		while (reg) {
+			unsigned int offset = find_first_bit(&reg, 32);
+			unsigned int index = i * 32 + offset;
+			unsigned int irq;
+
+			/* clear the interrupt */
+			writel(1 << offset, dbi_base + msi_contrl_interrupt + i * 0xc);
+
+			irq = irq_find_mapping(msi->domain, index);
+			if (irq) {
+				if (test_bit(index, msi->used)) {
+					generic_handle_irq(irq);
+				} else
+					dev_info(dev, "unhandled MSI\n");
+			} else {
+				/*
+				 * * that's weird who triggered this?
+				 * * just clear it
+				 *  */
+				dev_info(dev, "unexpected MSI\n");
+			}
+
+			/* see if there's any more pending in this vector */
+			reg = readl(dbi_base +  msi_contrl_interrupt + i * 0xc);
+			processed++;
+		}
+	}
+	return processed > 0 ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static int hisi_msi_setup_irq(struct msi_controller *chip,
+			      struct pci_dev *pdev, struct msi_desc *desc)
+{
+	struct hisi_msi *msi = to_hisi_msi(chip);
+	struct msi_msg msg;
+	unsigned int irq;
+	int hwirq;
+
+	if (pdev->bus->number == pcie_info[0].root_bus_nr ||
+			pdev->bus->number == pcie_info[1].root_bus_nr)
+		return 0;
+
+	hwirq = hisi_msi_alloc(msi);
+	if (hwirq < 0)
+		return hwirq;
+
+	irq = irq_create_mapping(msi->domain, hwirq);
+	if (!irq) {
+		hisi_msi_free(msi, hwirq);
+		return -EINVAL;
+	}
+
+	irq_set_msi_desc(irq, desc);
+
+	desc->msi_attrib.multiple = 0x5;
+
+	msg.address_lo = virt_to_phys((void *)(uintptr_t)msi->pages);
+	msg.address_hi = (virt_to_phys((void *)(uintptr_t)msi->pages) >> 32);
+	msg.data = hwirq;
+
+	pci_write_msi_msg(irq, &msg);
+
+	return 0;
+}
+
+static void hisi_msi_teardown_irq(struct msi_controller *chip,
+				  unsigned int irq)
+{
+	struct hisi_msi *msi = to_hisi_msi(chip);
+	struct irq_data *d = irq_get_irq_data(irq);
+	irq_hw_number_t hwirq = 0;
+
+	if (d != NULL)
+		hwirq = irqd_to_hwirq(d);
+
+	irq_dispose_mapping(irq);
+	hisi_msi_free(msi, hwirq);
+}
+
+static struct irq_chip hisi_msi_irq_chip = {
+	.name = "HISI PCIe MSI",
+	.irq_enable = pci_msi_unmask_irq,
+	.irq_disable = pci_msi_mask_irq,
+	.irq_mask = pci_msi_mask_irq,
+	.irq_unmask = pci_msi_unmask_irq,
+};
+
+static int hisi_msi_map(struct irq_domain *domain, unsigned int irq,
+			irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq, &hisi_msi_irq_chip, handle_simple_irq);
+	irq_set_chip_data(irq, domain->host_data);
+
+	return 0;
+}
+
+static const struct irq_domain_ops msi_domain_ops = {
+	.map = hisi_msi_map,
+};
+
+static int hisi_pcie_enable_msi(struct hw_pci *pcie)
+{
+	struct device *dev = pcie->dev;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct hisi_msi *msi = &pcie->msi;
+	unsigned long base;
+	int err;
+
+	void *dbi_base = (void *)(uintptr_t)
+			 pcie_info[pcie->nr_controllers].conf_base_addr;
+
+	if (!msi) {
+		dev_err(dev, "msi is null, error.\n");
+		return -EINVAL;
+	}
+
+	mutex_init(&msi->lock);
+
+	msi->chip.dev = dev;
+	msi->chip.setup_irq = hisi_msi_setup_irq;
+	msi->chip.teardown_irq = hisi_msi_teardown_irq;
+
+	msi->domain = irq_domain_add_linear(dev->of_node, HISI_PCI_MSI_NR,
+					    &msi_domain_ops, &msi->chip);
+	if (!msi->domain) {
+		dev_err(dev, "failed to create IRQ domain\n");
+		return -ENOMEM;
+	}
+
+	err = platform_get_irq_byname(pdev, "msi");
+	if (err < 0) {
+		dev_err(dev, "failed to get IRQ: %d\n", err);
+		goto err;
+	}
+
+	msi->irq = err;
+
+	err = request_irq(msi->irq, hisi_pcie_msi_irq, IRQF_NO_THREAD,
+			  hisi_msi_irq_chip.name, pcie);
+	if (err < 0) {
+		dev_err(dev, "failed to request IRQ: %d\n", err);
+		goto err;
+	}
+
+	/* setup AFI/FPCI range */
+	msi->pages = __get_free_pages(GFP_KERNEL, 0);
+	base = virt_to_phys((void *)(uintptr_t)msi->pages);
+
+	writel(base >> 32, dbi_base + MSI_CTRL_UPPER_ADDR_OFF);
+	writel(base, dbi_base + MSI_CTRL_ADDR_OFF);
+
+	/* enable all MSI vectors */
+	writel(0xffffffff, dbi_base + MSI_CTRL_INT_EN_OFF0);
+	writel(0xffffffff, dbi_base + MSI_CTRL_INT_EN_OFF1);
+	writel(0xffffffff, dbi_base + MSI_CTRL_INT_EN_OFF2);
+	writel(0xffffffff, dbi_base + MSI_CTRL_INT_EN_OFF3);
+	writel(0xffffffff, dbi_base + MSI_CTRL_INT_EN_OFF4);
+	writel(0xffffffff, dbi_base + MSI_CTRL_INT_EN_OFF5);
+	writel(0xffffffff, dbi_base + MSI_CTRL_INT_EN_OFF6);
+	writel(0xffffffff, dbi_base + MSI_CTRL_INT_EN_OFF7);
+
+	return 0;
+
+err:
+	irq_domain_remove(msi->domain);
+	return err;
+}
+
+static int hisi_pcie_disable_msi(struct hw_pci *pcie)
+{
+	struct hisi_msi *msi = &pcie->msi;
+	unsigned int i, irq;
+	void *dbi_base = (void *)(uintptr_t)
+			 pcie_info[pcie->nr_controllers].conf_base_addr;
+
+	/* disable all MSI vectors */
+	writel(0x0, dbi_base + MSI_CTRL_INT_EN_OFF0);
+	writel(0x0, dbi_base + MSI_CTRL_INT_EN_OFF1);
+	writel(0x0, dbi_base + MSI_CTRL_INT_EN_OFF2);
+	writel(0x0, dbi_base + MSI_CTRL_INT_EN_OFF3);
+	writel(0x0, dbi_base + MSI_CTRL_INT_EN_OFF4);
+	writel(0x0, dbi_base + MSI_CTRL_INT_EN_OFF5);
+	writel(0x0, dbi_base + MSI_CTRL_INT_EN_OFF6);
+	writel(0x0, dbi_base + MSI_CTRL_INT_EN_OFF7);
+
+	free_pages(msi->pages, 0);
+
+	if (msi->irq > 0)
+		free_irq(msi->irq, pcie);
+
+	for (i = 0; i < HISI_PCI_MSI_NR; i++) {
+		irq = irq_find_mapping(msi->domain, i);
+		if (irq > 0)
+			irq_dispose_mapping(irq);
+	}
+
+	irq_domain_remove(msi->domain);
+
+	return 0;
+}
+#endif
+
+static int __init pcie_init(struct platform_device *pdev)
+{
+	int err;
+	struct hw_pci *hipcie = NULL;
+
+	if (!pdev) {
+		pr_err("pdev is null!\n");
+		return -ENOMEM;
+	}
+
+	hipcie = kzalloc(sizeof(struct hw_pci), GFP_KERNEL);
+	if (!hipcie) {
+		pr_err("kzalloc hw_pci space failed!\n");
+		return -ENOMEM;
+	}
+
+	hipcie->dev = &pdev->dev;
+
+	g_of_node = pdev->dev.of_node;
+	if (!g_of_node) {
+		pr_err("get node from dts failed! controller:%d\n", pcie_controllers_nr);
+		kfree(hipcie);
+		return -EIO;
+	}
+
+	err = of_property_read_u32(g_of_node, "pcie_controller", &pcie_controllers_nr);
+	if (err) {
+		pr_err("%s:No pcie_controller found!\n", __func__);
+		kfree(hipcie);
+		return -EINVAL;
+	}
+
+	if (__arch_pcie_info_setup(pcie_info, &pcie_controllers_nr)) {
+		kfree(hipcie);
+		return -EIO;
+	}
+
+	if (pcie_controllers_nr >= MAX_PCIE_CONTROLLER_NUM) {
+		pr_err("pcie_controllers_nr is Invalid, pcie_controllers_nr: %d\n",
+		       pcie_controllers_nr);
+		kfree(hipcie);
+		return -EINVAL;
+	}
+
+	if (__arch_pcie_sys_init(&pcie_info[pcie_controllers_nr]))
+		goto pcie_init_err;
+
+	hipcie->nr_controllers = pcie_controllers_nr;
+	pr_err("Number of PCIe controllers: %d\n",
+	       hipcie->nr_controllers);
+
+#ifdef CONFIG_PCI_MSI
+	if (pci_msi_is_enable(pdev)) {
+		err = hisi_pcie_enable_msi(hipcie);
+		if (err < 0) {
+			pr_err("failed to enable MSI support: %d\n", err);
+			goto pcie_init_err;
+		}
+	}
+#endif
+
+#ifdef CONFIG_ARM64
+	err = pci_common_init(pdev, hipcie);
+#else
+	err = pci_common_init_bvt(pdev, hipcie);
+#endif
+
+	if (err)
+		goto disable_msi;
+
+	return 0;
+
+disable_msi:
+#ifdef CONFIG_PCI_MSI
+	if (pci_msi_is_enable(pdev))
+		hisi_pcie_disable_msi(hipcie);
+#endif
+pcie_init_err:
+	__arch_pcie_info_release(&pcie_info[pcie_controllers_nr]);
+
+	kfree(hipcie);
+
+	return -EIO;
+}
+
+static int __exit pcie_uinit(struct platform_device *pdev)
+{
+	__arch_pcie_info_release(pcie_info);
+	return 0;
+}
+
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+
+int  hisi_pcie_plat_driver_probe(struct platform_device *pdev)
+{
+	return 0;
+}
+int  hisi_pcie_plat_driver_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PM
+int hisi_pcie_plat_driver_suspend(struct device *dev)
+{
+	__arch_pcie_sys_exit();
+	return 0;
+}
+
+int hisi_pcie_plat_driver_resume(struct device *dev)
+{
+	return __arch_pcie_sys_init(pcie_info);
+}
+
+const struct dev_pm_ops hisi_pcie_pm_ops = {
+	.suspend = NULL,
+	.suspend_noirq = hisi_pcie_plat_driver_suspend,
+	.resume = NULL,
+	.resume_noirq = hisi_pcie_plat_driver_resume
+};
+
+#define HISI_PCIE_PM_OPS (&hisi_pcie_pm_ops)
+#else
+#define HISI_PCIE_PM_OPS NULL
+#endif
+
+#define PCIE_RC_DRV_NAME "hisi pcie root complex"
+
+static const struct of_device_id hisi_pcie_match_table[] = {
+	{ .compatible = "hisilicon,hisi-pcie", },
+	{},
+};
+
+static struct platform_driver hisi_pcie_driver = {
+	.driver = {
+		.name = "hisi-pcie",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(hisi_pcie_match_table),
+	},
+	.probe = pcie_init,
+};
+module_platform_driver(hisi_pcie_driver);
+
+MODULE_DESCRIPTION("Hisilicon PCI-Express Root Complex driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 8b587fc97..07482a509 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -19,6 +19,7 @@
 #include <linux/kexec.h>
 #include <linux/of_device.h>
 #include <linux/acpi.h>
+#include <linux/of_pci.h>
 #include <linux/dma-map-ops.h>
 #include "pci.h"
 #include "pcie/portdrv.h"
@@ -394,6 +395,9 @@ static int __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
 
 int __weak pcibios_alloc_irq(struct pci_dev *dev)
 {
+#ifdef CONFIG_SATA_AHCI
+	dev->irq = of_irq_parse_and_map_pci(dev, 0, 0);
+#endif
 	return 0;
 }
 
diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index 9ed5f167a..533d43e77 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -83,5 +83,6 @@ source "drivers/phy/tegra/Kconfig"
 source "drivers/phy/ti/Kconfig"
 source "drivers/phy/intel/Kconfig"
 source "drivers/phy/xilinx/Kconfig"
+source "drivers/phy/hibvt/Kconfig"
 
 endmenu
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index 6eb291677..38a096b29 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_PHY_LPC18XX_USB_OTG)	+= phy-lpc18xx-usb-otg.o
 obj-$(CONFIG_PHY_XGENE)			+= phy-xgene.o
 obj-$(CONFIG_PHY_PISTACHIO_USB)		+= phy-pistachio-usb.o
 obj-$(CONFIG_USB_LGM_PHY)		+= phy-lgm-usb.o
+obj-$(CONFIG_ARCH_HISI_BVT)		+= hibvt/
 obj-y					+= allwinner/	\
 					   amlogic/	\
 					   broadcom/	\
diff --git a/drivers/phy/hibvt/Kconfig b/drivers/phy/hibvt/Kconfig
new file mode 100644
index 000000000..9fcb56c1c
--- /dev/null
+++ b/drivers/phy/hibvt/Kconfig
@@ -0,0 +1,23 @@
+config PHY_HISI_SATA
+	tristate "Hisilicon sata phy support"
+	depends on (ARCH_HI3531DV200 || ARCH_HI3535AV100 || ARCH_HI3521DV200 || ARCH_HI3520DV500) && OF && HAS_IOMEM
+	default n
+	select GENERIC_PHY
+	help
+	  Enable this to support the sata phy that is part of
+	  sata driver for hisilicon
+
+config HISI_SATA_MODE
+	int "Hisi sata interworking speed mode(1.5G:0/3G:1/6G:2)"
+	depends on PHY_HISI_SATA
+	help
+	  Hisilicon sata interworking speed mode
+
+menuconfig HI_USB_PHY
+	tristate "HiSilicon USB support"
+
+if HI_USB_PHY
+
+source "drivers/phy/hibvt/usb/Kconfig"
+
+endif # HI_USB_PHY
diff --git a/drivers/phy/hibvt/Makefile b/drivers/phy/hibvt/Makefile
new file mode 100644
index 000000000..7b038f48e
--- /dev/null
+++ b/drivers/phy/hibvt/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the phy drivers.
+#
+obj-$(CONFIG_PHY_HISI_SATA)			+= phy-hisi-sata.o
+obj-y	+= usb/
diff --git a/drivers/phy/hibvt/phy-hisi-sata.c b/drivers/phy/hibvt/phy-hisi-sata.c
new file mode 100644
index 000000000..d7384fec3
--- /dev/null
+++ b/drivers/phy/hibvt/phy-hisi-sata.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2016-2019 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+static unsigned int phy_mode = CONFIG_HISI_SATA_MODE;
+static unsigned int ports_num;
+unsigned int sata_port_map;
+
+#ifdef MODULE
+module_param(mode_3g, uint, 0600);
+MODULE_PARM_DESC(phy_mode, "sata phy mode (0:1.5G;1:3G(default);2:6G)");
+#endif
+
+#ifdef CONFIG_ARCH_HI3531DV200
+#include "phy-hi3531dv200-sata.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3535AV100
+#include "phy-hi3535av100-sata.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3521DV200
+#include "phy-hi3521dv200-sata.c"
+#endif
+
+#ifdef CONFIG_ARCH_HI3520DV500
+#include "phy-hi3521dv200-sata.c"
+#endif
+
+static int hisi_sata_phy_init(struct phy *phy)
+{
+	unsigned int sata_port_num = 0;
+	void __iomem *mmio = phy_get_drvdata(phy);
+
+	sata_port_num = hisi_sata_get_port_info();
+	if ((sata_port_num < 1)) {
+		pr_err("sata ports number:%d WRONG!!!\n", sata_port_num);
+		return -EINVAL;
+	}
+	ports_num = sata_port_num;
+
+	hisi_sata_poweron();
+	hisi_sata_reset();
+	hisi_sata_phy_reset();
+	hisi_sata_phy_clk_sel();
+	hisi_sata_clk_enable();
+	msleep(20);
+	hisi_sata_phy_unreset();
+	msleep(20);
+	hisi_sata_unreset();
+	msleep(20);
+	hisi_sata_phy_config(mmio, phy_mode);
+
+	return 0;
+}
+
+static int hisi_sata_phy_exit(struct phy *phy)
+{
+	hisi_sata_phy_reset();
+	msleep(20);
+	hisi_sata_reset();
+	msleep(20);
+	hisi_sata_clk_reset();
+	msleep(20);
+	hisi_sata_clk_disable();
+	hisi_sata_poweroff();
+	msleep(20);
+
+	return 0;
+}
+
+static struct phy_ops hisi_sata_phy_ops = {
+	.init		= hisi_sata_phy_init,
+	.exit		= hisi_sata_phy_exit,
+	.owner		= THIS_MODULE,
+};
+
+static int hisi_sata_phy_probe(struct platform_device *pdev)
+{
+	struct phy_provider *phy_provider = NULL;
+	struct device *dev = &pdev->dev;
+	struct resource *res = NULL;
+	struct phy *phy = NULL;
+	void __iomem *mmio = NULL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get reg base\n");
+		return -ENOENT;
+	}
+
+	mmio = devm_ioremap(dev, res->start, resource_size(res));
+	if (!mmio)
+		return -ENOMEM;
+
+	phy = devm_phy_create(dev, NULL, &hisi_sata_phy_ops);
+	if (IS_ERR(phy)) {
+		dev_err(dev, "failed to create PHY\n");
+		return PTR_ERR(phy);
+	}
+
+	of_property_read_u32(dev->of_node, "ports_num_max", &ports_num);
+
+	phy_set_drvdata(phy, mmio);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider))
+		return PTR_ERR(phy_provider);
+
+	return 0;
+}
+
+static int hisi_sata_phy_suspend(struct platform_device *pdev,
+				 pm_message_t state)
+{
+	struct device *dev = &pdev->dev;
+	struct phy *phy = to_phy(dev);
+
+	hisi_sata_phy_exit(phy);
+
+	return 0;
+}
+
+static int hisi_sata_phy_resume(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phy *phy = to_phy(dev);
+
+	hisi_sata_phy_init(phy);
+
+	return 0;
+}
+
+static const struct of_device_id hisi_sata_phy_of_match[] = {
+	{ .compatible = "hisilicon,hisi-sata-phy", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, hisi_sata_phy_of_match);
+
+static struct platform_driver hisi_sata_phy_driver = {
+	.probe	= hisi_sata_phy_probe,
+	.suspend = hisi_sata_phy_suspend,
+	.resume  = hisi_sata_phy_resume,
+	.driver = {
+		.name	= "hisi-sata-phy",
+		.of_match_table	= hisi_sata_phy_of_match,
+	}
+};
+module_platform_driver(hisi_sata_phy_driver);
+
+MODULE_AUTHOR("HiSilicon BVT");
+MODULE_DESCRIPTION("HISILICON SATA PHY driver");
+MODULE_ALIAS("platform:hisi-sata-phy");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/hibvt/phy-hisi-sata.h b/drivers/phy/hibvt/phy-hisi-sata.h
new file mode 100644
index 000000000..44730c519
--- /dev/null
+++ b/drivers/phy/hibvt/phy-hisi-sata.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+enum {
+	/* hisi extended global controller registers */
+	PHY_CTL0    = 0xA0,
+	PHY_CTL1    = 0xA4,
+	PHY_RST_BACK_MASK	= 0xAC,
+	PHY_CTL2	= 0xB0,
+
+#define PHY_DATA_INVERT     (0x1 << 3)
+#define PHY0_RST_MASK		(0x1 << 4)
+#define PHY_RST_MASK_ALL	(0xF << 4)
+
+	/* hisi extended registers for each SATA port */
+	PORT_FIFOTH		= 0x44,
+	PORT_FIFOTH2	= 0x7C,
+	PORT_PHYCTL1    = 0x48,
+	PORT_PHYCTL     = 0x74,
+
+#define PHY_MODE_1_5G   0
+#define PHY_MODE_3G     1
+#define PHY_MODE_6G     2
+};
diff --git a/drivers/phy/hibvt/usb/Kconfig b/drivers/phy/hibvt/usb/Kconfig
new file mode 100644
index 000000000..c7b5ab6e7
--- /dev/null
+++ b/drivers/phy/hibvt/usb/Kconfig
@@ -0,0 +1,85 @@
+#
+# Phy drivers for Hisilicon platforms
+#
+config PHY_HISI_USB2
+	bool
+	depends on (!ARCH_HI3559AV100 && !ARCH_HI3569V100 && !ARCH_HI3516EV200 && \
+		!ARCH_HI3516EV300 && !ARCH_HI3518EV300 && !ARCH_HI3516DV200)
+	default y
+	help
+	  Support for PHY on Hisilicon Socs. This Phy supports
+	  USB 1.5Mb/s, USB 12Mb/s, USB 480Mb/s speeds. It suppots one
+	  USB host port to accept one USB device. Support init the phy
+	  and adjust phy Eye Diagram.
+
+config PHY_HISI_USB3
+	bool
+	depends on (ARCH_HI3519AV100 || ARCH_HI3556AV100 || ARCH_HI3559AV100 || \
+		ARCH_HI3569V100 || ARCH_HI3568V100 || ARCH_HI3531DV200 || \
+		ARCH_HI3535AV100)
+	default y
+	help
+	  Support for PHY on Hisilicon Socs. This Phy supports
+	  USB3.0 and Compatible with USB2.0. It suppots one
+	  USB host port to accept one USB device. Support init the phy
+	  and adjust phy Eye Diagram.
+
+config HIBVT_USB_PHY
+	bool "Hisilicon USB PHY driver"
+	depends on (!ARCH_HI3516EV200 && !ARCH_HI3516EV300 && !ARCH_HI3518EV300 && \
+		!ARCH_HI3516DV200)
+	default y
+	help
+	  Support for PHY on Hisilicon Socs. This Phy supports
+	  USB 1.5Mb/s, USB 12Mb/s, USB 480Mb/s speeds. It suppots one
+	  USB host port to accept one USB device. Support init the phy
+	  and adjust phy Eye Diagram.
+
+config PHY_HISI_XVP_USB2
+	tristate "Hisilicon XVP USB2 PHY Driver"
+	depends on (ARCH_HI3516EV200 || ARCH_HI3516EV300 || ARCH_HI3518EV300 || \
+		ARCH_HI3516DV200)
+	select GENERIC_PHY
+	default y
+	help
+	  Support for PHY on Hisilicon Socs. This Phy supports
+	  USB 1.5Mb/s, USB 12Mb/s, USB 480Mb/s speeds. It suppots one
+	  USB host port to accept one USB device. Support init the phy
+	  and adjust phy Eye Diagram.
+
+menuconfig USB_MODE_OPTION
+	bool "Hisilicon USB related configuration"
+	depends on (!ARCH_HI3516EV200 && !ARCH_HI3516EV300 && !ARCH_HI3518EV300 && \
+		!ARCH_HI3516DV200 && !ARCH_HI3531DV200 && !ARCH_HI3535AV100 &&	\
+		!ARCH_HI3521DV200 && !ARCH_HI3520DV500)
+
+if USB_MODE_OPTION
+
+config USB_DRD0_IN_HOST
+	bool "USB DRD0 Mode Select HOST"
+	help
+	  Select whether the USB drd0 is working in host mode.
+
+config USB_DRD0_IN_DEVICE
+	bool "USB DRD0 Mode Select DEVICE"
+	depends on (!ARCH_HI3531DV200 && !ARCH_HI3535AV100 && !ARCH_HI3521DV200 && \
+		!ARCH_HI3520DV500)
+	help
+	  Select whether the USB drd0 is working in device mode.
+
+config USB_DRD1_IN_HOST
+	bool "USB DRD1 Mode Select HOST"
+	depends on (ARCH_HI3519AV100 || ARCH_HI3556AV100 || ARCH_HI3559AV100 ||	\
+		ARCH_HI3569V100 || ARCH_HI3568V100)
+	help
+	  Select whether the USB drd1 is working in host mode.
+
+config USB_DRD1_IN_DEVICE
+	bool "USB DRD1 Mode Select DEVICE"
+	depends on (!USB_DRD1_IN_HOST && !USB_DRD0_IN_DEVICE)
+	depends on (ARCH_HI3519AV100 || ARCH_HI3556AV100 || ARCH_HI3559AV100 || \
+		ARCH_HI3569V100 || ARCH_HI3568V100)
+	help
+	  Select whether the USB drd1 is working in device mode.
+
+endif # USB_MODE_OPTION
diff --git a/drivers/phy/hibvt/usb/Makefile b/drivers/phy/hibvt/usb/Makefile
new file mode 100644
index 000000000..dc9e8d71f
--- /dev/null
+++ b/drivers/phy/hibvt/usb/Makefile
@@ -0,0 +1,17 @@
+obj-$(CONFIG_HIBVT_USB_PHY)		    += phy-hisi-usb.o
+obj-$(CONFIG_ARCH_HI3531DV200)		+= phy-hi3531dv200-usb.o
+obj-$(CONFIG_ARCH_HI3535AV100)		+= phy-hi3531dv200-usb.o
+obj-$(CONFIG_ARCH_HI3521DV200)		+= phy-hi3521dv200-usb.o
+obj-$(CONFIG_ARCH_HI3520DV500)		+= phy-hi3521dv200-usb.o
+obj-$(CONFIG_ARCH_HI3559AV100)			+= phy-hi3559av100-usb.o
+obj-$(CONFIG_ARCH_HI3569V100)			+= phy-hi3559av100-usb.o
+obj-$(CONFIG_ARCH_HI3556AV100)			+= phy-hi3556av100-usb.o
+obj-$(CONFIG_ARCH_HI3519AV100)			+= phy-hi3519av100-usb.o
+obj-$(CONFIG_ARCH_HI3568V100)			+= phy-hi3519av100-usb.o
+obj-$(CONFIG_ARCH_HI3516CV500)			+= phy-hi3516cv500-usb.o
+obj-$(CONFIG_ARCH_HI3516DV300)			+= phy-hi3516dv300-usb.o
+obj-$(CONFIG_ARCH_HI3559V200)			+= phy-hi3559v200-usb.o
+obj-$(CONFIG_ARCH_HI3562V100)			+= phy-hi3559v200-usb.o
+obj-$(CONFIG_ARCH_HI3566V100)			+= phy-hi3559v200-usb.o
+obj-$(CONFIG_ARCH_HI3556V200)			+= phy-hi3556v200-usb.o
+obj-$(CONFIG_PHY_HISI_XVP_USB2)		+= phy-hixvp-hisi-usb.o
diff --git a/drivers/phy/hibvt/usb/phy-hi3516dv300-usb.c b/drivers/phy/hibvt/usb/phy-hi3516dv300-usb.c
new file mode 100644
index 000000000..ba232b259
--- /dev/null
+++ b/drivers/phy/hibvt/usb/phy-hi3516dv300-usb.c
@@ -0,0 +1,310 @@
+/*
+ * phy-hi3516dv300-usb.c
+ *
+ * USB phy driver.
+ *
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2018-2019. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/delay.h>
+#include <linux/of_address.h>
+#include <linux/phy/phy.h>
+#include <linux/usb/ch9.h>
+
+#include "phy-hisi-usb.h"
+
+#define CRG_BASE_REG           0x140
+#define USB2_UTMI_PCTRL        (0x1 << 15)
+#define USB2_PHY_TEST_SRST_REQ (0x1 << 14)
+#define USB2_UTMI_CKSEL        (0x1 << 13)
+#define USB2_UTMI_CKEN         (0x1 << 12)
+#define USB2_REF_CKEN          (0x1 << 9)
+#define USB2_BUS_CKEN          (0x1 << 8)
+#define USB2_VCC_SRST_REQ      (0x1 << 3)
+#define USB2_PHY_CKEN          (0x1 << 2)
+#define USB2_PHY_PORT_TREQ     (0x1 << 1)
+#define USB2_PHY_REQ           (0x1 << 0)
+
+#define CTRL_BASE_REG 0x100e0000
+
+#define REG_GUSB3PIPECTL0    0xc2c0
+#define PCS_SSP_SOFT_RESET   (0x1 << 31)
+#define PORT_DISABLE_SUSPEND (0x1 << 17)
+
+#define REG_GCTL      0xc110
+#define PORT_CAP_DIR  (0x3 << 12)
+#define PORT_SET_HOST (0x1 << 12)
+
+#define GTXTHRCFG       0xc108
+#define USB2_G_TXTHRCFG 0x23100000
+
+#define GRXTHRCFG       0xc10c
+#define USB2_G_RXTHRCFG 0x23100000
+
+#define REG_GUCTL1            0xc11c
+#define PARKMODE_DISABLE_FSLS (0x1 << 15)
+#define PARKMODE_DISABLE_HS   (0x1 << 16)
+#define PARKMODE_DISABLE_SS   (0x1 << 17)
+
+#define USB2_INNO_PHY_BASE_REG  0x10110000
+#define USB2_PHY_CLK_OUTPUT_REG 0x18
+#define USB2_PHY_CLK_OUTPUT_VAL 0x0c
+#define USB2_INNO_TRIM_OFFSET   0x0c
+
+#define USB2_VBUS_IO_BASE_REG 0x10ff0000
+#define USB2_VBUS_IO_OFFSET   0x40
+#define USB2_VBUS_IO_VAL      0x431
+
+#define USB_TRIM_BASE_REG    0x100a0000
+#define USB_TRIM_OFFSET      0x38
+#define USB_INNO_TRIM_MASK   0x7c
+#define USB_INNO_TRIM_VAL(a) (((a) << 2) & USB_INNO_TRIM_MASK)
+#define USB_TRIM_VAL_MASK    0x1f
+#define USB_TRIM_VAL_MIN     0xf
+#define USB_TRIM_VAL_MAX     0x1c
+
+#define HS_HIGH_HEIGHT_TUNING_OFFSET 0x8
+#define HS_HIGH_HEIGHT_TUNING_MASK   (0x7 << 4)
+#define HS_HIGH_HEIGHT_TUNING_VAL    0x5 << 4
+
+#define PRE_EMPHASIS_TUNING_OFFSET 0x0
+#define PRE_EMPHASIS_TUNING_MASK   (0x7 << 0)
+#define PRE_EMPHASIS_TUNING_VAL    0x7 << 0
+
+#define PRE_EMPHASIS_STRENGTH_OFFSET 0x14
+#define PRE_EMPHASIS_STRENGTH_MASK   (0x7 << 2)
+#define PRE_EMPHASIS_STRENGTH_VAL    0x3 << 2
+
+#define HS_SLEW_RATE_TUNING_OFFSET 0x74
+#define HS_SLEW_RATE_TUNING_MASK   (0x7 << 1)
+#define HS_SLEW_RATE_TUNING_VAL    0x7 << 1
+
+#define DISCONNECT_TRIGGER_OFFSET 0x10
+#define DISCONNECT_TRIGGER_MASK   (0xf << 4)
+#define DISCONNECT_TRIGGER_VAL    0xd << 4
+
+static void usb_vbus_multi_gpio(void)
+{
+	void __iomem *vbus = ioremap(USB2_VBUS_IO_BASE_REG, __1K__);
+	if (vbus == NULL)
+		return;
+
+	writel(USB2_VBUS_IO_VAL, vbus + USB2_VBUS_IO_OFFSET);
+	udelay(U_LEVEL2);
+
+	iounmap(vbus);
+}
+
+static void usb_trim_c(void)
+{
+	unsigned int reg;
+	unsigned int trim_val;
+	void __iomem *inno_clk_output = NULL;
+	void __iomem *usb_trim = NULL;
+
+	inno_clk_output = ioremap(USB2_INNO_PHY_BASE_REG, __1K__);
+	if (inno_clk_output == NULL)
+		return;
+
+	usb_trim = ioremap(USB_TRIM_BASE_REG, __1K__);
+	if (usb_trim == NULL)
+		goto free;
+
+	/* set inno phy output clock */
+	writel(USB2_PHY_CLK_OUTPUT_VAL, inno_clk_output + USB2_PHY_CLK_OUTPUT_REG);
+	udelay(U_LEVEL2);
+
+	/*
+	 * USB Trim config:45ohm HS ODT value tuning & FS/LS
+	 * driver strength tuning, adapt it to usb trim val.
+	 */
+	trim_val = readl(usb_trim + USB_TRIM_OFFSET);
+	trim_val &= USB_TRIM_VAL_MASK;
+	if ((trim_val >= USB_TRIM_VAL_MIN) && (trim_val <= USB_TRIM_VAL_MAX)) {
+		reg = readl(inno_clk_output + USB2_INNO_TRIM_OFFSET);
+		udelay(U_LEVEL2);
+		reg &= ~USB_INNO_TRIM_MASK;
+		reg |= USB_INNO_TRIM_VAL(trim_val);
+		writel(reg, inno_clk_output + USB2_INNO_TRIM_OFFSET);
+		udelay(U_LEVEL2);
+	}
+
+	iounmap(usb_trim);
+free:
+	iounmap(inno_clk_output);
+	return;
+}
+
+static void usb_crg_c(struct phy *phy)
+{
+	unsigned int reg;
+	struct hisi_priv *priv = phy_get_drvdata(phy);
+
+	/* usb phy reset */
+	reg = readl(priv->peri_crg + CRG_BASE_REG);
+	reg |= USB2_PHY_TEST_SRST_REQ;
+	writel(reg, priv->peri_crg + CRG_BASE_REG);
+	udelay(U_LEVEL5);
+
+	/* cancel usb phy srst */
+	reg = readl(priv->peri_crg + CRG_BASE_REG);
+	reg &= ~USB2_PHY_TEST_SRST_REQ;
+	writel(reg, priv->peri_crg + CRG_BASE_REG);
+	udelay(U_LEVEL2);
+
+	/* usb2 vcc reset */
+	reg = readl(priv->peri_crg + CRG_BASE_REG);
+	reg |= USB2_VCC_SRST_REQ;
+	writel(reg, priv->peri_crg + CRG_BASE_REG);
+	udelay(U_LEVEL6);
+
+	usb_trim_c();
+
+	/* open phy ref cken, utmi pctrl and utmi cksel */
+	reg = readl(priv->peri_crg + CRG_BASE_REG);
+	reg |= USB2_PHY_CKEN;
+	reg &= ~USB2_UTMI_PCTRL;
+	reg &= ~USB2_UTMI_CKSEL;
+	writel(reg, priv->peri_crg + CRG_BASE_REG);
+	udelay(U_LEVEL1);
+
+	/* open utmi cken and controller ref cken */
+	reg = readl(priv->peri_crg + CRG_BASE_REG);
+	reg |= USB2_UTMI_CKEN;
+	reg |= USB2_REF_CKEN;
+	writel(reg, priv->peri_crg + CRG_BASE_REG);
+	udelay(U_LEVEL1);
+
+	/* open bus cken */
+	reg = readl(priv->peri_crg + CRG_BASE_REG);
+	reg |= USB2_BUS_CKEN;
+	writel(reg, priv->peri_crg + CRG_BASE_REG);
+	udelay(U_LEVEL6);
+
+	/* cancel POR reset, TPOR reset and vcc reset */
+	reg = readl(priv->peri_crg + CRG_BASE_REG);
+	reg &= ~USB2_PHY_REQ;
+	reg &= ~USB2_PHY_PORT_TREQ;
+	reg &= ~USB2_VCC_SRST_REQ;
+	writel(reg, priv->peri_crg + CRG_BASE_REG);
+	udelay(U_LEVEL6);
+}
+
+static void usb_ctrl_c(struct phy *phy)
+{
+	unsigned int reg;
+	struct hisi_priv *priv = phy_get_drvdata(phy);
+
+	priv->ctrl_base = ioremap(CTRL_BASE_REG, __64K__);
+	if (priv->ctrl_base == NULL)
+		return;
+
+	reg = readl(priv->ctrl_base + REG_GUCTL1);
+	reg |= PARKMODE_DISABLE_FSLS;
+	reg |= PARKMODE_DISABLE_HS;
+	reg |= PARKMODE_DISABLE_SS;
+	writel(reg, priv->ctrl_base + REG_GUCTL1);
+	udelay(U_LEVEL2);
+
+	reg = readl(priv->ctrl_base + REG_GUSB3PIPECTL0);
+	reg |= PCS_SSP_SOFT_RESET;
+	writel(reg, priv->ctrl_base + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	reg = readl(priv->ctrl_base + REG_GCTL);
+	reg &= ~PORT_CAP_DIR;
+	reg |= PORT_SET_HOST; /* [13:12] 01: Host; 10: Device; 11: OTG */
+	writel(reg, priv->ctrl_base + REG_GCTL);
+	udelay(U_LEVEL2);
+
+	reg = readl(priv->ctrl_base + REG_GUSB3PIPECTL0);
+	reg &= ~PCS_SSP_SOFT_RESET;
+	reg &= ~PORT_DISABLE_SUSPEND;  /* disable suspend */
+	writel(reg, priv->ctrl_base + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	writel(USB2_G_TXTHRCFG, priv->ctrl_base + GTXTHRCFG);
+	writel(USB2_G_RXTHRCFG, priv->ctrl_base + GRXTHRCFG);
+	udelay(U_LEVEL2);
+
+	iounmap(priv->ctrl_base);
+}
+
+static void usb_eye_c(struct phy *phy)
+{
+	unsigned int reg;
+	void __iomem *inno_base = NULL;
+
+	inno_base = ioremap(USB2_INNO_PHY_BASE_REG, __1K__);
+	if (inno_base == NULL)
+		return;
+
+	/* HS eye height tuning */
+	reg = readl(inno_base + HS_HIGH_HEIGHT_TUNING_OFFSET);
+	reg &= ~HS_HIGH_HEIGHT_TUNING_MASK;
+	reg |= HS_HIGH_HEIGHT_TUNING_VAL;
+	writel(reg, inno_base + HS_HIGH_HEIGHT_TUNING_OFFSET);
+
+	/* Pre-emphasis tuning */
+	reg = readl(inno_base + PRE_EMPHASIS_TUNING_OFFSET);
+	reg &= ~PRE_EMPHASIS_TUNING_MASK;
+	reg |= PRE_EMPHASIS_TUNING_VAL;
+	writel(reg, inno_base + PRE_EMPHASIS_TUNING_OFFSET);
+
+	/* Pre-emphasis strength */
+	reg = readl(inno_base + PRE_EMPHASIS_STRENGTH_OFFSET);
+	reg &= ~PRE_EMPHASIS_STRENGTH_MASK;
+	reg |= PRE_EMPHASIS_STRENGTH_VAL;
+	writel(reg, inno_base + PRE_EMPHASIS_STRENGTH_OFFSET);
+
+	/* HS driver slew rate tunning */
+	reg = readl(inno_base + HS_SLEW_RATE_TUNING_OFFSET);
+	reg &= ~HS_SLEW_RATE_TUNING_MASK;
+	reg |= HS_SLEW_RATE_TUNING_VAL;
+	writel(reg, inno_base + HS_SLEW_RATE_TUNING_OFFSET);
+
+	/* HOST disconnects detection trigger point */
+	reg = readl(inno_base + DISCONNECT_TRIGGER_OFFSET);
+	reg &= ~DISCONNECT_TRIGGER_MASK;
+	reg |= DISCONNECT_TRIGGER_VAL;
+	writel(reg, inno_base + DISCONNECT_TRIGGER_OFFSET);
+	iounmap(inno_base);
+}
+
+void hisi_usb_phy_on(struct phy *phy)
+{
+	usb_crg_c(phy);
+
+	usb_vbus_multi_gpio();
+
+	usb_eye_c(phy);
+
+	usb_ctrl_c(phy);
+}
+EXPORT_SYMBOL(hisi_usb_phy_on);
+
+void hisi_usb_phy_off(struct phy *phy)
+{
+	unsigned int reg;
+	struct hisi_priv *priv = phy_get_drvdata(phy);
+
+	/* usb2 vcc reset */
+	reg = readl(priv->peri_crg + CRG_BASE_REG);
+	reg |= USB2_VCC_SRST_REQ;
+	writel(reg, priv->peri_crg + CRG_BASE_REG);
+	udelay(U_LEVEL6);
+}
+EXPORT_SYMBOL(hisi_usb_phy_off);
diff --git a/drivers/phy/hibvt/usb/phy-hisi-usb.c b/drivers/phy/hibvt/usb/phy-hisi-usb.c
new file mode 100644
index 000000000..da83abdf9
--- /dev/null
+++ b/drivers/phy/hibvt/usb/phy-hisi-usb.c
@@ -0,0 +1,149 @@
+/*
+ * phy-hisi-usb.c
+ *
+ * USB phy driver.
+ *
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2019. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+
+#include "phy-hisi-usb.h"
+
+static int hisi_usb_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phy *phy = NULL;
+	struct hisi_priv *priv = NULL;
+	struct device_node *np = pdev->dev.of_node;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	phy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);
+	if (phy == NULL) {
+		devm_kfree(dev, priv);
+		return -ENOMEM;
+	}
+
+	priv->peri_crg = of_iomap(np, CRG_NODE_IDX);
+	if (IS_ERR(priv->peri_crg))
+		priv->peri_crg = NULL;
+
+	priv->misc_ctrl = of_iomap(np, MISC_NODE_IDX);
+	if (IS_ERR(priv->misc_ctrl))
+		priv->misc_ctrl = NULL;
+
+	priv->sys_ctrl = of_iomap(np, SYS_NODE_IDX);
+	if (IS_ERR(priv->sys_ctrl))
+		priv->sys_ctrl = NULL;
+
+	priv->ctrl_base = of_iomap(np, CTRL_NODE_IDX);
+	if (IS_ERR(priv->ctrl_base))
+		priv->ctrl_base = NULL;
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3569V100)
+	if (of_property_read_u32(np, "phyid", &priv->phyid))
+		return -EINVAL;
+#endif
+	platform_set_drvdata(pdev, phy);
+	phy_set_drvdata(phy, priv);
+
+#ifdef CONFIG_PHY_HISI_USB2
+	hisi_usb_phy_on(phy);
+#endif
+#ifdef CONFIG_PHY_HISI_USB3
+	hisi_usb3_phy_on(phy);
+#endif
+	iounmap(priv->peri_crg);
+	iounmap(priv->misc_ctrl);
+	iounmap(priv->sys_ctrl);
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3569V100)
+	iounmap(priv->ctrl_base);
+#endif
+
+	return 0;
+}
+
+static int hisi_usb_phy_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phy *phy = dev_get_drvdata(&pdev->dev);
+	struct hisi_priv *priv = phy_get_drvdata(phy);
+
+#ifdef CONFIG_PHY_HISI_USB2
+	hisi_usb_phy_off(phy);
+#endif
+#ifdef CONFIG_PHY_HISI_USB3
+	hisi_usb3_phy_off(phy);
+#endif
+	devm_kfree(dev, priv);
+	devm_kfree(dev, phy);
+
+	return 0;
+}
+
+static const struct of_device_id hisi_usb_phy_of_match[] = {
+	{ .compatible = "hisilicon,hisi-usb-phy", },
+	{ .compatible = "hisilicon,hisi-usb3-phy_0", },
+	{ .compatible = "hisilicon,hisi-usb3-phy_1", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, hisi_usb_phy_of_match);
+
+#ifdef CONFIG_PM_SLEEP
+static int hisi_usb_phy_suspend(struct device *dev)
+{
+	struct phy *phy = dev_get_drvdata(dev);
+#ifdef CONFIG_PHY_HISI_USB2
+	hisi_usb_phy_off(phy);
+#endif
+#ifdef CONFIG_PHY_HISI_USB3
+	hisi_usb3_phy_off(phy);
+#endif
+	return 0;
+}
+
+static int hisi_usb_phy_resume(struct device *dev)
+{
+	struct phy *phy = dev_get_drvdata(dev);
+#ifdef CONFIG_PHY_HISI_USB2
+	hisi_usb_phy_on(phy);
+#endif
+#ifdef CONFIG_PHY_HISI_USB3
+	hisi_usb3_phy_on(phy);
+#endif
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(hisi_usb_pm_ops, hisi_usb_phy_suspend,
+			 hisi_usb_phy_resume);
+
+static struct platform_driver hisi_usb_phy_driver = {
+	.probe	= hisi_usb_phy_probe,
+	.remove = hisi_usb_phy_remove,
+	.driver = {
+		.name	= "hisi-usb-phy",
+		.pm	= &hisi_usb_pm_ops,
+		.of_match_table	= hisi_usb_phy_of_match,
+	}
+};
+module_platform_driver(hisi_usb_phy_driver);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/hibvt/usb/phy-hisi-usb.h b/drivers/phy/hibvt/usb/phy-hisi-usb.h
new file mode 100644
index 000000000..5e20e6e4a
--- /dev/null
+++ b/drivers/phy/hibvt/usb/phy-hisi-usb.h
@@ -0,0 +1,72 @@
+/*
+ * phy-hisi-usb.h
+ *
+ * USB phy driver headerfile.
+ *
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2019. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef USB2_INCLUDE_PHY_H
+#define USB2_INCLUDE_PHY_H
+
+extern void hisi_usb_phy_on(struct phy *phy);
+extern void hisi_usb_phy_off(struct phy *phy);
+extern void hisi_usb3_phy_on(struct phy *phy);
+extern void hisi_usb3_phy_off(struct phy *phy);
+
+struct hisi_priv {
+	void __iomem    *peri_crg;
+	void __iomem	*misc_ctrl;
+	void __iomem	*sys_ctrl;
+	void __iomem	*ctrl_base;
+	unsigned int	phyid;
+};
+
+typedef enum mode {
+	PCIE_X2 = 0,
+	PCIE_X1,
+	USB3
+} combphy_mode;
+
+#define U_LEVEL1 10
+#define U_LEVEL2 20
+#define U_LEVEL3 30
+#define U_LEVEL4 50
+#define U_LEVEL5 100
+#define U_LEVEL6 200
+#define U_LEVEL7 300
+#define U_LEVEL8 500
+
+#define M_LEVEL1 2
+#define M_LEVEL2 5
+#define M_LEVEL3 10
+#define M_LEVEL4 20
+#define M_LEVEL5 50
+#define M_LEVEL6 100
+#define M_LEVEL7 200
+
+#define __1K__  0x400
+#define __2K__  0x800
+#define __4K__  0x1000
+#define __8K__  0x2000
+#define __64K__ 0x10000
+
+#define CRG_NODE_IDX    0
+#define MISC_NODE_IDX   1
+#define SYS_NODE_IDX    2
+#define CTRL_NODE_IDX   3
+
+#endif /* USB2_INCLUDE_PHY_H */
diff --git a/drivers/phy/hibvt/usb/phy-hixvp-hisi-usb.c b/drivers/phy/hibvt/usb/phy-hixvp-hisi-usb.c
new file mode 100644
index 000000000..be6831947
--- /dev/null
+++ b/drivers/phy/hibvt/usb/phy-hixvp-hisi-usb.c
@@ -0,0 +1,803 @@
+/*
+ * phy-hixvp-hisi-usb.c
+ *
+ * USB phy driver.
+ *
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2019. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/usb/ch9.h>
+
+#include "phy-hisi-usb.h"
+
+#define HIXVP_PHY_TRIM_OFFSET 0x0008
+#define HIXVP_PHY_TRIM_MASK   0x1f00
+#define HIXVP_PHY_TRIM_VAL(a) (((a) << 8) & HIXVP_PHY_TRIM_MASK)
+
+#define HIXVP_PHY_SVB_OFFSET 0x0000
+#define HIXVP_PHY_SVB_MASK   0x0f000000
+#define HIXVP_PHY_SVB_VAL(a) (((a) << 24) & HIXVP_PHY_SVB_MASK)
+
+struct hisi_hixvp_priv {
+	void __iomem *crg_base;
+	void __iomem *phy_base;
+	void __iomem *pin_base;
+	struct phy *phy;
+	struct device *dev;
+	struct clk **clks;
+	int num_clocks;
+	u32 phy_pll_offset;
+	u32 phy_pll_mask;
+	u32 phy_pll_val;
+	u32 crg_offset;
+	u32 crg_defal_mask;
+	u32 crg_defal_val;
+	u32 vbus_offset;
+	u32 vbus_val;
+	int vbus_flag;
+	u32 pwren_offset;
+	u32 pwren_val;
+	int pwren_flag;
+	u32 ana_cfg_0_eye_val;
+	u32 ana_cfg_0_offset;
+	int ana_cfg_0_flag;
+	u32 ana_cfg_2_eye_val;
+	u32 ana_cfg_2_offset;
+	int ana_cfg_2_flag;
+	u32 ana_cfg_4_eye_val;
+	u32 ana_cfg_4_offset;
+	int ana_cfg_4_flag;
+	struct reset_control *usb_phy_tpor_rst;
+	struct reset_control *usb_phy_por_rst;
+	u32 trim_otp_addr;
+	u32 trim_otp_mask;
+	u32 trim_otp_bit_offset;
+	u32 trim_otp_min;
+	u32 trim_otp_max;
+	int trim_flag;
+	u32 svb_otp_addr;
+	u32 svb_otp_predev5_min;
+	u32 svb_otp_predev5_max;
+	u32 svb_phy_predev5_val;
+	int svb_predev5_flag;
+	u32 svb_otp_predev4_min;
+	u32 svb_otp_predev4_max;
+	u32 svb_phy_predev4_val;
+	int svb_predev4_flag;
+	u32 svb_otp_predev3_min;
+	u32 svb_otp_predev3_max;
+	u32 svb_phy_predev3_val;
+	int svb_predev3_flag;
+	u32 svb_otp_predev2_min;
+	u32 svb_otp_predev2_max;
+	u32 svb_phy_predev2_val;
+	int svb_predev2_flag;
+	int svb_flag;
+};
+
+void hisi_usb_hixvp_def_all_exist(struct hisi_hixvp_priv *priv)
+{
+	if (priv == NULL)
+		return;
+
+	/* All parameters exist by default */
+	priv->vbus_flag = 1;
+
+	priv->pwren_flag = 1;
+
+	priv->ana_cfg_0_flag = 1;
+
+	priv->ana_cfg_2_flag = 1;
+
+	priv->ana_cfg_4_flag = 1;
+
+	priv->trim_flag = 1;
+
+	priv->svb_predev5_flag = 1;
+
+	priv->svb_predev4_flag = 1;
+
+	priv->svb_predev3_flag = 1;
+
+	priv->svb_predev2_flag = 1;
+
+	priv->svb_flag = 1;
+}
+
+void hisi_usb_hixvp_get_eye_para(const struct device *dev,
+    struct hisi_hixvp_priv *priv)
+{
+	int ret;
+
+	if ((dev == NULL) || (priv == NULL))
+		return;
+
+	if (dev->of_node == NULL)
+		return;
+
+	/*
+	 * Get phy eye parameters,if you want to change them,please open
+	 * dtsi file and modify parameters at phy node.
+	 */
+	ret = of_property_read_u32(dev->of_node, "ana_cfg_0_eye_val",
+				   &(priv->ana_cfg_0_eye_val));
+	if (ret)
+		priv->ana_cfg_0_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "ana_cfg_0_offset",
+				   &(priv->ana_cfg_0_offset));
+	if (ret)
+		priv->ana_cfg_0_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "ana_cfg_2_eye_val",
+				   &(priv->ana_cfg_2_eye_val));
+	if (ret)
+		priv->ana_cfg_2_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "ana_cfg_2_offset",
+				   &(priv->ana_cfg_2_offset));
+	if (ret)
+		priv->ana_cfg_2_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "ana_cfg_4_eye_val",
+				   &(priv->ana_cfg_4_eye_val));
+	if (ret)
+		priv->ana_cfg_4_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "ana_cfg_4_offset",
+				   &(priv->ana_cfg_4_offset));
+	if (ret)
+		priv->ana_cfg_4_flag = 0;
+}
+
+void hisi_usb_hixvp_phy_eye_config(const struct hisi_hixvp_priv *priv)
+{
+	if (priv == NULL)
+		return;
+
+	if (priv->ana_cfg_0_flag)
+		writel(priv->ana_cfg_0_eye_val, priv->phy_base + priv->ana_cfg_0_offset);
+
+	if (priv->ana_cfg_2_flag)
+		writel(priv->ana_cfg_2_eye_val, priv->phy_base + priv->ana_cfg_2_offset);
+
+	if (priv->ana_cfg_4_flag)
+		writel(priv->ana_cfg_4_eye_val, priv->phy_base + priv->ana_cfg_4_offset);
+}
+
+void hisi_usb_hixvp_get_trim_para(const struct device *dev,
+    struct hisi_hixvp_priv *priv)
+{
+	int ret;
+
+	if ((dev == NULL) || (priv == NULL))
+		return;
+
+	if (dev->of_node == NULL)
+		return;
+
+	/* get phy trim parameters */
+	ret = of_property_read_u32(dev->of_node, "trim_otp_addr",
+				   &(priv->trim_otp_addr));
+	if (ret)
+		priv->trim_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "trim_otp_mask",
+				   &(priv->trim_otp_mask));
+	if (ret)
+		priv->trim_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "trim_otp_bit_offset",
+				   &(priv->trim_otp_bit_offset));
+	if (ret)
+		priv->trim_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "trim_otp_min", &(priv->trim_otp_min));
+	if (ret)
+		priv->trim_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "trim_otp_max", &(priv->trim_otp_max));
+	if (ret)
+		priv->trim_flag = 0;
+}
+
+void hisi_usb_hixvp_phy_trim_config(const struct hisi_hixvp_priv *priv)
+{
+	unsigned int trim_otp_val;
+	unsigned int reg;
+	void __iomem *phy_trim = NULL;
+
+	if (priv == NULL)
+		return;
+
+	if (priv->trim_flag) {
+		phy_trim = ioremap_nocache(priv->trim_otp_addr, __1K__);
+		if (phy_trim == NULL)
+			return;
+
+		reg = readl(phy_trim);
+		trim_otp_val = (reg & priv->trim_otp_mask);
+		if ((trim_otp_val >= priv->trim_otp_min) &&
+				(trim_otp_val <= priv->trim_otp_max)) {
+			/* set trim value to HiXVPV100 phy */
+			reg = readl(priv->phy_base + HIXVP_PHY_TRIM_OFFSET);
+			reg &= ~HIXVP_PHY_TRIM_MASK;
+			reg |= HIXVP_PHY_TRIM_VAL(trim_otp_val >> priv->trim_otp_bit_offset);
+			writel(reg, priv->phy_base + HIXVP_PHY_TRIM_OFFSET);
+		}
+		iounmap(phy_trim);
+	}
+}
+
+void hisi_usb_hixvp_get_svb_para_1(const struct device *dev,
+    struct hisi_hixvp_priv *priv)
+{
+	int ret;
+
+	if ((dev == NULL) || (priv == NULL))
+		return;
+
+	if (dev->of_node == NULL)
+		return;
+
+	/* get phy svb parmteters */
+	ret = of_property_read_u32(dev->of_node, "svb_otp_addr", &
+				   (priv->svb_otp_addr));
+	if (ret)
+		priv->svb_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_otp_predev5_min",
+				   &(priv->svb_otp_predev5_min));
+	if (ret)
+		priv->svb_predev5_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_otp_predev5_max",
+				   &(priv->svb_otp_predev5_max));
+	if (ret)
+		priv->svb_predev5_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_phy_predev5_val",
+				   &(priv->svb_phy_predev5_val));
+	if (ret)
+		priv->svb_predev5_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_otp_predev4_min",
+				   &(priv->svb_otp_predev4_min));
+	if (ret)
+		priv->svb_predev4_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_otp_predev4_max",
+				   &(priv->svb_otp_predev4_max));
+	if (ret)
+		priv->svb_predev4_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_phy_predev4_val",
+				   &(priv->svb_phy_predev4_val));
+	if (ret)
+		priv->svb_predev4_flag = 0;
+}
+
+void hisi_usb_hixvp_get_svb_para_2(const struct device *dev,
+    struct hisi_hixvp_priv *priv)
+{
+	int ret;
+
+	if ((dev == NULL) || (priv == NULL))
+		return;
+
+	if (dev->of_node == NULL)
+		return;
+
+	ret = of_property_read_u32(dev->of_node, "svb_otp_predev3_min",
+				   &(priv->svb_otp_predev3_min));
+	if (ret)
+		priv->svb_predev3_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_otp_predev3_max",
+				   &(priv->svb_otp_predev3_max));
+	if (ret)
+		priv->svb_predev3_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_phy_predev3_val",
+				   &(priv->svb_phy_predev3_val));
+	if (ret)
+		priv->svb_predev3_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_otp_predev2_min",
+				   &(priv->svb_otp_predev2_min));
+	if (ret)
+		priv->svb_predev2_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_otp_predev2_max",
+				   &(priv->svb_otp_predev2_max));
+	if (ret)
+		priv->svb_predev2_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "svb_phy_predev2_val",
+				   &(priv->svb_phy_predev2_val));
+	if (ret)
+		priv->svb_predev2_flag = 0;
+}
+
+void hisi_usb_hixvp_phy_svb_config(const struct hisi_hixvp_priv *priv)
+{
+	unsigned int reg;
+	unsigned int ret;
+	void __iomem *phy_svb = NULL;
+
+	if (priv == NULL)
+		return;
+
+	if (priv->svb_flag) {
+		phy_svb = ioremap_nocache(priv->svb_otp_addr, __1K__);
+		if (phy_svb == NULL)
+			return;
+
+		ret = readl(phy_svb);
+		reg = readl(priv->phy_base + HIXVP_PHY_SVB_OFFSET);
+		reg &= ~HIXVP_PHY_SVB_MASK;
+		if ((ret >= priv->svb_otp_predev5_min) &&
+				(ret < priv->svb_otp_predev5_max) && (priv->svb_predev5_flag))
+			reg |= HIXVP_PHY_SVB_VAL(priv->svb_phy_predev5_val);
+		else if ((ret >= priv->svb_otp_predev4_min) &&
+				(ret < priv->svb_otp_predev4_max) && (priv->svb_predev4_flag))
+			reg |= HIXVP_PHY_SVB_VAL(priv->svb_phy_predev4_val);
+		else if ((ret >= priv->svb_otp_predev3_min) &&
+				(ret <= priv->svb_otp_predev3_max) && (priv->svb_predev3_flag))
+			reg |= HIXVP_PHY_SVB_VAL(priv->svb_phy_predev3_val);
+		else if ((ret > priv->svb_otp_predev2_min) &&
+				(ret <= priv->svb_otp_predev2_max) && (priv->svb_predev2_flag))
+			reg |= HIXVP_PHY_SVB_VAL(priv->svb_phy_predev2_val);
+		else
+			reg |= HIXVP_PHY_SVB_VAL(priv->svb_phy_predev4_val);
+
+		writel(reg, priv->phy_base + HIXVP_PHY_SVB_OFFSET);
+		iounmap(phy_svb);
+	}
+}
+
+static void hisi_usb_vbus_and_pwren_config(const struct device *dev,
+    struct hisi_hixvp_priv *priv)
+{
+	int ret;
+
+	if ((dev == NULL) || (priv == NULL))
+		return;
+
+	if (dev->of_node == NULL)
+		return;
+
+	/* Some chips do not have VBUS encapsulation and need to be configured */
+	ret = of_property_read_u32(dev->of_node, "vbus_offset", &(priv->vbus_offset));
+	if (ret)
+		priv->vbus_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "vbus_val", &(priv->vbus_val));
+	if (ret)
+		priv->vbus_flag = 0;
+
+	/* Some chips do not have PWREN encapsulation and need to be configured */
+	ret = of_property_read_u32(dev->of_node, "pwren_offset", &(priv->pwren_offset));
+	if (ret)
+		priv->pwren_flag = 0;
+
+	ret = of_property_read_u32(dev->of_node, "pwren_val", &(priv->pwren_val));
+	if (ret)
+		priv->pwren_flag = 0;
+
+	if (priv->vbus_flag)
+		writel(priv->vbus_val, priv->pin_base + priv->vbus_offset);
+
+	udelay(U_LEVEL2);
+
+	if (priv->pwren_flag)
+		writel(priv->pwren_val, priv->pin_base + priv->pwren_offset);
+
+	udelay(U_LEVEL2);
+}
+
+static int hisi_usb_hixvp_get_pll_clk(const struct device *dev,
+    struct hisi_hixvp_priv *priv)
+{
+	int ret;
+
+	if ((dev == NULL) || (priv == NULL))
+		return -EINVAL;
+
+	if (dev->of_node == NULL)
+		return -EINVAL;
+
+	/* Get phy pll clk config parameters from the phy node of the dtsi file */
+	ret = of_property_read_u32(dev->of_node, "phy_pll_offset",
+				   &(priv->phy_pll_offset));
+	if (ret) {
+		dev_err(dev, "get phy_pll_offset failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "phy_pll_mask", &(priv->phy_pll_mask));
+	if (ret) {
+		dev_err(dev, "get phy_pll_mask failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "phy_pll_val", &(priv->phy_pll_val));
+	if (ret) {
+		dev_err(dev, "get phy_pll_val failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hisi_usb_hixvp_set_crg_val(const struct device *dev,
+    struct hisi_hixvp_priv *priv)
+{
+	int ret;
+	unsigned int reg;
+
+	if ((dev == NULL) || (priv == NULL))
+		return -EINVAL;
+
+	if (dev->of_node == NULL)
+		return -EINVAL;
+
+	/* Get CRG default value from the phy node of the dtsi file */
+	ret = of_property_read_u32(dev->of_node, "crg_offset", &(priv->crg_offset));
+	if (ret) {
+		dev_err(dev, "get crg_offset failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "crg_defal_mask",
+				   &(priv->crg_defal_mask));
+	if (ret) {
+		dev_err(dev, "get crg_defal_mask failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "crg_defal_val",
+				   &(priv->crg_defal_val));
+	if (ret) {
+		dev_err(dev, "get crg_defal_val failed: %d\n", ret);
+		return ret;
+	}
+
+	/* write phy crg default value */
+	reg = readl(priv->crg_base + priv->crg_offset);
+	reg &= ~priv->crg_defal_mask;
+	reg |= priv->crg_defal_val;
+	writel(reg, priv->crg_base + priv->crg_offset);
+
+	return 0;
+}
+
+static int hisi_usb_hixvp_phy_get_para(struct device *dev,
+    struct hisi_hixvp_priv *priv)
+{
+	int ret;
+
+	if ((dev == NULL) || (priv == NULL))
+		return -EINVAL;
+
+	hisi_usb_hixvp_def_all_exist(priv);
+
+	ret = hisi_usb_hixvp_get_pll_clk(dev, priv);
+	if (ret) {
+		dev_err(dev, "get pll clk failed: %d\n", ret);
+		return ret;
+	}
+
+	hisi_usb_hixvp_get_trim_para(dev, priv);
+	hisi_usb_hixvp_get_eye_para(dev, priv);
+	hisi_usb_hixvp_get_svb_para_1(dev, priv);
+	hisi_usb_hixvp_get_svb_para_2(dev, priv);
+
+	return 0;
+}
+
+static int hisi_usb_hixvp_phy_get_clks(struct hisi_hixvp_priv *priv, int count)
+{
+	struct device *dev = priv->dev;
+	struct device_node *np = dev->of_node;
+	int i;
+
+	priv->num_clocks = count;
+
+	if (!count)
+		return 0;
+
+	priv->clks =
+		devm_kcalloc(dev, priv->num_clocks, sizeof(struct clk *), GFP_KERNEL);
+	if (priv->clks == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < priv->num_clocks; i++) {
+		struct clk *clk;
+
+		clk = of_clk_get(np, i);
+		if (IS_ERR(clk)) {
+			while (--i >= 0)
+				clk_put(priv->clks[i]);
+
+			devm_kfree(dev, priv->clks);
+			priv->clks = NULL;
+			return PTR_ERR(clk);
+		}
+
+		priv->clks[i] = clk;
+	}
+	return 0;
+}
+
+static int hisi_usb_hixvp_clk_rst_config(struct platform_device *pdev,
+    struct hisi_hixvp_priv *priv)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	ret = hisi_usb_hixvp_phy_get_clks(priv, of_clk_get_parent_count(np));
+	if (ret) {
+		dev_err(dev, "get hixvp phy clk failed\n");
+		return ret;
+	}
+
+	priv->usb_phy_tpor_rst = devm_reset_control_get(dev, "phy_tpor_reset");
+	if (IS_ERR_OR_NULL(priv->usb_phy_tpor_rst)) {
+		dev_err(dev, "get phy_tpor_reset failed: %d\n", ret);
+		return PTR_ERR(priv->usb_phy_tpor_rst);
+	}
+
+	priv->usb_phy_por_rst = devm_reset_control_get(dev, "phy_por_reset");
+	if (IS_ERR_OR_NULL(priv->usb_phy_por_rst)) {
+		dev_err(dev, "get phy_por_reset failed: %d\n", ret);
+		return PTR_ERR(priv->usb_phy_por_rst);
+	}
+
+	return 0;
+}
+
+static int hisi_usb_hixvp_iomap(struct device_node *np,
+				struct hisi_hixvp_priv *priv)
+{
+	if ((np == NULL) || (priv == NULL))
+		return -EINVAL;
+
+	priv->phy_base = of_iomap(np, 0);
+	if (IS_ERR(priv->phy_base))
+		return -ENOMEM;
+
+	priv->crg_base = of_iomap(np, 1);
+	if (IS_ERR(priv->crg_base)) {
+		iounmap(priv->phy_base);
+		return -ENOMEM;
+	}
+
+	priv->pin_base = of_iomap(np, 2);
+	if (IS_ERR(priv->pin_base)) {
+		iounmap(priv->phy_base);
+		iounmap(priv->crg_base);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int hisi_usb_hixvp_phy_init(struct phy *phy)
+{
+	struct hisi_hixvp_priv *priv = phy_get_drvdata(phy);
+	int i, ret;
+	unsigned int reg;
+
+	for (i = 0; i < priv->num_clocks; i++) {
+		ret = clk_prepare_enable(priv->clks[i]);
+		if (ret < 0) {
+			while (--i >= 0) {
+				clk_disable_unprepare(priv->clks[i]);
+				clk_put(priv->clks[i]);
+			}
+		}
+	}
+
+	udelay(U_LEVEL5);
+
+	/* undo por reset */
+	ret = reset_control_deassert(priv->usb_phy_por_rst);
+	if (ret)
+		return ret;
+
+	/* pll out clk */
+	reg = readl(priv->phy_base + priv->phy_pll_offset);
+	reg &= ~priv->phy_pll_mask;
+	reg |= priv->phy_pll_val;
+	writel(reg, priv->phy_base + priv->phy_pll_offset);
+
+	mdelay(M_LEVEL1);
+
+	/* undo tpor reset */
+	ret = reset_control_deassert(priv->usb_phy_tpor_rst);
+	if (ret)
+		return ret;
+
+	udelay(U_LEVEL6);
+
+	hisi_usb_hixvp_phy_eye_config(priv);
+
+	hisi_usb_hixvp_phy_trim_config(priv);
+
+	hisi_usb_hixvp_phy_svb_config(priv);
+	return 0;
+}
+
+static int hisi_usb_hixvp_phy_exit(struct phy *phy)
+{
+	struct hisi_hixvp_priv *priv = phy_get_drvdata(phy);
+	int i, ret;
+
+	for (i = 0; i < priv->num_clocks; i++)
+		clk_disable_unprepare(priv->clks[i]);
+
+	ret = reset_control_assert(priv->usb_phy_por_rst);
+	if (ret)
+		return ret;
+
+	ret = reset_control_assert(priv->usb_phy_tpor_rst);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct phy_ops hisi_usb_hixvp_phy_ops = {
+	.init = hisi_usb_hixvp_phy_init,
+	.exit = hisi_usb_hixvp_phy_exit,
+	.owner = THIS_MODULE,
+};
+
+static int hisi_usb_hixvp_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phy *phy = NULL;
+	struct hisi_hixvp_priv *priv = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	struct phy_provider *phy_provider = NULL;
+	int ret;
+
+	phy = devm_phy_create(dev, dev->of_node, &hisi_usb_hixvp_phy_ops);
+	if (IS_ERR(phy))
+		return PTR_ERR(phy);
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	ret = hisi_usb_hixvp_iomap(np, priv);
+	if (ret) {
+		devm_kfree(dev, priv);
+		priv = NULL;
+
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, priv);
+	priv->dev = dev;
+
+	ret = hisi_usb_hixvp_clk_rst_config(pdev, priv);
+	if (ret)
+		goto xvp_unmap;
+
+	ret = hisi_usb_hixvp_phy_get_para(dev, priv);
+	if (ret)
+		goto xvp_unmap;
+
+	hisi_usb_vbus_and_pwren_config(dev, priv);
+
+	ret = hisi_usb_hixvp_set_crg_val(dev, priv);
+	if (ret)
+		goto xvp_unmap;
+
+	platform_set_drvdata(pdev, priv);
+	phy_set_drvdata(phy, priv);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider)) {
+		ret = PTR_ERR(phy_provider);
+		goto xvp_unmap;
+	}
+
+	return 0;
+xvp_unmap:
+	iounmap(priv->phy_base);
+	iounmap(priv->crg_base);
+	iounmap(priv->pin_base);
+
+	devm_kfree(dev, priv);
+	priv = NULL;
+
+	return ret;
+}
+
+static int hisi_usb_hixvp_phy_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct hisi_hixvp_priv *priv = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < priv->num_clocks; i++)
+		clk_put(priv->clks[i]);
+
+	iounmap(priv->phy_base);
+	iounmap(priv->crg_base);
+	iounmap(priv->pin_base);
+
+	devm_kfree(dev, priv);
+	priv = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int hisi_usb_hixvp_phy_suspend(struct device *dev)
+{
+	struct phy *phy = dev_get_drvdata(dev);
+
+	if (hisi_usb_hixvp_phy_exit(phy))
+		return -1;
+
+	return 0;
+}
+
+static int hisi_usb_hixvp_phy_resume(struct device *dev)
+{
+	struct phy *phy = dev_get_drvdata(dev);
+
+	if (hisi_usb_hixvp_phy_init(phy))
+		return -1;
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(hisi_usb_pm_ops, hisi_usb_hixvp_phy_suspend,
+			 hisi_usb_hixvp_phy_resume);
+
+static const struct of_device_id hisi_usb_hixvp_phy_of_match[] = {
+	{ .compatible = "hisilicon,hixvp-usb2-phy" },
+	{},
+};
+
+static struct platform_driver hisi_usb_hixvp_phy_driver = {
+	.probe = hisi_usb_hixvp_phy_probe,
+	.remove = hisi_usb_hixvp_phy_remove,
+	.driver = {
+		.name = "hisi-usb-hixvp-phy",
+		.pm = &hisi_usb_pm_ops,
+		.of_match_table = hisi_usb_hixvp_phy_of_match,
+	}
+};
+module_platform_driver(hisi_usb_hixvp_phy_driver);
+MODULE_DESCRIPTION("HISILICON USB HIXVP PHY driver");
+MODULE_ALIAS("platform:hisi-usb-hixvp-phy");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/power/reset/Kconfig b/drivers/power/reset/Kconfig
index d55b3727e..6d73fab25 100644
--- a/drivers/power/reset/Kconfig
+++ b/drivers/power/reset/Kconfig
@@ -95,7 +95,7 @@ config POWER_RESET_GPIO_RESTART
 
 config POWER_RESET_HISI
 	bool "Hisilicon power-off driver"
-	depends on ARCH_HISI
+	depends on ARCH_HISI || ARCH_HISI_BVT
 	help
 	  Reboot support for Hisilicon boards.
 
diff --git a/drivers/ras/Kconfig b/drivers/ras/Kconfig
index c2a236f2e..fa3951a03 100644
--- a/drivers/ras/Kconfig
+++ b/drivers/ras/Kconfig
@@ -29,8 +29,8 @@ menuconfig RAS
 	  so have ideal availability, but may be unreliable, with frequent
 	  data corruption.
 
-if RAS
+#if RAS
 
-source "arch/x86/ras/Kconfig"
+#source "arch/x86/ras/Kconfig"
 
-endif
+#endif
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 54cf5ec8f..a1de70bd3 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -944,6 +944,14 @@ comment "Platform RTC drivers"
 # <asm/mc146818rtc.h> defining CMOS_READ/CMOS_WRITE, and a
 # global rtc_lock ... it's not yet just another platform_device.
 
+config RTC_DRV_HIBVT
+	tristate "HiSilicon BVT RTC support"
+	help
+	  Generic RTC framework driver for HiSilicon BVT SoCs.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called rtc-hibvt.
+
 config RTC_DRV_CMOS
 	tristate "PC-style 'CMOS'"
 	depends on X86 || ARM || PPC || MIPS || SPARC64
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index bfb574641..41f5ad4f9 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -18,6 +18,7 @@ rtc-core-$(CONFIG_RTC_INTF_SYSFS)	+= sysfs.o
 
 # Keep the list ordered.
 
+obj-$(CONFIG_RTC_DRV_HIBVT)	+= rtc-hibvt.o
 obj-$(CONFIG_RTC_DRV_88PM80X)	+= rtc-88pm80x.o
 obj-$(CONFIG_RTC_DRV_88PM860X)	+= rtc-88pm860x.o
 obj-$(CONFIG_RTC_DRV_AB3100)	+= rtc-ab3100.o
diff --git a/drivers/rtc/rtc-hibvt.c b/drivers/rtc/rtc-hibvt.c
new file mode 100644
index 000000000..2ad9e970e
--- /dev/null
+++ b/drivers/rtc/rtc-hibvt.c
@@ -0,0 +1,663 @@
+/*
+ * rtc-hibvt.c
+ *
+ * RTC driver for Hisilicon BVT
+ *
+ * Copyright (C) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/bcd.h>
+#include <linux/bitops.h>
+#include <linux/log2.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rtc.h>
+#include <linux/version.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+union u_spi_rw {
+	struct {
+		unsigned int spi_wdata : 8; /* [7:0] */
+		unsigned int spi_rdata : 8; /* [15:8] */
+		unsigned int spi_addr : 7; /* [22:16] */
+		unsigned int spi_rw : 1; /* [23] */
+		unsigned int spi_start : 1; /* [24] */
+		unsigned int reserved : 6; /* [30:25] */
+		unsigned int spi_busy : 1; /* [31] */
+	} bits;
+	unsigned int u32;
+};
+
+struct hibvt_time_str {
+	unsigned char dayl;
+	unsigned char dayh;
+	unsigned char second;
+	unsigned char minute;
+	unsigned char hour;
+};
+
+#define SPI_CLK_DIV 0x000
+#define SPI_RW 0x004
+
+#define SPI_WRITE		0
+#define SPI_READ		1
+
+#if defined(CONFIG_ARCH_HI3531DV200) || defined(CONFIG_ARCH_HI3535AV100) || \
+	defined(CONFIG_ARCH_HI3521DV200) || defined(CONFIG_ARCH_HI3520DV500)
+
+/* RTC REG */
+#define RTC_10MS_COUN		0x00
+#define RTC_S_COUNT		0x04
+#define RTC_M_COUNT		0x08
+#define RTC_H_COUNT		0x0C
+#define RTC_D_COUNT_L		0x10
+#define RTC_D_COUNT_H		0x14
+
+#define RTC_MR_10MS		0x18
+#define RTC_MR_S		0x1C
+#define RTC_MR_M		0x20
+#define RTC_MR_H		0x24
+#define RTC_MR_D_L		0x28
+#define RTC_MR_D_H		0x2C
+
+#define RTC_LR_10MS		0x30
+#define RTC_LR_S		0x34
+#define RTC_LR_M		0x38
+#define RTC_LR_H		0x3C
+#define RTC_LR_D_L		0x40
+#define RTC_LR_D_H		0x44
+
+#define RTC_LORD		0x48
+
+#define RTC_IMSC		0x4C
+#define RTC_INT_CLR		0x50
+#define RTC_INT			0x54
+#define RTC_INT_RAW		0x58
+
+#define RTC_CLK			0x5C
+#define RTC_POR_N		0x60
+#define RTC_SAR_CTRL		0x68
+#define RTC_CLK_CFG		0x6C
+
+#define RTC_FREQ_H		0x144
+#define RTC_FREQ_L		0x148
+
+#define RTC_REG_LOCK1	0x190
+#define RTC_REG_LOCK2	0x194
+#define RTC_REG_LOCK3	0x198
+#define RTC_REG_LOCK4	0x19C
+#endif
+
+#if defined(CONFIG_ARCH_HI3556AV100) || defined(CONFIG_ARCH_HI3519AV100) || \
+    defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  || \
+    defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) || \
+    defined(CONFIG_ARCH_HI3516EV200) || defined(CONFIG_ARCH_HI3516EV300) || \
+    defined(CONFIG_ARCH_HI3518EV300) || defined(CONFIG_ARCH_HI3516DV200) || \
+    defined(CONFIG_ARCH_HI3562V100)  || defined(CONFIG_ARCH_HI3566V100)  || \
+    defined(CONFIG_ARCH_HI3568V100)  || defined(CONFIG_ARCH_HI3559AV100) || \
+	defined(CONFIG_ARCH_HI3559CV100) || defined(CONFIG_ARCH_HI3569V100)
+
+#define SPI_RTC_TYPE
+
+/* RTC REG */
+#define RTC_10MS_COUN	0x00
+#define RTC_S_COUNT		0x01
+#define RTC_M_COUNT		0x02
+#define RTC_H_COUNT		0x03
+#define RTC_D_COUNT_L	0x04
+#define RTC_D_COUNT_H	0x05
+
+#define RTC_MR_10MS		0x06
+#define RTC_MR_S		0x07
+#define RTC_MR_M		0x08
+#define RTC_MR_H		0x09
+#define RTC_MR_D_L		0x0A
+#define RTC_MR_D_H		0x0B
+
+#define RTC_LR_10MS		0x0C
+#define RTC_LR_S		0x0D
+#define RTC_LR_M		0x0E
+#define RTC_LR_H		0x0F
+#define RTC_LR_D_L		0x10
+#define RTC_LR_D_H		0x11
+
+#define RTC_LORD		0x12
+
+#define RTC_IMSC		0x13
+#define RTC_INT_CLR		0x14
+#define RTC_INT			0x15
+#define RTC_INT_RAW		0x16
+
+#define RTC_CLK			0x17
+#define RTC_POR_N		0x18
+#define RTC_SAR_CTRL	0x1A
+#define RTC_CLK_CFG	    0x1B
+
+#define RTC_FREQ_H		0x51
+#define RTC_FREQ_L		0x52
+
+#define RTC_REG_LOCK1	0x64
+#define RTC_REG_LOCK2	0x65
+#define RTC_REG_LOCK3	0x66
+#define RTC_REG_LOCK4	0x67
+#endif
+
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3559CV100) || \
+    defined(CONFIG_ARCH_HI3569V100)
+#define PWR_REG_ADDR	0x180C0000
+#define PWR_REG_LENGTH	0x100
+#endif
+#define FREQ_H_DEFAULT  0x8
+#define FREQ_L_DEFAULT  0x1B
+
+#define LV_CTL_DEFAULT  0x20
+#define CLK_DIV_DEFAULT 0x4
+#define INT_RST_DEFAULT 0x0
+#define INT_MSK_DEFAULT 0x4
+
+#define AIE_INT_MASK       BIT(0)
+#define LV_INT_MASK        BIT(1)
+#define REG_LOAD_STAT      BIT(0)
+#define REG_LOCK_STAT      BIT(1)
+#define REG_LOCK_BYPASS    BIT(2)
+
+#define RTC_RW_RETRY_CNT    5
+#define SPI_RW_RETRY_CNT    500
+#define RTC_SLEEP_TIME_MS   20
+
+#define date_to_sec(d, h, m, s)     ((s) + (m) * 60 + (h) * 60 * 60 + (d) * 24 * 60 * 60)
+#define sec_to_day(s)            ((s) / (60 * 60 * 24))
+
+struct hibvt_rtc {
+	struct rtc_device *rtc_dev;
+	void __iomem *regs;
+	int                  rtc_irq;
+};
+#define hibvt_rtc_readl(x) (*((volatile unsigned char *)(x)))
+#define hibvt_rtc_writel(v, x) (*((volatile unsigned char *)(x)) = (v))
+
+#if defined(SPI_RTC_TYPE)
+static int hibvt_spi_write(void *spi_reg, unsigned char reg,
+			   unsigned char val)
+{
+	union u_spi_rw w_data, r_data;
+	int cnt = SPI_RW_RETRY_CNT;
+
+	r_data.u32 = 0;
+	w_data.u32 = 0;
+
+	w_data.bits.spi_wdata = val;
+	w_data.bits.spi_addr = reg;
+	w_data.bits.spi_rw = SPI_WRITE;
+	w_data.bits.spi_start = 0x1;
+
+	writel(w_data.u32, (spi_reg+SPI_RW));
+
+	do
+		r_data.u32 = readl(spi_reg+SPI_RW);
+	while (r_data.bits.spi_busy && (--cnt));
+
+	if (r_data.bits.spi_busy)
+		return -EIO;
+
+	return 0;
+}
+
+static int hibvt_spi_read(void *spi_reg, unsigned char reg,
+			  unsigned char *val)
+{
+	union u_spi_rw w_data, r_data;
+	int cnt = SPI_RW_RETRY_CNT;
+
+	r_data.u32 = 0;
+	w_data.u32 = 0;
+	w_data.bits.spi_addr = reg;
+	w_data.bits.spi_rw = SPI_READ;
+	w_data.bits.spi_start = 0x1;
+
+	writel(w_data.u32, (spi_reg+SPI_RW));
+
+	do
+		r_data.u32 = readl(spi_reg+SPI_RW);
+	while (r_data.bits.spi_busy && (--cnt));
+
+	if (r_data.bits.spi_busy)
+		return -EIO;
+
+	*val = r_data.bits.spi_rdata;
+
+	return 0;
+}
+#else
+static unsigned int hibvt_write_reg(void *spi_reg, unsigned long offset,
+				    unsigned char val)
+{
+	hibvt_rtc_writel(val, (spi_reg + offset));
+	return 0;
+}
+
+static unsigned int hibvt_read_reg(void *spi_reg, unsigned long offset,
+				   unsigned char *val)
+{
+	*val = hibvt_rtc_readl(spi_reg + offset);
+	return 0;
+}
+#endif
+
+
+static unsigned int hibvt_rtc_write(void *spi_reg, unsigned long offset,
+				    unsigned char val)
+{
+#if defined(SPI_RTC_TYPE)
+	return hibvt_spi_write(spi_reg, offset, val);
+#else
+	return hibvt_write_reg(spi_reg, offset, val);
+#endif
+}
+
+static unsigned int hibvt_rtc_read(void *spi_reg, unsigned long offset,
+				   unsigned char *val)
+{
+#if defined(SPI_RTC_TYPE)
+	return hibvt_spi_read(spi_reg, offset, val);
+#else
+	return hibvt_read_reg(spi_reg, offset, val);
+#endif
+}
+
+static int hibvt_rtc_read_time(struct device *dev, struct rtc_time *time)
+{
+	struct hibvt_rtc *rtc = dev_get_drvdata(dev);
+	struct hibvt_time_str time_str = {0};
+	unsigned long seconds = 0;
+	unsigned int day;
+	unsigned char raw_value = 0;
+	int cnt = RTC_RW_RETRY_CNT;
+
+	hibvt_rtc_read(rtc->regs, RTC_INT_RAW, &raw_value);
+
+	if (raw_value & LV_INT_MASK)
+		/* low voltage detected, date/time is not reliable. */
+		hibvt_rtc_write(rtc->regs, RTC_INT_CLR, 1);
+
+	hibvt_rtc_read(rtc->regs, RTC_LORD, &raw_value);
+	if (raw_value & REG_LOCK_BYPASS)
+		hibvt_rtc_write(rtc->regs, RTC_LORD,
+				(~(REG_LOCK_BYPASS)) & raw_value);
+
+	hibvt_rtc_read(rtc->regs, RTC_LORD, &raw_value);
+	/* lock the time */
+	hibvt_rtc_write(rtc->regs, RTC_LORD, (REG_LOCK_STAT) | raw_value);
+	/* wait rtc load flag */
+	do {
+		hibvt_rtc_read(rtc->regs, RTC_LORD, &raw_value);
+		msleep(RTC_SLEEP_TIME_MS);
+	} while ((raw_value & REG_LOCK_STAT) && (--cnt));
+
+	if (raw_value & REG_LOCK_STAT)
+		return -EBUSY;
+
+	hibvt_rtc_read(rtc->regs, RTC_S_COUNT, &time_str.second);
+	hibvt_rtc_read(rtc->regs, RTC_M_COUNT, &time_str.minute);
+	hibvt_rtc_read(rtc->regs, RTC_H_COUNT, &time_str.hour);
+	hibvt_rtc_read(rtc->regs, RTC_D_COUNT_L, &time_str.dayl);
+	hibvt_rtc_read(rtc->regs, RTC_D_COUNT_H, &time_str.dayh);
+
+	day = (time_str.dayl | (time_str.dayh << 8)); /* Move to a high 8 bit. */
+	seconds = date_to_sec(day, time_str.hour, time_str.minute, time_str.second);
+
+	rtc_time64_to_tm(seconds, time);
+
+	return rtc_valid_tm(time);
+}
+
+static int hibvt_rtc_set_time(struct device *dev, struct rtc_time *time)
+{
+	struct hibvt_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int days;
+	unsigned long seconds = 0;
+	unsigned int cnt = RTC_RW_RETRY_CNT;
+	unsigned char raw_value = 0;
+
+	seconds = rtc_tm_to_time64(time);
+
+	days = sec_to_day(seconds);
+
+	hibvt_rtc_write(rtc->regs, RTC_LR_10MS, 0);
+	hibvt_rtc_write(rtc->regs, RTC_LR_S, time->tm_sec);
+	hibvt_rtc_write(rtc->regs, RTC_LR_M, time->tm_min);
+	hibvt_rtc_write(rtc->regs, RTC_LR_H, time->tm_hour);
+	hibvt_rtc_write(rtc->regs, RTC_LR_D_L, (days & 0xFF));
+	hibvt_rtc_write(rtc->regs, RTC_LR_D_H, (days >> 8));  /* Move to a Low 8 bit. */
+
+	hibvt_rtc_write(rtc->regs, RTC_LORD,
+			(raw_value | REG_LOAD_STAT));
+	/* wait rtc load flag */
+	do {
+		hibvt_rtc_read(rtc->regs, RTC_LORD, &raw_value);
+		msleep(RTC_SLEEP_TIME_MS);
+	} while ((raw_value & REG_LOAD_STAT) && (--cnt));
+
+	if (raw_value & REG_LOAD_STAT)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int hibvt_rtc_read_alarm(struct device *dev,
+				struct rtc_wkalrm *alrm)
+{
+	struct hibvt_rtc *rtc = dev_get_drvdata(dev);
+	struct hibvt_time_str time_str = {0};
+	unsigned long seconds = 0;
+	unsigned int day;
+	unsigned char int_state = 0;
+
+	memset(alrm, 0, sizeof(struct rtc_wkalrm));
+
+	hibvt_rtc_read(rtc->regs, RTC_MR_S, &time_str.second);
+	hibvt_rtc_read(rtc->regs, RTC_MR_M, &time_str.minute);
+	hibvt_rtc_read(rtc->regs, RTC_MR_H, &time_str.hour);
+	hibvt_rtc_read(rtc->regs, RTC_MR_D_L, &time_str.dayl);
+	hibvt_rtc_read(rtc->regs, RTC_MR_D_H, &time_str.dayh);
+
+	day = (unsigned int)(time_str.dayl | (time_str.dayh << 8)); /* Move to a high 8 bit. */
+	seconds = date_to_sec(day, time_str.hour, time_str.minute, time_str.second);
+
+	rtc_time64_to_tm(seconds, &alrm->time);
+
+	hibvt_rtc_read(rtc->regs, RTC_IMSC, &int_state);
+
+	alrm->enabled = !!(int_state & AIE_INT_MASK);
+	alrm->pending = alrm->enabled;
+
+	return 0;
+}
+
+static int hibvt_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct hibvt_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int days;
+	unsigned long seconds = 0;
+	unsigned char val = 0;
+
+	seconds = rtc_tm_to_time64(&alrm->time);
+
+	days = sec_to_day(seconds);
+
+	hibvt_rtc_write(rtc->regs, RTC_MR_10MS, 0);
+	hibvt_rtc_write(rtc->regs, RTC_MR_S, alrm->time.tm_sec);
+	hibvt_rtc_write(rtc->regs, RTC_MR_M, alrm->time.tm_min);
+	hibvt_rtc_write(rtc->regs, RTC_MR_H, alrm->time.tm_hour);
+	hibvt_rtc_write(rtc->regs, RTC_MR_D_L, (days & 0xFF));
+	hibvt_rtc_write(rtc->regs, RTC_MR_D_H, (days >> 8)); /* Move to a Low 8 bit. */
+
+	hibvt_rtc_read(rtc->regs, RTC_IMSC, &val);
+	if (alrm->enabled)
+		hibvt_rtc_write(rtc->regs, RTC_IMSC, val | AIE_INT_MASK);
+	else
+		hibvt_rtc_write(rtc->regs, RTC_IMSC, val & ~AIE_INT_MASK);
+
+	return 0;
+}
+
+static int hibvt_rtc_alarm_irq_enable(struct device *dev,
+				      unsigned int enabled)
+{
+	struct hibvt_rtc *rtc = dev_get_drvdata(dev);
+	unsigned char val = 0;
+
+	hibvt_rtc_read(rtc->regs, RTC_IMSC, &val);
+	if (enabled)
+		hibvt_rtc_write(rtc->regs, RTC_IMSC, val | AIE_INT_MASK);
+	else
+		hibvt_rtc_write(rtc->regs, RTC_IMSC, val & ~AIE_INT_MASK);
+
+	return 0;
+}
+
+/*
+ * interrupt function
+ * do nothing. left for future
+ */
+static irqreturn_t hibvt_rtc_alm_interrupt(int irq, void *data)
+{
+	struct hibvt_rtc *rtc = (struct hibvt_rtc *)data;
+	unsigned char val = 0;
+
+	hibvt_rtc_read(rtc->regs, RTC_INT, &val);
+	hibvt_rtc_write(rtc->regs, RTC_INT_CLR, AIE_INT_MASK);
+
+	if (val & AIE_INT_MASK)
+		rtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);
+
+	return IRQ_HANDLED;
+}
+
+#define FREQ_MAX_VAL	    3277000
+#define FREQ_MIN_VAL	    3276000
+
+static int hibvt_rtc_ioctl(struct device *dev,
+			   unsigned int cmd, unsigned long arg)
+{
+	struct hibvt_rtc *rtc = dev_get_drvdata(dev);
+
+	switch (cmd) {
+	case RTC_PLL_SET: {
+		char freq_l, freq_h;
+		struct rtc_pll_info pll_info = {0};
+
+		if (copy_from_user(&pll_info, (struct rtc_pll_info *)(uintptr_t)arg,
+				   sizeof(struct rtc_pll_info)))
+			return -EFAULT;
+
+		/* freq = 32700 + (freq /3052)*100 */
+		if (pll_info.pll_value > FREQ_MAX_VAL ||
+			pll_info.pll_value < FREQ_MIN_VAL)
+			return -EINVAL;
+
+		/* freq convert: (freq-3270000) * 3052 / 10000 */
+		pll_info.pll_value = (pll_info.pll_value - 3270000) *
+				     3052 / 10000;
+
+		/* & 0xff Obtains the lower eight bits of data. */
+		freq_l = (char)(pll_info.pll_value & 0xff);
+		/* pll_info.pll_value >> 8 & 0xf  Obtains the last four bits of the higher eight bits. */
+		freq_h = (char)((pll_info.pll_value >> 8) & 0xf);
+
+		hibvt_rtc_write(rtc->regs, RTC_FREQ_H, freq_h);
+		hibvt_rtc_write(rtc->regs, RTC_FREQ_L, freq_l);
+
+		return 0;
+	}
+	case RTC_PLL_GET: {
+		char freq_l = 0;
+		char freq_h = 0;
+		struct rtc_pll_info pll_info = {0};
+
+		hibvt_rtc_read(rtc->regs, RTC_FREQ_H, &freq_h);
+		hibvt_rtc_read(rtc->regs, RTC_FREQ_L, &freq_l);
+
+		if ((void __user *)(uintptr_t)arg == NULL) {
+			dev_err(dev, "IO err or user buf is NULL..\n");
+			return -1;
+		}
+
+		/* freq_h & 0xf << 8 :Shifts leftwards by 8 bits and obtains the lower 4 bits. */
+		pll_info.pll_value = (((unsigned)freq_h & 0xf) << 8) + freq_l;
+
+		/* freq convert: 3270000 + (freq * 10000) / 3052 */
+		pll_info.pll_value = 3270000 + ((unsigned int)pll_info.pll_value * 10000) / 3052;
+
+		pll_info.pll_max = FREQ_MAX_VAL;
+		pll_info.pll_min = FREQ_MIN_VAL;
+		if (copy_to_user((void __user *)(uintptr_t)arg,
+				 &pll_info, sizeof(struct rtc_pll_info)))
+			return -EFAULT;
+
+		return 0;
+	}
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+static const struct rtc_class_ops hibvt_rtc_ops = {
+	.read_time = hibvt_rtc_read_time,
+	.set_time = hibvt_rtc_set_time,
+	.read_alarm = hibvt_rtc_read_alarm,
+	.set_alarm = hibvt_rtc_set_alarm,
+	.alarm_irq_enable = hibvt_rtc_alarm_irq_enable,
+	.ioctl = hibvt_rtc_ioctl,
+};
+
+static int hibvt_rtc_init(struct hibvt_rtc *rtc)
+{
+	void *spi_reg = rtc->regs;
+	unsigned char val = 0;
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3559CV100) || \
+    defined(CONFIG_ARCH_HI3569V100)
+	void *pwr_reg = NULL;
+#endif
+	/*
+	 * clk div value = (apb_clk/spi_clk)/2-1,
+	 *  apb clk = 100MHz, spi_clk = 10MHz,so value= 0x4
+	 */
+	writel(CLK_DIV_DEFAULT, (spi_reg + SPI_CLK_DIV));
+
+	hibvt_rtc_write(spi_reg, RTC_IMSC, INT_MSK_DEFAULT);
+	hibvt_rtc_write(spi_reg, RTC_SAR_CTRL, LV_CTL_DEFAULT);
+
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3559CV100) || \
+    defined(CONFIG_ARCH_HI3569V100)
+	pwr_reg = ioremap(PWR_REG_ADDR, PWR_REG_LENGTH);
+	if(pwr_reg == NULL)	{
+		return -1;
+	}
+	writel(0x5A5AABCD, pwr_reg+0x58);
+	iounmap(pwr_reg);
+#else
+	/* default driver capability */
+	hibvt_rtc_write(spi_reg, RTC_REG_LOCK4, 0x5A); /* 0x5A:ctl order */
+	hibvt_rtc_write(spi_reg, RTC_REG_LOCK3, 0x5A); /* 0x5A:ctl order */
+	hibvt_rtc_write(spi_reg, RTC_REG_LOCK2, 0xAB); /* 0xAB:ctl order */
+	hibvt_rtc_write(spi_reg, RTC_REG_LOCK1, 0xCD); /* 0xCD:ctl order */
+#endif
+
+#if defined(CONFIG_ARCH_HI3516CV500) || defined(CONFIG_ARCH_HI3516DV300) ||\
+	defined(CONFIG_ARCH_HI3556V200)  || defined(CONFIG_ARCH_HI3559V200)  ||\
+	defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3559CV100) ||\
+	defined(CONFIG_ARCH_HI3519AV100) || defined(CONFIG_ARCH_HI3556AV100) ||\
+	defined(CONFIG_ARCH_HI3536DV100) || defined(CONFIG_ARCH_HI3562V100)  ||\
+	defined(CONFIG_ARCH_HI3566V100)  || defined(CONFIG_ARCH_HI3569V100)  || \
+	defined(CONFIG_ARCH_HI3568V100)
+	hibvt_rtc_write(spi_reg, RTC_CLK_CFG, 0x02);
+#elif defined(CONFIG_ARCH_HI3516EV200) || defined(CONFIG_ARCH_HI3516EV300) ||\
+	defined(CONFIG_ARCH_HI3518EV300) || defined(CONFIG_ARCH_HI3516DV200) ||\
+	defined(CONFIG_ARCH_HI3531DV200) || defined(CONFIG_ARCH_HI3535AV100) || \
+    defined(CONFIG_ARCH_HI3521DV200) || defined(CONFIG_ARCH_HI3520DV500)
+	hibvt_rtc_write(spi_reg, RTC_CLK_CFG, 0x03);
+#else
+	/* HI3536CV100 */
+	hibvt_rtc_write(spi_reg, RTC_CLK_CFG, 0x01);
+#endif
+
+	/* default FREQ COEF */
+	hibvt_rtc_write(spi_reg, RTC_FREQ_H, FREQ_H_DEFAULT);
+	hibvt_rtc_write(spi_reg, RTC_FREQ_L, FREQ_L_DEFAULT);
+
+	hibvt_rtc_read(spi_reg, RTC_INT_RAW, &val);
+
+	if (val & LV_INT_MASK)
+		/* low voltage detected, date/time is not reliable. */
+		hibvt_rtc_write(rtc->regs, RTC_INT_CLR, 1);
+
+	return 0;
+}
+
+static int hibvt_rtc_probe(struct platform_device *pdev)
+{
+	struct resource  *mem = NULL;
+	struct hibvt_rtc *rtc = NULL;
+	int    ret;
+
+	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
+	if (!rtc)
+		return -ENOMEM;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	rtc->regs = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR((const void *)rtc->regs)) {
+		dev_err(&pdev->dev, "could not map I/O memory\n");
+		return PTR_ERR((const void *)rtc->regs);
+	}
+
+	rtc->rtc_irq = platform_get_irq(pdev, 0);
+	ret = devm_request_irq(&pdev->dev, rtc->rtc_irq,
+			       hibvt_rtc_alm_interrupt, 0, pdev->name, rtc);
+	if (ret) {
+		dev_err(&pdev->dev, "could not request irq %d\n", rtc->rtc_irq);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, rtc);
+	rtc->rtc_dev = devm_rtc_device_register(&pdev->dev, pdev->name,
+						&hibvt_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc->rtc_dev)) {
+		dev_err(&pdev->dev, "could not register rtc device\n");
+		return PTR_ERR(rtc->rtc_dev);
+	}
+
+	if (hibvt_rtc_init(rtc)) {
+		dev_err(&pdev->dev, "hibvt_rtc_init failed.\n");
+		return -EIO;
+	}
+
+	dev_info(&pdev->dev, "RTC driver for hibvt enabled\n");
+
+	return 0;
+}
+
+static int hibvt_rtc_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id hibvt_rtc_match[] = {
+	{ .compatible = "hisilicon,hi35xx-rtc" },
+	{},
+};
+
+static struct platform_driver hibvt_rtc_driver = {
+	.probe  = hibvt_rtc_probe,
+	.remove = hibvt_rtc_remove,
+	.driver =  {
+		.name = "hibvt_rtc",
+		.of_match_table = hibvt_rtc_match,
+	},
+};
+
+module_platform_driver(hibvt_rtc_driver);
+
+#define OSDRV_MODULE_VERSION_STRING "HISI_rtc @HiMPP"
+
+MODULE_AUTHOR("Hisilicon");
+MODULE_DESCRIPTION("Hisilicon RTC driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("HI_VERSION=" OSDRV_MODULE_VERSION_STRING);
diff --git a/drivers/scsi/ufs/Kconfig b/drivers/scsi/ufs/Kconfig
index c339517b7..4ff8f3de5 100644
--- a/drivers/scsi/ufs/Kconfig
+++ b/drivers/scsi/ufs/Kconfig
@@ -182,3 +182,12 @@ config SCSI_UFS_CRYPTO
 	  Enabling this makes it possible for the kernel to use the crypto
 	  capabilities of the UFS device (if present) to perform crypto
 	  operations on data being transferred to/from the device.
+
+config SCSI_UFS_HI3559AV100
+	tristate "Hi3559av100 specific hooks to UFS controller platform driver"
+	depends on SCSI_UFSHCD_PLATFORM
+	help
+	  This selects the UFS support for Hi3559av100 SoC.
+
+	  Select this if you have UFS controller on Hi3751v810 chipset.
+	  If unsure, say N.
diff --git a/drivers/scsi/ufs/Makefile b/drivers/scsi/ufs/Makefile
index 4679af1b5..8042bf7c6 100644
--- a/drivers/scsi/ufs/Makefile
+++ b/drivers/scsi/ufs/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_SCSI_UFSHCD_PLATFORM) += ufshcd-pltfrm.o
 obj-$(CONFIG_SCSI_UFS_HISI) += ufs-hisi.o
 obj-$(CONFIG_SCSI_UFS_MEDIATEK) += ufs-mediatek.o
 obj-$(CONFIG_SCSI_UFS_TI_J721E) += ti-j721e-ufs.o
+obj-$(CONFIG_SCSI_UFS_HI3559AV100) += hi3559av100.o
diff --git a/drivers/scsi/ufs/ufshcd-pltfrm.c b/drivers/scsi/ufs/ufshcd-pltfrm.c
index 24927cf48..ccf04e4f1 100644
--- a/drivers/scsi/ufs/ufshcd-pltfrm.c
+++ b/drivers/scsi/ufs/ufshcd-pltfrm.c
@@ -17,6 +17,9 @@
 #include "unipro.h"
 
 #define UFSHCD_DEFAULT_LANES_PER_DIRECTION		2
+#define UFSHCD_DEFAULT_PWM		FAST_MODE
+#define UFSHCD_DEFAULT_GEAR		UFS_HS_G1
+#define UFSHCD_DEFAULT_RATE		PA_HS_MODE_B
 
 static int ufshcd_parse_clock_info(struct ufs_hba *hba)
 {
@@ -172,6 +175,9 @@ static int ufshcd_parse_regulator_info(struct ufs_hba *hba)
 	struct device *dev = hba->dev;
 	struct ufs_vreg_info *info = &hba->vreg_info;
 
+	if (hba->info_skip)
+		return 0;
+
 	err = ufshcd_populate_vreg(dev, "vdd-hba", &info->vdd_hba);
 	if (err)
 		goto out;
@@ -189,6 +195,18 @@ static int ufshcd_parse_regulator_info(struct ufs_hba *hba)
 	return err;
 }
 
+static void ufshcd_parse_cd_pin(struct ufs_hba *hba)
+{
+#ifdef CONFIG_SCSI_UFS_CARD
+	struct device *dev = hba->dev;
+	struct device_node *np = dev->of_node;
+	if (of_get_property(np, "cd-gpio", NULL))
+		hba->cd_gpio = of_get_named_gpio(np, "cd-gpio", 0);
+	else
+		hba->cd_gpio = -1;
+#endif
+}
+
 #ifdef CONFIG_PM
 /**
  * ufshcd_pltfrm_suspend - suspend power management function
@@ -242,6 +260,34 @@ void ufshcd_pltfrm_shutdown(struct platform_device *pdev)
 }
 EXPORT_SYMBOL_GPL(ufshcd_pltfrm_shutdown);
 
+static void ufshcd_init_skip_info(struct ufs_hba *hba)
+{
+	struct device *dev = hba->dev;
+	int ret;
+
+	ret = of_property_read_u32(dev->of_node, "skip-info", &hba->info_skip);
+	if (ret)
+		hba->info_skip = 0;
+}
+
+static void ufshcd_init_powermode(struct ufs_hba *hba)
+{
+	struct device *dev = hba->dev;
+	int ret;
+
+	ret = of_property_read_u32(dev->of_node, "power-mode", &hba->hc_pwm);
+	if (ret)
+		hba->hc_pwm = UFSHCD_DEFAULT_PWM;
+
+	ret = of_property_read_u32(dev->of_node, "gear", &hba->hc_gear);
+	if (ret)
+		hba->hc_gear = UFSHCD_DEFAULT_GEAR;
+
+	ret = of_property_read_u32(dev->of_node, "rate", &hba->hc_rate);
+	if (ret)
+		hba->hc_rate = UFSHCD_DEFAULT_RATE;
+}
+
 static void ufshcd_init_lanes_per_dir(struct ufs_hba *hba)
 {
 	struct device *dev = hba->dev;
@@ -388,6 +434,7 @@ int ufshcd_pltfrm_init(struct platform_device *pdev,
 	}
 
 	hba->vops = vops;
+	ufshcd_init_skip_info(hba);
 
 	err = ufshcd_parse_clock_info(hba);
 	if (err) {
@@ -402,6 +449,8 @@ int ufshcd_pltfrm_init(struct platform_device *pdev,
 		goto dealloc_host;
 	}
 
+	ufshcd_parse_cd_pin(hba);
+	ufshcd_init_powermode(hba);
 	ufshcd_init_lanes_per_dir(hba);
 
 	err = ufshcd_init(hba, mmio_base, irq);
diff --git a/drivers/scsi/ufs/ufshcd.c b/drivers/scsi/ufs/ufshcd.c
index 3139d9df6..fc0b43268 100644
--- a/drivers/scsi/ufs/ufshcd.c
+++ b/drivers/scsi/ufs/ufshcd.c
@@ -6231,6 +6231,40 @@ static irqreturn_t ufshcd_intr(int irq, void *__hba)
 	return retval;
 }
 
+#ifdef CONFIG_SCSI_UFS_CARD
+static int ufshcd_check_card_detect(struct ufs_hba *hba)
+{
+	int ret = D_IGNORED;
+
+	if (gpio_is_valid(hba->cd_gpio))
+		ret = gpio_get_value(hba->cd_gpio) ?  D_NO_DETECT : D_DETECT;
+
+	return ret;
+}
+
+static irqreturn_t ufshcd_intr_card_detect(int irq, void *__hba)
+{
+	struct ufs_hba *hba = __hba;
+	unsigned long flags;
+
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	hba->card_status_changed = true;
+	hba->ufshcd_state = UFSHCD_STATE_OFFLINE;
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+
+	/*
+	 * This handler would not work during UFS driver's sleep mode.
+	 * That makes pending tasks failed when UFS driver enters
+	 * into suspend mode and interface re-establishment be permitted
+	 * only after UFS driver exit from suspend mode.
+	 */
+	if (!(work_pending(&hba->cd_work))) {
+		queue_work(hba->cd_wq, &hba->cd_work);
+	}
+	return IRQ_HANDLED;
+}
+#endif
+
 static int ufshcd_clear_tm_cmd(struct ufs_hba *hba, int tag)
 {
 	int err = 0;
@@ -6829,6 +6863,10 @@ static int ufshcd_host_reset_and_restore(struct ufs_hba *hba)
 	int err;
 	unsigned long flags;
 
+#ifdef CONFIG_SCSI_UFS_CARD
+	if (ufshcd_check_card_detect(hba) == D_NO_DETECT)
+		return 0;
+#endif
 	/*
 	 * Stop the host controller and complete the requests
 	 * cleared by h/w
@@ -6844,6 +6882,8 @@ static int ufshcd_host_reset_and_restore(struct ufs_hba *hba)
 	/* scale up clocks to max frequency before full reinitialization */
 	ufshcd_set_clk_freq(hba, true);
 
+	ufshcd_vops_clk_hareware_init_notify(hba);
+
 	err = ufshcd_hba_enable(hba);
 	if (err)
 		goto out;
@@ -7268,6 +7308,7 @@ static int ufs_get_device_desc(struct ufs_hba *hba)
 	dev_info->wspecversion = desc_buf[DEVICE_DESC_PARAM_SPEC_VER] << 8 |
 				      desc_buf[DEVICE_DESC_PARAM_SPEC_VER + 1];
 
+	hba->manufacturer_id = dev_desc->wmanufacturerid;
 	model_index = desc_buf[DEVICE_DESC_PARAM_PRDCT_NAME];
 
 	err = ufshcd_read_string_desc(hba, model_index,
@@ -7831,6 +7872,138 @@ static const struct attribute_group *ufshcd_driver_groups[] = {
 	NULL,
 };
 
+#ifdef CONFIG_SCSI_UFS_CARD
+static int ufshcd_select_next_job(struct ufs_hba *hba, bool current_status)
+{
+	bool is_card_detected;
+
+	/*
+	 * We assume scenarios for 4 cases and decribe them
+	 * with following conventions
+	 *
+	 * Physical card Status (A) / Device file status (B)
+	 * Insertion (I) / Removal (R)
+	 *
+	 * 1) A = I
+	 * 	1-1) B = I : (I) -> R
+	 *	This might means bad card insertion that can cause
+	 *	something wrong for opertions.
+	 *
+	 *	1-2) B = R : (R) -> I
+	 *	Normal insertion
+	 *
+	 * 2) A = R
+	 * 	2-1) B = I : (I) -> R
+	 *	Normal removal
+	 *
+	 *	2-2) B = R : (R)
+	 *	Return because old status is 'removal'
+	 *	and any care isn't required.
+	 *
+	 *
+	 */
+	is_card_detected = (D_DETECT == ufshcd_check_card_detect(hba));
+	if (hba->latest_card_status == H_INSERT) {
+		return H_REMOVE;
+	} else {
+		if (is_card_detected)
+			return H_INSERT;
+		else
+			return H_BREAK;
+	}
+}
+
+static void ufshcd_card_detect_handler(struct work_struct *work)
+{
+	struct ufs_hba *hba;
+	unsigned long flags;
+	int tag;
+	unsigned long outstanding_reqs;
+	int current_status;
+	struct scsi_target *starget;
+	struct uic_command uic_cmd = {0};
+
+	hba = container_of(work, struct ufs_hba, cd_work);
+	msleep(50);
+	current_status = hba->latest_card_status;
+	while (1) {
+		pm_runtime_get_sync(hba->dev);
+
+		/*
+		 * There is a requirement of whether card detection interrupt
+		 * happens before terminating here not to miss the interrupt.
+		 * The hint should be wrapped by spin lock.
+		 */
+		spin_lock_irqsave(hba->host->host_lock, flags);
+		if (unlikely(!hba->card_status_changed)) {
+			spin_unlock_irqrestore(hba->host->host_lock, flags);
+			return;
+		}
+		hba->card_status_changed = false;
+		spin_unlock_irqrestore(hba->host->host_lock, flags);
+
+		current_status = ufshcd_select_next_job(hba, current_status);
+
+		if (current_status == H_INSERT) {
+			/*
+			 * On insertion, a total sequence to initialize
+			 * UFS interface is required.
+			 */
+
+			ufshcd_hba_enable(hba);
+			ufshcd_probe_hba(hba);
+
+			dev_err(hba->dev, "card inserted\n");
+			hba->latest_card_status = current_status;
+			hba->error_count = 0;
+			break;
+		} else if (current_status == H_REMOVE) {
+			/*
+			 * On removal, clearing slots and I/O completion
+			 * of pending tasks, if any, are required.
+			 */
+
+			spin_lock_irqsave(hba->host->host_lock, flags);
+			outstanding_reqs = hba->outstanding_reqs;
+			spin_unlock_irqrestore(hba->host->host_lock, flags);
+			if (outstanding_reqs) {
+				for_each_set_bit(tag, &outstanding_reqs, hba->nutrs)
+					ufshcd_clear_cmd(hba, tag);
+				__ufshcd_transfer_req_compl(hba, DID_NO_CONNECT);
+			}
+
+			uic_cmd.command = UIC_CMD_DME_RESET;
+			ufshcd_send_uic_cmd(hba, &uic_cmd);
+
+			spin_lock_irqsave(hba->host->host_lock, flags);
+			ufshcd_hba_stop(hba, true);
+			hba->ufshcd_state = UFSHCD_STATE_OFFLINE;
+			spin_unlock_irqrestore(hba->host->host_lock, flags);
+
+			/*
+			 * A device file removal is required on card removal
+			 */
+			if (!list_empty(&hba->host->__targets)) {
+				starget = list_first_entry(&hba->host->__targets,
+						struct scsi_target, siblings);
+				scsi_remove_device(hba->sdev_rpmb);
+				scsi_remove_device(hba->sdev_boot);
+				scsi_remove_device(hba->sdev_ufs_device);
+				scsi_remove_target(&starget->dev);
+			}
+
+			dev_err(hba->dev, "card removed\n");
+			hba->latest_card_status = current_status;
+			return;
+		} else {
+			dev_err(hba->dev, "returned\n");
+			break;
+		}
+	}
+	pm_runtime_put_sync(hba->dev);
+}
+#endif
+
 static struct ufs_hba_variant_params ufs_hba_vps = {
 	.hba_enable_delay_us		= 1000,
 	.wb_flush_threshold		= UFS_WB_BUF_REMAIN_PERCENT(40),
@@ -8540,6 +8713,10 @@ static int ufshcd_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op)
 	enum ufs_dev_pwr_mode req_dev_pwr_mode;
 	enum uic_link_state req_link_state;
 
+#ifdef CONFIG_SCSI_UFS_CARD
+	if (hba->ufshcd_state == UFSHCD_STATE_OFFLINE)
+		return 0;
+#endif
 	hba->pm_op_in_progress = 1;
 	if (!ufshcd_is_shutdown_pm(pm_op)) {
 		pm_lvl = ufshcd_is_runtime_pm(pm_op) ?
@@ -9017,6 +9194,9 @@ void ufshcd_remove(struct ufs_hba *hba)
 	ufshcd_exit_clk_gating(hba);
 	if (ufshcd_is_clkscaling_supported(hba))
 		device_remove_file(hba->dev, &hba->clk_scaling.enable_attr);
+#ifdef CONFIG_SCSI_UFS_CARD
+	destroy_workqueue(hba->cd_wq);
+#endif
 	ufshcd_hba_exit(hba);
 }
 EXPORT_SYMBOL_GPL(ufshcd_remove);
@@ -9185,6 +9365,14 @@ int ufshcd_init(struct ufs_hba *hba, void __iomem *mmio_base, unsigned int irq)
 	INIT_WORK(&hba->eh_work, ufshcd_err_handler);
 	INIT_WORK(&hba->eeh_work, ufshcd_exception_event_handler);
 
+#ifdef CONFIG_SCSI_UFS_CARD
+	INIT_WORK(&hba->cd_work, ufshcd_card_detect_handler);
+	hba->cd_wq = alloc_workqueue("ufshcd_cd_wq", WQ_FREEZABLE, 0);
+	if (!hba->cd_wq) {
+		err = -ENOMEM;
+		goto out_error;
+	}
+#endif
 	/* Initialize UIC command mutex */
 	mutex_init(&hba->uic_cmd_mutex);
 
@@ -9293,7 +9481,37 @@ int ufshcd_init(struct ufs_hba *hba, void __iomem *mmio_base, unsigned int irq)
 	 */
 	ufshcd_set_ufs_dev_active(hba);
 
+#ifndef CONFIG_SCSI_UFS_CARD
 	async_schedule(ufshcd_async_scan, hba);
+#else
+	unsigned int cd_irq;
+	if (gpio_is_valid(hba->cd_gpio) &&
+			!gpio_request(hba->cd_gpio, "UFSCARD")) {
+		cd_irq = gpio_to_irq(hba->cd_gpio);
+		dev_err(hba->dev, "card detection interrupt number = %d\n", cd_irq);
+		if (cd_irq &&
+			devm_request_irq(hba->dev, cd_irq, ufshcd_intr_card_detect,
+				IRQF_TRIGGER_RISING |
+				IRQF_TRIGGER_FALLING |
+				IRQF_ONESHOT,
+				UFSCARDHCD, hba) == 0) {
+			dev_warn(hba->dev, "success to request irq for card detect.\n");
+			enable_irq_wake(cd_irq);
+			hba->is_cd_irq_enabled = true;
+			hba->cd_irq = cd_irq;
+		} else
+			dev_warn(hba->dev, "cannot request irq for card detect.\n");
+	}
+
+	if (D_DETECT == ufshcd_check_card_detect(hba)) {
+		hba->latest_card_status = true;
+		async_schedule(ufshcd_async_scan, hba);
+	} else {
+		hba->latest_card_status = false;
+		ufshcd_hba_stop(hba, true);
+		hba->ufshcd_state = UFSHCD_STATE_OFFLINE;
+	}
+#endif
 	ufs_sysfs_add_nodes(hba->dev);
 
 	return 0;
diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 812aa3487..c2fe83d27 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -50,6 +50,7 @@
 
 #define UFSHCD "ufshcd"
 #define UFSHCD_DRIVER_VERSION "0.2"
+#define UFSCARDHCD "ufscarddetect"
 
 struct ufs_hba;
 
@@ -324,6 +325,7 @@ struct ufs_hba_variant_ops {
 					void *data);
 	int	(*program_key)(struct ufs_hba *hba,
 			       const union ufs_crypto_cfg_entry *cfg, int slot);
+	void	(*clk_hareware_init_notify)(void);
 };
 
 /* clock gating state  */
@@ -463,6 +465,20 @@ struct ufs_stats {
 	struct ufs_err_reg_hist task_abort;
 };
 
+/* card status */
+enum ufs_card_status {
+	D_IGNORED = -1,
+	D_NO_DETECT = 0,
+	D_DETECT,
+};
+
+/* card detect handler action */
+enum {
+	H_BREAK = -1,
+	H_REMOVE = 0,
+	H_INSERT,
+};
+
 enum ufshcd_quirks {
 	/* Interrupt aggregation support is broken */
 	UFSHCD_QUIRK_BROKEN_INTR_AGGR			= 1 << 0,
@@ -747,6 +763,18 @@ struct ufs_hba {
 	struct work_struct eh_work;
 	struct work_struct eeh_work;
 
+#ifdef CONFIG_SCSI_UFS_CARD
+	/* card irq */
+	unsigned int cd_irq;
+	bool is_cd_irq_enabled;
+
+	/* card detect & work queue */
+	int cd_gpio;
+	bool latest_card_status;
+	bool card_status_changed;
+	struct work_struct cd_work;
+	struct workqueue_struct *cd_wq;
+#endif
 	/* HBA Errors */
 	u32 errors;
 	u32 uic_error;
@@ -757,6 +785,7 @@ struct ufs_hba {
 	bool force_pmc;
 	bool silence_err_logs;
 
+	uint16_t manufacturer_id;
 	/* Device management request data */
 	struct ufs_dev_cmd dev_cmd;
 	ktime_t last_dme_cmd_tstamp;
@@ -781,6 +810,11 @@ struct ufs_hba {
 	/* Control to enable/disable host capabilities */
 	u32 caps;
 
+	u32 hc_pwm;
+	u32 hc_gear;
+	u32 hc_rate;
+	u32 info_skip;
+
 	struct devfreq *devfreq;
 	struct ufs_clk_scaling clk_scaling;
 	bool is_sys_suspended;
@@ -1234,4 +1268,9 @@ static inline u8 ufshcd_scsi_to_upiu_lun(unsigned int scsi_lun)
 int ufshcd_dump_regs(struct ufs_hba *hba, size_t offset, size_t len,
 		     const char *prefix);
 
+static inline void ufshcd_vops_clk_hareware_init_notify(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->clk_hareware_init_notify)
+		hba->vops->clk_hareware_init_notify();
+}
 #endif /* End of Header */
diff --git a/drivers/spi/spi-gpio.c b/drivers/spi/spi-gpio.c
index 0584f4d2f..d035d4995 100644
--- a/drivers/spi/spi-gpio.c
+++ b/drivers/spi/spi-gpio.c
@@ -367,8 +367,10 @@ static int spi_gpio_probe(struct platform_device *pdev)
 	else
 		status = spi_gpio_probe_pdata(pdev, master);
 
-	if (status)
+	if (status) {
+		spi_master_put(master);
 		return status;
+	}
 
 	spi_gpio = spi_master_get_devdata(master);
 
diff --git a/drivers/spi/spi-pl022.c b/drivers/spi/spi-pl022.c
index d1776fea2..3b280d713 100644
--- a/drivers/spi/spi-pl022.c
+++ b/drivers/spi/spi-pl022.c
@@ -34,6 +34,7 @@
 #include <linux/gpio.h>
 #include <linux/of_gpio.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/of_address.h>
 
 /*
  * This macro is used to define some register default values.
@@ -127,6 +128,18 @@
 /* This one is only in the PL023 variant */
 #define SSP_CR1_MASK_FBCLKDEL_ST (0x7UL << 13)
 
+#ifdef CONFIG_ARCH_HISI_BVT
+/*
+ * The Hisilicon version of this block adds some bits
+ * in SSP_CR1
+ */
+#define SSP_CR1_MASK_BIGEND_HISI	(0x1UL << 4)
+#define SSP_CR1_MASK_ALTASENS_HISI	(0x1UL << 6)
+
+#define SSP_TX_FIFO_CR(r)  (r + 0x28)
+#define SSP_RX_FIFO_CR(r)  (r + 0x2C)
+#endif
+
 /*
  * SSP Status Register - SSP_SR
  */
@@ -288,6 +301,10 @@
 
 #define SPI_POLLING_TIMEOUT 1000
 
+#ifdef CONFIG_ARCH_HISI_BVT
+#define PL022_IDS_INDEX_HISI		4
+#endif
+
 /*
  * The type of reading going on on this chip
  */
@@ -330,6 +347,15 @@ struct vendor_data {
 	bool internal_cs_ctrl;
 };
 
+#ifdef CONFIG_ARCH_HISI_BVT
+struct cs_data {
+	struct resource		res;
+	void __iomem		*virt_addr;
+	unsigned int		cs_sb;
+	unsigned int		cs_mask_bit;
+};
+#endif
+
 /**
  * struct pl022 - This is the private SSP driver data structure
  * @adev: AMBA device model hookup
@@ -399,6 +425,9 @@ struct pl022 {
 #endif
 	int cur_cs;
 	int *chipselects;
+#ifdef CONFIG_ARCH_HISI_BVT
+	struct cs_data		*cs_data;
+#endif
 };
 
 /**
@@ -455,13 +484,41 @@ static void null_cs_control(u32 command)
 static void internal_cs_control(struct pl022 *pl022, u32 command)
 {
 	u32 tmp;
+#ifdef CONFIG_ARCH_HISI_BVT
+	struct amba_device *adev = pl022->adev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
+
+	if (pl022->vendor->extended_cr && (adev->periphid ==
+				adrv->id_table[PL022_IDS_INDEX_HISI].id)) {
+		if (pl022->cs_data) {
+			tmp = readl(pl022->cs_data->virt_addr);
+			tmp &= ~(pl022->cs_data->cs_mask_bit);
+			tmp |= ((u32)pl022->cur_cs) << pl022->cs_data->cs_sb;
+			writel(tmp, pl022->cs_data->virt_addr);
+		}
 
-	tmp = readw(SSP_CSR(pl022->virtbase));
-	if (command == SSP_CHIP_SELECT)
-		tmp &= ~BIT(pl022->cur_cs);
-	else
-		tmp |= BIT(pl022->cur_cs);
-	writew(tmp, SSP_CSR(pl022->virtbase));
+		if (command == SSP_CHIP_SELECT)
+			/* Enable SSP */
+			writew((readw(SSP_CR1(pl022->virtbase)) |
+						SSP_CR1_MASK_SSE),
+					SSP_CR1(pl022->virtbase));
+		else
+			/* disable SSP */
+			writew((readw(SSP_CR1(pl022->virtbase)) &
+						(~SSP_CR1_MASK_SSE)),
+					SSP_CR1(pl022->virtbase));
+	} else {
+#endif
+		tmp = readw(SSP_CSR(pl022->virtbase));
+		if (command == SSP_CHIP_SELECT)
+			tmp &= ~BIT(pl022->cur_cs);
+		else
+			tmp |= BIT(pl022->cur_cs);
+		writew(tmp, SSP_CSR(pl022->virtbase));
+#ifdef CONFIG_ARCH_HISI_BVT
+	}
+#endif
 }
 
 static void pl022_cs_control(struct pl022 *pl022, u32 command)
@@ -561,8 +618,16 @@ static int flush(struct pl022 *pl022)
 static void restore_state(struct pl022 *pl022)
 {
 	struct chip_data *chip = pl022->cur_chip;
+#ifdef CONFIG_ARCH_HISI_BVT
+	struct amba_device *adev = pl022->adev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
 
+	if (pl022->vendor->extended_cr && (adev->periphid !=
+				adrv->id_table[PL022_IDS_INDEX_HISI].id))
+#else
 	if (pl022->vendor->extended_cr)
+#endif
 		writel(chip->cr0, SSP_CR0(pl022->virtbase));
 	else
 		writew(chip->cr0, SSP_CR0(pl022->virtbase));
@@ -635,6 +700,15 @@ static void restore_state(struct pl022 *pl022)
 	GEN_MASK_BITS(SSP_FEEDBACK_CLK_DELAY_NONE, SSP_CR1_MASK_FBCLKDEL_ST, 13) \
 )
 
+#ifdef CONFIG_ARCH_HISI_BVT
+/* Hisilicon versions extend this register to use all 16 bits */
+#define DEFAULT_SSP_REG_CR1_HISI ( \
+	DEFAULT_SSP_REG_CR1 | \
+	GEN_MASK_BITS(SSP_RX_MSB, SSP_CR1_MASK_BIGEND_HISI, 4) | \
+	GEN_MASK_BITS(0x1, SSP_CR1_MASK_ALTASENS_HISI, 6) \
+)
+#endif
+
 #define DEFAULT_SSP_REG_CPSR ( \
 	GEN_MASK_BITS(SSP_DEFAULT_PRESCALE, SSP_CPSR_MASK_CPSDVSR, 0) \
 )
@@ -654,8 +728,22 @@ static void load_ssp_default_config(struct pl022 *pl022)
 		writel(DEFAULT_SSP_REG_CR0_ST_PL023, SSP_CR0(pl022->virtbase));
 		writew(DEFAULT_SSP_REG_CR1_ST_PL023, SSP_CR1(pl022->virtbase));
 	} else if (pl022->vendor->extended_cr) {
+#ifdef CONFIG_ARCH_HISI_BVT
+		struct amba_device *adev = pl022->adev;
+		struct amba_driver *adrv = container_of(adev->dev.driver,
+				struct amba_driver, drv);
+
+		if (adev->periphid == adrv->id_table[PL022_IDS_INDEX_HISI].id) {
+			writew(DEFAULT_SSP_REG_CR0, SSP_CR0(pl022->virtbase));
+			writew(DEFAULT_SSP_REG_CR1_HISI,
+					SSP_CR1(pl022->virtbase));
+		} else {
+#endif
 		writel(DEFAULT_SSP_REG_CR0_ST, SSP_CR0(pl022->virtbase));
 		writew(DEFAULT_SSP_REG_CR1_ST, SSP_CR1(pl022->virtbase));
+#ifdef CONFIG_ARCH_HISI_BVT
+		}
+#endif
 	} else {
 		writew(DEFAULT_SSP_REG_CR0, SSP_CR0(pl022->virtbase));
 		writew(DEFAULT_SSP_REG_CR1, SSP_CR1(pl022->virtbase));
@@ -1138,7 +1226,7 @@ static int pl022_dma_probe(struct pl022 *pl022)
 	if (!pl022->dummypage)
 		goto err_no_dummypage;
 
-	dev_info(&pl022->adev->dev, "setup for DMA on RX %s, TX %s\n",
+	dev_dbg(&pl022->adev->dev, "setup for DMA on RX %s, TX %s\n",
 		 dma_chan_name(pl022->dma_rx_channel),
 		 dma_chan_name(pl022->dma_tx_channel));
 
@@ -1563,11 +1651,10 @@ static void do_polling_transfer(struct pl022 *pl022)
 
 		/* Update total byte transferred */
 		message->actual_length += pl022->cur_transfer->len;
+		if (pl022->cur_transfer->cs_change)
+			pl022_cs_control(pl022, SSP_CHIP_DESELECT);
 		/* Move to next transfer */
 		message->state = next_transfer(pl022);
-		if (message->state != STATE_DONE
-		    && pl022->cur_transfer->cs_change)
-			pl022_cs_control(pl022, SSP_CHIP_DESELECT);
 	}
 out:
 	/* Handle end of message */
@@ -1855,6 +1942,13 @@ static int pl022_setup(struct spi_device *spi)
 	unsigned int bits = spi->bits_per_word;
 	u32 tmp;
 	struct device_node *np = spi->dev.of_node;
+#ifdef CONFIG_ARCH_HISI_BVT
+	struct amba_device *adev = pl022->adev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
+	writel(0, SSP_TX_FIFO_CR(pl022->virtbase));
+	writel(0, SSP_RX_FIFO_CR(pl022->virtbase));
+#endif
 
 	if (!spi->max_speed_hz)
 		return -EINVAL;
@@ -1997,7 +2091,12 @@ static int pl022_setup(struct spi_device *spi)
 	chip->cpsr = clk_freq.cpsdvsr;
 
 	/* Special setup for the ST micro extended control registers */
+#ifdef CONFIG_ARCH_HISI_BVT
+	if (pl022->vendor->extended_cr && (adev->periphid !=
+				adrv->id_table[PL022_IDS_INDEX_HISI].id)) {
+#else
 	if (pl022->vendor->extended_cr) {
+#endif
 		u32 etx;
 
 		if (pl022->vendor->pl023) {
@@ -2031,6 +2130,22 @@ static int pl022_setup(struct spi_device *spi)
 			       SSP_CR1_MASK_RXIFLSEL_ST, 7);
 		SSP_WRITE_BITS(chip->cr1, chip_info->tx_lev_trig,
 			       SSP_CR1_MASK_TXIFLSEL_ST, 10);
+#ifdef CONFIG_ARCH_HISI_BVT
+	} else if (pl022->vendor->extended_cr && (adev->periphid ==
+				adrv->id_table[PL022_IDS_INDEX_HISI].id)) {
+		SSP_WRITE_BITS(chip->cr0, bits - 1,
+			       SSP_CR0_MASK_DSS, 0);
+		SSP_WRITE_BITS(chip->cr0, chip_info->iface,
+			       SSP_CR0_MASK_FRF, 4);
+
+		if (spi->mode & SPI_LSB_FIRST)
+			tmp = !!SPI_LSB_FIRST;
+		else
+			tmp = !SPI_LSB_FIRST;
+
+		SSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_BIGEND_HISI, 4);
+		SSP_WRITE_BITS(chip->cr1, 0x1, SSP_CR1_MASK_ALTASENS_HISI, 6);
+#endif
 	} else {
 		SSP_WRITE_BITS(chip->cr0, bits - 1,
 			       SSP_CR0_MASK_DSS, 0);
@@ -2119,6 +2234,8 @@ pl022_platform_data_dt_get(struct device *dev)
 static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 {
 	struct device *dev = &adev->dev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
 	struct pl022_ssp_controller *platform_info =
 			dev_get_platdata(&adev->dev);
 	struct spi_master *master;
@@ -2126,7 +2243,7 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 	struct device_node *np = adev->dev.of_node;
 	int status = 0, i, num_cs;
 
-	dev_info(&adev->dev,
+	dev_dbg(&adev->dev,
 		 "ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);
 	if (!platform_info && IS_ENABLED(CONFIG_OF))
 		platform_info = pl022_platform_data_dt_get(dev);
@@ -2182,6 +2299,43 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 	} else if (pl022->vendor->internal_cs_ctrl) {
 		for (i = 0; i < num_cs; i++)
 			pl022->chipselects[i] = i;
+
+#ifdef CONFIG_ARCH_HISI_BVT
+		if ((adev->periphid == adrv->id_table[PL022_IDS_INDEX_HISI].id)
+				&& pl022->vendor->extended_cr
+				&& (num_cs > 1)) {
+			pl022->cs_data = devm_kzalloc(dev,
+					sizeof(struct cs_data),
+					GFP_KERNEL);
+			if (!pl022->cs_data) {
+				status = -ENOMEM;
+				goto err_no_mem;
+			}
+
+			if (of_address_to_resource(np, 1,
+						&pl022->cs_data->res)) {
+				status = -EPROBE_DEFER;
+				goto err_no_gpio;
+			}
+
+			if (of_property_read_u32(np, "hisi,spi_cs_sb",
+						&pl022->cs_data->cs_sb)) {
+				status = -EPROBE_DEFER;
+				goto err_no_gpio;
+			}
+
+			if (of_property_read_u32(np, "hisi,spi_cs_mask_bit",
+						&pl022->cs_data->cs_mask_bit)) {
+				status = -EPROBE_DEFER;
+				goto err_no_gpio;
+			}
+
+			pl022->cs_data->virt_addr = devm_ioremap(dev,
+					pl022->cs_data->res.start,
+					resource_size(&pl022->cs_data->res));
+		} else
+				pl022->cs_data = NULL;
+#endif
 	} else if (IS_ENABLED(CONFIG_OF)) {
 		for (i = 0; i < num_cs; i++) {
 			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
@@ -2227,7 +2381,7 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 		status = -ENOMEM;
 		goto err_no_ioremap;
 	}
-	dev_info(&adev->dev, "mapped registers from %pa to %p\n",
+	dev_dbg(&adev->dev, "mapped registers from %pa to %p\n",
 		&adev->res.start, pl022->virtbase);
 
 	pl022->clk = devm_clk_get(&adev->dev, NULL);
@@ -2287,7 +2441,7 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 
 	/* let runtime pm put suspend */
 	if (platform_info->autosuspend_delay > 0) {
-		dev_info(&adev->dev,
+		dev_dbg(&adev->dev,
 			"will use autosuspend for runtime pm, delay %dms\n",
 			platform_info->autosuspend_delay);
 		pm_runtime_set_autosuspend_delay(dev,
@@ -2308,6 +2462,10 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
  err_no_ioremap:
 	amba_release_regions(adev);
  err_no_ioregion:
+#ifdef CONFIG_ARCH_HISI_BVT
+	if (pl022->cs_data)
+		devm_iounmap(&adev->dev, pl022->cs_data->virt_addr);
+#endif
  err_no_gpio:
  err_no_mem:
 	spi_master_put(master);
@@ -2334,6 +2492,10 @@ pl022_remove(struct amba_device *adev)
 
 	clk_disable_unprepare(pl022->clk);
 	amba_release_regions(adev);
+#ifdef CONFIG_ARCH_HISI_BVT
+	if (pl022->cs_data)
+		devm_iounmap(&adev->dev, pl022->cs_data->virt_addr);
+#endif
 	tasklet_disable(&pl022->pump_transfers);
 	return 0;
 }
@@ -2445,6 +2607,17 @@ static struct vendor_data vendor_lsi = {
 	.internal_cs_ctrl = true,
 };
 
+#ifdef CONFIG_ARCH_HISI_BVT
+static struct vendor_data vendor_hisi = {
+	.fifodepth = 256,
+	.max_bpw = 16,
+	.unidir = false,
+	.extended_cr = true,
+	.pl023 = false,
+	.loopback = true,
+	.internal_cs_ctrl = true,
+};
+#endif
 static const struct amba_id pl022_ids[] = {
 	{
 		/*
@@ -2485,6 +2658,17 @@ static const struct amba_id pl022_ids[] = {
 		.mask	= 0x000fffff,
 		.data	= &vendor_lsi,
 	},
+#ifdef CONFIG_ARCH_HISI_BVT
+	{
+		/*
+		 * Hisilicon derivative, this has a 16bit wide
+		 * and 256 locations deep TX/RX FIFO
+		 */
+		.id	= 0x00800022,
+		.mask	= 0xffffffff,
+		.data	= &vendor_hisi,
+	},
+#endif
 	{ 0, 0 },
 };
 
diff --git a/drivers/tty/vt/vc_screen.c b/drivers/tty/vt/vc_screen.c
index 1850bacdb..d3934eb8f 100644
--- a/drivers/tty/vt/vc_screen.c
+++ b/drivers/tty/vt/vc_screen.c
@@ -373,6 +373,9 @@ vcs_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 	loff_t pos;
 	bool viewed, attr, uni_mode;
 
+	if (use_unicode(inode))
+		return -EOPNOTSUPP;
+
 	con_buf = (char *) __get_free_page(GFP_KERNEL);
 	if (!con_buf)
 		return -ENOMEM;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 95a9bae72..ad951a1a1 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1419,6 +1419,10 @@ static int hub_configure(struct usb_hub *hub,
 		ret = -ENODEV;
 		goto fail;
 	} else if (hub->descriptor->bNbrPorts == 0) {
+		if (!hdev->parent) {
+			dev_info(hub_dev, "hub can't support USB3.0\n");
+			return -ENODEV;
+		}
 		message = "hub doesn't have any ports!";
 		ret = -ENODEV;
 		goto fail;
diff --git a/drivers/usb/core/notify.c b/drivers/usb/core/notify.c
index e61436637..b507a25ce 100644
--- a/drivers/usb/core/notify.c
+++ b/drivers/usb/core/notify.c
@@ -66,3 +66,11 @@ void usb_notify_remove_bus(struct usb_bus *ubus)
 {
 	blocking_notifier_call_chain(&usb_notifier_list, USB_BUS_REMOVE, ubus);
 }
+void usb_notify_online_status(bool online)
+{
+	if (online) {
+		blocking_notifier_call_chain(&usb_notifier_list, USB_GADGET_ADD, NULL);
+	} else {
+		blocking_notifier_call_chain(&usb_notifier_list, USB_GADGET_REMOVE, NULL);
+	}
+}
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index ae86da0dc..9abca9a8a 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -2,10 +2,9 @@
 # define_trace.h needs to know how to find our header
 CFLAGS_trace.o				:= -I$(src)
 
-obj-$(CONFIG_USB_DWC3)			+= dwc3.o
-
-dwc3-y					:= core.o
+obj-$(CONFIG_USB_DWC3)			+= dwc3.o dwc3-hisi.o
 
+dwc3-y					:= core.o proc.o
 ifneq ($(CONFIG_TRACING),)
 	dwc3-y				+= trace.o
 endif
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 1580d51ae..1219a6487 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -37,9 +37,25 @@
 #include "io.h"
 
 #include "debug.h"
+#include "dwc3-hisi.h"
 
 #define DWC3_DEFAULT_AUTOSUSPEND_DELAY	5000 /* ms */
 
+
+/*
+ * Default to the number of outstanding pipelined transfer
+ * requests is 0x3[11:8], modify the field change to 0x7.
+ */
+static void dwc3_outstanding_pipe_choose(struct dwc3 *dwc)
+{
+	u32	reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_GSBUSCFG1);
+	reg &= ~DWC3_PIPE_TRANS_LIMIT_MASK;
+	reg |= DWC3_PIPE_TRANS_LIMIT;
+	dwc3_writel(dwc->regs, DWC3_GSBUSCFG1, reg);
+}
+
 /**
  * dwc3_get_dr_mode - Validates and sets dr_mode
  * @dwc: pointer to our context structure
@@ -1294,7 +1310,8 @@ static void dwc3_get_properties(struct dwc3 *dwc)
 	 */
 	hird_threshold = 12;
 
-	dwc->maximum_speed = usb_get_maximum_speed(dev);
+	dwc->maximum_speed = usb_get_max_speed(dev);
+
 	dwc->dr_mode = usb_get_dr_mode(dev);
 	dwc->hsphy_mode = of_usb_get_phy_mode(dev->of_node);
 
@@ -1330,6 +1347,9 @@ static void dwc3_get_properties(struct dwc3 *dwc)
 	device_property_read_u8(dev, "snps,tx-max-burst-prd",
 				&tx_max_burst_prd);
 
+	dwc->usb2_lpm_disable = device_property_read_bool(dev,
+				"snps,usb2-lpm-disable");
+
 	dwc->disable_scramble_quirk = device_property_read_bool(dev,
 				"snps,disable_scramble_quirk");
 	dwc->u2exit_lfps_quirk = device_property_read_bool(dev,
@@ -1367,6 +1387,16 @@ static void dwc3_get_properties(struct dwc3 *dwc)
 	dwc->parkmode_disable_ss_quirk = device_property_read_bool(dev,
 				"snps,parkmode-disable-ss-quirk");
 
+	dwc->dis_initiate_u1 = device_property_read_bool(dev,
+				"snps,dis_initiate_u1");
+	dwc->dis_initiate_u2 = device_property_read_bool(dev,
+				"snps,dis_initiate_u2");
+
+	dwc->eps_new_init = device_property_read_bool(dev,
+				"snps,eps_new_init");
+	device_property_read_u32(dev, "eps_directions",
+				 &dwc->eps_directions);
+
 	dwc->tx_de_emphasis_quirk = device_property_read_bool(dev,
 				"snps,tx_de_emphasis_quirk");
 	device_property_read_u8(dev, "snps,tx_de_emphasis",
@@ -1550,6 +1580,10 @@ static int dwc3_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dwc);
 	dwc3_cache_hwparams(dwc);
 
+	device_property_read_u32_array(dev, "eps_map",
+					dwc->dwceps_map_to_usbeps,
+					DWC3_NUM_EPS(&dwc->hwparams));
+
 	spin_lock_init(&dwc->lock);
 	mutex_init(&dwc->mutex);
 
@@ -1585,6 +1619,8 @@ static int dwc3_probe(struct platform_device *pdev)
 		goto err4;
 	}
 
+	dwc3_outstanding_pipe_choose(dwc);
+
 	dwc3_check_params(dwc);
 	dwc3_debugfs_init(dwc);
 
@@ -1652,6 +1688,10 @@ static int dwc3_remove(struct platform_device *pdev)
 	dwc3_free_event_buffers(dwc);
 	dwc3_free_scratch_buffers(dwc);
 
+	hisi_dwc3_exited();
+
+	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_HOST);
+
 	return 0;
 }
 
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 79e1b82e5..ace408a7e 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -32,6 +32,8 @@
 #include <linux/phy/phy.h>
 
 #define DWC3_MSG_MAX	500
+#define DWC3_PIPE_TRANS_LIMIT_MASK	(0xf << 8)
+#define DWC3_PIPE_TRANS_LIMIT		(0x7 << 8)
 
 /* Global constants */
 #define DWC3_PULL_UP_TIMEOUT	500	/* ms */
@@ -478,6 +480,9 @@
 
 #define DWC3_DSTS_RXFIFOEMPTY		BIT(17)
 
+#define DWC3_EVENT_PRAM_MAX_SOFFN	0x3fff
+#define DWC3_EVENT_PRAM_SOFFN_MASK  0x3fff
+
 #define DWC3_DSTS_SOFFN_MASK		(0x3fff << 3)
 #define DWC3_DSTS_SOFFN(n)		(((n) & DWC3_DSTS_SOFFN_MASK) >> 3)
 
@@ -658,7 +663,7 @@ struct dwc3_event_buffer {
 #define DWC3_EP_DIRECTION_TX	true
 #define DWC3_EP_DIRECTION_RX	false
 
-#define DWC3_TRB_NUM		256
+#define DWC3_TRB_NUM		4096
 
 /**
  * struct dwc3_ep - device side endpoint representation
@@ -726,8 +731,8 @@ struct dwc3_ep {
 	 * By using u8 types we ensure that our % operator when incrementing
 	 * enqueue and dequeue get optimized away by the compiler.
 	 */
-	u8			trb_enqueue;
-	u8			trb_dequeue;
+	u32			trb_enqueue;
+	u32			trb_dequeue;
 
 	u8			number;
 	u8			type;
@@ -1092,6 +1097,8 @@ struct dwc3 {
 	struct dwc3_event_buffer *ev_buf;
 	struct dwc3_ep		*eps[DWC3_ENDPOINTS_NUM];
 
+	u32			dwceps_map_to_usbeps[DWC3_ENDPOINTS_NUM];
+
 	struct usb_gadget	*gadget;
 	struct usb_gadget_driver *gadget_driver;
 
@@ -1199,6 +1206,12 @@ struct dwc3 {
 	u8			speed;
 
 	u8			num_eps;
+/*
+ * NOTICE: eps_directions bitmap[0~31] 0: out ep, 1: in ep
+ * and used with total ep numbers(num_out_eps + num_in_eps)
+ */
+#define DWC3_EPS_DEFAULT_DIRECTIONS 0xaaaaaaaa
+	u32			eps_directions;
 
 	struct dwc3_hwparams	hwparams;
 	struct dentry		*root;
@@ -1215,6 +1228,13 @@ struct dwc3 {
 	u8			tx_thr_num_pkt_prd;
 	u8			tx_max_burst_prd;
 
+	struct proc_dir_entry* parent_entry;
+	struct proc_dir_entry* csts_entry;
+	u8			udc_connect_status;
+#define UDC_DISCONNECTED 	0
+#define UDC_CONNECT_HOST 	1
+#define UDC_CONNECT_CHARGER	2
+
 	const char		*hsphy_interface;
 
 	unsigned		connected:1;
@@ -1253,6 +1273,10 @@ struct dwc3 {
 	unsigned		dis_del_phy_power_chg_quirk:1;
 	unsigned		dis_tx_ipgap_linecheck_quirk:1;
 	unsigned		parkmode_disable_ss_quirk:1;
+	unsigned		dis_initiate_u1:1;
+	unsigned		dis_initiate_u2:1;
+
+	unsigned		eps_new_init:1;
 
 	unsigned		tx_de_emphasis_quirk:1;
 	unsigned		tx_de_emphasis:2;
@@ -1519,6 +1543,9 @@ static inline void dwc3_otg_host_init(struct dwc3 *dwc)
 { }
 #endif
 
+int dwc3_proc_init(struct dwc3 *dwc);
+int dwc3_proc_shutdown(struct dwc3 *dwc);
+
 /* power management interface */
 #if !IS_ENABLED(CONFIG_USB_DWC3_HOST)
 int dwc3_gadget_suspend(struct dwc3 *dwc);
diff --git a/drivers/usb/dwc3/dwc3-hisi.c b/drivers/usb/dwc3/dwc3-hisi.c
new file mode 100644
index 000000000..d8d3e8377
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-hisi.c
@@ -0,0 +1,446 @@
+/*
+ * dwc3-hisi.c
+ *
+ * Dwc3 private driver for Hisilicon.
+ *
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2018-2019. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/usb/ch9.h>
+
+#include "dwc3-hisi.h"
+
+#define USB3_CTRL           0x190
+#define REG_SYS_STAT        0x8c
+#define PCIE_USB3_MODE_MASK (0x3 << 12)
+#define USB3_PCLK_OCC_SEL   (0x1 << 30)
+
+#define PERI_USB3_GTXTHRCFG 0x2310000
+
+#define REG_GUSB3PIPECTL0 0xc2c0
+#define GTXTHRCFG         0xc108
+
+#define PCS_SSP_SOFT_RESET  (0x1 << 31)
+#define SUSPEND_USB3_SS_PHY (0x1 << 17)
+
+#define GUSB2PHYCFG_OFFSET 0xc200
+#define GCTL_OFFSET        0xc110
+#define GUCTL_OFFSET       0xc12C
+#define GFLADJ_OFFSET      0xc630
+
+#define U2_FREECLK_EXISTS (0x1 << 30)
+#define SOFITPSYNC        (0x1 << 10)
+#define REFCLKPER_MASK    0xffc00000
+#define REFCLKPER_VAL	0x29
+#define set_refclkper(a)  (((a) << 22) & REFCLKPER_MASK)
+
+#define PLS1        (0x1 << 31)
+#define DECR_MASK   0x7f000000
+#define DECR_VAL	0xa
+#define set_decr(a) (((a) << 24) & DECR_MASK)
+
+#define LPM_SEL      (0x1 << 23)
+#define FLADJ_MASK   0x003fff00
+#define FLADJ_VAL	0x7f0
+#define set_fladj(a) (((a) << 8) & FLADJ_MASK)
+
+/* hi3559a */
+#define DOUBLE_PCIE_MODE    0x0
+#define P0_PCIE_ADD_P1_USB3 (0x1 << 12)
+#define DOUBLE_USB3         (0x2 << 12)
+
+/* hi3556a,hi3519a */
+#define PCIE_X1_MODE (0x0 << 12)
+#define USB3_MODE    (0x1 << 12)
+
+static struct hi_priv *usb_priv = NULL;
+
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3569V100)
+static int speed_adapt_for_hi3559a(struct device_node *np)
+{
+	unsigned int ret;
+	unsigned int reg;
+
+	if (np == NULL)
+		return -EINVAL;
+
+	usb_priv->speed_id = -1;
+
+	reg = readl(usb_priv->sys_ctrl + REG_SYS_STAT);
+	reg &= PCIE_USB3_MODE_MASK;
+
+	switch (reg) {
+	case DOUBLE_PCIE_MODE:
+		ret = USB_SPEED_HIGH;
+		break;
+	case P0_PCIE_ADD_P1_USB3:
+		if (of_property_read_u32(np, "port_speed", &usb_priv->speed_id))
+			usb_priv->speed_id = -1;
+
+		if (usb_priv->speed_id == 0)
+			ret = USB_SPEED_HIGH;
+		else if (usb_priv->speed_id == 1)
+			ret = USB_SPEED_SUPER;
+		else
+			ret = USB_SPEED_UNKNOWN;
+
+		break;
+	case DOUBLE_USB3:
+		ret = USB_SPEED_SUPER;
+		break;
+	default:
+		ret = USB_SPEED_UNKNOWN;
+	}
+
+	return ret;
+}
+#endif
+
+#if defined(CONFIG_ARCH_HI3556AV100) || defined(CONFIG_ARCH_HI3519AV100)
+static int speed_adapt_for_hi3556a(struct device *dev)
+{
+	unsigned int ret;
+	unsigned int reg;
+
+	if (dev == NULL)
+		return -EINVAL;
+
+	reg = readl(usb_priv->sys_ctrl + REG_SYS_STAT);
+	reg &= PCIE_USB3_MODE_MASK;
+
+	if (reg == PCIE_X1_MODE)
+		ret = USB_SPEED_HIGH;
+	else
+		ret = usb_get_maximum_speed(dev);
+
+	return ret;
+}
+#endif
+
+int usb_get_max_speed(struct device *dev)
+{
+	unsigned int ret;
+	struct device_node *np = dev->of_node;
+
+	if (np == NULL)
+		return -EINVAL;
+
+	usb_priv = kzalloc(sizeof(*usb_priv), GFP_KERNEL);
+	if (usb_priv == NULL)
+		return -ENOMEM;
+
+	usb_priv->peri_crg = of_iomap(np, DEV_NODE_FLAG1);
+	if (IS_ERR(usb_priv->peri_crg)) {
+		kfree(usb_priv);
+		usb_priv = NULL;
+		return -ENOMEM;
+	}
+
+	usb_priv->sys_ctrl = of_iomap(np, DEV_NODE_FLAG2);
+	if (IS_ERR(usb_priv->sys_ctrl)) {
+		iounmap(usb_priv->peri_crg);
+
+		kfree(usb_priv);
+		usb_priv = NULL;
+		return -ENOMEM;
+	}
+
+#if defined(CONFIG_ARCH_HI3559AV100) || defined(CONFIG_ARCH_HI3569V100)
+	ret = speed_adapt_for_hi3559a(np);
+#elif defined(CONFIG_ARCH_HI3556AV100) || defined(CONFIG_ARCH_HI3519AV100)
+	ret = speed_adapt_for_hi3556a(dev);
+#else
+	ret = usb_get_maximum_speed(dev);
+#endif
+
+	iounmap(usb_priv->sys_ctrl);
+	iounmap(usb_priv->peri_crg);
+
+	return ret;
+}
+EXPORT_SYMBOL(usb_get_max_speed);
+
+void hisi_dwc3_exited(void)
+{
+	kfree(usb_priv);
+	usb_priv = NULL;
+}
+EXPORT_SYMBOL(hisi_dwc3_exited);
+
+static int set_ctrl_crg_val(struct device_node *np, struct dwc3_hisi *hisi)
+{
+	unsigned int ret;
+	unsigned int reg;
+
+	if ((np == NULL) || (hisi == NULL))
+		return -EINVAL;
+
+	/* get usb ctrl crg para */
+	ret = of_property_read_u32(np, "crg_offset", &hisi->crg_offset);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(np, "crg_ctrl_def_mask", &hisi->crg_ctrl_def_mask);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(np, "crg_ctrl_def_val", &hisi->crg_ctrl_def_val);
+	if (ret)
+		return ret;
+
+	/* write usb ctrl crg default value */
+	reg = readl(hisi->crg_base + hisi->crg_offset);
+	reg &= ~hisi->crg_ctrl_def_mask;
+	reg |= hisi->crg_ctrl_def_val;
+	writel(reg, hisi->crg_base + hisi->crg_offset);
+
+	return 0;
+}
+
+static int dwc3_hisi_clk_init(struct dwc3_hisi *hisi, int count)
+{
+	struct device *dev = hisi->dev;
+	struct device_node *np = dev->of_node;
+	int i, ret;
+
+	if (!count)
+		return -EINVAL;
+
+	if (np == NULL)
+		return -EINVAL;
+
+	hisi->num_clocks = count;
+
+	hisi->clks = devm_kcalloc(dev, hisi->num_clocks, sizeof(struct clk *),
+				  GFP_KERNEL);
+	if (hisi->clks == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < hisi->num_clocks; i++) {
+		struct clk *clk;
+
+		clk = of_clk_get(np, i);
+		if (IS_ERR(clk)) {
+			while (--i >= 0)
+				clk_put(hisi->clks[i]);
+
+			ret = PTR_ERR(clk);
+			goto clk_free;
+		}
+
+		ret = clk_prepare_enable(clk);
+		if (ret < 0) {
+			while (--i >= 0) {
+				clk_disable_unprepare(hisi->clks[i]);
+				clk_put(hisi->clks[i]);
+			}
+			clk_put(clk);
+
+			goto clk_free;
+		}
+
+		hisi->clks[i] = clk;
+	}
+
+	return 0;
+clk_free:
+	devm_kfree(dev, hisi->clks);
+	hisi->clks = NULL;
+
+	return ret;
+}
+
+static void control_free_clk_config(struct dwc3_hisi *hisi)
+{
+	unsigned int reg;
+
+	if (hisi == NULL)
+		return;
+
+	reg = readl(hisi->ctrl_base + GUSB2PHYCFG_OFFSET);
+	reg &= ~U2_FREECLK_EXISTS;
+	writel(reg, hisi->ctrl_base + GUSB2PHYCFG_OFFSET);
+
+	reg = readl(hisi->ctrl_base + GCTL_OFFSET);
+	reg &= ~SOFITPSYNC;
+	writel(reg, hisi->ctrl_base + GCTL_OFFSET);
+
+	reg = readl(hisi->ctrl_base + GUCTL_OFFSET);
+	reg &= ~REFCLKPER_MASK;
+	reg |= set_refclkper(REFCLKPER_VAL);
+	writel(reg, hisi->ctrl_base + GUCTL_OFFSET);
+
+	reg = readl(hisi->ctrl_base + GFLADJ_OFFSET);
+	reg &= ~PLS1;
+	writel(reg, hisi->ctrl_base + GFLADJ_OFFSET);
+
+	reg = readl(hisi->ctrl_base + GFLADJ_OFFSET);
+	reg &= ~DECR_MASK;
+	reg |= set_decr(DECR_VAL);
+	writel(reg, hisi->ctrl_base + GFLADJ_OFFSET);
+
+	reg = readl(hisi->ctrl_base + GFLADJ_OFFSET);
+	reg |= LPM_SEL;
+	writel(reg, hisi->ctrl_base + GFLADJ_OFFSET);
+
+	reg = readl(hisi->ctrl_base + GFLADJ_OFFSET);
+	reg &= ~FLADJ_MASK;
+	reg |= set_fladj(FLADJ_VAL);
+	writel(reg, hisi->ctrl_base + GFLADJ_OFFSET);
+}
+
+static int dwc3_hisi_iomap(struct device_node *np, struct dwc3_hisi *hisi)
+{
+	if ((np == NULL) || (hisi == NULL))
+		return -EINVAL;
+
+	hisi->ctrl_base = of_iomap(np, DEV_NODE_FLAG0);
+	if (IS_ERR(hisi->ctrl_base))
+		return -ENOMEM;
+
+	hisi->crg_base = of_iomap(np, DEV_NODE_FLAG1);
+	if (IS_ERR(hisi->crg_base)) {
+		iounmap(hisi->ctrl_base);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int dwc3_hisi_probe(struct platform_device *pdev)
+{
+	struct dwc3_hisi *hisi = NULL;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret, i;
+
+	hisi = devm_kzalloc(dev, sizeof(*hisi), GFP_KERNEL);
+	if (hisi == NULL)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, hisi);
+	hisi->dev = dev;
+
+	ret = dwc3_hisi_iomap(np, hisi);
+	if (ret) {
+		devm_kfree(dev, hisi);
+		hisi = NULL;
+
+		return -ENOMEM;
+	}
+
+	hisi->port_rst = devm_reset_control_get(dev, "vcc_reset");
+	if (IS_ERR_OR_NULL(hisi->port_rst)) {
+		ret = PTR_ERR(hisi->port_rst);
+		goto hidwc3_unmap;
+	}
+
+	ret = set_ctrl_crg_val(np, hisi);
+	if (ret)
+		goto hidwc3_unmap;
+
+	reset_control_assert(hisi->port_rst);
+
+	ret = dwc3_hisi_clk_init(hisi, of_clk_get_parent_count(np));
+	if (ret)
+		goto hidwc3_unmap;
+
+	reset_control_deassert(hisi->port_rst);
+
+	control_free_clk_config(hisi);
+
+	udelay(U_LEVEL2);
+
+	ret = of_platform_populate(np, NULL, NULL, dev);
+	if (ret) {
+		for (i = 0; i < hisi->num_clocks; i++) {
+			clk_disable_unprepare(hisi->clks[i]);
+			clk_put(hisi->clks[i]);
+		}
+		goto hidwc3_unmap;
+	}
+
+	return 0;
+hidwc3_unmap:
+	iounmap(hisi->ctrl_base);
+	iounmap(hisi->crg_base);
+
+	devm_kfree(dev, hisi);
+	hisi = NULL;
+
+	return ret;
+}
+
+static int dwc3_hisi_remove(struct platform_device *pdev)
+{
+	struct dwc3_hisi *hisi = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+	int i;
+
+	for (i = 0; i < hisi->num_clocks; i++) {
+		clk_disable_unprepare(hisi->clks[i]);
+		clk_put(hisi->clks[i]);
+	}
+
+	reset_control_assert(hisi->port_rst);
+
+	of_platform_depopulate(dev);
+
+	iounmap(hisi->ctrl_base);
+	iounmap(hisi->crg_base);
+
+	devm_kfree(dev, hisi);
+	hisi = NULL;
+
+	return 0;
+}
+
+static const struct of_device_id hisi_dwc3_match[] = {
+	{ .compatible = "hisi,dwusb2" },
+	{ .compatible = "hisi,dwusb3" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, hisi_dwc3_match);
+
+static struct platform_driver dwc3_hisi_driver = {
+	.probe = dwc3_hisi_probe,
+	.remove = dwc3_hisi_remove,
+	.driver = {
+		.name = "hisi-dwc3",
+		.of_match_table = hisi_dwc3_match,
+	},
+};
+module_platform_driver(dwc3_hisi_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("DesignWare USB3 of Hisilicon");
+MODULE_AUTHOR("Hisilicon Technologies Co., Ltd..>");
diff --git a/drivers/usb/dwc3/dwc3-hisi.h b/drivers/usb/dwc3/dwc3-hisi.h
new file mode 100644
index 000000000..606cf0507
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-hisi.h
@@ -0,0 +1,54 @@
+/*
+ * dwc3-hisi.h
+ *
+ * Dwc3 private headerfile for Hisilicon.
+ *
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2018-2019. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef USB_INCLUDE_DWC3_HISI_H
+#define USB_INCLUDE_DWC3_HISI_H
+
+struct hi_priv {
+	void __iomem *peri_crg;
+	void __iomem *sys_ctrl;
+	void __iomem *misc_ctrl;
+	unsigned int speed_id;
+};
+
+struct dwc3_hisi {
+	struct device *dev;
+	struct clk **clks;
+	int num_clocks;
+	void __iomem *ctrl_base;
+	void __iomem *crg_base;
+	struct reset_control *port_rst;
+	u32 crg_offset;
+	u32 crg_ctrl_def_mask;
+	u32 crg_ctrl_def_val;
+};
+
+extern int usb_get_max_speed(struct device *dev);
+extern void hisi_dwc3_exited(void);
+
+#define DEV_NODE_FLAG0	0
+#define DEV_NODE_FLAG1	1
+#define DEV_NODE_FLAG2	2
+
+#define U_LEVEL2	200
+
+#endif
diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c
index 3cd294264..edf3f9b59 100644
--- a/drivers/usb/dwc3/ep0.c
+++ b/drivers/usb/dwc3/ep0.c
@@ -281,6 +281,24 @@ void dwc3_ep0_out_start(struct dwc3 *dwc)
 	WARN_ON(ret < 0);
 }
 
+static u32 dwc3_usbep_to_dwc3ep(struct dwc3 *dwc, u32 num)
+{
+	u32 res = 0;
+	int i;
+
+	if (!dwc)
+		return 0;
+
+	for (i = 0; i < dwc->num_eps; i++) {
+		if (dwc->dwceps_map_to_usbeps[i] == num) {
+			res = i;
+			break;
+		}
+	}
+
+	return res;
+}
+
 static struct dwc3_ep *dwc3_wIndex_to_dep(struct dwc3 *dwc, __le16 wIndex_le)
 {
 	struct dwc3_ep		*dep;
@@ -291,6 +309,9 @@ static struct dwc3_ep *dwc3_wIndex_to_dep(struct dwc3 *dwc, __le16 wIndex_le)
 	if ((windex & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
 		epnum |= 1;
 
+	if (dwc->eps_new_init)
+		epnum = dwc3_usbep_to_dwc3ep(dwc, epnum);
+
 	dep = dwc->eps[epnum];
 	if (dep == NULL)
 		return NULL;
@@ -385,6 +406,9 @@ static int dwc3_ep0_handle_u1(struct dwc3 *dwc, enum usb_device_state state,
 	if (set && dwc->dis_u1_entry_quirk)
 		return -EINVAL;
 
+	if (dwc->dis_initiate_u1)
+		return -EINVAL;
+
 	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
 	if (set)
 		reg |= DWC3_DCTL_INITU1ENA;
@@ -409,6 +433,9 @@ static int dwc3_ep0_handle_u2(struct dwc3 *dwc, enum usb_device_state state,
 	if (set && dwc->dis_u2_entry_quirk)
 		return -EINVAL;
 
+	if (dwc->dis_initiate_u2)
+		return -EINVAL;
+
 	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
 	if (set)
 		reg |= DWC3_DCTL_INITU2ENA;
@@ -638,9 +665,14 @@ static int dwc3_ep0_set_config(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 			 * nothing is pending from application.
 			 */
 			reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-			if (!dwc->dis_u1_entry_quirk)
+			if (dwc->dis_initiate_u1)
+				reg &= (~DWC3_DCTL_ACCEPTU1ENA);
+			else
 				reg |= DWC3_DCTL_ACCEPTU1ENA;
-			if (!dwc->dis_u2_entry_quirk)
+
+			if (dwc->dis_initiate_u2)
+				reg &= (~DWC3_DCTL_ACCEPTU2ENA);
+			else
 				reg |= DWC3_DCTL_ACCEPTU2ENA;
 			dwc3_writel(dwc->regs, DWC3_DCTL, reg);
 		}
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
old mode 100644
new mode 100755
index b75fe5680..bec11c742
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -27,6 +27,8 @@
 #include "gadget.h"
 #include "io.h"
 
+static bool __dwc3_gadget_target_frame_elapsed(struct dwc3_ep *dep);
+
 #define DWC3_ALIGN_FRAME(d, n)	(((d)->frame_number + ((d)->interval * (n))) \
 					& ~((d)->interval - 1))
 
@@ -147,7 +149,7 @@ int dwc3_gadget_set_link_state(struct dwc3 *dwc, enum dwc3_link_state state)
  * if it is point to the link TRB, wrap around to the beginning. The
  * link TRB is always at the last TRB entry.
  */
-static void dwc3_ep_inc_trb(u8 *index)
+static void dwc3_ep_inc_trb(u32 *index)
 {
 	(*index)++;
 	if (*index == (DWC3_TRB_NUM - 1))
@@ -594,7 +596,11 @@ static int dwc3_gadget_set_ep_config(struct dwc3_ep *dep, unsigned int action)
 	 * so on. We consider the direction bit as part of the physical
 	 * endpoint number. So USB endpoint 0x81 is 0x03.
 	 */
-	params.param1 |= DWC3_DEPCFG_EP_NUMBER(dep->number);
+	if (dwc->eps_new_init)
+		params.param1 |=
+			DWC3_DEPCFG_EP_NUMBER(dwc->dwceps_map_to_usbeps[dep->number]);
+	else
+		params.param1 |= DWC3_DEPCFG_EP_NUMBER(dep->number);
 
 	/*
 	 * We must use the lower 16 TX FIFOs even though
@@ -665,7 +671,12 @@ static int __dwc3_gadget_ep_enable(struct dwc3_ep *dep, unsigned int action)
 		dep->flags |= DWC3_EP_ENABLED;
 
 		reg = dwc3_readl(dwc->regs, DWC3_DALEPENA);
-		reg |= DWC3_DALEPENA_EP(dep->number);
+
+		if (dwc->eps_new_init)
+			reg |= DWC3_DALEPENA_EP(dwc->dwceps_map_to_usbeps[dep->number]);
+		else
+			reg |= DWC3_DALEPENA_EP(dep->number);
+
 		dwc3_writel(dwc->regs, DWC3_DALEPENA, reg);
 
 		if (usb_endpoint_xfer_control(desc))
@@ -789,7 +800,12 @@ static int __dwc3_gadget_ep_disable(struct dwc3_ep *dep)
 		__dwc3_gadget_ep_set_halt(dep, 0, false);
 
 	reg = dwc3_readl(dwc->regs, DWC3_DALEPENA);
-	reg &= ~DWC3_DALEPENA_EP(dep->number);
+
+	if (dwc->eps_new_init)
+		reg &= ~DWC3_DALEPENA_EP(dwc->dwceps_map_to_usbeps[dep->number]);
+	else
+		reg &= ~DWC3_DALEPENA_EP(dep->number);
+
 	dwc3_writel(dwc->regs, DWC3_DALEPENA, reg);
 
 	/* Clear out the ep descriptors for non-ep0 */
@@ -920,9 +936,9 @@ static void dwc3_gadget_ep_free_request(struct usb_ep *ep,
  * index is 0, we will wrap backwards, skip the link TRB, and return
  * the one just before that.
  */
-static struct dwc3_trb *dwc3_ep_prev_trb(struct dwc3_ep *dep, u8 index)
+static struct dwc3_trb *dwc3_ep_prev_trb(struct dwc3_ep *dep, u32 index)
 {
-	u8 tmp = index;
+	u32 tmp = index;
 
 	if (!tmp)
 		tmp = DWC3_TRB_NUM - 1;
@@ -932,7 +948,7 @@ static struct dwc3_trb *dwc3_ep_prev_trb(struct dwc3_ep *dep, u8 index)
 
 static u32 dwc3_calc_trbs_left(struct dwc3_ep *dep)
 {
-	u8			trbs_left;
+	u32			trbs_left;
 
 	/*
 	 * If the enqueue & dequeue are equal then the TRB ring is either full
@@ -968,6 +984,7 @@ static void __dwc3_prepare_one_trb(struct dwc3_ep *dep, struct dwc3_trb *trb,
 	struct dwc3		*dwc = dep->dwc;
 	struct usb_gadget	*gadget = dwc->gadget;
 	enum usb_device_speed	speed = gadget->speed;
+	unsigned int chain_skip = 0;
 
 	trb->size = DWC3_TRB_SIZE_LENGTH(length);
 	trb->bpl = lower_32_bits(dma);
@@ -1016,8 +1033,19 @@ static void __dwc3_prepare_one_trb(struct dwc3_ep *dep, struct dwc3_trb *trb,
 					mult--;
 
 				trb->size |= DWC3_TRB_SIZE_PCM1(mult);
+
+				/*
+				 * If there are three transactions per mframe,
+				 * and each transcation length = 1024B, no any
+				 * chain trb needed, so skip it.
+				 */
+				if (length == (3 * maxp))
+					chain_skip = 1;
 			}
+			if (speed == USB_SPEED_SUPER)
+				chain_skip = 1;
 		} else {
+			chain_skip = 1;
 			trb->ctrl = DWC3_TRBCTL_ISOCHRONOUS;
 		}
 
@@ -1053,7 +1081,7 @@ static void __dwc3_prepare_one_trb(struct dwc3_ep *dep, struct dwc3_trb *trb,
 	if ((!no_interrupt && !chain) || must_interrupt)
 		trb->ctrl |= DWC3_TRB_CTRL_IOC;
 
-	if (chain)
+	if ((!chain_skip) && chain)
 		trb->ctrl |= DWC3_TRB_CTRL_CHN;
 	else if (dep->stream_capable && is_last)
 		trb->ctrl |= DWC3_TRB_CTRL_LST;
@@ -1167,6 +1195,9 @@ static int dwc3_prepare_last_sg(struct dwc3_ep *dep,
 static int dwc3_prepare_trbs_sg(struct dwc3_ep *dep,
 		struct dwc3_request *req)
 {
+	struct dwc3             *dwc = dep->dwc;
+	struct usb_gadget       *gadget = dwc->gadget;
+	enum usb_device_speed   speed = gadget->speed;
 	struct scatterlist *sg = req->start_sg;
 	struct scatterlist *s;
 	int		i;
@@ -1220,9 +1251,13 @@ static int dwc3_prepare_trbs_sg(struct dwc3_ep *dep,
 					num_trbs_left <= 2 &&
 					sg_dma_len(sg_next(s)) >= length))
 				must_interrupt = true;
-
-			dwc3_prepare_one_trb(dep, req, trb_length, 1, i, false,
-					must_interrupt);
+			if ((speed == USB_SPEED_HIGH) &&
+					usb_endpoint_xfer_isoc(dep->endpoint.desc))
+				dwc3_prepare_one_trb(dep, req, trb_length, 1, 0, false,
+	                    must_interrupt);
+			else
+				dwc3_prepare_one_trb(dep, req, trb_length, 1, i, false,
+						must_interrupt);
 		}
 
 		/*
@@ -1382,6 +1417,13 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)
 	if (starting) {
 		params.param0 = upper_32_bits(req->trb_dma);
 		params.param1 = lower_32_bits(req->trb_dma);
+		if (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
+			while (__dwc3_gadget_target_frame_elapsed(dep))
+				dep->frame_number = DWC3_ALIGN_FRAME(dep, 1);
+
+			dep->frame_number = DWC3_ALIGN_FRAME(dep, 1);
+		}
+
 		cmd = DWC3_DEPCMD_STARTTRANSFER;
 
 		if (dep->stream_capable)
@@ -1427,6 +1469,16 @@ static int __dwc3_gadget_get_frame(struct dwc3 *dwc)
 	return DWC3_DSTS_SOFFN(reg);
 }
 
+static bool __dwc3_gadget_target_frame_elapsed(struct dwc3_ep *dep) {
+	u16 cframe =  __dwc3_gadget_get_frame(dep->dwc);
+	u16 eframe = dep->frame_number & DWC3_EVENT_PRAM_SOFFN_MASK;
+	if (eframe == cframe)
+		return true;
+
+	return (((eframe - cframe) & DWC3_EVENT_PRAM_SOFFN_MASK)
+		> DWC3_EVENT_PRAM_MAX_SOFFN / 2);
+}
+
 /**
  * dwc3_gadget_start_isoc_quirk - workaround invalid frame number
  * @dep: isoc endpoint
@@ -1584,6 +1636,9 @@ static int __dwc3_gadget_start_isoc(struct dwc3_ep *dep)
 	}
 
 	for (i = 0; i < DWC3_ISOC_MAX_RETRIES; i++) {
+		while (__dwc3_gadget_target_frame_elapsed(dep))
+			dep->frame_number = DWC3_ALIGN_FRAME(dep, i + 1);
+
 		dep->frame_number = DWC3_ALIGN_FRAME(dep, i + 1);
 
 		ret = __dwc3_gadget_kick_transfer(dep);
@@ -1668,8 +1723,10 @@ static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
 	 */
 	if (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
 		if (!(dep->flags & DWC3_EP_PENDING_REQUEST) &&
-				!(dep->flags & DWC3_EP_TRANSFER_STARTED))
+				list_empty(&dep->started_list)) {
+			dwc3_stop_active_transfer(dep, true, true);
 			return 0;
+		}
 
 		if ((dep->flags & DWC3_EP_PENDING_REQUEST)) {
 			if (!(dep->flags & DWC3_EP_TRANSFER_STARTED))
@@ -1756,6 +1813,9 @@ static int dwc3_gadget_ep_dequeue(struct usb_ep *ep,
 
 	spin_lock_irqsave(&dwc->lock, flags);
 
+	if (list_empty(&dep->pending_list) && list_empty(&dep->started_list) )
+		goto out;
+
 	list_for_each_entry(r, &dep->cancelled_list, list) {
 		if (r == req)
 			goto out;
@@ -2679,12 +2739,77 @@ static int dwc3_gadget_init_endpoint(struct dwc3 *dwc, u8 epnum)
 	return 0;
 }
 
+static int dwc3_gadget_init_hw_all_endpoints(struct dwc3 *dwc)
+{
+	struct dwc3_ep			*dep = NULL;
+	struct dwc3_hwparams    *parms = &dwc->hwparams;
+	u32 direction = dwc->eps_directions;
+	u8 num_eps = DWC3_NUM_EPS(parms);
+	u8 num_in_eps = 0;
+	u8 num_out_eps = 0;
+	u8 epnum = 0;
+	u8 i;
+	int ret;
+
+	if (!direction)
+		direction = DWC3_EPS_DEFAULT_DIRECTIONS;
+
+	for (i = 0; i < num_eps; i++) {
+		if (direction & 0x1)
+			epnum = (num_in_eps++ << 1) + 1;
+		else
+			epnum = (num_out_eps++ << 1);
+
+		dep = kzalloc(sizeof(*dep), GFP_KERNEL);
+		if (!dep)
+			return -ENOMEM;
+
+		dep->dwc = dwc;
+		dep->number = i;
+		dep->direction = !!(direction & 0x1);
+		dep->regs = dwc->regs + DWC3_DEP_BASE(i);
+		dwc->eps[i] = dep;
+
+		snprintf(dep->name, sizeof(dep->name), "ep%d%s", epnum >> 1,
+				(epnum & 1) ? "in" : "out");
+
+		dep->endpoint.name = dep->name;
+
+		if (epnum == 0 || epnum == 1) {
+			dep->endpoint.desc = &dwc3_gadget_ep0_desc;
+			dep->endpoint.comp_desc = NULL;
+			ret = dwc3_gadget_init_control_endpoint(dep);
+		} else if (dep->direction) {
+			ret = dwc3_gadget_init_in_endpoint(dep);
+		} else {
+			ret = dwc3_gadget_init_out_endpoint(dep);
+		}
+
+		if (ret)
+		return ret;
+
+		dep->endpoint.caps.dir_in = !!(direction & 0x1);
+		dep->endpoint.caps.dir_out = !(direction & 0x1);
+		direction = (direction >> 1);
+
+		INIT_LIST_HEAD(&dep->pending_list);
+		INIT_LIST_HEAD(&dep->started_list);
+		INIT_LIST_HEAD(&dep->cancelled_list);
+	}
+
+	return 0;
+}
+
 static int dwc3_gadget_init_endpoints(struct dwc3 *dwc, u8 total)
 {
 	u8				epnum;
 
 	INIT_LIST_HEAD(&dwc->gadget->ep_list);
 
+	if (dwc->eps_new_init) {
+		return dwc3_gadget_init_hw_all_endpoints(dwc);
+	}
+
 	for (epnum = 0; epnum < total; epnum++) {
 		int			ret;
 
@@ -3640,6 +3765,7 @@ static void dwc3_gadget_interrupt(struct dwc3 *dwc,
 		break;
 	case DWC3_DEVICE_EVENT_CONNECT_DONE:
 		dwc3_gadget_conndone_interrupt(dwc);
+		usb_notify_online_status(true);
 		break;
 	case DWC3_DEVICE_EVENT_WAKEUP:
 		dwc3_gadget_wakeup_interrupt(dwc);
@@ -3661,9 +3787,11 @@ static void dwc3_gadget_interrupt(struct dwc3 *dwc,
 			 * Ignore suspend event until the gadget enters into
 			 * USB_STATE_CONFIGURED state.
 			 */
-			if (dwc->gadget->state >= USB_STATE_CONFIGURED)
+			if (dwc->gadget->state >= USB_STATE_CONFIGURED) {
 				dwc3_gadget_suspend_interrupt(dwc,
 						event->event_info);
+				usb_notify_online_status(false);
+			}	
 		}
 		break;
 	case DWC3_DEVICE_EVENT_SOF:
@@ -3892,6 +4020,7 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 		goto err3;
 	}
 
+	dwc3_proc_init(dwc);
 
 	usb_initialize_gadget(dwc->dev, dwc->gadget, dwc_gadget_release);
 	dev				= &dwc->gadget->dev;
diff --git a/drivers/usb/dwc3/proc.c b/drivers/usb/dwc3/proc.c
new file mode 100755
index 000000000..7425e0eb9
--- /dev/null
+++ b/drivers/usb/dwc3/proc.c
@@ -0,0 +1,138 @@
+/*
+ * proc.c
+ *
+ * Dwc3 private driver for Hisilicon.
+ *
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2018-2019. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+
+#include "core.h"
+
+#define DWC3_PROC_ROOT "dwc3"
+#define DWC3_PROC_CONNECTED_STATUS "csts"
+
+static struct proc_dir_entry *proc_dwc3_dir = NULL;
+static int proc_dwc3_dir_cnt = 0;
+
+static void dwc3_stats_seq_printout(struct seq_file *s)
+{
+	struct dwc3 *dwc = s->private;
+
+	switch (dwc->udc_connect_status) {
+	case UDC_CONNECT_HOST:
+		seq_puts(s, "cnt2host\n");
+		break;
+	case UDC_CONNECT_CHARGER:
+		seq_puts(s, "cnt2charger\n");
+		break;
+	default:
+		seq_puts(s, "disconnected\n");
+		break;
+	}
+}
+
+/* define parameters where showed in proc file */
+static int dwc3_stats_seq_show(struct seq_file *s, void *v)
+{
+	if (s == NULL)
+		return -EINVAL;
+
+	dwc3_stats_seq_printout(s);
+	return 0;
+}
+
+/* proc file open */
+static int dwc3_stats_proc_open(struct inode *inode, struct file *file)
+{
+	if ((inode == NULL) || (file == NULL))
+		return -EINVAL;
+
+	return single_open(file, dwc3_stats_seq_show, PDE_DATA(inode));
+};
+
+/* proc file operation */
+static const struct proc_ops dwc3_stats_proc_ops = {
+	.proc_open = dwc3_stats_proc_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+int dwc3_proc_init(struct dwc3 *dwc)
+{
+	struct proc_dir_entry *proc_entry = NULL;
+
+	if (dwc == NULL)
+		return -EINVAL;
+
+	if (proc_dwc3_dir == NULL) {
+		proc_entry = proc_mkdir(DWC3_PROC_ROOT, NULL);
+		if (proc_entry == NULL) {
+			pr_err("%s: failed to create proc file %s\n",
+			       __func__, DWC3_PROC_ROOT);
+			return 1;
+		}
+		proc_dwc3_dir = proc_entry;
+	}
+	proc_dwc3_dir_cnt++;
+
+	proc_entry = proc_mkdir(to_platform_device(dwc->dev)->name, proc_dwc3_dir);
+	if (proc_entry == NULL) {
+		pr_err("%s: failed to create proc file %s\n",
+		       __func__, to_platform_device(dwc->dev)->name);
+		return -1;
+	}
+	dwc->parent_entry = proc_entry;
+
+	proc_entry = proc_create_data(DWC3_PROC_CONNECTED_STATUS,
+				      0, dwc->parent_entry,
+				      &dwc3_stats_proc_ops, dwc);
+	if (proc_entry == NULL) {
+		pr_err("%s: failed to create proc file %s\n",
+		       __func__, DWC3_PROC_CONNECTED_STATUS);
+		return -1;
+	}
+	dwc->csts_entry = proc_entry;
+
+	/*
+	 * add here if more proc information need.
+	 */
+	return 0;
+}
+
+int dwc3_proc_shutdown(struct dwc3 *dwc)
+{
+	if (proc_dwc3_dir != NULL) {
+		remove_proc_entry(DWC3_PROC_CONNECTED_STATUS, dwc->parent_entry);
+		remove_proc_entry(to_platform_device(dwc->dev)->name, proc_dwc3_dir);
+	}
+
+	if (proc_dwc3_dir_cnt)
+		proc_dwc3_dir_cnt--;
+
+	if (proc_dwc3_dir_cnt == 0) {
+		remove_proc_entry(DWC3_PROC_ROOT, NULL);
+		proc_dwc3_dir = NULL;
+	}
+
+	return 0;
+}
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 8bec0cbf8..db79eab52 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -705,8 +705,7 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	usb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;
 	usb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
 	usb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;
-	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT |
-					    USB_BESL_SUPPORT | besl);
+	usb_ext->bmAttributes = cpu_to_le32(0x0);
 
 	/*
 	 * The Superspeed USB Capability descriptor shall be implemented by all
diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
old mode 100644
new mode 100755
index 1eb4fa2e6..02be1969b
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -67,6 +67,9 @@ struct usb_ep *usb_ep_autoconfig_ss(
 )
 {
 	struct usb_ep	*ep;
+	u8 type;
+
+	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
 	if (gadget->ops->match_ep) {
 		ep = gadget->ops->match_ep(gadget, desc, ep_comp);
@@ -75,9 +78,16 @@ struct usb_ep *usb_ep_autoconfig_ss(
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
-	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		if (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
-			goto found_ep;
+	if (type == USB_ENDPOINT_XFER_INT) {
+		list_for_each_entry_reverse(ep, &gadget->ep_list, ep_list) {
+			if (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
+				goto found_ep;
+		}
+	} else {
+		list_for_each_entry(ep, &gadget->ep_list, ep_list) {
+			if (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
+				goto found_ep;
+		}
 	}
 
 	/* Fail */
diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index 950c9435b..a92694ff6 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -307,6 +307,7 @@ struct fsg_common {
 	unsigned int		bad_lun_okay:1;
 	unsigned int		running:1;
 	unsigned int		sysfs:1;
+	unsigned int		actived:1;
 
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
@@ -1338,7 +1339,7 @@ static int do_start_stop(struct fsg_common *common)
 
 	up_read(&common->filesem);
 	down_write(&common->filesem);
-	fsg_lun_close(curlun);
+	common->actived = 0;
 	up_write(&common->filesem);
 	down_read(&common->filesem);
 
@@ -1775,7 +1776,7 @@ static int check_command(struct fsg_common *common, int cmnd_size,
 
 	/* If the medium isn't mounted and the command needs to access
 	 * it, return an error. */
-	if (curlun && !fsg_lun_is_open(curlun) && needs_medium) {
+	if (curlun && !common->actived && needs_medium) {
 		curlun->sense_data = SS_MEDIUM_NOT_PRESENT;
 		return -EINVAL;
 	}
@@ -2234,6 +2235,7 @@ static int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)
 	}
 
 	common->running = 0;
+	common->actived = 0;
 	if (!new_fsg || rc)
 		return rc;
 
@@ -2277,7 +2279,7 @@ static int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)
 		bh->inreq->complete = bulk_in_complete;
 		bh->outreq->complete = bulk_out_complete;
 	}
-
+	common->actived = 1;
 	common->running = 1;
 	for (i = 0; i < ARRAY_SIZE(common->luns); ++i)
 		if (common->luns[i])
diff --git a/drivers/usb/gadget/function/f_uac1.c b/drivers/usb/gadget/function/f_uac1.c
index e65f474ad..5bb7ce3eb 100644
--- a/drivers/usb/gadget/function/f_uac1.c
+++ b/drivers/usb/gadget/function/f_uac1.c
@@ -56,6 +56,16 @@ static inline struct f_uac1_opts *g_audio_to_uac1_opts(struct g_audio *audio)
 /* Number of streaming interfaces */
 #define F_AUDIO_NUM_INTERFACES		2
 
+static struct usb_interface_assoc_descriptor uac_iad = {
+	.bLength = sizeof(uac_iad),
+	.bDescriptorType = USB_DT_INTERFACE_ASSOCIATION,
+	.bFirstInterface = 0,
+	.bInterfaceCount = 3,
+	.bFunctionClass = USB_CLASS_AUDIO,
+	.bFunctionSubClass = 0,
+	.bFunctionProtocol = UAC_VERSION_1,
+};
+
 /* B.3.1  Standard AC Interface Descriptor */
 static struct usb_interface_descriptor ac_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
@@ -254,7 +264,46 @@ static struct uac_iso_endpoint_descriptor as_iso_in_desc = {
 	.wLockDelay =		0,
 };
 
+static struct usb_ss_ep_comp_descriptor as_ss_ep_comp = {
+	.bLength        = sizeof(as_ss_ep_comp),
+	.bDescriptorType    = USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst =		0,
+	.bmAttributes =		0,
+	.wBytesPerInterval = cpu_to_le16(UAC1_OUT_EP_MAX_PACKET_SIZE),
+};
+
 static struct usb_descriptor_header *f_audio_desc[] = {
+	(struct usb_descriptor_header *)&uac_iad,
+	(struct usb_descriptor_header *)&ac_interface_desc,
+	(struct usb_descriptor_header *)&ac_header_desc,
+
+	(struct usb_descriptor_header *)&usb_out_it_desc,
+	(struct usb_descriptor_header *)&io_out_ot_desc,
+	(struct usb_descriptor_header *)&io_in_it_desc,
+	(struct usb_descriptor_header *)&usb_in_ot_desc,
+
+	(struct usb_descriptor_header *)&as_out_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&as_out_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&as_out_header_desc,
+
+	(struct usb_descriptor_header *)&as_out_type_i_desc,
+
+	(struct usb_descriptor_header *)&as_out_ep_desc,
+	(struct usb_descriptor_header *)&as_iso_out_desc,
+
+	(struct usb_descriptor_header *)&as_in_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&as_in_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&as_in_header_desc,
+
+	(struct usb_descriptor_header *)&as_in_type_i_desc,
+
+	(struct usb_descriptor_header *)&as_in_ep_desc,
+	(struct usb_descriptor_header *)&as_iso_in_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *f_audio_ss_desc[] = {
+	(struct usb_descriptor_header *)&uac_iad,
 	(struct usb_descriptor_header *)&ac_interface_desc,
 	(struct usb_descriptor_header *)&ac_header_desc,
 
@@ -270,6 +319,7 @@ static struct usb_descriptor_header *f_audio_desc[] = {
 	(struct usb_descriptor_header *)&as_out_type_i_desc,
 
 	(struct usb_descriptor_header *)&as_out_ep_desc,
+	(struct usb_descriptor_header *)&as_ss_ep_comp,
 	(struct usb_descriptor_header *)&as_iso_out_desc,
 
 	(struct usb_descriptor_header *)&as_in_interface_alt_0_desc,
@@ -279,6 +329,7 @@ static struct usb_descriptor_header *f_audio_desc[] = {
 	(struct usb_descriptor_header *)&as_in_type_i_desc,
 
 	(struct usb_descriptor_header *)&as_in_ep_desc,
+	(struct usb_descriptor_header *)&as_ss_ep_comp,
 	(struct usb_descriptor_header *)&as_iso_in_desc,
 	NULL,
 };
@@ -567,6 +618,7 @@ static int f_audio_bind(struct usb_configuration *c, struct usb_function *f)
 	us = usb_gstrings_attach(cdev, uac1_strings, ARRAY_SIZE(strings_uac1));
 	if (IS_ERR(us))
 		return PTR_ERR(us);
+	uac_iad.iFunction = us[STR_AC_IF].id;
 	ac_interface_desc.iInterface = us[STR_AC_IF].id;
 	usb_out_it_desc.iTerminal = us[STR_USB_OUT_IT].id;
 	usb_out_it_desc.iChannelNames = us[STR_USB_OUT_IT_CH_NAMES].id;
@@ -603,6 +655,7 @@ static int f_audio_bind(struct usb_configuration *c, struct usb_function *f)
 	status = usb_interface_id(c, f);
 	if (status < 0)
 		goto fail;
+	uac_iad.bFirstInterface = status;
 	ac_interface_desc.bInterfaceNumber = status;
 	uac1->ac_intf = status;
 	uac1->ac_alt = 0;
@@ -643,8 +696,8 @@ static int f_audio_bind(struct usb_configuration *c, struct usb_function *f)
 	audio->in_ep->desc = &as_in_ep_desc;
 
 	/* copy descriptors, and track endpoint copies */
-	status = usb_assign_descriptors(f, f_audio_desc, f_audio_desc, NULL,
-					NULL);
+	status = usb_assign_descriptors(f, f_audio_desc, f_audio_desc,
+				f_audio_ss_desc, NULL);
 	if (status)
 		goto fail;
 
diff --git a/drivers/usb/gadget/function/f_uvc.c b/drivers/usb/gadget/function/f_uvc.c
index f48a00e49..b6b9a69c2 100644
--- a/drivers/usb/gadget/function/f_uvc.c
+++ b/drivers/usb/gadget/function/f_uvc.c
@@ -642,7 +642,7 @@ uvc_function_bind(struct usb_configuration *c, struct usb_function *f)
 
 	uvc_ss_streaming_ep.wMaxPacketSize = cpu_to_le16(max_packet_size);
 	uvc_ss_streaming_ep.bInterval = opts->streaming_interval;
-	uvc_ss_streaming_comp.bmAttributes = max_packet_mult - 1;
+	uvc_ss_streaming_comp.bmAttributes = 1;
 	uvc_ss_streaming_comp.bMaxBurst = opts->streaming_maxburst;
 	uvc_ss_streaming_comp.wBytesPerInterval =
 		cpu_to_le16(max_packet_size * max_packet_mult *
@@ -789,6 +789,11 @@ static struct usb_function_instance *uvc_alloc_inst(void)
 	struct uvc_descriptor_header **ctl_cls;
 	int ret;
 
+	struct UVC_EXTENSION_UNIT_DESCRIPTOR(1, 2) *ed;
+	/* GUID of the UVC H.264 extension unit */
+    static char extension_guid[] = {0x41, 0x76, 0x9E, 0xA2, 0x04, 0xDE, 0xE3, 0x47,
+		0x8B, 0x2B, 0xF4, 0x34, 0x1A, 0xFF, 0x00, 0x3B};
+
 	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
 	if (!opts)
 		return ERR_PTR(-ENOMEM);
@@ -824,6 +829,20 @@ static struct usb_function_instance *uvc_alloc_inst(void)
 	pd->iProcessing			= 0;
 	pd->bmVideoStandards		= 0;
 
+	ed = &opts->uvc_extension;
+	ed->bLength			= UVC_DT_EXTENSION_UNIT_SIZE(1, 2);
+	ed->bDescriptorType		= USB_DT_CS_INTERFACE;
+	ed->bDescriptorSubType		= UVC_VC_EXTENSION_UNIT;
+	ed->bUnitID			= 10;
+	memcpy(ed->guidExtensionCode, extension_guid, sizeof(extension_guid));
+	ed->bNrInPins			= 1;
+	ed->baSourceID[0]      	= 2;
+	ed->bNumControls		= 15;
+	ed->bControlSize		= 2;
+	ed->bmControls[0]		= 1;
+	ed->bmControls[1]		= 0;
+	ed->iExtension			= 0;
+
 	od = &opts->uvc_output_terminal;
 	od->bLength			= UVC_DT_OUTPUT_TERMINAL_SIZE;
 	od->bDescriptorType		= USB_DT_CS_INTERFACE;
@@ -847,8 +866,9 @@ static struct usb_function_instance *uvc_alloc_inst(void)
 	ctl_cls[0] = NULL;	/* assigned elsewhere by configfs */
 	ctl_cls[1] = (struct uvc_descriptor_header *)cd;
 	ctl_cls[2] = (struct uvc_descriptor_header *)pd;
-	ctl_cls[3] = (struct uvc_descriptor_header *)od;
-	ctl_cls[4] = NULL;	/* NULL-terminate */
+	ctl_cls[3] = (struct uvc_descriptor_header *)ed;
+	ctl_cls[4] = (struct uvc_descriptor_header *)od;
+	ctl_cls[5] = NULL;	/* NULL-terminate */
 	opts->fs_control =
 		(const struct uvc_descriptor_header * const *)ctl_cls;
 
@@ -863,7 +883,8 @@ static struct usb_function_instance *uvc_alloc_inst(void)
 		(const struct uvc_descriptor_header * const *)ctl_cls;
 
 	opts->streaming_interval = 1;
-	opts->streaming_maxpacket = 1024;
+	opts->streaming_maxpacket = 3072;
+	opts->streaming_maxburst = 15;
 
 	ret = uvcg_attach_configfs(opts);
 	if (ret < 0) {
diff --git a/drivers/usb/gadget/function/u_uvc.h b/drivers/usb/gadget/function/u_uvc.h
index 9a01a7d4f..392ae14dc 100644
--- a/drivers/usb/gadget/function/u_uvc.h
+++ b/drivers/usb/gadget/function/u_uvc.h
@@ -52,6 +52,7 @@ struct f_uvc_opts {
 	struct uvc_processing_unit_descriptor		uvc_processing;
 	struct uvc_output_terminal_descriptor		uvc_output_terminal;
 	struct uvc_color_matching_descriptor		uvc_color_matching;
+	struct UVC_EXTENSION_UNIT_DESCRIPTOR(1, 2) 	uvc_extension;
 
 	/*
 	 * Control descriptors pointers arrays for full-/high-speed and
@@ -60,8 +61,8 @@ struct f_uvc_opts {
 	 * descriptors. Used by configfs only, must not be touched by legacy
 	 * gadgets.
 	 */
-	struct uvc_descriptor_header			*uvc_fs_control_cls[5];
-	struct uvc_descriptor_header			*uvc_ss_control_cls[5];
+	struct uvc_descriptor_header			*uvc_fs_control_cls[6];
+	struct uvc_descriptor_header			*uvc_ss_control_cls[6];
 
 	/*
 	 * Streaming descriptors for full-speed, high-speed and super-speed.
diff --git a/drivers/usb/gadget/function/uvc.h b/drivers/usb/gadget/function/uvc.h
index 23ee25383..f2936f637 100644
--- a/drivers/usb/gadget/function/uvc.h
+++ b/drivers/usb/gadget/function/uvc.h
@@ -64,8 +64,11 @@ extern unsigned int uvc_gadget_trace_param;
 /* ------------------------------------------------------------------------
  * Driver specific constants
  */
-
-#define UVC_NUM_REQUESTS			4
+#ifdef UVC_SG_REQ
+#define UVC_NUM_REQUESTS	1
+#else
+#define UVC_NUM_REQUESTS	32
+#endif
 #define UVC_MAX_REQUEST_SIZE			64
 #define UVC_MAX_EVENTS				4
 
@@ -87,6 +90,9 @@ struct uvc_video {
 	unsigned int imagesize;
 	struct mutex mutex;	/* protects frame parameters */
 
+	unsigned int num_sgs; /* record base */
+	__u8 *sg_buf;
+
 	/* Requests */
 	unsigned int req_size;
 	struct usb_request *req[UVC_NUM_REQUESTS];
diff --git a/drivers/usb/gadget/function/uvc_configfs.c b/drivers/usb/gadget/function/uvc_configfs.c
old mode 100644
new mode 100755
index 00fb58e50..604e87788
--- a/drivers/usb/gadget/function/uvc_configfs.c
+++ b/drivers/usb/gadget/function/uvc_configfs.c
@@ -319,7 +319,49 @@ static ssize_t uvcg_default_processing_bm_controls_show(
 	return result;
 }
 
-UVC_ATTR_RO(uvcg_default_processing_, bm_controls, bmControls);
+static ssize_t uvcg_default_processing_bm_controls_store(
+	struct config_item *item, const char *page, size_t len)
+{
+	struct config_group *group = to_config_group(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct mutex *su_mutex = &group->cg_subsys->su_mutex;
+	struct uvc_processing_unit_descriptor *pd;
+	int ret, i;
+	const char *pg = page;
+	/* sign, base 2 representation, newline, terminator */
+	char buf[1 + sizeof(u8) * 8 + 1 + 1];
+	int idx;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = group->cg_item.ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+	pd = &opts->uvc_processing;
+
+	idx = 0;
+	while (pg - page < len) {
+		i = 0;
+		while (i < sizeof(buf) && (pg - page < len) &&
+				*pg != '\0' && *pg != '\n')
+			buf[i++] = *pg++;
+		while ((pg - page < len) && (*pg == '\0' || *pg == '\n'))
+			++pg;
+		buf[i] = '\0';
+		ret = kstrtou8(buf, 0, &pd->bmControls[idx++]);
+		if (ret < 0)
+			goto end;
+		if (idx >= pd->bControlSize)
+			break;
+	}
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	mutex_unlock(su_mutex);
+	return ret;
+}
+
+UVC_ATTR(uvcg_default_processing_, bm_controls, bmControls);
 
 static struct configfs_attribute *uvcg_default_processing_attrs[] = {
 	&uvcg_default_processing_attr_b_unit_id,
@@ -342,11 +384,10 @@ static const struct uvcg_config_group_type uvcg_default_processing_type = {
 /* -----------------------------------------------------------------------------
  * control/processing
  */
-
 static const struct uvcg_config_group_type uvcg_processing_grp_type = {
 	.type = {
-		.ct_item_ops	= &uvcg_config_item_ops,
-		.ct_owner	= THIS_MODULE,
+		.ct_item_ops    = &uvcg_config_item_ops,
+		.ct_owner   = THIS_MODULE,
 	},
 	.name = "processing",
 	.children = (const struct uvcg_config_group_type*[]) {
@@ -355,6 +396,115 @@ static const struct uvcg_config_group_type uvcg_processing_grp_type = {
 	},
 };
 
+/* control/extension/default */
+static struct uvcg_default_extension {
+	struct config_group	group;
+} uvcg_default_extension;
+
+static inline struct uvcg_default_extension
+*to_uvcg_default_extension(struct config_item *item)
+{
+	return container_of(to_config_group(item),
+			    struct uvcg_default_extension, group);
+}
+
+#define UVCG_DEFAULT_EXTENSION_ATTR(cname, aname, conv)		\
+static ssize_t uvcg_default_extension_##cname##_show(			\
+	struct config_item *item, char *page)				\
+{									\
+	struct uvcg_default_extension *dp = to_uvcg_default_extension(item); \
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &dp->group.cg_subsys->su_mutex;	\
+	struct UVC_EXTENSION_UNIT_DESCRIPTOR(1, 2) *ed;			\
+	int result;							\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = dp->group.cg_item.ci_parent->ci_parent->ci_parent;	\
+	opts = to_f_uvc_opts(opts_item);				\
+	ed = &opts->uvc_extension;					\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%d\n", conv(ed->aname));		\
+	mutex_unlock(&opts->lock);					\
+									\
+	mutex_unlock(su_mutex);						\
+	return result;							\
+}									\
+									\
+UVC_ATTR_RO(uvcg_default_extension_, cname, aname)
+
+#define identity_conv(x) (x)
+
+UVCG_DEFAULT_EXTENSION_ATTR(b_unit_id, bUnitID, identity_conv);
+UVCG_DEFAULT_EXTENSION_ATTR(b_num_input_pins, bNrInPins, identity_conv);
+UVCG_DEFAULT_EXTENSION_ATTR(i_extension, iExtension, identity_conv);
+
+#undef identity_conv
+
+#undef UVCG_DEFAULT_EXTENSION_ATTR
+
+static ssize_t uvcg_default_extension_bm_controls_show(
+	struct config_item *item, char *page)
+{
+	struct uvcg_default_extension *dp = to_uvcg_default_extension(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct mutex *su_mutex = &dp->group.cg_subsys->su_mutex;
+	struct UVC_EXTENSION_UNIT_DESCRIPTOR(1, 2) *ed;
+	int result, i;
+	char *pg = page;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = dp->group.cg_item.ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+	ed = &opts->uvc_extension;
+
+	mutex_lock(&opts->lock);
+	for (result = 0, i = 0; i < ed->bControlSize; ++i) {
+		result += sprintf(pg, "%d\n", ed->bmControls[i]);
+		pg = page + result;
+	}
+	mutex_unlock(&opts->lock);
+
+	mutex_unlock(su_mutex);
+
+	return result;
+}
+
+UVC_ATTR_RO(uvcg_default_extension_, bm_controls, bmControls);
+
+static struct configfs_attribute *uvcg_default_extension_attrs[] = {
+	&uvcg_default_extension_attr_b_unit_id,
+	&uvcg_default_extension_attr_b_num_input_pins,
+	&uvcg_default_extension_attr_bm_controls,
+	&uvcg_default_extension_attr_i_extension,
+	NULL,
+};
+
+static struct config_item_type uvcg_default_extension_type = {
+	.ct_attrs	= uvcg_default_extension_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+/* struct uvcg_extension {}; */
+
+/* control/extension */
+static struct uvcg_extension_grp {
+	struct config_group	group;
+} uvcg_extension_grp;
+
+static struct config_item_type uvcg_extension_grp_type = {
+ 	.ct_owner = THIS_MODULE,
+ };
+
+/* streaming/frame_based */
+static struct uvcg_frame_based_format_grp {
+	struct config_group	group;
+} uvcg_frame_based_format_grp;
+
 /* -----------------------------------------------------------------------------
  * control/terminal/camera/default
  */
@@ -430,7 +580,50 @@ static ssize_t uvcg_default_camera_bm_controls_show(
 	return result;
 }
 
-UVC_ATTR_RO(uvcg_default_camera_, bm_controls, bmControls);
+static ssize_t uvcg_default_camera_bm_controls_store(
+	struct config_item *item, const char *page, size_t len)
+{
+	struct config_group *group = to_config_group(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct mutex *su_mutex = &group->cg_subsys->su_mutex;
+	struct uvc_camera_terminal_descriptor *cd;
+	int ret, i;
+	const char *pg = page;
+	/* sign, base 2 representation, newline, terminator */
+	char buf[1 + sizeof(u8) * 8 + 1 + 1];
+	int idx;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = group->cg_item.ci_parent->ci_parent->ci_parent->
+			ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+	cd = &opts->uvc_camera_terminal;
+
+	idx = 0;
+	while (pg - page < len) {
+		i = 0;
+		while (i < sizeof(buf) && (pg - page < len) &&
+				*pg != '\0' && *pg != '\n')
+			buf[i++] = *pg++;
+		while ((pg - page < len) && (*pg == '\0' || *pg == '\n'))
+			++pg;
+		buf[i] = '\0';
+		ret = kstrtou8(buf, 0, &cd->bmControls[idx++]);
+		if (ret < 0)
+			goto end;
+		if (idx >= cd->bControlSize)
+			break;
+	}
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	mutex_unlock(su_mutex);
+	return ret;
+}
+
+UVC_ATTR(uvcg_default_camera_, bm_controls, bmControls);
 
 static struct configfs_attribute *uvcg_default_camera_attrs[] = {
 	&uvcg_default_camera_attr_b_terminal_id,
@@ -772,6 +965,7 @@ static const char * const uvcg_format_names[] = {
 enum uvcg_format_type {
 	UVCG_UNCOMPRESSED = 0,
 	UVCG_MJPEG,
+	UVCG_FRAME_FRAME_BASED,
 };
 
 struct uvcg_format {
@@ -1381,6 +1575,7 @@ static struct config_item *uvcg_frame_make(struct config_group *group,
 		return ERR_PTR(-EINVAL);
 	}
 	++fmt->num_frames;
+	h->frame.b_frame_index	= fmt->num_frames;
 	mutex_unlock(&opts->lock);
 
 	config_item_init_type_name(&h->item, name, &uvcg_frame_type);
@@ -1405,6 +1600,263 @@ static void uvcg_frame_drop(struct config_group *group, struct config_item *item
 	config_item_put(item);
 }
 
+struct uvcg_frame_based_frame {
+	struct {
+		u8	b_length;
+		u8	b_descriptor_type;
+		u8	b_descriptor_subtype;
+		u8	b_frame_index;
+		u8	bm_capabilities;
+		u16	w_width;
+		u16	w_height;
+		u32	dw_min_bit_rate;
+		u32	dw_max_bit_rate;
+		u32	dw_default_frame_interval;
+		u8	b_frame_interval_type;
+		u32  dw_bytes_per_line;
+	} __attribute__((packed)) frame;
+	u32 *dw_frame_interval;
+	enum uvcg_format_type	fmt_type;
+	struct config_item	item;
+};
+
+static struct uvcg_frame_based_frame *to_uvcg_frame_based_frame(struct config_item *item)
+{
+	return container_of(item, struct uvcg_frame_based_frame, item);
+}
+
+#define UVCG_FRAME_BASED_FRAME_ATTR(cname, aname, to_cpu_endian, to_little_endian, bits) \
+static ssize_t uvcg_frame_based_frame_##cname##_show(struct config_item *item, char *page)\
+{									\
+	struct uvcg_frame_based_frame *f = to_uvcg_frame_based_frame(item);			\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &f->item.ci_group->cg_subsys->su_mutex;\
+	int result;							\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = f->item.ci_parent->ci_parent->ci_parent->ci_parent;	\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%d\n", to_cpu_endian(f->frame.cname));	\
+	mutex_unlock(&opts->lock);					\
+									\
+	mutex_unlock(su_mutex);						\
+	return result;							\
+}									\
+									\
+static ssize_t  uvcg_frame_based_frame_##cname##_store(struct config_item *item,	\
+					   const char *page, size_t len)\
+{									\
+	struct uvcg_frame_based_frame *f = to_uvcg_frame_based_frame(item);			\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct uvcg_format *fmt;					\
+	struct mutex *su_mutex = &f->item.ci_group->cg_subsys->su_mutex;\
+	int ret;							\
+	u##bits num;							\
+									\
+	ret = kstrtou##bits(page, 0, &num);				\
+	if (ret)							\
+		return ret;						\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = f->item.ci_parent->ci_parent->ci_parent->ci_parent;	\
+	opts = to_f_uvc_opts(opts_item);				\
+	fmt = to_uvcg_format(f->item.ci_parent);			\
+									\
+	mutex_lock(&opts->lock);					\
+	if (fmt->linked || opts->refcnt) {				\
+		ret = -EBUSY;						\
+		goto end;						\
+	}								\
+									\
+	f->frame.cname = to_little_endian(num);				\
+	ret = len;							\
+end:									\
+	mutex_unlock(&opts->lock);					\
+	mutex_unlock(su_mutex);						\
+	return ret;							\
+}									\
+									\
+UVC_ATTR(uvcg_frame_based_frame_, cname, aname);
+
+#define noop_conversion(x) (x)
+
+UVCG_FRAME_BASED_FRAME_ATTR(bm_capabilities, bmCapabilities, noop_conversion,
+		noop_conversion, 8);
+UVCG_FRAME_BASED_FRAME_ATTR(w_width, wWidth, le16_to_cpu, cpu_to_le16, 16);
+UVCG_FRAME_BASED_FRAME_ATTR(w_height, wHeight, le16_to_cpu, cpu_to_le16, 16);
+UVCG_FRAME_BASED_FRAME_ATTR(dw_min_bit_rate, dwMinBitRate, le32_to_cpu, cpu_to_le32, 32);
+UVCG_FRAME_BASED_FRAME_ATTR(dw_max_bit_rate, dwMaxBitRate, le32_to_cpu, cpu_to_le32, 32);
+UVCG_FRAME_BASED_FRAME_ATTR(dw_default_frame_interval, dwDefaultFrameInterval,
+		le32_to_cpu, cpu_to_le32, 32);
+UVCG_FRAME_BASED_FRAME_ATTR(dw_bytes_per_line, dwBytesPerLine,
+		le32_to_cpu, cpu_to_le32, 32);
+
+#undef noop_conversion
+
+#undef UVCG_FRAME_BASED_FRAME_ATTR
+
+static ssize_t uvcg_frame_based_frame_dw_frame_interval_show(struct config_item *item,
+						 char *page)
+{
+	struct uvcg_frame_based_frame *frm = to_uvcg_frame_based_frame(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct mutex *su_mutex = &frm->item.ci_group->cg_subsys->su_mutex;
+	int result, i;
+	char *pg = page;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = frm->item.ci_parent->ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+
+	mutex_lock(&opts->lock);
+	for (result = 0, i = 0; i < frm->frame.b_frame_interval_type; ++i) {
+		result += sprintf(pg, "%d\n",
+				  le32_to_cpu(frm->dw_frame_interval[i]));
+		pg = page + result;
+	}
+	mutex_unlock(&opts->lock);
+
+	mutex_unlock(su_mutex);
+	return result;
+}
+
+static ssize_t uvcg_frame_based_frame_dw_frame_interval_store(struct config_item *item,
+						  const char *page, size_t len)
+{
+	struct uvcg_frame_based_frame *ch = to_uvcg_frame_based_frame(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct uvcg_format *fmt;
+	struct mutex *su_mutex = &ch->item.ci_group->cg_subsys->su_mutex;
+	int ret = 0, n = 0;
+	u32 *frm_intrv, *tmp;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = ch->item.ci_parent->ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+	fmt = to_uvcg_format(ch->item.ci_parent);
+
+	mutex_lock(&opts->lock);
+	if (fmt->linked || opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = __uvcg_iter_frm_intrv(page, len, __uvcg_count_frm_intrv, &n);
+	if (ret)
+		goto end;
+
+	tmp = frm_intrv = kcalloc(n, sizeof(u32), GFP_KERNEL);
+	if (!frm_intrv) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	ret = __uvcg_iter_frm_intrv(page, len, __uvcg_fill_frm_intrv, &tmp);
+	if (ret) {
+		kfree(frm_intrv);
+		goto end;
+	}
+
+	kfree(ch->dw_frame_interval);
+	ch->dw_frame_interval = frm_intrv;
+	ch->frame.b_frame_interval_type = n;
+	ret = len;
+
+end:
+	mutex_unlock(&opts->lock);
+	mutex_unlock(su_mutex);
+	return ret;
+}
+
+UVC_ATTR(uvcg_frame_based_frame_, dw_frame_interval, dwFrameInterval);
+
+static struct configfs_attribute *uvcg_frame_based_frame_attrs[] = {
+	&uvcg_frame_based_frame_attr_bm_capabilities,
+	&uvcg_frame_based_frame_attr_w_width,
+	&uvcg_frame_based_frame_attr_w_height,
+	&uvcg_frame_based_frame_attr_dw_min_bit_rate,
+	&uvcg_frame_based_frame_attr_dw_max_bit_rate,
+	&uvcg_frame_based_frame_attr_dw_default_frame_interval,
+	&uvcg_frame_based_frame_attr_dw_frame_interval,
+	&uvcg_frame_based_frame_attr_dw_bytes_per_line,
+	NULL,
+};
+
+static struct config_item_type uvcg_frame_based_frame_type = {
+	.ct_attrs	= uvcg_frame_based_frame_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_item *uvcg_frame_based_frame_make(struct config_group *group,
+					   const char *name)
+{
+	struct uvcg_frame_based_frame *h;
+	struct uvcg_format *fmt;
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+
+	h = kzalloc(sizeof(*h), GFP_KERNEL);
+	if (!h)
+		return ERR_PTR(-ENOMEM);
+
+	h->frame.b_descriptor_type		= USB_DT_CS_INTERFACE;
+	h->frame.b_frame_index			= 1;
+	h->frame.w_width			= cpu_to_le16(640);
+	h->frame.w_height			= cpu_to_le16(360);
+	h->frame.dw_min_bit_rate		= cpu_to_le32(18432000);
+	h->frame.dw_max_bit_rate		= cpu_to_le32(55296000);
+	h->frame.dw_default_frame_interval	= cpu_to_le32(333333);
+	h->frame.dw_bytes_per_line	= cpu_to_le32(0);
+
+	opts_item = group->cg_item.ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+
+	mutex_lock(&opts->lock);
+	fmt = to_uvcg_format(&group->cg_item);
+	if (fmt->type == UVCG_FRAME_FRAME_BASED) {
+		h->frame.b_descriptor_subtype = UVC_VS_FRAME_FRAME_BASED;
+		h->fmt_type = UVCG_FRAME_FRAME_BASED;
+	} else {
+		mutex_unlock(&opts->lock);
+		kfree(h);
+		return ERR_PTR(-EINVAL);
+	}
+	++fmt->num_frames;
+	h->frame.b_frame_index	= fmt->num_frames;
+	mutex_unlock(&opts->lock);
+
+	config_item_init_type_name(&h->item, name, &uvcg_frame_based_frame_type);
+
+	return &h->item;
+}
+
+static void uvcg_frame_based_frame_drop(struct config_group *group, struct config_item *item)
+{
+	struct uvcg_frame_based_frame *h = to_uvcg_frame_based_frame(item);
+	struct uvcg_format *fmt;
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+
+	opts_item = group->cg_item.ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+
+	mutex_lock(&opts->lock);
+	fmt = to_uvcg_format(&group->cg_item);
+	--fmt->num_frames;
+	kfree(h);
+	mutex_unlock(&opts->lock);
+}
+
 static void uvcg_format_set_indices(struct config_group *fmt)
 {
 	struct config_item *ci;
@@ -1629,10 +2081,17 @@ static const struct config_item_type uvcg_uncompressed_type = {
 static struct config_group *uvcg_uncompressed_make(struct config_group *group,
 						   const char *name)
 {
+#ifndef CONFIG_HISI_MC
 	static char guid[] = {
 		'Y',  'U',  'Y',  '2', 0x00, 0x00, 0x10, 0x00,
 		 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
 	};
+#else
+	static char guid[] = {
+		'N',  'V',  '2',  '1', 0x00, 0x00, 0x10, 0x00,
+		 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+	};
+#endif
 	struct uvcg_uncompressed *h;
 
 	h = kzalloc(sizeof(*h), GFP_KERNEL);
@@ -1643,7 +2102,11 @@ static struct config_group *uvcg_uncompressed_make(struct config_group *group,
 	h->desc.bDescriptorType		= USB_DT_CS_INTERFACE;
 	h->desc.bDescriptorSubType	= UVC_VS_FORMAT_UNCOMPRESSED;
 	memcpy(h->desc.guidFormat, guid, sizeof(guid));
+#ifndef CONFIG_HISI_MC
 	h->desc.bBitsPerPixel		= 16;
+#else
+	h->desc.bBitsPerPixel		= 12;
+#endif
 	h->desc.bDefaultFrameIndex	= 1;
 	h->desc.bAspectRatioX		= 0;
 	h->desc.bAspectRatioY		= 0;
@@ -1818,6 +2281,205 @@ static const struct config_item_type uvcg_mjpeg_type = {
 	.ct_owner	= THIS_MODULE,
 };
 
+/* streaming/frame_based<NAME> */
+struct uvcg_frame_based_format {
+	struct uvcg_format		fmt;
+	struct uvc_frame_based_format_desc		desc;
+};
+
+static struct uvcg_frame_based_format *to_uvcg_frame_based_format(struct config_item *item)
+{
+	return container_of(
+		container_of(to_config_group(item), struct uvcg_format, group),
+		struct uvcg_frame_based_format, fmt);
+}
+
+static struct configfs_group_operations uvcg_frame_based_format_group_ops = {
+	.make_item		= uvcg_frame_based_frame_make,
+	.drop_item		= uvcg_frame_based_frame_drop,
+};
+
+#define UVCG_FRAME_BASED_FORMAT_ATTR_RO(cname, aname, conv)				\
+static ssize_t uvcg_frame_based_format_##cname##_show(struct config_item *item, char *page)\
+{									\
+	struct uvcg_frame_based_format *u = to_uvcg_frame_based_format(item);			\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int result;							\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%d\n", conv(u->desc.aname));		\
+	mutex_unlock(&opts->lock);					\
+									\
+	mutex_unlock(su_mutex);						\
+	return result;							\
+}									\
+									\
+UVC_ATTR_RO(uvcg_frame_based_format_, cname, aname)
+
+#define UVCG_FRAME_BASED_FORMAT_ATTR(cname, aname, conv)				\
+static ssize_t uvcg_frame_based_format_##cname##_show(struct config_item *item, char *page)\
+{									\
+	struct uvcg_frame_based_format *u = to_uvcg_frame_based_format(item);			\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int result;							\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%d\n", conv(u->desc.aname));		\
+	mutex_unlock(&opts->lock);					\
+									\
+	mutex_unlock(su_mutex);						\
+	return result;							\
+}									\
+									\
+static ssize_t								\
+uvcg_frame_based_format_##cname##_store(struct config_item *item,			\
+			   const char *page, size_t len)		\
+{									\
+	struct uvcg_frame_based_format *u = to_uvcg_frame_based_format(item);			\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int ret;							\
+	u8 num;								\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	if (u->fmt.linked || opts->refcnt) {				\
+		ret = -EBUSY;						\
+		goto end;						\
+	}								\
+									\
+	ret = kstrtou8(page, 0, &num);					\
+	if (ret)							\
+		goto end;						\
+									\
+	if (num > 255) {						\
+		ret = -EINVAL;						\
+		goto end;						\
+	}								\
+	u->desc.aname = num;						\
+	ret = len;							\
+end:									\
+	mutex_unlock(&opts->lock);					\
+	mutex_unlock(su_mutex);						\
+	return ret;							\
+}									\
+									\
+UVC_ATTR(uvcg_frame_based_format_, cname, aname)
+
+#define identity_conv(x) (x)
+
+UVCG_FRAME_BASED_FORMAT_ATTR(b_default_frame_index, bDefaultFrameIndex,
+		       identity_conv);
+UVCG_FRAME_BASED_FORMAT_ATTR_RO(b_aspect_ratio_x, bAspectRatioX, identity_conv);
+UVCG_FRAME_BASED_FORMAT_ATTR_RO(b_aspect_ratio_y, bAspectRatioY, identity_conv);
+UVCG_FRAME_BASED_FORMAT_ATTR_RO(bm_interface_flags, bmInterfaceFlags, identity_conv);
+
+#undef identity_conv
+
+#undef UVCG_FRAME_BASED_FORMAT_ATTR
+#undef UVCG_FRAME_BASED_FORMAT_ATTR_RO
+
+static inline ssize_t
+uvcg_frame_based_format_bma_controls_show(struct config_item *item, char *page)
+{
+	struct uvcg_frame_based_format *u = to_uvcg_frame_based_format(item);
+	return uvcg_format_bma_controls_show(&u->fmt, page);
+}
+
+static inline ssize_t
+uvcg_frame_based_format_bma_controls_store(struct config_item *item,
+				     const char *page, size_t len)
+{
+	struct uvcg_frame_based_format *u = to_uvcg_frame_based_format(item);
+	return uvcg_format_bma_controls_store(&u->fmt, page, len);
+}
+
+UVC_ATTR(uvcg_frame_based_format_, bma_controls, bmaControls);
+
+static struct configfs_attribute *uvcg_frame_based_format_attrs[] = {
+	&uvcg_frame_based_format_attr_b_default_frame_index,
+	&uvcg_frame_based_format_attr_b_aspect_ratio_x,
+	&uvcg_frame_based_format_attr_b_aspect_ratio_y,
+	&uvcg_frame_based_format_attr_bm_interface_flags,
+	&uvcg_frame_based_format_attr_bma_controls,
+	NULL,
+};
+
+static struct config_item_type uvcg_frame_based_format_type = {
+	.ct_group_ops	= &uvcg_frame_based_format_group_ops,
+	.ct_attrs	= uvcg_frame_based_format_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_group *uvcg_frame_based_format_make(struct config_group *group,
+						   const char *name)
+{
+	static char guid[] = { /*Declear frame frame based as H264*/
+		'H',  '2',  '6',  '4', 0x00, 0x00, 0x10, 0x00,
+		 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+	};
+	struct uvcg_frame_based_format *h;
+
+	h = kzalloc(sizeof(*h), GFP_KERNEL);
+	if (!h)
+		return ERR_PTR(-ENOMEM);
+
+	h->desc.bLength			= UVC_DT_FRAME_BASED_FORMAT_SIZE;
+	h->desc.bDescriptorType		= USB_DT_CS_INTERFACE;
+	h->desc.bDescriptorSubType	= UVC_VS_FORMAT_FRAME_BASED;
+	memcpy(h->desc.guidFormat, guid, sizeof(guid));
+	h->desc.bBitsPerPixel		= 16;
+	h->desc.bDefaultFrameIndex	= 1;
+	h->desc.bAspectRatioX	= 0;
+	h->desc.bAspectRatioY	= 0;
+	h->desc.bmInterfaceFlags	= 0;
+	h->desc.bCopyProtect		= 0;
+	h->desc.bVariableSize		= 1;
+
+	h->fmt.type = UVCG_FRAME_FRAME_BASED;
+	config_group_init_type_name(&h->fmt.group, name,
+				    &uvcg_frame_based_format_type);
+
+	return &h->fmt.group;
+}
+
+static void uvcg_frame_based_format_drop(struct config_group *group,
+			    struct config_item *item)
+{
+	struct uvcg_frame_based_format *h = to_uvcg_frame_based_format(item);
+
+	kfree(h);
+}
+
+static struct configfs_group_operations uvcg_frame_based_format_grp_ops = {
+	.make_group		= uvcg_frame_based_format_make,
+	.drop_item		= uvcg_frame_based_format_drop,
+};
+
+static struct config_item_type uvcg_frame_based_format_grp_type = {
+	.ct_group_ops	= &uvcg_frame_based_format_grp_ops,
+	.ct_owner	= THIS_MODULE,
+};
+
 static struct config_group *uvcg_mjpeg_make(struct config_group *group,
 						   const char *name)
 {
@@ -2049,6 +2711,11 @@ static int __uvcg_cnt_strm(void *priv1, void *priv2, void *priv3, int n,
 				container_of(fmt, struct uvcg_mjpeg, fmt);
 
 			*size += sizeof(m->desc);
+		} else if (fmt->type == UVCG_FRAME_FRAME_BASED) {
+			struct uvcg_frame_based_format *h =
+				container_of(fmt, struct uvcg_frame_based_format, fmt);
+
+			*size += sizeof(h->desc);
 		} else {
 			return -EINVAL;
 		}
@@ -2057,7 +2724,14 @@ static int __uvcg_cnt_strm(void *priv1, void *priv2, void *priv3, int n,
 	case UVCG_FRAME: {
 		struct uvcg_frame *frm = priv1;
 		int sz = sizeof(frm->dw_frame_interval);
+		if (frm->frame.b_descriptor_subtype == UVC_VS_FRAME_FRAME_BASED) {
+			struct uvcg_frame_based_frame *fb_frm = priv1;
+			*size += sizeof(fb_frm->frame);
+			*size += fb_frm->frame.b_frame_interval_type * sizeof(fb_frm->dw_frame_interval);
 
+			++*count;
+			return 0;
+		}
 		*size += sizeof(frm->frame);
 		*size += frm->frame.b_frame_interval_type * sz;
 	}
@@ -2123,6 +2797,15 @@ static int __uvcg_fill_strm(void *priv1, void *priv2, void *priv3, int n,
 			m->desc.bNumFrameDescriptors = fmt->num_frames;
 			memcpy(*dest, &m->desc, sizeof(m->desc));
 			*dest += sizeof(m->desc);
+		} else if (fmt->type == UVCG_FRAME_FRAME_BASED) {
+			struct uvc_frame_based_format_desc *ffb = *dest;
+			struct uvcg_frame_based_format *h =
+				container_of(fmt, struct uvcg_frame_based_format, fmt);
+
+			memcpy(*dest, &h->desc, sizeof(h->desc));
+			*dest += sizeof(h->desc);
+			ffb->bNumFrameDescriptors = fmt->num_frames;
+			ffb->bFormatIndex = n + 1;
 		} else {
 			return -EINVAL;
 		}
@@ -2132,6 +2815,19 @@ static int __uvcg_fill_strm(void *priv1, void *priv2, void *priv3, int n,
 		struct uvcg_frame *frm = priv1;
 		struct uvc_descriptor_header *h = *dest;
 
+		if (frm->frame.b_descriptor_subtype == UVC_VS_FRAME_FRAME_BASED) {
+			struct uvcg_frame_based_frame *fb_frm = priv1;
+			sz = sizeof(fb_frm->frame);
+			memcpy(*dest, &fb_frm->frame, sz);
+			*dest += sz;
+			sz = fb_frm->frame.b_frame_interval_type *
+			sizeof(*fb_frm->dw_frame_interval);
+			memcpy(*dest, fb_frm->dw_frame_interval, sz);
+			*dest += sz;
+			h->bLength = UVC_DT_FRAME_BASED_FRAME_SIZE(
+				fb_frm->frame.b_frame_interval_type);
+			return 0;
+		}
 		sz = sizeof(frm->frame);
 		memcpy(*dest, &frm->frame, sz);
 		*dest += sz;
diff --git a/drivers/usb/gadget/function/uvc_v4l2.c b/drivers/usb/gadget/function/uvc_v4l2.c
index 4ca89eab6..1272038be 100644
--- a/drivers/usb/gadget/function/uvc_v4l2.c
+++ b/drivers/usb/gadget/function/uvc_v4l2.c
@@ -56,8 +56,13 @@ struct uvc_format {
 };
 
 static struct uvc_format uvc_formats[] = {
+#ifndef CONFIG_HISI_MC
 	{ 16, V4L2_PIX_FMT_YUYV  },
+#else
+	{ 12, V4L2_PIX_FMT_NV21 },
+#endif
 	{ 0,  V4L2_PIX_FMT_MJPEG },
+	{ 0,  V4L2_PIX_FMT_H264 },
 };
 
 static int
diff --git a/drivers/usb/gadget/function/uvc_video.c b/drivers/usb/gadget/function/uvc_video.c
index 633e23d58..835f5f048 100644
--- a/drivers/usb/gadget/function/uvc_video.c
+++ b/drivers/usb/gadget/function/uvc_video.c
@@ -12,13 +12,15 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/video.h>
-
+#include <linux/usb/g_uvc.h>
 #include <media/v4l2-dev.h>
 
 #include "uvc.h"
 #include "uvc_queue.h"
 #include "uvc_video.h"
 
+#include <linux/scatterlist.h>
+#include <linux/io.h>
 /* --------------------------------------------------------------------------
  * Video codecs
  */
@@ -98,9 +100,45 @@ static void
 uvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,
 		struct uvc_buffer *buf)
 {
+	int ret;
+#ifdef UVC_SG_REQ
+	int len;
+	int ttllen = 0;
+	unsigned int sg_idx;
+	u8 *mem = NULL;
+
+	for (sg_idx = 0; sg_idx < video->num_sgs; sg_idx++) {
+		mem = sg_virt(&req->sg[sg_idx]);
+		len = video->req_size;
+
+		/* Add the header. */
+		ret = uvc_video_encode_header(video, buf, mem, len);
+		mem += ret;
+		len -= ret;
+
+		/* Process video data. */
+		ret = uvc_video_encode_data(video, buf, mem, len);
+		len -= ret;
+
+		/* Sync sg buffer len , default is 1024 or 3072 */
+		sg_set_buf(&req->sg[sg_idx], sg_virt(&req->sg[sg_idx]),
+				video->req_size - len);
+		ttllen += video->req_size - len;
+
+		if (buf->bytesused == video->queue.buf_used) {
+			video->queue.buf_used = 0;
+			buf->state = UVC_BUF_STATE_DONE;
+			uvcg_queue_next_buffer(&video->queue, buf);
+			video->fid ^= UVC_STREAM_FID;
+			break;
+		}
+	}
+	req->num_sgs = sg_idx + 1;
+	sg_mark_end(&req->sg[sg_idx]);
+	req->length = ttllen;
+#else
 	void *mem = req->buf;
 	int len = video->req_size;
-	int ret;
 
 	/* Add the header. */
 	ret = uvc_video_encode_header(video, buf, mem, len);
@@ -119,6 +157,7 @@ uvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,
 		uvcg_queue_next_buffer(&video->queue, buf);
 		video->fid ^= UVC_STREAM_FID;
 	}
+#endif
 }
 
 /* --------------------------------------------------------------------------
@@ -129,6 +168,15 @@ static int uvcg_video_ep_queue(struct uvc_video *video, struct usb_request *req)
 {
 	int ret;
 
+	/*
+	 * Fixme, this is just to workaround the warning by udc core when the ep
+	 * is disabled, this may happens when the uvc application is still
+	 * streaming new data while the uvc gadget driver has already recieved
+	 * the streamoff but the streamoff event is not yet received by the app
+	 */
+	if (!video->ep->enabled)
+		return -EINVAL;
+
 	ret = usb_ep_queue(video->ep, req, GFP_ATOMIC);
 	if (ret < 0) {
 		uvcg_err(&video->uvc->func, "Failed to queue request (%d).\n",
@@ -176,9 +224,22 @@ static int
 uvc_video_free_requests(struct uvc_video *video)
 {
 	unsigned int i;
+#ifdef UVC_SG_REQ
+	unsigned int sg_idx;
+#endif
 
 	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
 		if (video->req[i]) {
+#ifdef UVC_SG_REQ
+			for (sg_idx = 0; sg_idx < video->num_sgs; sg_idx++)
+				if (sg_page(&video->req[i]->sg[sg_idx]))
+					kfree(sg_virt(&video->req[i]->sg[sg_idx]));
+
+			if (video->req[i]->sg) {
+				kfree(video->req[i]->sg);
+				video->req[i]->sg = NULL;
+			}
+#endif
 			usb_ep_free_request(video->ep, video->req[i]);
 			video->req[i] = NULL;
 		}
@@ -200,6 +261,11 @@ uvc_video_alloc_requests(struct uvc_video *video)
 	unsigned int req_size;
 	unsigned int i;
 	int ret = -ENOMEM;
+#ifdef UVC_SG_REQ
+	struct scatterlist  *sg;
+	unsigned int num_sgs;
+	unsigned int sg_idx;
+#endif
 
 	BUG_ON(video->req_size);
 
@@ -207,6 +273,35 @@ uvc_video_alloc_requests(struct uvc_video *video)
 		 * max_t(unsigned int, video->ep->maxburst, 1)
 		 * (video->ep->mult);
 
+#ifdef UVC_SG_REQ
+	num_sgs = ((video->imagesize / (req_size - 2)) + 1);
+	video->num_sgs = num_sgs;
+
+	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
+		sg = kmalloc(num_sgs * sizeof(struct scatterlist), GFP_ATOMIC);
+		if (sg == NULL)
+			goto error;
+		sg_init_table(sg, num_sgs);
+
+		video->req[i] = usb_ep_alloc_request(video->ep, GFP_KERNEL);
+		if (video->req[i] == NULL)
+			goto error;
+
+		for (sg_idx = 0 ; sg_idx < num_sgs ; sg_idx++) {
+			video->sg_buf = kmalloc(req_size, GFP_KERNEL);
+			if (video->sg_buf == NULL)
+				goto error;
+			sg_set_buf(&sg[sg_idx], video->sg_buf, req_size);
+		}
+		video->req[i]->sg = sg;
+		video->req[i]->num_sgs = num_sgs;
+		video->req[i]->length = 0;
+		video->req[i]->complete = uvc_video_complete;
+		video->req[i]->context = video;
+
+		list_add_tail(&video->req[i]->list, &video->req_free);
+	}
+#else
 	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
 		video->req_buffer[i] = kmalloc(req_size, GFP_KERNEL);
 		if (video->req_buffer[i] == NULL)
@@ -223,7 +318,7 @@ uvc_video_alloc_requests(struct uvc_video *video)
 
 		list_add_tail(&video->req[i]->list, &video->req_free);
 	}
-
+#endif
 	video->req_size = req_size;
 
 	return 0;
@@ -276,6 +371,9 @@ static void uvcg_video_pump(struct work_struct *work)
 			break;
 		}
 
+#ifdef UVC_SG_REQ
+	sg_unmark_end(&req->sg[req->num_sgs - 1]);
+#endif
 		video->encode(req, video, buf);
 
 		/* Queue the USB request */
@@ -289,6 +387,9 @@ static void uvcg_video_pump(struct work_struct *work)
 	}
 
 	spin_lock_irqsave(&video->req_lock, flags);
+#ifdef UVC_SG_REQ
+	sg_unmark_end(&req->sg[req->num_sgs - 1]);
+#endif
 	list_add_tail(&req->list, &video->req_free);
 	spin_unlock_irqrestore(&video->req_lock, flags);
 	return;
@@ -348,11 +449,17 @@ int uvcg_video_init(struct uvc_video *video, struct uvc_device *uvc)
 	INIT_WORK(&video->pump, uvcg_video_pump);
 
 	video->uvc = uvc;
+#ifndef CONFIG_HISI_MC
 	video->fcc = V4L2_PIX_FMT_YUYV;
+	video->imagesize = 320 * 240 * 2;
 	video->bpp = 16;
+#else
+	video->fcc = V4L2_PIX_FMT_NV21;
+	video->imagesize = 320 * 240 * 3 / 2;	/* YUV420: w*h*1.5 */
+	video->bpp = 12;
+#endif
 	video->width = 320;
 	video->height = 240;
-	video->imagesize = 320 * 240 * 2;
 
 	/* Initialize the video buffers queue. */
 	uvcg_queue_init(&video->queue, V4L2_BUF_TYPE_VIDEO_OUTPUT,
diff --git a/drivers/vfio/pci/vfio_pci_intrs.c b/drivers/vfio/pci/vfio_pci_intrs.c
index 869dce5f1..3807bb163 100644
--- a/drivers/vfio/pci/vfio_pci_intrs.c
+++ b/drivers/vfio/pci/vfio_pci_intrs.c
@@ -642,6 +642,8 @@ int vfio_pci_set_irqs_ioctl(struct vfio_pci_device *vdev, uint32_t flags,
 	int (*func)(struct vfio_pci_device *vdev, unsigned index,
 		    unsigned start, unsigned count, uint32_t flags,
 		    void *data) = NULL;
+	int ret;
+	u16 cmd;
 
 	switch (index) {
 	case VFIO_PCI_INTX_IRQ_INDEX:
@@ -689,5 +691,19 @@ int vfio_pci_set_irqs_ioctl(struct vfio_pci_device *vdev, uint32_t flags,
 	if (!func)
 		return -ENOTTY;
 
-	return func(vdev, index, start, count, flags, data);
+	if (index == VFIO_PCI_MSIX_IRQ_INDEX) {
+		down_write(&vdev->memory_lock);
+		pci_read_config_word(vdev->pdev, PCI_COMMAND, &cmd);
+		pci_write_config_word(vdev->pdev, PCI_COMMAND,
+				      cmd | PCI_COMMAND_MEMORY);
+	}
+
+	ret = func(vdev, index, start, count, flags, data);
+
+	if (index == VFIO_PCI_MSIX_IRQ_INDEX) {
+		pci_write_config_word(vdev->pdev, PCI_COMMAND, cmd);
+		up_write(&vdev->memory_lock);
+	}
+
+	return ret;
 }
diff --git a/drivers/vfio/vfio_iommu_spapr_tce.c b/drivers/vfio/vfio_iommu_spapr_tce.c
index fe888b5dc..5a0791e56 100644
--- a/drivers/vfio/vfio_iommu_spapr_tce.c
+++ b/drivers/vfio/vfio_iommu_spapr_tce.c
@@ -21,9 +21,9 @@
 #include <linux/sched/signal.h>
 #include <linux/mm.h>
 
-#include <asm/iommu.h>
-#include <asm/tce.h>
-#include <asm/mmu_context.h>
+#include <linux/iommu.h>
+/* #include <linux/tce.h> */
+#include <linux/mmu_context.h>
 
 #define DRIVER_VERSION  "0.1"
 #define DRIVER_AUTHOR   "aik@ozlabs.ru"
diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c
index fbd438e9b..64431a1a9 100644
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@ -28,6 +28,7 @@
 #include <linux/iommu.h>
 #include <linux/module.h>
 #include <linux/mm.h>
+#include <linux/ptrace.h>
 #include <linux/kthread.h>
 #include <linux/rbtree.h>
 #include <linux/sched/signal.h>
@@ -64,6 +65,7 @@ MODULE_PARM_DESC(dma_entry_limit,
 
 struct vfio_iommu {
 	struct list_head	domain_list;
+	struct list_head	mm_list;
 	struct list_head	iova_list;
 	struct vfio_domain	*external_domain; /* domain for external user */
 	struct mutex		lock;
@@ -103,6 +105,14 @@ struct vfio_group {
 	struct list_head	next;
 	bool			mdev_group;	/* An mdev group */
 	bool			pinned_page_dirty_scope;
+	bool                    sva_enabled;
+};
+
+struct vfio_mm {
+#define VFIO_PASID_INVALID	(-1)
+	int			pasid;
+	struct mm_struct	*mm;
+	struct list_head	next;
 };
 
 struct vfio_iova {
diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c
index 0791480bf..5a195dd31 100644
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -999,6 +999,7 @@ v9fs_vfs_getattr(const struct path *path, struct kstat *stat,
 		 u32 request_mask, unsigned int flags)
 {
 	struct dentry *dentry = path->dentry;
+	struct inode *inode = d_inode(dentry);
 	struct v9fs_session_info *v9ses;
 	struct p9_fid *fid;
 	struct p9_wstat *st;
@@ -1006,7 +1007,7 @@ v9fs_vfs_getattr(const struct path *path, struct kstat *stat,
 	p9_debug(P9_DEBUG_VFS, "dentry: %p\n", dentry);
 	v9ses = v9fs_dentry2v9ses(dentry);
 	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {
-		generic_fillattr(d_inode(dentry), stat);
+		generic_fillattr(inode, stat);
 		return 0;
 	}
 	fid = v9fs_fid_lookup(dentry);
@@ -1017,8 +1018,10 @@ v9fs_vfs_getattr(const struct path *path, struct kstat *stat,
 	if (IS_ERR(st))
 		return PTR_ERR(st);
 
-	v9fs_stat2inode(st, d_inode(dentry), dentry->d_sb, 0);
-	generic_fillattr(d_inode(dentry), stat);
+	spin_lock(&inode->i_lock);
+	v9fs_stat2inode(st, inode, dentry->d_sb);
+	spin_unlock(&inode->i_lock);
+	generic_fillattr(inode, stat);
 
 	p9stat_free(st);
 	kfree(st);
diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c
index 72b67d810..74629e0a7 100644
--- a/fs/9p/vfs_inode_dotl.c
+++ b/fs/9p/vfs_inode_dotl.c
@@ -459,6 +459,7 @@ v9fs_vfs_getattr_dotl(const struct path *path, struct kstat *stat,
 		 u32 request_mask, unsigned int flags)
 {
 	struct dentry *dentry = path->dentry;
+	struct inode *inode = d_inode(dentry);
 	struct v9fs_session_info *v9ses;
 	struct p9_fid *fid;
 	struct p9_stat_dotl *st;
@@ -466,7 +467,7 @@ v9fs_vfs_getattr_dotl(const struct path *path, struct kstat *stat,
 	p9_debug(P9_DEBUG_VFS, "dentry: %p\n", dentry);
 	v9ses = v9fs_dentry2v9ses(dentry);
 	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {
-		generic_fillattr(d_inode(dentry), stat);
+		generic_fillattr(inode, stat);
 		return 0;
 	}
 	fid = v9fs_fid_lookup(dentry);
@@ -481,8 +482,10 @@ v9fs_vfs_getattr_dotl(const struct path *path, struct kstat *stat,
 	if (IS_ERR(st))
 		return PTR_ERR(st);
 
-	v9fs_stat2inode_dotl(st, d_inode(dentry), 0);
-	generic_fillattr(d_inode(dentry), stat);
+	spin_lock(&inode->i_lock);
+	v9fs_stat2inode_dotl(st, inode);
+	spin_unlock(&inode->i_lock);
+	generic_fillattr(inode, stat);
 	/* Change block size to what the server returned */
 	stat->blksize = st->st_blksize;
 
diff --git a/fs/aio.c b/fs/aio.c
index bd182bcca..425db15b5 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1764,6 +1764,12 @@ static int aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)
 	INIT_LIST_HEAD(&req->wait.entry);
 	init_waitqueue_func_entry(&req->wait, aio_poll_wake);
 
+	/*
+	 * file may be released by aio_poll_wake() if an expected event
+	 * is triggered immediately after the return of vfs_poll(), so
+	 * an extra reference is needed here to prevent use-after-free.
+	 */
+	get_file(req->file);
 	mask = vfs_poll(req->file, &apt.pt) & req->events;
 	spin_lock_irq(&ctx->ctx_lock);
 	if (likely(req->head)) {
@@ -1791,6 +1797,8 @@ static int aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)
 	spin_unlock_irq(&ctx->ctx_lock);
 	if (mask)
 		iocb_put(aiocb);
+	/* release the extra reference for vfs_poll() */
+	fput(req->file);
 	return apt.error;
 }
 
diff --git a/fs/btrfs/block-group.c b/fs/btrfs/block-group.c
index c99e293b5..9a2861604 100644
--- a/fs/btrfs/block-group.c
+++ b/fs/btrfs/block-group.c
@@ -1824,6 +1824,41 @@ static struct btrfs_block_group *btrfs_create_block_group_cache(
 	return cache;
 }
 
+static int check_exist_chunk(struct btrfs_fs_info *fs_info, u64 start, u64 len,
+			     u64 flags)
+{
+	struct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;
+	struct extent_map *em;
+	int ret;
+
+	read_lock(&map_tree->map_tree.lock);
+	em = lookup_extent_mapping(&map_tree->map_tree, start, len);
+	read_unlock(&map_tree->map_tree.lock);
+
+	if (!em) {
+		btrfs_err_rl(fs_info,
+	"block group start=%llu len=%llu doesn't have corresponding chunk",
+			     start, len);
+		ret = -ENOENT;
+		goto out;
+	}
+	if (em->start != start || em->len != len ||
+	    (em->map_lookup->type & BTRFS_BLOCK_GROUP_TYPE_MASK) !=
+	    (flags & BTRFS_BLOCK_GROUP_TYPE_MASK)) {
+		btrfs_err_rl(fs_info,
+"block group start=%llu len=%llu flags=0x%llx doesn't match with chunk start=%llu len=%llu flags=0x%llx",
+			     start, len , flags & BTRFS_BLOCK_GROUP_TYPE_MASK,
+			     em->start, em->len, em->map_lookup->type &
+			     BTRFS_BLOCK_GROUP_TYPE_MASK);
+		ret = -EUCLEAN;
+		goto out;
+	}
+	ret = 0;
+out:
+	free_extent_map(em);
+	return ret;
+}
+
 /*
  * Iterate all chunks and verify that each of them has the corresponding block
  * group
@@ -2021,6 +2056,9 @@ int btrfs_read_block_groups(struct btrfs_fs_info *info)
 		need_clear = 1;
 
 	while (1) {
+		struct btrfs_block_group_item bg;
+		int slot;
+
 		ret = find_first_block_group(info, path, &key);
 		if (ret > 0)
 			break;
diff --git a/fs/fat/dir.c b/fs/fat/dir.c
index c4a274285..5972b82de 100644
--- a/fs/fat/dir.c
+++ b/fs/fat/dir.c
@@ -565,7 +565,8 @@ static int __fat_readdir(struct inode *inode, struct file *file,
 	const char *fill_name = NULL;
 	int fake_offset = 0;
 	loff_t cpos;
-	int short_len = 0, fill_len = 0;
+	int short_len;
+	int fill_len;
 	int ret = 0;
 
 	mutex_lock(&sbi->s_lock);
@@ -614,12 +615,13 @@ static int __fat_readdir(struct inode *inode, struct file *file,
 			bh = NULL;
 			ret = status;
 			goto end_of_dir;
-		} else if (status == PARSE_INVALID)
+		} else if (status == PARSE_INVALID) {
 			goto record_end;
-		else if (status == PARSE_NOT_LONGNAME)
+		} else if (status == PARSE_NOT_LONGNAME) {
 			goto parse_record;
-		else if (status == PARSE_EOF)
+		} else if (status == PARSE_EOF) {
 			goto end_of_dir;
+		}
 
 		if (nr_slots) {
 			void *longname = unicode + FAT_MAX_UNI_CHARS;
@@ -672,8 +674,9 @@ static int __fat_readdir(struct inode *inode, struct file *file,
 		if (tmp) {
 			inum = tmp->i_ino;
 			iput(tmp);
-		} else
+		} else {
 			inum = iunique(sb, MSDOS_ROOT_INO);
+		}
 		if (!dir_emit(ctx, fill_name, fill_len, inum,
 			    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG))
 			goto fill_failed;
@@ -783,6 +786,388 @@ static int fat_ioctl_readdir(struct inode *inode, struct file *file,
 		ret = buf.result;
 	return ret;
 }
+#ifdef CONFIG_HISI_MC
+/*
+ * This is the "fatfilldirall_t" function type,
+ * used by fat_ioctl_filldirall to let
+ * the kernel specify what kind of dirent layout it wants to have.
+ * This allows the kernel to read directories into kernel space or
+ * to have different dirent layouts depending on the binary type.
+ */
+typedef int (*fatfilldirall_t)(void *__buf, const char *name,
+		int name_len, loff_t offset, u64 ino,
+		unsigned int d_type, struct msdos_dir_entry *de,
+		char *d_createtime);
+struct fatdirall_context {
+	const fatfilldirall_t actor;
+	loff_t pos;
+};
+
+struct fat_ioctl_filldirall_callback {
+	struct fatdirall_context ctx;
+	struct fat_direntall __user *current_dir;
+	struct fat_direntall __user *previous;
+	int count;
+	int usecount;
+	int error;
+	int result;
+	const char *longname;
+	int long_len;
+	const char *shortname;
+	int short_len;
+};
+
+static inline bool fat_dir_emit(struct fatdirall_context *ctx,
+		const char *name, int namelen,
+		u64 ino, unsigned type,
+		struct msdos_dir_entry *de,
+		char *d_createtime)
+{
+	return ctx->actor(ctx, name, namelen, ctx->pos, ino,
+			type, de, d_createtime) == 0;
+}
+static inline bool fat_dir_emit_dot(struct file *file,
+					struct fatdirall_context *ctx,
+					struct msdos_dir_entry *de,
+					char *d_createtime)
+{
+	return ctx->actor(ctx, ".", 1, ctx->pos,
+			file->f_path.dentry->d_inode->i_ino,
+			DT_DIR, de, d_createtime) == 0;
+}
+static inline bool fat_dir_emit_dotdot(struct file *file,
+					struct fatdirall_context *ctx,
+					struct msdos_dir_entry *de,
+					char *d_createtime)
+{
+	return ctx->actor(ctx, "..", 2, ctx->pos,
+			parent_ino(file->f_path.dentry),
+			DT_DIR, de, d_createtime) == 0;
+}
+
+static inline bool fat_dir_emit_dots(struct file *file,
+					struct fatdirall_context *ctx,
+					struct msdos_dir_entry *de,
+					char *d_createtime)
+{
+	if (ctx->pos == 0) {
+		if (!fat_dir_emit_dot(file, ctx, de, d_createtime))
+			return false;
+		ctx->pos = 1;
+	}
+	if (ctx->pos == 1) {
+		if (!fat_dir_emit_dotdot(file, ctx, de, d_createtime))
+			return false;
+		ctx->pos = 2;
+	}
+	return true;
+}
+
+
+static int __fat_readdirall(struct inode *inode, struct file *file,
+		struct fatdirall_context *ctx, int short_only,
+		struct fat_ioctl_filldirall_callback *both)
+{
+	struct super_block *sb = inode->i_sb;
+	struct msdos_sb_info *sbi = MSDOS_SB(sb);
+	struct buffer_head *bh;
+	struct msdos_dir_entry *de;
+	unsigned char nr_slots;
+	wchar_t *unicode = NULL;
+	unsigned char bufname[FAT_MAX_SHORT_SIZE];
+	int isvfat = sbi->options.isvfat;
+	const char *fill_name = NULL;
+	int fake_offset = 0;
+	loff_t cpos;
+	int short_len = 0, fill_len = 0;
+	int ret = 0;
+	char d_createtime[8];
+
+	mutex_lock(&sbi->s_lock);
+
+	cpos = ctx->pos;
+	/* Fake . and .. for the root directory. */
+	if (inode->i_ino == MSDOS_ROOT_INO) {
+		if (!fat_dir_emit_dots(file, ctx, NULL, NULL))
+			goto out;
+		if (ctx->pos == 2) {
+			fake_offset = 1;
+			cpos = 0;
+		}
+	}
+	if (cpos & (sizeof(struct msdos_dir_entry) - 1)) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	bh = NULL;
+get_new:
+	if (fat_get_entry(inode, &cpos, &bh, &de) == -1)
+		goto end_of_dir;
+parse_record:
+	nr_slots = 0;
+	/*
+	 * Check for long filename entry, but if short_only, we don't
+	 * need to parse long filename.
+	 */
+	if (isvfat && !short_only) {
+		if (de->name[0] == DELETED_FLAG)
+			goto record_end;
+		if (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))
+			goto record_end;
+		if (de->attr != ATTR_EXT && IS_FREE(de->name))
+			goto record_end;
+	} else {
+		if ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))
+			goto record_end;
+	}
+
+	if (isvfat && de->attr == ATTR_EXT) {
+		int status = fat_parse_long(inode, &cpos, &bh, &de,
+				&unicode, &nr_slots);
+		if (status < 0) {
+			ctx->pos = cpos;
+			ret = status;
+			goto out;
+		} else if (status == PARSE_INVALID)
+			goto record_end;
+		else if (status == PARSE_NOT_LONGNAME)
+			goto parse_record;
+		else if (status == PARSE_EOF)
+			goto end_of_dir;
+
+		if (nr_slots) {
+			void *longname = unicode + FAT_MAX_UNI_CHARS;
+			int size = PATH_MAX - FAT_MAX_UNI_SIZE;
+			int len = fat_uni_to_x8(sb, unicode, longname, size);
+
+			fill_name = longname;
+			fill_len = len;
+
+			short_len = fat_parse_short(sb, de, bufname,
+					sbi->options.dotsOK);
+			if (short_len == 0)
+				goto record_end;
+
+			/* hack for fat_ioctl_filldir() */
+			both->longname = fill_name;
+			both->long_len = fill_len;
+			both->shortname = bufname;
+			both->short_len = short_len;
+			fill_name = NULL;
+			fill_len = 0;
+			goto start_filldir;
+		}
+	}
+
+	short_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);
+	if (short_len == 0)
+		goto record_end;
+
+	fill_name = bufname;
+	fill_len = short_len;
+
+start_filldir:
+	if (!fake_offset)
+		ctx->pos = cpos - (nr_slots + 1)
+			* sizeof(struct msdos_dir_entry);
+
+	memset(d_createtime, 0, 8);
+	fat_time_fat2str(sbi, d_createtime, de->ctime,
+			de->cdate, de->ctime_cs);
+
+	if (!memcmp(de->name, MSDOS_DOT, MSDOS_NAME)) {
+		if (!fat_dir_emit_dot(file, ctx, de, d_createtime))
+			goto fill_failed;
+	} else if (!memcmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {
+		if (!fat_dir_emit_dotdot(file, ctx, de, d_createtime))
+			goto fill_failed;
+	} else {
+		unsigned long inum;
+		loff_t i_pos = fat_make_i_pos(sb, bh, de);
+		struct inode *tmp = fat_iget(sb, i_pos);
+
+		if (tmp) {
+			inum = tmp->i_ino;
+			iput(tmp);
+		} else
+			inum = iunique(sb, MSDOS_ROOT_INO);
+		if (!fat_dir_emit(ctx, fill_name, fill_len, inum,
+					(de->attr & ATTR_DIR) ? DT_DIR : DT_REG,
+					de, d_createtime))
+			goto fill_failed;
+	}
+
+record_end:
+	fake_offset = 0;
+	ctx->pos = cpos;
+	goto get_new;
+end_of_dir:
+	ctx->pos = cpos;
+fill_failed:
+	brelse(bh);
+	if (unicode)
+		__putname(unicode);
+out:
+	mutex_unlock(&sbi->s_lock);
+	return ret;
+}
+
+static int fat_ioctl_filldirall(void *__buf, const char *name,
+				int name_len, loff_t offset,
+				u64 ino, unsigned int d_type,
+				struct msdos_dir_entry *de,
+				char *d_createtime)
+{
+	struct fat_direntall __user *dirent;
+	struct fat_ioctl_filldirall_callback *buf;
+	unsigned long d_ino;
+	int reclen = 0;
+	const char *longname = NULL;
+	int long_len = 0;
+	const char *shortname = NULL;
+	int short_len = 0;
+
+	buf = (struct fat_ioctl_filldirall_callback *) __buf;
+
+	if (name != NULL) {
+		reclen = ALIGN(offsetof(struct fat_direntall, d_name)
+				+ name_len + 2, sizeof(long));
+	} else {
+		longname = buf->longname;
+		long_len = buf->long_len;
+		shortname = buf->shortname;
+		short_len = buf->short_len;
+		reclen = ALIGN(offsetof(struct fat_direntall, d_name)
+				+ long_len + 2, sizeof(long));
+	}
+
+	buf->error = -EINVAL;   /* only used if we fail.. */
+
+	if (reclen >= buf->count)
+		return -EINVAL;
+
+	d_ino = ino;
+
+	if (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {
+		buf->error = -EOVERFLOW;
+		return -EOVERFLOW;
+	}
+
+	dirent = buf->previous;
+
+	if (dirent) {
+		if (__put_user(offset, &dirent->d_off))
+			goto efault;
+	}
+
+	dirent = buf->current_dir;
+
+	if (__put_user(d_ino, &dirent->d_ino))
+		goto efault;
+
+	if (__put_user(reclen, &dirent->d_reclen))
+		goto efault;
+
+	if (name != NULL) {
+		if (copy_to_user(dirent->d_name, name, name_len))
+			goto efault;
+		if (__put_user(0, dirent->d_name + name_len))
+			goto efault;
+	} else {
+		if (copy_to_user(dirent->d_name, longname, long_len))
+			goto efault;
+		if (__put_user(0, dirent->d_name + long_len))
+			goto efault;
+	}
+
+	if (__put_user(d_type, &dirent->d_type))
+		goto efault;
+
+	if (de != NULL) {
+		u64 u_size = 0;
+		if (copy_to_user(&dirent->d_size, &u_size, sizeof(u64)))
+			goto efault;
+		if (copy_to_user(&dirent->d_size, &de->size, sizeof(u32)))
+			goto efault;
+	}
+
+	if (d_createtime != NULL) {
+		if (copy_to_user(dirent->d_createtime, d_createtime, 8))
+			goto efault;
+	}
+	buf->previous = dirent;
+	dirent = (void __user *)dirent + reclen;
+	buf->current_dir = dirent;
+	buf->count -= reclen;
+	buf->usecount += reclen;
+	return 0;
+efault:
+	buf->error = -EFAULT;
+	return -EFAULT;
+}
+
+
+static int fat_ioctl_readdirall(struct inode *inode, struct file *file,
+		void __user *dirent,
+		int short_only, int both)
+{
+	struct fat_ioctl_filldirall_callback buf = {
+		.ctx.actor = fat_ioctl_filldirall,
+	};
+
+	struct fat_direntall_buf __user *userbuf = dirent;
+	int ret;
+
+	buf.current_dir = &(userbuf->direntall);
+	buf.previous = NULL;
+	buf.error = 0;
+	buf.result = 0;
+	buf.usecount = 0;
+
+	if (get_user(buf.count, &(userbuf->d_count)))
+		return -EFAULT;
+
+	up_read(&inode->i_rwsem);
+	buf.ctx.pos = file->f_pos;
+	ret = -ENOENT;
+	if (!IS_DEADDIR(inode)) {
+		ret = __fat_readdirall(inode, file, &buf.ctx,
+				short_only, both ? &buf : NULL);
+		file->f_pos = buf.ctx.pos;
+	}
+	down_read(&inode->i_rwsem);
+
+	if (__put_user(buf.usecount, &(userbuf->d_usecount)))
+		return -EFAULT;
+	if (ret >= 0)
+		ret = buf.result;
+	return ret;
+}
+
+static int fat_dir_ioctl_readdirall(struct file *filp, unsigned int cmd,
+					unsigned long arg)
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct fat_direntall_buf __user *direntallbuf;
+	int short_only, both;
+
+	direntallbuf = (struct fat_direntall_buf __user *)arg;
+
+	if (!access_ok(VERIFY_WRITE, direntallbuf,
+			sizeof(struct fat_direntall_buf)))
+		return -EFAULT;
+	if (put_user(0, &(direntallbuf->direntall.d_reclen)))
+		return -EFAULT;
+	if (put_user(0, &(direntallbuf->d_usecount)))
+		return -EFAULT;
+	short_only = 0;
+	both = 1;
+	return fat_ioctl_readdirall(inode, filp, direntallbuf,
+			short_only, both);
+}
+#endif
+
 
 static long fat_dir_ioctl(struct file *filp, unsigned int cmd,
 			  unsigned long arg)
@@ -790,7 +1175,10 @@ static long fat_dir_ioctl(struct file *filp, unsigned int cmd,
 	struct inode *inode = file_inode(filp);
 	struct __fat_dirent __user *d1 = (struct __fat_dirent __user *)arg;
 	int short_only, both;
-
+#ifdef CONFIG_HISI_MC
+	if (VFAT_IOCTL_READDIR_ALL == cmd)
+		return fat_dir_ioctl_readdirall(filp, cmd, arg);
+#endif
 	switch (cmd) {
 	case VFAT_IOCTL_READDIR_SHORT:
 		short_only = 1;
@@ -1094,11 +1482,15 @@ static int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,
 			err = -ENOMEM;
 			goto error;
 		}
+#ifndef CONFIG_ARCH_HISI_BVT
 		/* Avoid race with userspace read via bdev */
 		lock_buffer(bhs[n]);
+#endif
 		memset(bhs[n]->b_data, 0, sb->s_blocksize);
 		set_buffer_uptodate(bhs[n]);
+#ifndef CONFIG_ARCH_HISI_BVT
 		unlock_buffer(bhs[n]);
+#endif
 		mark_buffer_dirty_inode(bhs[n], dir);
 
 		n++;
@@ -1155,8 +1547,10 @@ int fat_alloc_new_dir(struct inode *dir, struct timespec64 *ts)
 	fat_time_unix2fat(sbi, ts, &time, &date, &time_cs);
 
 	de = (struct msdos_dir_entry *)bhs[0]->b_data;
+#ifndef CONFIG_ARCH_HISI_BVT
 	/* Avoid race with userspace read via bdev */
 	lock_buffer(bhs[0]);
+#endif
 	/* filling the new directory slots ("." and ".." entries) */
 	memcpy(de[0].name, MSDOS_DOT, MSDOS_NAME);
 	memcpy(de[1].name, MSDOS_DOTDOT, MSDOS_NAME);
@@ -1179,7 +1573,9 @@ int fat_alloc_new_dir(struct inode *dir, struct timespec64 *ts)
 	de[0].size = de[1].size = 0;
 	memset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));
 	set_buffer_uptodate(bhs[0]);
+#ifndef CONFIG_ARCH_HISI_BVT
 	unlock_buffer(bhs[0]);
+#endif
 	mark_buffer_dirty_inode(bhs[0], dir);
 
 	err = fat_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);
@@ -1237,11 +1633,15 @@ static int fat_add_new_entries(struct inode *dir, void *slots, int nr_slots,
 
 			/* fill the directory entry */
 			copy = min(size, sb->s_blocksize);
+#ifndef CONFIG_ARCH_HISI_BVT
 			/* Avoid race with userspace read via bdev */
 			lock_buffer(bhs[n]);
+#endif
 			memcpy(bhs[n]->b_data, slots, copy);
 			set_buffer_uptodate(bhs[n]);
+#ifndef CONFIG_ARCH_HISI_BVT
 			unlock_buffer(bhs[n]);
+#endif
 			mark_buffer_dirty_inode(bhs[n], dir);
 			slots += copy;
 			size -= copy;
diff --git a/fs/fat/fat.h b/fs/fat/fat.h
index 922a0c6ba..a84663246 100644
--- a/fs/fat/fat.h
+++ b/fs/fat/fat.h
@@ -444,6 +444,10 @@ extern void fat_time_fat2unix(struct msdos_sb_info *sbi, struct timespec64 *ts,
 			      __le16 __time, __le16 __date, u8 time_cs);
 extern void fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec64 *ts,
 			      __le16 *time, __le16 *date, u8 *time_cs);
+#ifdef CONFIG_HISI_MC
+extern void fat_time_fat2str(struct msdos_sb_info *sbi, char *d_createtime,
+		__le16 __time, __le16 __date, u8 time_cs);
+#endif
 extern int fat_truncate_time(struct inode *inode, struct timespec64 *now,
 			     int flags);
 extern int fat_update_time(struct inode *inode, struct timespec64 *now,
diff --git a/fs/fat/fatent.c b/fs/fat/fatent.c
index f7e3304b7..4351eaa8b 100644
--- a/fs/fat/fatent.c
+++ b/fs/fat/fatent.c
@@ -379,6 +379,9 @@ static int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,
 	int err, n, copy;
 
 	err = 0;
+#ifdef CONFIG_HISI_MC
+	return 0;
+#endif
 	for (copy = 1; copy < sbi->fats; copy++) {
 		sector_t backup_fat = sbi->fat_length * copy;
 
@@ -388,11 +391,15 @@ static int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,
 				err = -ENOMEM;
 				goto error;
 			}
+#ifndef CONFIG_ARCH_HISI_BVT
 			/* Avoid race with userspace read via bdev */
 			lock_buffer(c_bh);
+#endif
 			memcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);
 			set_buffer_uptodate(c_bh);
+#ifndef CONFIG_ARCH_HISI_BVT
 			unlock_buffer(c_bh);
+#endif
 			mark_buffer_dirty_inode(c_bh, sbi->fat_inode);
 			if (sb->s_flags & SB_SYNCHRONOUS)
 				err = sync_dirty_buffer(c_bh);
diff --git a/fs/fat/file.c b/fs/fat/file.c
index f9ee27cf4..f424520d7 100644
--- a/fs/fat/file.c
+++ b/fs/fat/file.c
@@ -198,6 +198,17 @@ int fat_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)
 	return blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL);
 }
 
+#ifdef CONFIG_HISI_MC
+int fat_file_flush(struct file *file, fl_owner_t id)
+{
+	struct address_space * mapping = file->f_mapping;
+	struct inode *inode = mapping->host;
+
+	inode->i_sb->s_op->write_inode(inode, NULL);
+
+	return 0;
+}
+#endif
 
 const struct file_operations fat_file_operations = {
 	.llseek		= generic_file_llseek,
@@ -211,6 +222,9 @@ const struct file_operations fat_file_operations = {
 	.splice_read	= generic_file_splice_read,
 	.splice_write	= iter_file_splice_write,
 	.fallocate	= fat_fallocate,
+#ifdef CONFIG_HISI_MC
+	.flush		= fat_file_flush,
+#endif
 };
 
 static int fat_cont_expand(struct inode *inode, loff_t size)
@@ -461,7 +475,13 @@ static int fat_allow_set_time(struct msdos_sb_info *sbi, struct inode *inode)
 	/* use a default check */
 	return 0;
 }
-
+#ifdef CONFIG_HISI_MC
+void reset_mmu_private(struct inode *inode, loff_t offset)
+{
+	MSDOS_I(inode)->mmu_private = offset;
+	inode->i_ctime = inode->i_mtime = ((struct timespec64) { get_seconds(), 0 });
+}
+#endif
 #define TIMES_SET_FLAGS	(ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)
 /* valid file mode bits */
 #define FAT_VALID_MODE	(S_IFREG | S_IFDIR | S_IRWXUGO)
@@ -494,6 +514,7 @@ int fat_setattr(struct dentry *dentry, struct iattr *attr)
 	 * hole before it. XXX: this is no longer true with new truncate
 	 * sequence.
 	 */
+#ifndef CONFIG_HISI_MC
 	if (attr->ia_valid & ATTR_SIZE) {
 		inode_dio_wait(inode);
 
@@ -504,7 +525,7 @@ int fat_setattr(struct dentry *dentry, struct iattr *attr)
 			attr->ia_valid &= ~ATTR_SIZE;
 		}
 	}
-
+#endif
 	if (((attr->ia_valid & ATTR_UID) &&
 	     (!uid_eq(attr->ia_uid, sbi->options.fs_uid))) ||
 	    ((attr->ia_valid & ATTR_GID) &&
@@ -534,6 +555,9 @@ int fat_setattr(struct dentry *dentry, struct iattr *attr)
 			goto out;
 		down_write(&MSDOS_I(inode)->truncate_lock);
 		truncate_setsize(inode, attr->ia_size);
+#ifdef CONFIG_HISI_MC
+		reset_mmu_private(inode, attr->ia_size);
+#endif
 		fat_truncate_blocks(inode, attr->ia_size);
 		up_write(&MSDOS_I(inode)->truncate_lock);
 	}
diff --git a/fs/fat/inode.c b/fs/fat/inode.c
index bab9b202b..769444c64 100644
--- a/fs/fat/inode.c
+++ b/fs/fat/inode.c
@@ -628,8 +628,9 @@ static void fat_free_eofblocks(struct inode *inode)
 			round_up(MSDOS_I(inode)->mmu_private,
 				MSDOS_SB(inode->i_sb)->cluster_size)) {
 		int err;
-
+#ifndef CONFIG_HISI_MC
 		fat_truncate_blocks(inode, MSDOS_I(inode)->mmu_private);
+#endif
 		/* Fallocate results in updating the i_start/iogstart
 		 * for the zero byte file. So, make it return to
 		 * original state during evict and commit it to avoid
@@ -899,7 +900,70 @@ static int __fat_write_inode(struct inode *inode, int wait)
 	brelse(bh);
 	return err;
 }
+#ifdef CONFIG_HISI_MC
+static int __fat_write_inode_(struct inode *inode, int wait)
+{
+	struct super_block *sb = inode->i_sb;
+	struct msdos_sb_info *sbi = MSDOS_SB(sb);
+	struct buffer_head *bh;
+	struct msdos_dir_entry *raw_entry;
+	loff_t i_pos;
+	sector_t blocknr;
+	int err = 0;
+	int offset;
+
+	if (inode->i_ino == MSDOS_ROOT_INO)
+		return 0;
+
+retry:
+	i_pos = fat_i_pos_read(sbi, inode);
+	if (!i_pos)
+		return 0;
+
+	fat_get_blknr_offset(sbi, i_pos, &blocknr, &offset);
+	bh = sb_bread(sb, blocknr);
+	if (!bh) {
+		fat_msg(sb, KERN_ERR, "unable to read inode block "
+		       "for updating (i_pos %lld)", i_pos);
+		return -EIO;
+	}
+	spin_lock(&sbi->inode_hash_lock);
+	if (i_pos != MSDOS_I(inode)->i_pos) {
+		spin_unlock(&sbi->inode_hash_lock);
+		brelse(bh);
+		goto retry;
+	}
 
+	raw_entry = &((struct msdos_dir_entry *) (bh->b_data))[offset];
+	if (S_ISDIR(inode->i_mode)) {
+		raw_entry->size = 0;
+	} else {
+		if ((raw_entry->start != 0) || (raw_entry->starthi != 0)) {
+			spin_unlock(&sbi->inode_hash_lock);
+			goto file_out;
+		}
+		raw_entry->size = cpu_to_le32(inode->i_size);
+	}
+	raw_entry->attr = fat_make_attrs(inode);
+	fat_set_start(raw_entry, MSDOS_I(inode)->i_logstart);
+	fat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,
+			  &raw_entry->date, NULL);
+	if (sbi->options.isvfat) {
+		__le16 atime;
+		fat_time_unix2fat(sbi, &inode->i_ctime, &raw_entry->ctime,
+				  &raw_entry->cdate, &raw_entry->ctime_cs);
+		fat_time_unix2fat(sbi, &inode->i_atime, &atime,
+				  &raw_entry->adate, NULL);
+	}
+	spin_unlock(&sbi->inode_hash_lock);
+	mark_buffer_dirty(bh);
+	if (wait)
+		err = sync_dirty_buffer(bh);
+file_out:
+	brelse(bh);
+	return err;
+}
+#endif
 static int fat_write_inode(struct inode *inode, struct writeback_control *wbc)
 {
 	int err;
@@ -910,8 +974,17 @@ static int fat_write_inode(struct inode *inode, struct writeback_control *wbc)
 		mutex_lock(&MSDOS_SB(sb)->s_lock);
 		err = fat_clusters_flush(sb);
 		mutex_unlock(&MSDOS_SB(sb)->s_lock);
-	} else
-		err = __fat_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);
+	} else {
+#ifdef CONFIG_HISI_MC
+		if (NULL == wbc) {
+			err = __fat_write_inode(inode, 1);
+		} else {
+			err = __fat_write_inode_(inode, wbc->sync_mode == WB_SYNC_ALL);
+		}
+#else
+			err = __fat_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);
+#endif
+	}
 
 	return err;
 }
diff --git a/fs/fat/misc.c b/fs/fat/misc.c
index f1b2a1fc2..ddb5cf98a 100644
--- a/fs/fat/misc.c
+++ b/fs/fat/misc.c
@@ -198,7 +198,8 @@ static inline int fat_tz_offset(struct msdos_sb_info *sbi)
 void fat_time_fat2unix(struct msdos_sb_info *sbi, struct timespec64 *ts,
 		       __le16 __time, __le16 __date, u8 time_cs)
 {
-	u16 time = le16_to_cpu(__time), date = le16_to_cpu(__date);
+	u16 time = le16_to_cpu(__time);
+	u16 date = le16_to_cpu(__date);
 	time64_t second;
 	long day, leap_day, month, year;
 
@@ -267,6 +268,35 @@ void fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec64 *ts,
 }
 EXPORT_SYMBOL_GPL(fat_time_unix2fat);
 
+#ifdef CONFIG_HISI_MC
+void fat_time_fat2str(struct msdos_sb_info *sbi, char *d_createtime,
+		__le16 __time, __le16 __date, u8 time_cs)
+{
+	u16 time = le16_to_cpu(__time), date = le16_to_cpu(__date);
+	time_t day, month, year;
+
+	year  = date >> 9;
+	month = max(1, (date >> 5) & 0xf);
+	day   = max(1, date & 0x1f) - 1;
+
+	d_createtime[0] = year;
+	d_createtime[1] = month;
+	d_createtime[2] = day;
+	d_createtime[3] = (time >> 11);  /*hour*/
+	d_createtime[4] = ((time >> 5) & 0x3f);  /*min*/
+	d_createtime[5] = (time & 0x1f);  /*second 2s*/
+
+	if (!sbi->options.tz_set)
+		d_createtime[4] += sys_tz.tz_minuteswest;
+	else
+		d_createtime[4] -= sbi->options.time_offset;
+
+	if (time_cs)
+		d_createtime[5] += (time_cs / 100); /*second 1s*/
+}
+EXPORT_SYMBOL_GPL(fat_time_fat2str);
+#endif
+
 static inline struct timespec64 fat_timespec64_trunc_2secs(struct timespec64 ts)
 {
 	return (struct timespec64){ ts.tv_sec & ~1ULL, 0 };
diff --git a/fs/jffs2/compr.h b/fs/jffs2/compr.h
index 5e91d578f..01116b8ea 100644
--- a/fs/jffs2/compr.h
+++ b/fs/jffs2/compr.h
@@ -29,9 +29,15 @@
 #define JFFS2_DYNRUBIN_PRIORITY  20
 #define JFFS2_LZARI_PRIORITY     30
 #define JFFS2_RTIME_PRIORITY     50
+
+#ifdef CONFIG_HISI_MC
+#define JFFS2_LZMA_PRIORITY      70
+#define JFFS2_ZLIB_PRIORITY      80
+#define JFFS2_LZO_PRIORITY       90
+#else
 #define JFFS2_ZLIB_PRIORITY      60
 #define JFFS2_LZO_PRIORITY       80
-
+#endif
 
 #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
 #define JFFS2_DYNRUBIN_DISABLED  /*	   for decompression */
diff --git a/fs/ubifs/file.c b/fs/ubifs/file.c
index df46f2d3f..b38ea130b 100644
--- a/fs/ubifs/file.c
+++ b/fs/ubifs/file.c
@@ -1493,6 +1493,9 @@ static int ubifs_releasepage(struct page *page, gfp_t unused_gfp_flags)
 	 */
 	if (PageWriteback(page))
 		return 0;
+#ifdef CONFIG_ARCH_HISI_BVT
+	return 0;
+#endif
 	ubifs_assert(c, PagePrivate(page));
 	ubifs_assert(c, 0);
 	detach_page_private(page);
diff --git a/include/dt-bindings/clock/hi3516dv300-clock.h b/include/dt-bindings/clock/hi3516dv300-clock.h
new file mode 100644
index 000000000..408c9b09d
--- /dev/null
+++ b/include/dt-bindings/clock/hi3516dv300-clock.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __DTS_HI3516DV300_CLOCK_H
+#define __DTS_HI3516DV300_CLOCK_H
+
+/* clk in Hi3516CV500 CRG */
+/* fixed rate clocks */
+#define HI3516DV300_FIXED_3M        1
+#define HI3516DV300_FIXED_6M        2
+#define HI3516DV300_FIXED_12M       3
+#define HI3516DV300_FIXED_24M       4
+#define HI3516DV300_FIXED_50M       5
+#define HI3516DV300_FIXED_83P3M     6
+#define HI3516DV300_FIXED_100M      7
+#define HI3516DV300_FIXED_125M      8
+#define HI3516DV300_FIXED_148P5M    9
+#define HI3516DV300_FIXED_150M      10
+#define HI3516DV300_FIXED_200M      11
+#define HI3516DV300_FIXED_250M      12
+#define HI3516DV300_FIXED_300M      13
+#define HI3516DV300_FIXED_324M      14
+#define HI3516DV300_FIXED_342M      15
+#define HI3516DV300_FIXED_375M      16
+#define HI3516DV300_FIXED_400M      17
+#define HI3516DV300_FIXED_448M      18
+#define HI3516DV300_FIXED_500M      19
+#define HI3516DV300_FIXED_540M      20
+#define HI3516DV300_FIXED_600M      21
+#define HI3516DV300_FIXED_750M      22
+#define HI3516DV300_FIXED_1000M     23
+#define HI3516DV300_FIXED_1500M     24
+#define HI3516DV300_FIXED_54M       25
+#define HI3516DV300_FIXED_25M       26
+#define HI3516DV300_FIXED_163M      27
+#define HI3516DV300_FIXED_257M      28
+#define HI3516DV300_FIXED_396M      29
+
+/* mux clocks */
+#define HI3516DV300_SYSAXI_CLK      30
+#define HI3516DV300_SYSAPB_CLK      31
+#define HI3516DV300_FMC_MUX         32
+#define HI3516DV300_UART_MUX        33
+#define HI3516DV300_MMC0_MUX        34
+#define HI3516DV300_MMC1_MUX        35
+#define HI3516DV300_MMC2_MUX        36
+#define HI3516DV300_UART1_MUX       33
+#define HI3516DV300_UART2_MUX       37
+#define HI3516DV300_UART4_MUX       38
+#define HI3516DV300_ETH_MUX     39
+
+/* gate clocks */
+#define HI3516DV300_UART0_CLK       40
+#define HI3516DV300_UART1_CLK       41
+#define HI3516DV300_UART2_CLK       42
+#define HI3516DV300_FMC_CLK         43
+#define HI3516DV300_ETH0_CLK        44
+#define HI3516DV300_USB2_BUS_CLK    45
+#define HI3516DV300_USB2_CLK        46
+#define HI3516DV300_DMAC_CLK        47
+#define HI3516DV300_SPI0_CLK        48
+#define HI3516DV300_SPI1_CLK        49
+#define HI3516DV300_MMC0_CLK        50
+#define HI3516DV300_MMC1_CLK        51
+#define HI3516DV300_MMC2_CLK        52
+#define HI3516DV300_UART4_CLK       53
+#define HI3516DV300_SPI2_CLK        54
+#define HI3516DV300_I2C0_CLK        55
+#define HI3516DV300_I2C1_CLK        56
+#define HI3516DV300_I2C2_CLK        57
+#define HI3516DV300_I2C3_CLK        58
+#define HI3516DV300_I2C4_CLK        59
+#define HI3516DV300_I2C5_CLK        60
+#define HI3516DV300_I2C6_CLK        61
+#define HI3516DV300_I2C7_CLK        62
+#define HI3516DV300_UART3_MUX       63
+#define HI3516DV300_UART3_CLK       64
+#define HI3516DV300_DMAC_AXICLK     70
+#define HI3516DV300_PWM_CLK         71
+#define HI3516DV300_PWM_MUX         72
+
+#define HI3516DV300_NR_CLKS     256
+#define HI3516DV300_NR_RSTS     256
+
+#endif  /* __DTS_HI3516DV300_CLOCK_H */
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 31febd3e1..0fa3ac740 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -1384,7 +1384,11 @@ static inline bool bdev_is_partition(struct block_device *bdev)
 enum blk_default_limits {
 	BLK_MAX_SEGMENTS	= 128,
 	BLK_SAFE_MAX_SECTORS	= 255,
+#ifndef CONFIG_HISI_MC
 	BLK_DEF_MAX_SECTORS	= 2560,
+#else
+	BLK_DEF_MAX_SECTORS	= 8192,
+#endif
 	BLK_MAX_SEGMENT_SIZE	= 65536,
 	BLK_SEG_BOUNDARY_MASK	= 0xFFFFFFFFUL,
 };
diff --git a/include/linux/cpu.h b/include/linux/cpu.h
index d6428aaf6..a8d659c9a 100644
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@ -41,6 +41,7 @@ extern bool arch_match_cpu_phys_id(int cpu, u64 phys_id);
 extern bool arch_find_n_match_cpu_physical_id(struct device_node *cpun,
 					      int cpu, unsigned int *thread);
 
+extern int hi_register_cpu_notifier(struct notifier_block *nb);
 extern int cpu_add_dev_attr(struct device_attribute *attr);
 extern void cpu_remove_dev_attr(struct device_attribute *attr);
 
diff --git a/include/linux/fb.h b/include/linux/fb.h
index ecfbcc055..b8567818b 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -293,6 +293,12 @@ struct fb_ops {
 	/* called at KDB enter and leave time to prepare the console */
 	int (*fb_debug_enter)(struct fb_info *info);
 	int (*fb_debug_leave)(struct fb_info *info);
+#ifdef CONFIG_ARCH_HISI_BVT
+#ifdef CONFIG_DMA_SHARED_BUFFER
+	/* Export the frame buffer as a dmabuf object */
+	struct dma_buf *(*fb_dmabuf_export)(struct fb_info *info);
+#endif
+#endif
 };
 
 #ifdef CONFIG_FB_TILEBLITTING
diff --git a/include/linux/hi_cma.h b/include/linux/hi_cma.h
new file mode 100644
index 000000000..38444524f
--- /dev/null
+++ b/include/linux/hi_cma.h
@@ -0,0 +1,54 @@
+/*
+ * hi_cma.h
+ *
+ * Copyright (c) 2019 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __HI_CMA_H__
+#define __HI_CMA_H__
+
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-map-ops.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/cma.h>
+#include <linux/memblock.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
+
+#define NAME_LEN_MAX   64
+#define ZONE_MAX       64
+
+struct cma_zone {
+	struct device pdev;
+	char name[NAME_LEN_MAX];
+	gfp_t gfp;
+	phys_addr_t phys_start;
+	phys_addr_t nbytes;
+	u32 alloc_type;
+	u32 block_align;
+};
+
+#ifdef CONFIG_CMA
+int is_hicma_address(phys_addr_t phys, unsigned long size);
+phys_addr_t hisi_get_zones_start(void);
+struct cma_zone *hisi_get_cma_zone(const char *name);
+struct device *hisi_get_cma_device(const char *name);
+int __init hisi_declare_heap_memory(void);
+#endif /* CONFIG_CMA */
+
+#endif
diff --git a/include/linux/hiedmac.h b/include/linux/hiedmac.h
new file mode 100644
index 000000000..26157899a
--- /dev/null
+++ b/include/linux/hiedmac.h
@@ -0,0 +1,65 @@
+#ifndef __DMAC_H__
+#define __DMAC_H__
+
+#define DMAC_ERROR_BASE     0x64
+
+#define DMAC_CHN_SUCCESS            (DMAC_ERROR_BASE + 0x10)
+#define DMAC_CHN_ERROR              (DMAC_ERROR_BASE + 0x11)
+#define DMAC_CHN_TIMEOUT            (DMAC_ERROR_BASE + 0x12)
+#define DMAC_CHN_ALLOCAT            (DMAC_ERROR_BASE + 0x13)
+#define DMAC_CHN_VACANCY            (DMAC_ERROR_BASE + 0x14)
+#define DMAC_NOT_FINISHED           (DMAC_ERROR_BASE + 0xe)
+
+#ifdef CONFIG_HIEDMAC
+extern int dma_driver_init(void);
+extern int dmac_channelclose(unsigned int channel);
+extern int dmac_channelstart(unsigned int u32channel);
+extern int dmac_channel_allocate(void);
+
+extern int dmac_start_m2p(unsigned int channel, unsigned int pmemaddr,
+			  unsigned int uwperipheralid,
+			  unsigned int uwnumtransfers,
+			  unsigned int next_lli_addr);
+extern int dmac_m2p_transfer(unsigned long long memaddr, unsigned int uwperipheralid,
+			     unsigned int length);
+extern int dmac_channel_free(unsigned int channel);
+
+extern int do_dma_m2p(unsigned long long memaddr, unsigned int peripheral_addr,
+		      unsigned int length);
+extern int do_dma_p2m(unsigned long mem_addr, unsigned int peripheral_addr,
+		      unsigned int length);
+extern int dmac_wait(int channel);
+
+extern int dmac_start_m2m(unsigned int  channel, unsigned long psource,
+			  unsigned long pdest, unsigned int uwnumtransfers);
+extern int dmac_m2m_transfer(unsigned long source, unsigned long dest,
+			     unsigned int length);
+extern int dmac_register_isr(unsigned int channel, void *pisr);
+extern int free_dmalli_space(unsigned int *ppheadlli, unsigned int page_num);
+extern int dmac_start_llim2p(unsigned int channel, unsigned int *pfirst_lli,
+			     unsigned int uwperipheralid);
+extern int dmac_buildllim2m(unsigned long *ppheadlli,
+			    unsigned long psource,
+			    unsigned long pdest,
+			    unsigned int totaltransfersize,
+			    unsigned int uwnumtransfers);
+
+extern int dmac_start_llim2m(unsigned int channel, unsigned long *pfirst_lli);
+
+extern int allocate_dmalli_space(struct device *dev, unsigned long *ppheadlli,
+				 unsigned int page_num);
+#endif /* CONFIG_HIEDMAC*/
+
+
+/*structure for LLI*/
+typedef struct dmac_lli {
+	//must be 64Byte aligned
+	unsigned long next_lli;
+	unsigned int reserved[5];
+	unsigned int count;
+	unsigned long src_addr;
+	unsigned long dest_addr;
+	unsigned int config;
+	unsigned int pad[51];
+} dmac_lli;
+#endif
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index a670ae129..815f52046 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -124,6 +124,23 @@ static inline int i2c_master_send_dmasafe(const struct i2c_client *client,
 /* Transfer num messages.
  */
 int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
+
+#ifdef CONFIG_ARCH_HISI_BVT
+
+extern int hi_i2c_master_send(const struct i2c_client *client, const char *buf,
+					int count);
+
+extern int hi_i2c_master_send_mul_reg(const struct i2c_client *client, const char *buf,
+					unsigned int count, unsigned int reg_data_width);
+
+extern int hi_i2c_master_recv(const struct i2c_client *client, char *buf,
+					int count);
+
+extern int hi_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+					int num);
+
+#endif
+
 /* Unlocked flavor */
 int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
 
diff --git a/include/linux/mfd/hisi_fmc.h b/include/linux/mfd/hisi_fmc.h
new file mode 100644
index 000000000..28ce45908
--- /dev/null
+++ b/include/linux/mfd/hisi_fmc.h
@@ -0,0 +1,477 @@
+/*
+ * Header file for HiSilicon Flash Memory Controller Driver
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __HISI_FMC_H
+#define __HISI_FMC_H
+
+#include <linux/compiler.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/bitops.h>
+
+#define _512B					(512)
+#define _1K					(1024)
+#define _2K					(2048)
+#define _4K					(4096)
+#define _8K					(8192)
+#define _16K					(16384)
+#define _32K					(32768)
+#define _64K					(0x10000UL)
+#define _128K					(0x20000UL)
+#define _256K					(0x40000UL)
+#define _512K					(0x80000UL)
+#define _1M					(0x100000UL)
+#define _2M					(0x200000UL)
+#define _4M					(0x400000UL)
+#define _8M					(0x800000UL)
+#define _16M					(0x1000000UL)
+#define _32M					(0x2000000UL)
+#define _64M					(0x4000000UL)
+#define _128M					(0x8000000UL)
+#define _256M					(0x10000000UL)
+#define _512M					(0x20000000UL)
+#define _1G					(0x40000000ULL)
+#define _2G					(0x80000000ULL)
+#define _4G					(0x100000000ULL)
+#define _8G					(0x200000000ULL)
+#define _16G					(0x400000000ULL)
+#define _64G					(0x1000000000ULL)
+
+/* HIFMC REG MAP */
+#define FMC_CFG					0x00
+#define FMC_CFG_SPI_NAND_SEL(_type)		(((_size) & 0x3) << 11)
+#define SPI_NOR_ADDR_MODE			BIT(10)
+#define FMC_CFG_OP_MODE_MASK			BIT_MASK(0)
+#define FMC_CFG_OP_MODE_BOOT			0
+#define FMC_CFG_OP_MODE_NORMAL			1
+#define SPI_NOR_ADDR_MODE_3BYTES		(0x0 << 10)
+#define SPI_NOR_ADDR_MODE_4BYTES		(0x1 << 10)
+
+#define FMC_CFG_BLOCK_SIZE(_size)		(((_size) & 0x3) << 8)
+#define FMC_CFG_ECC_TYPE(_type)			(((_type) & 0x7) << 5)
+#define FMC_CFG_PAGE_SIZE(_size)		(((_size) & 0x3) << 3)
+#define FMC_CFG_FLASH_SEL(_type)		(((_type) & 0x3) << 1)
+#define FMC_CFG_OP_MODE(_mode)			((_mode) & 0x1)
+
+#define SPI_NAND_MFR_OTHER			0x0
+#define SPI_NAND_MFR_WINBOND			0x1
+#define SPI_NAND_MFR_ESMT			0x2
+#define SPI_NAND_MFR_MICRON			0x3
+
+#define SPI_NAND_SEL_SHIFT			11
+#define SPI_NAND_SEL_MASK			(0x3 << SPI_NAND_SEL_SHIFT)
+
+#define SPI_NOR_ADDR_MODE_3_BYTES		0x0
+#define SPI_NOR_ADDR_MODE_4_BYTES		0x1
+
+#define SPI_NOR_ADDR_MODE_SHIFT			10
+#define SPI_NOR_ADDR_MODE_MASK			(0x1 << SPI_NOR_ADDR_MODE_SHIFT)
+
+#define BLOCK_SIZE_64_PAGE			0x0
+#define BLOCK_SIZE_128_PAGE			0x1
+#define BLOCK_SIZE_256_PAGE			0x2
+#define BLOCK_SIZE_512_PAGE			0x3
+
+#define BLOCK_SIZE_MASK				(0x3 << 8)
+
+#define ECC_TYPE_0BIT				0x0
+#define ECC_TYPE_8BIT				0x1
+#define ECC_TYPE_16BIT				0x2
+#define ECC_TYPE_24BIT				0x3
+#define ECC_TYPE_28BIT				0x4
+#define ECC_TYPE_40BIT				0x5
+#define ECC_TYPE_64BIT				0x6
+
+#define ECC_TYPE_SHIFT				5
+#define ECC_TYPE_MASK				(0x7 << ECC_TYPE_SHIFT)
+
+#define PAGE_SIZE_2KB				0x0
+#define PAGE_SIZE_4KB				0x1
+#define PAGE_SIZE_8KB				0x2
+#define PAGE_SIZE_16KB				0x3
+
+#define PAGE_SIZE_SHIFT				3
+#define PAGE_SIZE_MASK				(0x3 << PAGE_SIZE_SHIFT)
+
+#define FLASH_TYPE_SPI_NOR			0x0
+#define FLASH_TYPE_SPI_NAND			0x1
+#define FLASH_TYPE_NAND				0x2
+#define FLASH_TYPE_UNKNOWN			0x3
+
+#define FLASH_TYPE_SEL_MASK			(0x3 << 1)
+#define GET_SPI_FLASH_TYPE(_reg)		(((_reg) >> 1) & 0x3)
+
+#define FMC_GLOBAL_CFG				0x04
+#define FMC_GLOBAL_CFG_WP_ENABLE		BIT(6)
+#define FMC_GLOBAL_CFG_RANDOMIZER_EN		(1 << 2)
+#define FLASH_TYPE_SEL_MASK			(0x3 << 1)
+#define FMC_CFG_FLASH_SEL(_type)		(((_type) & 0x3) << 1)
+
+#define FMC_GLOBAL_CFG_DTR_MODE		BIT(11)
+#define FMC_SPI_TIMING_CFG			0x08
+#define TIMING_CFG_TCSH(nr)			(((nr) & 0xf) << 8)
+#define TIMING_CFG_TCSS(nr)			(((nr) & 0xf) << 4)
+#define TIMING_CFG_TSHSL(nr)			((nr) & 0xf)
+
+#define CS_HOLD_TIME				0x6
+#define CS_SETUP_TIME				0x6
+#define CS_DESELECT_TIME			0xf
+
+#define FMC_PND_PWIDTH_CFG			0x0c
+#define PWIDTH_CFG_RW_HCNT(_n)			(((_n) & 0xf) << 8)
+#define PWIDTH_CFG_R_LCNT(_n)			(((_n) & 0xf) << 4)
+#define PWIDTH_CFG_W_LCNT(_n)			((_n) & 0xf)
+
+#define RW_H_WIDTH				(0xa)
+#define R_L_WIDTH				(0xa)
+#define W_L_WIDTH				(0xa)
+
+#define FMC_INT					0x18
+#define FMC_INT_AHB_OP				BIT(7)
+#define FMC_INT_WR_LOCK				BIT(6)
+#define FMC_INT_DMA_ERR				BIT(5)
+#define FMC_INT_ERR_ALARM			BIT(4)
+#define FMC_INT_ERR_INVALID			BIT(3)
+#define FMC_INT_ERR_INVALID_MASK		(0x8)
+#define FMC_INT_ERR_VALID			BIT(2)
+#define FMC_INT_ERR_VALID_MASK			(0x4)
+#define FMC_INT_OP_FAIL				BIT(1)
+#define FMC_INT_OP_DONE				BIT(0)
+
+#define FMC_INT_EN				0x1c
+#define FMC_INT_EN_AHB_OP			BIT(7)
+#define FMC_INT_EN_WR_LOCK			BIT(6)
+#define FMC_INT_EN_DMA_ERR			BIT(5)
+#define FMC_INT_EN_ERR_ALARM			BIT(4)
+#define FMC_INT_EN_ERR_INVALID			BIT(3)
+#define FMC_INT_EN_ERR_VALID			BIT(2)
+#define FMC_INT_EN_OP_FAIL			BIT(1)
+#define FMC_INT_EN_OP_DONE			BIT(0)
+
+#define FMC_INT_CLR				0x20
+#define FMC_INT_CLR_AHB_OP			BIT(7)
+#define FMC_INT_CLR_WR_LOCK			BIT(6)
+#define FMC_INT_CLR_DMA_ERR			BIT(5)
+#define FMC_INT_CLR_ERR_ALARM			BIT(4)
+#define FMC_INT_CLR_ERR_INVALID			BIT(3)
+#define FMC_INT_CLR_ERR_VALID			BIT(2)
+#define FMC_INT_CLR_OP_FAIL			BIT(1)
+#define FMC_INT_CLR_OP_DONE			BIT(0)
+
+#define FMC_INT_CLR_ALL				0xff
+
+#define FMC_CMD					0x24
+#define FMC_CMD_CMD2(_cmd)			(((_cmd) & 0xff) << 8)
+#define FMC_CMD_CMD1(_cmd)			((_cmd) & 0xff)
+
+#define FMC_ADDRH				0x28
+#define FMC_ADDRH_SET(_addr)			((_addr) & 0xff)
+
+#define FMC_ADDRL				0x2c
+#define FMC_ADDRL_BLOCK_MASK(_page)		((_page) & 0xffffffc0)
+#define FMC_ADDRL_BLOCK_H_MASK(_page)		(((_page) & 0xffff) << 16)
+#define FMC_ADDRL_BLOCK_L_MASK(_page)		((_page) & 0xffc0)
+
+#define READ_ID_ADDR				0x00
+#define PROTECT_ADDR				0xa0
+#define FEATURE_ADDR				0xb0
+#define STATUS_ADDR					0xc0
+#define FMC_OP_CFG				0x30
+#define OP_CFG_FM_CS(_cs)			((_cs) << 11)
+#define OP_CFG_FORCE_CS_EN(_en)			((_en) << 10)
+#define OP_CFG_MEM_IF_TYPE(_type)		(((_type) & 0x7) << 7)
+#define OP_CFG_ADDR_NUM(_addr)			(((_addr) & 0x7) << 4)
+#define OP_CFG_DUMMY_NUM(_dummy)		((_dummy) & 0xf)
+#define OP_CFG_OEN_EN               (0x1 << 13)
+
+#define IF_TYPE_SHIFT				7
+#define IF_TYPE_MASK				(0x7 << IF_TYPE_SHIFT)
+
+#define READ_ID_ADDR_NUM			1
+#define FEATURES_OP_ADDR_NUM			1
+#define STD_OP_ADDR_NUM				3
+
+#define FMC_SPI_OP_ADDR				0x34
+
+#define FMC_DATA_NUM				0x38
+#define FMC_DATA_NUM_CNT(_n)			((_n) & 0x3fff)
+
+#define SPI_NOR_SR_LEN				1 /* Status Register length */
+#define SPI_NOR_CR_LEN				1 /* Config Register length */
+#define FEATURES_DATA_LEN			1
+#define READ_OOB_BB_LEN				1
+
+#define PROTECT_BRWD_MASK			BIT(7)
+#define PROTECT_BP3_MASK			BIT(6)
+#define PROTECT_BP2_MASK			BIT(5)
+#define PROTECT_BP1_MASK			BIT(4)
+#define PROTECT_BP0_MASK			BIT(3)
+
+#define ANY_BP_ENABLE(_val)			((PROTECT_BP3_MASK & _val) \
+						|| (PROTECT_BP2_MASK & _val) \
+						|| (PROTECT_BP1_MASK & _val) \
+						|| (PROTECT_BP0_MASK & _val))
+
+#define ALL_BP_MASK				(PROTECT_BP3_MASK \
+						| PROTECT_BP2_MASK \
+						| PROTECT_BP1_MASK \
+						| PROTECT_BP0_MASK)
+
+#define FEATURE_ECC_ENABLE		        (1 << 4)
+#define FEATURE_QE_ENABLE			(1 << 0)
+
+#define FMC_OP					0x3c
+#define FMC_OP_DUMMY_EN				BIT(8)
+#define FMC_OP_CMD1_EN				BIT(7)
+#define FMC_OP_ADDR_EN				BIT(6)
+#define FMC_OP_WRITE_DATA_EN			BIT(5)
+#define FMC_OP_CMD2_EN				BIT(4)
+#define FMC_OP_WAIT_READY_EN			BIT(3)
+#define FMC_OP_READ_DATA_EN			BIT(2)
+#define FMC_OP_READ_STATUS_EN			BIT(1)
+#define FMC_OP_REG_OP_START			BIT(0)
+
+#define FMC_OP_DMA				0x68
+#define FMC_DMA_LEN				0x40
+#define FMC_DMA_LEN_SET(_len)			((_len) & 0x0fffffff)
+
+#define FMC_DMA_AHB_CTRL			0x48
+#define FMC_DMA_AHB_CTRL_DMA_PP_EN		BIT(3)
+#define FMC_DMA_AHB_CTRL_BURST16_EN		BIT(2)
+#define FMC_DMA_AHB_CTRL_BURST8_EN		BIT(1)
+#define FMC_DMA_AHB_CTRL_BURST4_EN		BIT(0)
+
+#define ALL_BURST_ENABLE			(FMC_DMA_AHB_CTRL_BURST16_EN \
+						| FMC_DMA_AHB_CTRL_BURST8_EN \
+						| FMC_DMA_AHB_CTRL_BURST4_EN)
+
+#define FMC_DMA_ADDR_OFFSET			4096
+
+#define FMC_DMA_SADDR_D0			0x4c
+
+#define FMC_DMA_SADDR_D1			0x50
+
+#define FMC_DMA_SADDR_D2			0x54
+
+#define FMC_DMA_SADDR_D3			0x58
+
+#define FMC_DMA_SADDR_OOB			0x5c
+
+#ifdef CONFIG_64BIT
+#define FMC_DMA_SADDRH_D0                       0x200
+#define FMC_DMA_SADDRH_SHIFT                    0x3LL
+#define FMC_DMA_SADDRH_MASK                     (FMC_DMA_SADDRH_SHIFT << 32)
+
+#define FMC_DMA_SADDRH_OOB                      0x210
+#endif
+
+#define FMC_DMA_BLK_SADDR			0x60
+#define FMC_DMA_BLK_SADDR_SET(_addr)		((_addr) & 0xffffff)
+
+#define FMC_DMA_BLK_LEN				0x64
+#define FMC_DMA_BLK_LEN_SET(_len)		((_len) & 0xffff)
+
+#define FMC_OP_CTRL				0x68
+#define OP_CTRL_RD_OPCODE(code)		(((code) & 0xff) << 16)
+#define OP_CTRL_WR_OPCODE(code)		(((code) & 0xff) << 8)
+#define OP_CTRL_RD_OP_SEL(_op)          	(((_op) & 0x3) << 4)
+#define OP_CTRL_DMA_OP(_type)			((_type) << 2)
+#define OP_CTRL_RW_OP(op)		((op) << 1)
+#define OP_CTRL_DMA_OP_READY		BIT(0)
+
+#define RD_OP_READ_ALL_PAGE			0x0
+#define RD_OP_READ_OOB				0x1
+#define RD_OP_BLOCK_READ			0x2
+
+#define RD_OP_SHIFT				4
+#define RD_OP_MASK				(0x3 << RD_OP_SHIFT)
+
+#define OP_TYPE_DMA				0x0
+#define OP_TYPE_REG				0x1
+
+#define FMC_OP_READ				0x0
+#define FMC_OP_WRITE				0x1
+#define RW_OP_READ				0x0
+#define RW_OP_WRITE				0x1
+
+#define FMC_OP_PARA				0x70
+#define FMC_OP_PARA_RD_OOB_ONLY			BIT(1)
+
+#define FMC_BOOT_SET				0x74
+#define FMC_BOOT_SET_DEVICE_ECC_EN		BIT(3)
+#define FMC_BOOT_SET_BOOT_QUAD_EN		BIT(1)
+
+#define FMC_STATUS				0xac
+
+#ifndef FMC_VERSION
+#define FMC_VERSION				0xbc
+#endif
+
+/* Hifmc IP version */
+#ifndef HIFMC_VER_100
+#define HIFMC_VER_100				(0x100)
+#endif
+
+/* DMA address align with 32 bytes. */
+#define FMC_DMA_ALIGN                           32
+
+#define FMC_CHIP_DELAY                          25
+#define HIFMC_ECC_ERR_NUM0_BUF0			0xc0
+#define GET_ECC_ERR_NUM(_i, _reg)		(((_reg) >> ((_i) * 8)) & 0xff)
+
+#define DISABLE               0
+#define ENABLE                1
+
+#define HIFMC_REG_ADDRESS_LEN			0x200
+
+#define FMC_MAX_READY_WAIT_JIFFIES		(HZ)
+
+#define MAX_SPI_NOR_ID_LEN			8
+#define MAX_NAND_ID_LEN				8
+#define MAX_SPI_NAND_ID_LEN			3
+
+#define GET_OP					0
+#define SET_OP					1
+
+#define STATUS_ECC_MASK				(0x3 << 4)
+#define STATUS_P_FAIL_MASK			(1 << 3)
+#define STATUS_E_FAIL_MASK			(1 << 2)
+#define STATUS_WEL_MASK				(1 << 1)
+#define STATUS_OIP_MASK				(1 << 0)
+
+#define FMC_VERSION				0xbc
+
+/* Hifmc IP version */
+#define HIFMC_VER_100				(0x100)
+
+#define CONFIG_SPI_NAND_MAX_CHIP_NUM		(1)
+
+#define CONFIG_HIFMC100_MAX_NAND_CHIP	(1)
+
+#define GET_PAGE_INDEX(host) \
+	                ((host->addr_value[0] >> 16) | (host->addr_value[1] << 16))
+#define HIFMC_MAX_CHIP_NUM		2
+
+extern unsigned char hifmc_cs_user[];
+
+#define hifmc_readl(_host, _reg) \
+	(readl((char *)_host->regbase + (_reg)))
+
+#define hifmc_readb( _addr) \
+	(readb((void __iomem *)(_addr)))
+
+#define hifmc_readw( _addr) \
+	(readw((void __iomem *)(_addr)))
+
+#define hifmc_writel(_host, _reg, _value) \
+	(writel((u_int)(_value), ((char *)_host->regbase + (_reg))))
+
+#define hifmc_writeb(_val, _addr) \
+	(writeb((u_int)(_val), ((char *)_addr)))
+
+#define FMC_WAIT_TIMEOUT 0x2000000
+
+#define FMC_CMD_WAIT_CPU_FINISH(_host) \
+	do { \
+		unsigned regval, timeout = FMC_WAIT_TIMEOUT * 2; \
+		do { \
+			regval = hifmc_readl((_host), FMC_OP); \
+			--timeout; \
+		} while ((regval & FMC_OP_REG_OP_START) && timeout); \
+		if (!timeout) \
+			pr_info("Error: Wait cmd cpu finish timeout!\n"); \
+	} while (0)
+
+#define FMC_DMA_WAIT_INT_FINISH(_host) \
+	do { \
+		unsigned regval, timeout = FMC_WAIT_TIMEOUT; \
+		do { \
+			regval = hifmc_readl((_host), FMC_INT); \
+			--timeout; \
+		} while ((!(regval & FMC_INT_OP_DONE) && timeout)); \
+		if (!timeout) \
+			pr_info("Error: Wait dma int finish timeout!\n"); \
+	} while (0)
+
+#define FMC_DMA_WAIT_CPU_FINISH(_host) \
+	do { \
+		unsigned regval, timeout = FMC_WAIT_TIMEOUT; \
+		do { \
+			regval = hifmc_readl((_host), FMC_OP_CTRL); \
+			--timeout; \
+		} while ((regval & OP_CTRL_DMA_OP_READY) && timeout); \
+		if (!timeout) \
+			pr_info("Error: Wait dma cpu finish timeout!\n"); \
+	} while (0)
+
+#define BT_DBG 0 /* Boot init debug print */
+#define ER_DBG 0 /* Erase debug print */
+#define WR_DBG 0 /* Write debug print */
+#define RD_DBG 0 /* Read debug print */
+#define QE_DBG 0 /* Quad Enable debug print */
+#define OP_DBG 0 /* OP command debug print */
+#define DMA_DB 0 /* DMA read or write debug print */
+#define AC_DBG 0 /* 3-4byte Address Cycle */
+#define SR_DBG 0 /* Status Register debug print */
+#define CR_DBG 0 /* Config Register debug print */
+#define FT_DBG 0 /* Features debug print */
+#define WE_DBG 0 /* Write Enable debug print */
+#define BP_DBG 0 /* Block Protection debug print */
+#define EC_DBG 0 /* enable/disable ecc0 and randomizer */
+#define PM_DBG 0 /* power management debug */
+
+#define FMC_PR(_type, _fmt, arg...) \
+	do { \
+		if (_type) \
+			DB_MSG(_fmt, ##arg) \
+	} while (0)
+
+#define DB_MSG(_fmt, arg...) \
+	pr_info("%s(%d): " _fmt, __func__, __LINE__, ##arg);
+
+#define DB_BUG(fmt, args...) \
+	do { \
+		pr_info("%s(%d): BUG: " fmt, __FILE__, __LINE__, ##args); \
+		while (1) \
+			; \
+	} while (0)
+
+enum hifmc_iftype {
+	IF_TYPE_STD,
+	IF_TYPE_DUAL,
+	IF_TYPE_DIO,
+	IF_TYPE_QUAD,
+	IF_TYPE_QIO,
+};
+
+struct hisi_fmc {
+	void __iomem *regbase;
+	void __iomem *iobase;
+	struct clk *clk;
+	struct mutex lock;
+	void *buffer;
+	dma_addr_t dma_buffer;
+	unsigned int dma_len;
+};
+
+struct hifmc_cmd_op {
+	unsigned char cs;
+	unsigned char cmd;
+	unsigned char l_cmd;
+	unsigned char addr_h;
+	unsigned int addr_l;
+	unsigned int data_no;
+	unsigned short option;
+	unsigned short op_cfg;
+};
+
+extern struct mutex fmc_switch_mutex;
+
+#endif /* __HISI_FMC_H */
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 40d7e98fc..5b77c8cda 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -173,6 +173,7 @@ struct mmc_host_ops {
 	 */
 	int	(*multi_io_quirk)(struct mmc_card *card,
 				  unsigned int direction, int blk_size);
+	int     (*card_info_save)(struct mmc_host *host);
 };
 
 struct mmc_cqe_ops {
@@ -281,6 +282,12 @@ struct mmc_host {
 	unsigned int		f_min;
 	unsigned int		f_max;
 	unsigned int		f_init;
+	unsigned int		type;
+#define MMC_HOST_TYPE_MMC		0		/* MMC card */
+#define MMC_HOST_TYPE_SD		1		/* SD card */
+#define MMC_HOST_TYPE_SDIO		2		/* SDIO card */
+#define MMC_HOST_TYPE_SD_COMBO		3		/* SD combo (IO+mem) card */
+
 	u32			ocr_avail;
 	u32			ocr_avail_sdio;	/* SDIO-specific OCR */
 	u32			ocr_avail_sd;	/* SD-specific OCR */
@@ -425,6 +432,11 @@ struct mmc_host {
 
 	struct delayed_work	detect;
 	int			detect_change;	/* card detect flag */
+	u32			card_status;
+#define MMC_CARD_UNINIT		0
+#define MMC_CARD_INIT		1
+#define MMC_CARD_INIT_FAIL	2
+
 	struct mmc_slot		slot;
 
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 157357ec1..3588dc165 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -18,6 +18,12 @@
 
 #include <asm/div64.h>
 
+#define MTD_ERASE_PENDING	0x01
+#define MTD_ERASING		0x02
+#define MTD_ERASE_SUSPEND	0x04
+#define MTD_ERASE_DONE		0x08
+#define MTD_ERASE_FAILED	0x10
+
 #define MTD_FAIL_ADDR_UNKNOWN -1LL
 
 struct mtd_info;
@@ -28,9 +34,18 @@ struct mtd_info;
  * or was not specific to any particular block.
  */
 struct erase_info {
+	struct mtd_info *mtd;
 	uint64_t addr;
 	uint64_t len;
 	uint64_t fail_addr;
+	u_long time;
+	u_long retries;
+	unsigned dev;
+	unsigned cell;
+	void (*callback) (struct erase_info *self);
+	u_long priv;
+	u_char state;
+	struct erase_info *next;
 };
 
 struct mtd_erase_region_info {
@@ -55,11 +70,9 @@ struct mtd_erase_region_info {
  * @datbuf:	data buffer - if NULL only oob data are read/written
  * @oobbuf:	oob data buffer
  *
- * Note, some MTD drivers do not allow you to write more than one OOB area at
- * one go. If you try to do that on such an MTD device, -EINVAL will be
- * returned. If you want to make your implementation portable on all kind of MTD
- * devices you should split the write request into several sub-requests when the
- * request crosses a page boundary.
+ * Note, it is allowed to read more than one OOB area at one go, but not write.
+ * The interface assumes that the OOB write requests program only one page's
+ * OOB area.
  */
 struct mtd_oob_ops {
 	unsigned int	mode;
@@ -314,6 +327,10 @@ struct mtd_info {
 	int (*_point) (struct mtd_info *mtd, loff_t from, size_t len,
 		       size_t *retlen, void **virt, resource_size_t *phys);
 	int (*_unpoint) (struct mtd_info *mtd, loff_t from, size_t len);
+	unsigned long (*_get_unmapped_area) (struct mtd_info *mtd,
+					     unsigned long len,
+					     unsigned long offset,
+					     unsigned long flags);
 	int (*_read) (struct mtd_info *mtd, loff_t from, size_t len,
 		      size_t *retlen, u_char *buf);
 	int (*_write) (struct mtd_info *mtd, loff_t to, size_t len,
@@ -356,6 +373,11 @@ struct mtd_info {
 	int (*_get_device) (struct mtd_info *mtd);
 	void (*_put_device) (struct mtd_info *mtd);
 
+	/* Backing device capabilities for this device
+	 * - provides mmap capabilities
+	 */
+	struct backing_dev_info *backing_dev_info;
+
 	/*
 	 * flag indicates a panic write, low level drivers can take appropriate
 	 * action if required to ensure writes go through
@@ -456,13 +478,11 @@ static inline void mtd_set_of_node(struct mtd_info *mtd,
 				   struct device_node *np)
 {
 	mtd->dev.of_node = np;
-	if (!mtd->name)
-		of_property_read_string(np, "label", &mtd->name);
 }
 
 static inline struct device_node *mtd_get_of_node(struct mtd_info *mtd)
 {
-	return dev_of_node(&mtd->dev);
+	return mtd->dev.of_node;
 }
 
 static inline u32 mtd_oobavail(struct mtd_info *mtd, struct mtd_oob_ops *ops)
@@ -580,34 +600,6 @@ static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
 	return do_div(sz, mtd->erasesize);
 }
 
-/**
- * mtd_align_erase_req - Adjust an erase request to align things on eraseblock
- *			 boundaries.
- * @mtd: the MTD device this erase request applies on
- * @req: the erase request to adjust
- *
- * This function will adjust @req->addr and @req->len to align them on
- * @mtd->erasesize. Of course we expect @mtd->erasesize to be != 0.
- */
-static inline void mtd_align_erase_req(struct mtd_info *mtd,
-				       struct erase_info *req)
-{
-	u32 mod;
-
-	if (WARN_ON(!mtd->erasesize))
-		return;
-
-	mod = mtd_mod_by_eb(req->addr, mtd);
-	if (mod) {
-		req->addr -= mod;
-		req->len += mod;
-	}
-
-	mod = mtd_mod_by_eb(req->addr + req->len, mtd);
-	if (mod)
-		req->len += mtd->erasesize - mod;
-}
-
 static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
 {
 	if (mtd->writesize_shift)
@@ -692,6 +684,8 @@ extern void register_mtd_user (struct mtd_notifier *new);
 extern int unregister_mtd_user (struct mtd_notifier *old);
 void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size);
 
+void mtd_erase_callback(struct erase_info *instr);
+
 static inline int mtd_is_bitflip(int err) {
 	return err == -EUCLEAN;
 }
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 60bac2c0e..04e292e88 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -11,6 +11,44 @@
 #include <linux/mtd/mtd.h>
 #include <linux/spi/spi-mem.h>
 
+#ifdef CONFIG_ARCH_HISI_BVT
+#define SNOR_MFR_EON		CFI_MFR_EON
+#define SNOR_MFR_WINBOND	0xef
+#define SNOR_MFR_ESMT		0x8c
+#define SNOR_MFR_GD		0xc8
+#define SNOR_MFR_XTX		0x0b
+#define SNOR_MFR_PUYA		0x85
+
+/* Flash set the RESET# from */
+#define SPI_NOR_SR_RST_MASK	BIT(7)
+#define SPI_NOR_GET_RST(val)	(((val) & SPI_NOR_SR_RST_MASK) >> 7)
+#define SPI_NOR_SET_RST(val)    ((val) | SPI_NOR_SR_RST_MASK)
+
+/* Flash block protect */
+#ifdef CONFIG_HISI_SPI_BLOCK_PROTECT
+#define _2M				(0x200000UL)
+#define _4M				(0x400000UL)
+#define _8M				(0x800000UL)
+#define _16M				(0x1000000UL)
+#define _32M				(0x2000000UL)
+
+#define BP_NUM_3                        3
+#define BP_NUM_4                        4
+
+#define DEBUG_SPI_NOR_BP	0
+
+#define SPI_NOR_SR_BP0_SHIFT    2
+#define SPI_NOR_SR_BP_WIDTH_4   0xf
+#define SPI_NOR_SR_BP_MASK_4    (SPI_NOR_SR_BP_WIDTH_4 << SPI_NOR_SR_BP0_SHIFT)
+
+#define SPI_NOR_SR_BP_WIDTH_3   0x7
+#define SPI_NOR_SR_BP_MASK_3    (SPI_NOR_SR_BP_WIDTH_3 << SPI_NOR_SR_BP0_SHIFT)
+
+#define LOCK_LEVEL_MAX(bp_num)	(((0x01) << bp_num) - 1)
+
+#endif /* CONFIG_HISI_SPI_BLOCK_PROTECT */
+#endif /* CONFIG_ARCH_HISI_BVT */
+
 /*
  * Note on opcode nomenclature: some opcodes have a format like
  * SPINOR_OP_FUNCTION{4,}_x_y_z. The numbers x, y, and z stand for the number
@@ -98,6 +136,17 @@
 
 /* Used for Spansion flashes only. */
 #define SPINOR_OP_BRWR		0x17	/* Bank register write */
+
+#ifdef CONFIG_ARCH_HISI_BVT
+#define SPINOR_OP_RDSR3		0x15    /* Read Status Register-3 */
+#define SPINOR_OP_WRSR3		0x11    /* Write Status Register-3 1 byte*/
+/* Used for GigaDevice flashes only. */
+#define SPINOR_OP_WRCR		0x31	/* Config register write */
+/* Software reset code */
+#define CR_DUMMY_CYCLE      (0x03 << 6) /* Macronix dummy cycle bits */
+#define SR_QUAD_EN_XTX      BIT(1)
+#endif
+
 #define SPINOR_OP_CLSR		0x30	/* Clear status register 1 */
 
 /* Used for Micron flashes only. */
@@ -166,6 +215,23 @@
 	(SNOR_PROTO_IS_DTR |					\
 	 SNOR_PROTO_STR(_inst_nbits, _addr_nbits, _data_nbits))
 
+#ifdef CONFIG_ARCH_HISI_BVT
+#define SNOR_OP_READ(_num_mode_clocks, _num_wait_states, _opcode, _proto) \
+	{							  \
+		.num_mode_clocks = _num_mode_clocks,		  \
+		.num_wait_states = _num_wait_states,		  \
+		.opcode = _opcode,				  \
+		.proto = _proto,				  \
+	}
+
+#define SNOR_OP_PROGRAMS(_opcode, _proto) \
+	{							  \
+		.opcode = _opcode,				  \
+		.proto = _proto,				  \
+	}
+
+#endif /* CONFIG_ARCH_HISI_BVT */
+
 enum spi_nor_protocol {
 	SNOR_PROTO_1_1_1 = SNOR_PROTO_STR(1, 1, 1),
 	SNOR_PROTO_1_1_2 = SNOR_PROTO_STR(1, 1, 2),
@@ -386,6 +452,15 @@ struct spi_nor {
 		struct spi_mem_dirmap_desc *wdesc;
 	} dirmap;
 
+#ifdef CONFIG_ARCH_HISI_BVT
+#ifdef CONFIG_HISI_SPI_BLOCK_PROTECT
+	unsigned int end_addr;
+	unsigned int lock_level_max;
+	unsigned char level;
+#endif
+	struct device_node	*flash_node;
+	u32 clkrate;
+#endif
 	void *priv;
 };
 
@@ -414,6 +489,13 @@ static inline struct device_node *spi_nor_get_flash_node(struct spi_nor *nor)
  *
  * Return: 0 for success, others for failure.
  */
+#ifdef CONFIG_ARCH_HISI_BVT
+void spi_nor_driver_shutdown(struct spi_nor *nor);
+#ifdef CONFIG_PM
+int spi_nor_suspend(struct spi_nor *nor, pm_message_t state);
+int hisi_spi_nor_resume(struct spi_nor *nor);
+#endif
+#endif /* CONFIG_ARCH_HISI_BVT */
 int spi_nor_scan(struct spi_nor *nor, const char *name,
 		 const struct spi_nor_hwcaps *hwcaps);
 
diff --git a/include/linux/netdev_features.h b/include/linux/netdev_features.h
index f96b7f8d8..11911795d 100644
--- a/include/linux/netdev_features.h
+++ b/include/linux/netdev_features.h
@@ -30,6 +30,7 @@ enum {
 	NETIF_F_GRO_BIT,		/* Generic receive offload */
 	NETIF_F_LRO_BIT,		/* large receive offload */
 
+	NETIF_F_UFO_BIT,		/* UDPv4 fragmentation */
 	/**/NETIF_F_GSO_SHIFT,		/* keep the order of SKB_GSO_* bits */
 	NETIF_F_TSO_BIT			/* ... TCPv4 segmentation */
 		= NETIF_F_GSO_SHIFT,
@@ -127,6 +128,7 @@ enum {
 #define NETIF_F_TSO6		__NETIF_F(TSO6)
 #define NETIF_F_TSO_ECN		__NETIF_F(TSO_ECN)
 #define NETIF_F_TSO		__NETIF_F(TSO)
+#define NETIF_F_UFO		__NETIF_F(UFO)
 #define NETIF_F_VLAN_CHALLENGED	__NETIF_F(VLAN_CHALLENGED)
 #define NETIF_F_RXFCS		__NETIF_F(RXFCS)
 #define NETIF_F_RXALL		__NETIF_F(RXALL)
@@ -207,7 +209,7 @@ static inline int find_next_netdev_feature(u64 feature, unsigned long start)
 				 NETIF_F_FSO)
 
 /* List of features with software fallbacks. */
-#define NETIF_F_GSO_SOFTWARE	(NETIF_F_ALL_TSO | \
+#define NETIF_F_GSO_SOFTWARE	(NETIF_F_ALL_TSO | NETIF_F_UFO | \
 				 NETIF_F_GSO_SCTP)
 
 /*
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 08725a262..45c717bc1 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1547,6 +1547,7 @@ void phy_queue_state_machine(struct phy_device *phydev, unsigned long jiffies);
 void phy_mac_interrupt(struct phy_device *phydev);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
+int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 void phy_ethtool_ksettings_get(struct phy_device *phydev,
 			       struct ethtool_link_ksettings *cmd);
 int phy_ethtool_ksettings_set(struct phy_device *phydev,
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index acbf1875a..f4573b855 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -521,6 +521,7 @@ struct skb_shared_info {
 	struct skb_shared_hwtstamps hwtstamps;
 	unsigned int	gso_type;
 	u32		tskey;
+	__be32          ip6_frag_id;
 
 	/*
 	 * Warning : all fields before dataref are cleared in __alloc_skb()
diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index e7b997d6f..8bec8c190 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -156,6 +156,7 @@ struct rpc_xprt_ops {
 	void		(*inject_disconnect)(struct rpc_xprt *xprt);
 	int		(*bc_setup)(struct rpc_xprt *xprt,
 				    unsigned int min_reqs);
+	struct svc_xprt*(*bc_get_xprt)(struct svc_serv *serv, struct net *net);
 	size_t		(*bc_maxpayload)(struct rpc_xprt *xprt);
 	unsigned int	(*bc_num_slots)(struct rpc_xprt *xprt);
 	void		(*bc_free_rqst)(struct rpc_rqst *rqst);
diff --git a/include/linux/types.h b/include/linux/types.h
index a14797760..2c35430e2 100644
--- a/include/linux/types.h
+++ b/include/linux/types.h
@@ -227,5 +227,8 @@ typedef void (*swap_func_t)(void *a, void *b, int size);
 typedef int (*cmp_r_func_t)(const void *a, const void *b, const void *priv);
 typedef int (*cmp_func_t)(const void *a, const void *b);
 
+/* clocksource cycle base type */
+typedef u64 cycle_t;
+
 #endif /*  __ASSEMBLY__ */
 #endif /* _LINUX_TYPES_H */
diff --git a/include/linux/usb.h b/include/linux/usb.h
index d6a41841b..de3232ee5 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -2019,8 +2019,11 @@ static inline int usb_translate_errors(int error_code)
 #define USB_DEVICE_REMOVE	0x0002
 #define USB_BUS_ADD		0x0003
 #define USB_BUS_REMOVE		0x0004
+#define USB_GADGET_ADD		0x0005
+#define USB_GADGET_REMOVE	0x0006
 extern void usb_register_notify(struct notifier_block *nb);
 extern void usb_unregister_notify(struct notifier_block *nb);
+extern void usb_notify_online_status(bool online);
 
 /* debugfs stuff */
 extern struct dentry *usb_debug_root;
diff --git a/include/uapi/linux/i2c-dev.h b/include/uapi/linux/i2c-dev.h
index 85f8047af..3f50287f3 100644
--- a/include/uapi/linux/i2c-dev.h
+++ b/include/uapi/linux/i2c-dev.h
@@ -52,6 +52,8 @@
 #define I2C_PEC		0x0708	/* != 0 to use PEC with SMBus */
 #define I2C_SMBUS	0x0720	/* SMBus transfer */
 
+#define I2C_CONFIG_MUL_REG 0x070c
+#define I2C_CONFIG_FLAGS   0x070d
 
 /* This is the structure as used in the I2C_SMBUS ioctl call */
 struct i2c_smbus_ioctl_data {
diff --git a/include/uapi/linux/i2c.h b/include/uapi/linux/i2c.h
index f71a1751c..f85deb485 100644
--- a/include/uapi/linux/i2c.h
+++ b/include/uapi/linux/i2c.h
@@ -22,7 +22,7 @@
     MA 02110-1301 USA.							     */
 /* ------------------------------------------------------------------------- */
 
-/* With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi> and
+/* With some changes from Kyosti Malkki <kmalkki@cc.hut.fi> and
    Frodo Looijaard <frodol@dds.nl> */
 
 #ifndef _UAPI_LINUX_I2C_H
@@ -81,8 +81,14 @@ struct i2c_msg {
 #define I2C_M_REV_DIR_ADDR	0x2000	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_NOSTART		0x4000	/* if I2C_FUNC_NOSTART */
 #define I2C_M_STOP		0x8000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_16BIT_REG		0x0002	/* indicate reg bit-width is 16bit */
+#define I2C_M_16BIT_DATA	0x0008	/* indicate data bit-width is 16bit */
+#define I2C_M_DMA		0x0004	/* indicate use dma mode */
 	__u16 len;		/* msg length				*/
 	__u8 *buf;		/* pointer to msg data			*/
+#if defined(CONFIG_HI_DMAC) || defined(CONFIG_HIEDMAC)
+	__u8 *highmem_buf;
+#endif
 };
 
 /* To determine what functionality is present */
diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index a5773899f..89a461a27 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -93,7 +93,23 @@ struct __fat_dirent {
 	unsigned short	d_reclen;
 	char		d_name[256]; /* We must not include limits.h! */
 };
+#ifdef CONFIG_HISI_MC
+struct fat_direntall {
+	unsigned long   d_ino;
+	unsigned long   d_off;
+	unsigned char   d_type;
+	u64     d_size;
+	char    d_createtime[8];
+	unsigned short  d_reclen;
+	char        d_name[1];
+};
 
+struct fat_direntall_buf {
+	int d_count;
+	int d_usecount;
+	struct fat_direntall direntall;
+};
+#endif
 /*
  * ioctl commands
  */
@@ -104,7 +120,9 @@ struct __fat_dirent {
 #define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
 /*Android kernel has used 0x12, so we use 0x13*/
 #define FAT_IOCTL_GET_VOLUME_ID		_IOR('r', 0x13, __u32)
-
+#ifdef CONFIG_HISI_MC
+#define VFAT_IOCTL_READDIR_ALL    _IOR('r', 0x14, struct fat_direntall_buf)
+#endif
 struct fat_boot_sector {
 	__u8	ignored[3];	/* Boot strap short or near jump */
 	__u8	system_id[8];	/* Name - can be used to special case
diff --git a/include/uapi/linux/usb/g_uvc.h b/include/uapi/linux/usb/g_uvc.h
index 652f169a0..8addd4f94 100644
--- a/include/uapi/linux/usb/g_uvc.h
+++ b/include/uapi/linux/usb/g_uvc.h
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <linux/usb/ch9.h>
 
+#define UVC_SG_REQ
 #define UVC_EVENT_FIRST			(V4L2_EVENT_PRIVATE_START + 0)
 #define UVC_EVENT_CONNECT		(V4L2_EVENT_PRIVATE_START + 0)
 #define UVC_EVENT_DISCONNECT		(V4L2_EVENT_PRIVATE_START + 1)
diff --git a/include/uapi/linux/usb/video.h b/include/uapi/linux/usb/video.h
index bfdae12cd..2d33002e9 100644
--- a/include/uapi/linux/usb/video.h
+++ b/include/uapi/linux/usb/video.h
@@ -342,6 +342,8 @@ struct UVC_EXTENSION_UNIT_DESCRIPTOR(p, n) {		\
 	__u8  iExtension;				\
 } __attribute__ ((packed))
 
+DECLARE_UVC_EXTENSION_UNIT_DESCRIPTOR(1,2);
+
 /* 3.8.2.2. Video Control Interrupt Endpoint Descriptor */
 struct uvc_control_endpoint_descriptor {
 	__u8   bLength;
@@ -567,5 +569,63 @@ struct UVC_FRAME_MJPEG(n) {				\
 	__le32 dwFrameInterval[n];			\
 } __attribute__ ((packed))
 
+/* 3.1.1  Frame Based Payload Video Format Descriptor */
+struct uvc_frame_based_format_desc {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubType;
+	__u8  bFormatIndex;
+	__u8  bNumFrameDescriptors;
+	__u8  guidFormat[16];
+	__u8  bBitsPerPixel;
+	__u8  bDefaultFrameIndex;
+	__u8  bAspectRatioX;
+	__u8  bAspectRatioY;
+	__u8  bmInterfaceFlags;
+	__u8  bCopyProtect;
+	__u8  bVariableSize;
+} __attribute__((__packed__));
+
+#define UVC_DT_FRAME_BASED_FORMAT_SIZE		28
+
+/* 3.1.2  Frame Based Payload Frame Descriptor */
+struct uvc_frame_based_frame_desc {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubType;
+	__u8  bFrameIndex;
+	__u8  bmCapabilities;
+	__u16 wWidth;
+	__u16 wHeight;
+	__u32 dwMinBitRate;
+	__u32 dwMaxBitRate;
+	__u32 dwDefaultFrameInterval;
+	__u8  bFrameIntervalType;
+	__u32 dwBytesPerLine;
+	__u32 dwFrameInterval[];
+} __attribute__((__packed__));
+
+#define UVC_DT_FRAME_BASED_FRAME_SIZE(n)			(26+4*(n))
+
+#define UVC_FRAME_BASED(n) \
+	uvc_frame_based_desc##n
+
+#define DECLARE_UVC_FRAME_BASED(n)			\
+struct UVC_FRAME_BASED(n) {				\
+	__u8  bLength;					\
+	__u8  bDescriptorType;				\
+	__u8  bDescriptorSubType;			\
+	__u8  bFrameIndex;				\
+	__u8  bmCapabilities;				\
+	__u16 wWidth;					\
+	__u16 wHeight;					\
+	__u32 dwMinBitRate;				\
+	__u32 dwMaxBitRate;				\
+	__u32 dwDefaultFrameInterval;			\
+	__u8  bFrameIntervalType;			\
+	__u32 dwBytesPerLine;			\
+	__u32 dwFrameInterval[n];			\
+} __attribute__ ((packed))
+
 #endif /* __LINUX_USB_VIDEO_H */
 
diff --git a/init/main.c b/init/main.c
index 63cdf49f7..4263c0bb3 100644
--- a/init/main.c
+++ b/init/main.c
@@ -842,6 +842,34 @@ static void __init mm_init(void)
 	pti_init();
 }
 
+#ifndef HISI_CHIP_OEM
+static char * __initdata hi3516_usb_mode;
+static int __init hi3516_usb_mode_setup(char *str)
+{
+	hi3516_usb_mode = str;
+	return 1;
+}
+__setup("Hi3516usbmode=", hi3516_usb_mode_setup);
+
+/*
+ * Set up device tree oem feature
+ */
+static void __init _dtb_hisi_oem(void)
+{
+	if (hi3516_usb_mode != NULL && strcmp(hi3516_usb_mode, "host") == 0) {
+		pr_notice("set usb mode to %s \n",hi3516_usb_mode);
+
+		struct device_node *root_node, *child_node;
+		root_node =  of_find_node_by_name(NULL, "soc");
+		if (root_node)
+			child_node = of_find_node_by_name(root_node, "xhci_0");
+		if (child_node)
+			child_node->sibling = child_node->sibling->sibling;
+	}
+
+}
+#endif
+
 void __init __weak arch_call_rest_init(void)
 {
 	rest_init();
@@ -895,6 +923,10 @@ asmlinkage __visible void __init __no_sanitize_address start_kernel(void)
 		parse_args("Setting extra init args", extra_init_args,
 			   NULL, 0, -1, -1, NULL, set_init_arg);
 
+#ifndef HISI_CHIP_OEM
+	_dtb_hisi_oem();
+#endif
+
 	/*
 	 * These use large bootmem allocations and must precede
 	 * kmem_cache_init()
diff --git a/kernel/cpu.c b/kernel/cpu.c
index 67c22941b..dfbd3887e 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -331,6 +331,19 @@ void lockdep_assert_cpus_held(void)
 	percpu_rwsem_assert_held(&cpu_hotplug_lock);
 }
 
+static RAW_NOTIFIER_HEAD(cpu_chain);
+
+/* Need to know about CPUs going up/down? */
+int hi_register_cpu_notifier(struct notifier_block *nb)
+{
+	int ret;
+	cpu_maps_update_begin();
+	ret = raw_notifier_chain_register(&cpu_chain, nb);
+	cpu_maps_update_done();
+	return ret;
+}
+EXPORT_SYMBOL(hi_register_cpu_notifier);
+
 static void lockdep_acquire_cpus_lock(void)
 {
 	rwsem_acquire(&cpu_hotplug_lock.dep_map, 0, 0, _THIS_IP_);
diff --git a/kernel/dma/contiguous.c b/kernel/dma/contiguous.c
index 16b95ff12..90f379978 100644
--- a/kernel/dma/contiguous.c
+++ b/kernel/dma/contiguous.c
@@ -164,6 +164,11 @@ void __init dma_pernuma_cma_reserve(void)
  * has been activated and all other subsystems have already allocated/reserved
  * memory.
  */
+#ifdef CONFIG_ARCH_HISI_BVT
+#ifdef CONFIG_64BIT
+extern __init int hisi_declare_heap_memory(void);
+#endif
+#endif
 void __init dma_contiguous_reserve(phys_addr_t limit)
 {
 	phys_addr_t selected_size = 0;
@@ -173,6 +178,11 @@ void __init dma_contiguous_reserve(phys_addr_t limit)
 
 	pr_debug("%s(limit %08lx)\n", __func__, (unsigned long)limit);
 
+#ifdef CONFIG_ARCH_HISI_BVT
+#ifdef CONFIG_64BIT
+	hisi_declare_heap_memory();
+#endif
+#endif
 	if (size_cmdline != -1) {
 		selected_size = size_cmdline;
 		selected_base = base_cmdline;
@@ -262,6 +272,7 @@ struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,
 
 	return cma_alloc(dev_get_cma_area(dev), count, align, no_warn);
 }
+EXPORT_SYMBOL(dma_alloc_from_contiguous);
 
 /**
  * dma_release_from_contiguous() - release allocated pages
@@ -278,6 +289,12 @@ bool dma_release_from_contiguous(struct device *dev, struct page *pages,
 {
 	return cma_release(dev_get_cma_area(dev), pages, count);
 }
+EXPORT_SYMBOL(dma_release_from_contiguous);
+
+#ifdef CONFIG_ARM64
+#include <asm/cacheflush.h>
+EXPORT_SYMBOL(__flush_dcache_area);
+#endif
 
 static struct page *cma_alloc_aligned(struct cma *cma, size_t size, gfp_t gfp)
 {
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 85351a12c..e9e070a36 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1475,7 +1475,7 @@ static int syslog_print(char __user *buf, int size)
 	char *text;
 	int len = 0;
 
-	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
+	text = kzalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
 	if (!text)
 		return -ENOMEM;
 
diff --git a/kernel/relay.c b/kernel/relay.c
index b08d936d5..1a62975c6 100644
--- a/kernel/relay.c
+++ b/kernel/relay.c
@@ -581,7 +581,8 @@ struct rchan *relay_open(const char *base_filename,
 	if (!chan)
 		return NULL;
 
-	chan->buf = alloc_percpu(struct rchan_buf *);
+	chan->buf = alloc_percpu_gfp(struct rchan_buf *,
+				GFP_KERNEL | __GFP_NOWARN);
 	if (!chan->buf) {
 		kfree(chan);
 		return NULL;
diff --git a/mm/init-mm.c b/mm/init-mm.c
index 153162669..6382b3b6b 100644
--- a/mm/init-mm.c
+++ b/mm/init-mm.c
@@ -40,3 +40,4 @@ struct mm_struct init_mm = {
 	.cpu_bitmap	= CPU_BITS_NONE,
 	INIT_MM_CONTEXT(init_mm)
 };
+EXPORT_SYMBOL(init_mm);
diff --git a/mm/madvise.c b/mm/madvise.c
index 23b48a004..2e09438d6 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -30,6 +30,7 @@
 #include <linux/swapops.h>
 #include <linux/shmem_fs.h>
 #include <linux/mmu_notifier.h>
+#include <linux/sched/mm.h>
 
 #include <asm/tlb.h>
 
diff --git a/mm/mincore.c b/mm/mincore.c
index 02db1a834..9a2c1208d 100644
--- a/mm/mincore.c
+++ b/mm/mincore.c
@@ -42,57 +42,15 @@ static int mincore_hugetlb(pte_t *pte, unsigned long hmask, unsigned long addr,
 	return 0;
 }
 
-/*
- * Later we can get more picky about what "in core" means precisely.
- * For now, simply check to see if the page is in the page cache,
- * and is up to date; i.e. that no page-in operation would be required
- * at this time if an application were to map and access this page.
- */
-static unsigned char mincore_page(struct address_space *mapping, pgoff_t index)
-{
-	unsigned char present = 0;
-	struct page *page;
-
-	/*
-	 * When tmpfs swaps out a page from a file, any process mapping that
-	 * file will not get a swp_entry_t in its pte, but rather it is like
-	 * any other file mapping (ie. marked !present and faulted in with
-	 * tmpfs's .fault). So swapped out tmpfs mappings are tested here.
-	 */
-	page = find_get_incore_page(mapping, index);
-	if (page) {
-		present = PageUptodate(page);
-		put_page(page);
-	}
-
-	return present;
-}
-
-static int __mincore_unmapped_range(unsigned long addr, unsigned long end,
-				struct vm_area_struct *vma, unsigned char *vec)
-{
-	unsigned long nr = (end - addr) >> PAGE_SHIFT;
-	int i;
-
-	if (vma->vm_file) {
-		pgoff_t pgoff;
-
-		pgoff = linear_page_index(vma, addr);
-		for (i = 0; i < nr; i++, pgoff++)
-			vec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);
-	} else {
-		for (i = 0; i < nr; i++)
-			vec[i] = 0;
-	}
-	return nr;
-}
-
 static int mincore_unmapped_range(unsigned long addr, unsigned long end,
 				   __always_unused int depth,
 				   struct mm_walk *walk)
 {
-	walk->private += __mincore_unmapped_range(addr, end,
-						  walk->vma, walk->private);
+	unsigned char *vec = walk->private;
+	unsigned long nr = (end - addr) >> PAGE_SHIFT;
+
+	memset(vec, 0, nr);
+	walk->private += nr;
 	return 0;
 }
 
@@ -112,8 +70,9 @@ static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
 		goto out;
 	}
 
+	/* We'll consider a THP page under construction to be there */
 	if (pmd_trans_unstable(pmd)) {
-		__mincore_unmapped_range(addr, end, vma, vec);
+		memset(vec, 1, nr);
 		goto out;
 	}
 
@@ -122,28 +81,17 @@ static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
 		pte_t pte = *ptep;
 
 		if (pte_none(pte))
-			__mincore_unmapped_range(addr, addr + PAGE_SIZE,
-						 vma, vec);
+			*vec = 0;
 		else if (pte_present(pte))
 			*vec = 1;
 		else { /* pte is a swap entry */
 			swp_entry_t entry = pte_to_swp_entry(pte);
 
-			if (non_swap_entry(entry)) {
-				/*
-				 * migration or hwpoison entries are always
-				 * uptodate
-				 */
-				*vec = 1;
-			} else {
-#ifdef CONFIG_SWAP
-				*vec = mincore_page(swap_address_space(entry),
-						    swp_offset(entry));
-#else
-				WARN_ON(1);
-				*vec = 1;
-#endif
-			}
+			/*
+			 * migration or hwpoison entries are always
+			 * uptodate
+			 */
+			*vec = !!non_swap_entry(entry);
 		}
 		vec++;
 	}
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index f98801428..1a565eaad 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -326,6 +326,7 @@ int map_kernel_range(unsigned long start, unsigned long size, pgprot_t prot,
 	flush_cache_vmap(start, start + size);
 	return ret;
 }
+EXPORT_SYMBOL(map_kernel_range);
 
 int is_vmalloc_or_module_addr(const void *x)
 {
@@ -2097,6 +2098,7 @@ struct vm_struct *__get_vm_area_caller(unsigned long size, unsigned long flags,
 	return __get_vm_area_node(size, 1, flags, start, end, NUMA_NO_NODE,
 				  GFP_KERNEL, caller);
 }
+EXPORT_SYMBOL(__get_vm_area_caller);
 
 /**
  * get_vm_area - reserve a contiguous kernel virtual area
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index 9f52145bb..6baf1f429 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -5593,7 +5593,8 @@ static void process_adv_report(struct hci_dev *hdev, u8 type, bdaddr_t *bdaddr,
 		/* If the report will trigger a SCAN_REQ store it for
 		 * later merging.
 		 */
-		if (type == LE_ADV_IND || type == LE_ADV_SCAN_IND) {
+		if (!ext_adv && (type == LE_ADV_IND ||
+				 type == LE_ADV_SCAN_IND)) {
 			store_pending_adv_report(hdev, bdaddr, bdaddr_type,
 						 rssi, flags, data, len);
 			return;
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 19ef4577b..bebc833f4 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -1561,6 +1561,11 @@ int tcp_fragment(struct sock *sk, enum tcp_queue tcp_queue,
 		return -ENOMEM;
 	}
 
+	if (unlikely((sk->sk_wmem_queued >> 1) > sk->sk_sndbuf)) {
+		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);
+		return -ENOMEM;
+	}
+
 	if (skb_unclone(skb, gfp))
 		return -ENOMEM;
 
diff --git a/net/sunrpc/auth_gss/gss_mech_switch.c b/net/sunrpc/auth_gss/gss_mech_switch.c
index fae632da1..d6b8d6f61 100644
--- a/net/sunrpc/auth_gss/gss_mech_switch.c
+++ b/net/sunrpc/auth_gss/gss_mech_switch.c
@@ -34,11 +34,14 @@ gss_mech_free(struct gss_api_mech *gm)
 {
 	struct pf_desc *pf;
 	int i;
+	struct auth_domain *test;
 
 	for (i = 0; i < gm->gm_pf_num; i++) {
 		pf = &gm->gm_pfs[i];
-		if (pf->domain)
-			auth_domain_put(pf->domain);
+		test = auth_domain_find(pf->auth_domain_name);
+		if (test != NULL) {
+			test->flavour->domain_release(test);
+		}
 		kfree(pf->auth_domain_name);
 		pf->auth_domain_name = NULL;
 	}
diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c
index d38788cd9..f526b67d5 100644
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -1539,15 +1539,22 @@ int
 bc_svc_process(struct svc_serv *serv, struct rpc_rqst *req,
 	       struct svc_rqst *rqstp)
 {
+	struct net	*net = req->rq_xprt->xprt_net;
 	struct kvec	*argv = &rqstp->rq_arg.head[0];
 	struct kvec	*resv = &rqstp->rq_res.head[0];
 	struct rpc_task *task;
+	struct svc_xprt *s_xprt;
 	int proc_error;
 	int error;
 
 	dprintk("svc: %s(%p)\n", __func__, req);
 
+	s_xprt = req->rq_xprt->ops->bc_get_xprt(serv, net);
+	if (!s_xprt)
+		goto proc_error;
+
 	/* Build the svc_rqst used by the common processing routine */
+	rqstp->rq_xprt = s_xprt;
 	rqstp->rq_xid = req->rq_xid;
 	rqstp->rq_prot = req->rq_xprt->prot;
 	rqstp->rq_server = serv;
@@ -1606,6 +1613,12 @@ bc_svc_process(struct svc_serv *serv, struct rpc_rqst *req,
 out:
 	dprintk("svc: %s(), error=%d\n", __func__, error);
 	return error;
+
+proc_error:
+	/* Processing error: drop the request */
+	xprt_free_bc_request(req);
+	error = -EINVAL;
+	goto out;
 }
 EXPORT_SYMBOL_GPL(bc_svc_process);
 #endif /* CONFIG_SUNRPC_BACKCHANNEL */
diff --git a/net/sunrpc/xprtrdma/backchannel.c b/net/sunrpc/xprtrdma/backchannel.c
index c92c1aac2..9d1a966ba 100644
--- a/net/sunrpc/xprtrdma/backchannel.c
+++ b/net/sunrpc/xprtrdma/backchannel.c
@@ -35,6 +35,11 @@ int xprt_rdma_bc_setup(struct rpc_xprt *xprt, unsigned int reqs)
 	return 0;
 }
 
+struct svc_xprt *xprt_rdma_bc_get_xprt(struct svc_serv *serv, struct net *net)
+{
+	return svc_find_xprt(serv, "rdma-bc", net, AF_UNSPEC, 0);
+}
+
 /**
  * xprt_rdma_bc_maxpayload - Return maximum backchannel message size
  * @xprt: transport
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 8fb047888..5ea56bc2a 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -2121,7 +2121,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 
 	hdr = nl80211hdr_put(msg, portid, seq, flags, cmd);
 	if (!hdr)
-		return -ENOBUFS;
+		goto nla_put_failure;
 
 	if (WARN_ON(!state))
 		return -EINVAL;
diff --git a/net/wireless/wext-sme.c b/net/wireless/wext-sme.c
index 73df23570..9f959d7b5 100644
--- a/net/wireless/wext-sme.c
+++ b/net/wireless/wext-sme.c
@@ -201,8 +201,8 @@ int cfg80211_mgd_wext_giwessid(struct net_device *dev,
 			       struct iw_request_info *info,
 			       struct iw_point *data, char *ssid)
 {
-	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int ret = 0;
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
 
 	/* call only for station! */
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index 941337088..bbdfd6a1b 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -210,7 +210,9 @@ cpp_flags      = -Wp,-MMD,$(depfile) $(NOSTDINC_FLAGS) $(LINUXINCLUDE)     \
 
 ld_flags       = $(KBUILD_LDFLAGS) $(ldflags-y) $(LDFLAGS_$(@F))
 
-DTC_INCLUDE    := $(srctree)/scripts/dtc/include-prefixes
+DTC_INCLUDE    := $(srctree)/scripts/dtc/include-prefixes \
+		  $(objtree)/include/generated \
+		  $(srctree)/include/dt-bindings
 
 dtc_cpp_flags  = -Wp,-MMD,$(depfile).pre.tmp -nostdinc                    \
 		 $(addprefix -I,$(DTC_INCLUDE))                          \
@@ -316,7 +318,7 @@ $(obj)/%.dtb.S: $(obj)/%.dtb FORCE
 	$(call if_changed,dt_S_dtb)
 
 quiet_cmd_dtc = DTC     $@
-cmd_dtc = $(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
+cmd_dtc = mkdir -p $(dir $(dtc-tmp)); $(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
 	$(DTC) -O $(patsubst .%,%,$(suffix $@)) -o $@ -b 0 \
 		$(addprefix -i,$(dir $<) $(DTC_INCLUDE)) $(DTC_FLAGS) \
 		-d $(depfile).dtc.tmp $(dtc-tmp) ; \
diff --git a/scripts/dtc/checks.c b/scripts/dtc/checks.c
index 17cb6890d..af3392da3 100644
--- a/scripts/dtc/checks.c
+++ b/scripts/dtc/checks.c
@@ -819,8 +819,8 @@ static void check_pci_bridge(struct check *c, struct dt_info *dti, struct node *
 
 	node->bus = &pci_bus;
 
-	if (!strprefixeq(node->name, node->basenamelen, "pci") &&
-	    !strprefixeq(node->name, node->basenamelen, "pcie"))
+	if (!strprefixeq(node->name, 3, "pci") &&
+	    !strprefixeq(node->name, 4, "pcie"))
 		FAIL(c, dti, node, "node name is not \"pci\" or \"pcie\"");
 
 	prop = get_property(node, "ranges");
diff --git a/sound/core/control.c b/sound/core/control.c
index 3b44378b9..b94592b46 100644
--- a/sound/core/control.c
+++ b/sound/core/control.c
@@ -1443,7 +1443,7 @@ static int snd_ctl_elem_add(struct snd_ctl_file *file,
 		return -ENOMEM;
 
 	/* Check the number of elements for this userspace control. */
-	count = info->owner;
+	count = info->count;
 	if (count == 0)
 		count = 1;
 
diff --git a/tools/testing/selftests/net/fib_tests.sh b/tools/testing/selftests/net/fib_tests.sh
index 6fad54c7e..9d1302bb8 100755
--- a/tools/testing/selftests/net/fib_tests.sh
+++ b/tools/testing/selftests/net/fib_tests.sh
@@ -636,6 +636,20 @@ fib_suppress_test()
 	cleanup
 }
 
+fib_suppress_test()
+{
+	$IP link add dummy1 type dummy
+	$IP link set dummy1 up
+	$IP -6 route add default dev dummy1
+	$IP -6 rule add table main suppress_prefixlength 0
+	ping -f -c 1000 -W 1 1234::1 || true
+	$IP -6 rule del table main suppress_prefixlength 0
+	$IP link del dummy1
+
+	# If we got here without crashing, we're good.
+	return 0
+}
+
 ################################################################################
 # Tests on route add and replace
 
